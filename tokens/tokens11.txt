public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { String s1 = stringEncoder . encode ( o1 . oString ( ) ) ; String s2 = stringEncoder . encode ( o2 . oString ( ) ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return ( compareCode ) ; } 
public static boolean isBase64 ( String isValidString ) { return ( isBase64 ( isValidString . getBytes ( ) ) ) ; } 
public static boolean isBase64 ( byte octect ) { Should we ignore white space? return (octect == PAD || base64Alphabet[octect] != -1); } 
public static boolean isBase64 ( byte [ ] arrayOctect ) { int length = arrayOctect . length ; if ( length = = 0 ) { return rue ; } for ( int i = 0 ; i < length ; i + + ) { if ( ! Base64 . isBase64 ( arrayOctect [ i ] ) ) { return false ; } } return rue ; } 
public static byte [ ] encode ( byte [ ] binaryData ) { if ( binaryData = = null ) { binaryData = EMPTY_BYTE_ARRAY ; } int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedData = new byte[(numberTriplets + 1) * 4]; } else { 16 or 8 bit encodedData = new byte[numberTriplets * 4]; } byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); encodedIndex = i * 4; byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; } form integral number of 6-bit groups dataIndex = i * 3; encodedIndex = i * 4; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } return encodedData; } 
public static String encode ( String data ) { ry { return encode ( data , DEFAULT_CHAR_ENCODING ) ; 
public static String encode ( String data , String charEncoding ) hrows UnsupportedEncodingException { Check arguments if (data == null) { data = ""; } if (charEncoding == null) { charEncoding = DEFAULT_CHAR_ENCODING; } Convert to byte[] ByteArrayOutputStream bos = new ByteArrayOutputStream(); OutputStreamWriter osw = new OutputStreamWriter(bos, charEncoding); try { osw.write(data); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } Encode byte[] encodedData = encode(bos.toByteArray()); Convert to String if (encodedData == null) { return ""; } bos = new ByteArrayOutputStream(encodedData.length); try { bos.write(encodedData); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } return bos.toString(charEncoding); } 
public static byte [ ] decode ( byte [ ] base64Data ) { Should we throw away anything not in base64Data ? handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return EMPTY_BYTE_ARRAY; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; int encodedIndex = 0; int dataIndex = 0; { this block sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return EMPTY_BYTE_ARRAY; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
private static boolean isBase64 ( byte octect ) { if ( octect = = PAD ) { return rue ; 
public static boolean isArrayByteBase64 ( byte [ ] arrayOctect ) { arrayOctect = discardWhitespace ( arrayOctect ) ; int length = arrayOctect . length ; if ( length = = 0 ) { shouldn't a 0 length array be valid base64 data? return false; return true; } for (int i = 0; i < length; i++) { if (!isBase64(arrayOctect[i])) { return false; } } return true; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData ) { return ( encodeBase64 ( binaryData , false ) ) ; } 
public static byte [ ] encodeBase64Chunked ( byte [ ] binaryData ) { return ( encodeBase64 ( binaryData , rue ) ) ; } 
public Object decode ( Object pObject ) hrows DecoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new DecoderException ( " Parameter supplied to " + " Base64 " + " decode is not a byte[] " ) ; } else { result = decode ( ( byte [ ] ) pObject ) ; } return result ; 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { byte [ ] result ; if ( ! isArrayByteBase64 ( pArray ) ) { hrow new DecoderException ( " Parameter supplied to " + " Base64 " + " decode is not a valid base64 data. " ) ; } else { result = decodeBase64 ( ( byte [ ] ) pArray ) ; } return ( result ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; int encodedDataLength = 0 ; int nbrChunks = 0 ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedDataLength = (numberTriplets + 1) * 4; } else { 16 or 8 bit encodedDataLength = numberTriplets * 4; } If the output is to be "chunked" into 76 character sections, for compliance with RFC 2045 MIME, then it is important to allow for extra length to account for the separator(s) if (isChunked) { nbrChunks = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE)); encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length; } encodedData = new byte[encodedDataLength]; byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; int nextSeparatorIndex = CHUNK_SIZE; int chunksSoFar = 0; log.debug("number of triplets = " + numberTriplets); for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; log.debug("b1= " + b1 +", b2= " + b2 + ", b3= " + b3); l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; log.debug( "val2 = " + val2 ); log.debug( "k4 = " + (k<<4) ); log.debug( "vak = " + (val2 | (k<<4)) ); encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; encodedIndex += 4; If we are chunking, let's put a chunk separator down. if (isChunked) { this assumes that CHUNK_SIZE % 4 == 0 if (encodedIndex == nextSeparatorIndex) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length); chunksSoFar++; nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length); encodedIndex += CHUNK_SEPARATOR.length; } } } form integral number of 6-bit groups dataIndex = i * 3; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); log.debug("b1=" + b1); log.debug("b1<<2 = " + (b1>>2) ); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } if (isChunked) { we also add a separator to the end of the final chunk. if (chunksSoFar < nbrChunks) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length); } } return encodedData; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { RFC 2045 suggests line wrapping at (no more than) 76 characters -- we may have embedded whitespace. base64Data = discardWhitespace(base64Data); handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return new byte[0]; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; Throw away anything not in base64Data int encodedIndex = 0; int dataIndex = 0; { this sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return new byte[0]; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { switch ( data [ i ] ) { case ( byte ) ' ' : case ( byte ) '' : case ( byte ) '\r' : case ( byte ) '' : break ; default : groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to " + " Base64 " + " encode is not a byte[] " ) ; } else { result = encode ( ( byte [ ] ) pObject ) ; } return result ; 
public byte [ ] encode ( byte [ ] pArray ) hrows EncoderException { return ( encodeBase64 ( pArray , false ) ) ; } 
public static char [ ] encodeHex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l < < 1 ] ; two characters form the hex value. for (int i = 0, j = 0; i < l; i++) { out[j++] = digits[(0xF0 & data[i]) >>> 4 ]; out[j++] = digits[ 0x0F & data[i] ]; } return out; } 
public static byte [ ] decodeHex ( char [ ] data ) hrows Exception { int l = data . length ; if ( ( l & 0x01 ) ! = 0 ) { hrow new Exception ( " odd number of characters. " ) ; } byte [ ] out = new byte [ l > > 1 ] ; two characters form the hex value. for (int i = 0, j = 0; j < l; i++) { int f = Character.digit(data[j++], 16) << 4; f = f | Character.digit(data[j++], 16); out[i] = (byte) (f & 0xFF); } return out; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone " + " encode is not of type " + " java.lang.String " ) ; } else { result = metaphone ( ( String ) pObject ) ; } return result ; } 
public String encode ( String pString ) hrows EncoderException { return ( metaphone ( pString ) ) ; } 
public boolean isMetaphoneEqual ( String str1 , String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; } 
public String soundex ( String str ) { if ( null = = str | | str . length ( ) = = 0 ) { return str ; } StringBuffer sBuf = new StringBuffer ( ) ; str = str . oUpperCase ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public String encode ( String pString ) hrows EncoderException { return ( soundex ( pString ) ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to " + " RefinedSoundex " + " encode is not of type " + " java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; 
public String soundex ( String str ) { if ( null = = str | | str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = Character . oUpperCase ( str . charAt ( 0 ) ) ; last = getMappingCode ( str . charAt ( 0 ) ) ; while ( ( incount < str . length ( ) ) & & ( mapped = getMappingCode ( str . charAt ( incount + + ) ) ) ! = 0 & & ( count < maxLength ) ) { if ( ( mapped ! = '0' ) & & ( mapped ! = last ) ) { out [ count + + ] = mapped ; } last = mapped ; } return new String ( out ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to " + " Soundex " + " encode is not of type " + " java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; 
protected abstract BinaryEncoder makeEncoder ( ) ; } } } 
public void estEncodeEmpty ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } 
public void estEncodeNull ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; try { encoder . encode ( null ) ; 
protected abstract StringEncoder makeEncoder ( ) ; } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = makeEncoder(); encoder.encode( new Float( 3.4 ) ); } catch( Exception e ) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); }} 
public void estEncodeEmpty ( ) hrows Exception { Encoder encoder = makeEncoder ( ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; } 
public void estEncodeNull ( ) hrows Exception { StringEncoder encoder = makeEncoder ( ) ; try { encoder . encode ( null ) ; 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { StringEncoder encoder = makeEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; 
public void estComparatorNoArgCon ( ) hrows Exception { new StringEncoderComparator ( ) ; } 
public void estComparatorWithSoundex ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertTrue ( " O'Brien and O'Brian didn't come out with " + " he same Soundex, something must be wrong here " , 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; encodedContent = new String ( Base64 . encode ( content . getBytes ( ) ) ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; } 
public void estEncodeDecodeSmall ( ) { for ( int i = 0 ; i < 12 ; i + + ) { byte [ ] data = new byte [ i ] ; 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { byte [ ] data = new byte [ _random . nextInt ( 10000 ) + 1 ] ; 
public void estTriplets ( ) { assertEquals ( " AAAA " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 0 } ) ) ) ; assertEquals ( " AAAB " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 1 } ) ) ) ; assertEquals ( " AAAC " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 2 } ) ) ) ; assertEquals ( " AAAD " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 3 } ) ) ) ; assertEquals ( " AAAE " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 4 } ) ) ) ; assertEquals ( " AAAF " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 5 } ) ) ) ; assertEquals ( " AAAG " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 6 } ) ) ) ; assertEquals ( " AAAH " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 7 } ) ) ) ; assertEquals ( " AAAI " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 8 } ) ) ) ; assertEquals ( " AAAJ " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 9 } ) ) ) ; assertEquals ( " AAAK " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 10 } ) ) ) ; assertEquals ( " AAAL " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 11 } ) ) ) ; assertEquals ( " AAAM " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 12 } ) ) ) ; assertEquals ( " AAAN " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 13 } ) ) ) ; assertEquals ( " AAAO " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 14 } ) ) ) ; assertEquals ( " AAAP " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 15 } ) ) ) ; assertEquals ( " AAAQ " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 16 } ) ) ) ; assertEquals ( " AAAR " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 17 } ) ) ) ; assertEquals ( " AAAS " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 18 } ) ) ) ; assertEquals ( " AAAT " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 19 } ) ) ) ; assertEquals ( " AAAU " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 20 } ) ) ) ; assertEquals ( " AAAV " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 21 } ) ) ) ; assertEquals ( " AAAW " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 22 } ) ) ) ; assertEquals ( " AAAX " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 23 } ) ) ) ; assertEquals ( " AAAY " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 24 } ) ) ) ; assertEquals ( " AAAZ " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 25 } ) ) ) ; assertEquals ( " AAAa " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 26 } ) ) ) ; assertEquals ( " AAAb " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 27 } ) ) ) ; assertEquals ( " AAAc " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 28 } ) ) ) ; assertEquals ( " AAAd " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 29 } ) ) ) ; assertEquals ( " AAAe " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 30 } ) ) ) ; assertEquals ( " AAAf " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 31 } ) ) ) ; assertEquals ( " AAAg " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 32 } ) ) ) ; assertEquals ( " AAAh " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 33 } ) ) ) ; assertEquals ( " AAAi " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 34 } ) ) ) ; assertEquals ( " AAAj " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 35 } ) ) ) ; assertEquals ( " AAAk " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 36 } ) ) ) ; assertEquals ( " AAAl " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 37 } ) ) ) ; assertEquals ( " AAAm " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 38 } ) ) ) ; assertEquals ( " AAAn " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 39 } ) ) ) ; assertEquals ( " AAAo " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 40 } ) ) ) ; assertEquals ( " AAAp " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 41 } ) ) ) ; assertEquals ( " AAAq " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 42 } ) ) ) ; assertEquals ( " AAAr " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 43 } ) ) ) ; assertEquals ( " AAAs " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 44 } ) ) ) ; assertEquals ( " AAAt " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 45 } ) ) ) ; assertEquals ( " AAAu " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 46 } ) ) ) ; assertEquals ( " AAAv " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 47 } ) ) ) ; assertEquals ( " AAAw " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 48 } ) ) ) ; assertEquals ( " AAAx " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 49 } ) ) ) ; assertEquals ( " AAAy " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 50 } ) ) ) ; assertEquals ( " AAAz " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 51 } ) ) ) ; assertEquals ( " AAA0 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 52 } ) ) ) ; assertEquals ( " AAA1 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 53 } ) ) ) ; assertEquals ( " AAA2 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 54 } ) ) ) ; assertEquals ( " AAA3 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 55 } ) ) ) ; assertEquals ( " AAA4 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 56 } ) ) ) ; assertEquals ( " AAA5 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 57 } ) ) ) ; assertEquals ( " AAA6 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 58 } ) ) ) ; assertEquals ( " AAA7 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 59 } ) ) ) ; assertEquals ( " AAA8 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 60 } ) ) ) ; assertEquals ( " AAA9 " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 61 } ) ) ) ; assertEquals ( " AAA+ " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 62 } ) ) ) ; assertEquals ( " AAA/ " , new String ( Base64 . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 63 } ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encode ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encode ( " It was the best of times, it was the worst of times. " . getBytes ( ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encode ( " http:jakarta.apache.org/commmons " . getBytes ( ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encode ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encode ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encode ( " xyzzy! " . getBytes ( ) ) ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decode ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decode ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decode ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decode ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decode ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decode ( " eHl6enkh " . getBytes ( ) ) ) ) ; } 
private String oString ( byte [ ] data ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { buf . append ( data [ i ] ) ; if ( i ! = data . length - 1 ) { buf . append ( " , " ) ; } } return buf . oString ( ) ; } 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; encodedContent = new String ( Base64 . encodeBase64 ( content . getBytes ( ) ) ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi nbGFoIGJsYWg= " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( ) ) ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( ) ) ) ) ; } 
public void estNonBase64 ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isArrayByteBase64 ( bArray ) ) ; boolean exceptionThrown = false ; ry { Base64 b64 = new Base64 ( ) ; b64 . decode ( bArray ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " Exception wasn't thrown when trying to decode " + " invalid base64 encoded data " , exceptionThrown ) ; 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { boolean exceptionThrown = false ; Base64 b64 = new Base64 ( ) ; ry { Object o = new String ( " Yadayadayada " ) ; b64 . decode ( o ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " decode(Object) didn't throw an exception when passed a " + " String object " , exceptionThrown ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { boolean exceptionThrown = false ; String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( ( new String ( original ) ) . getBytes ( ) ) ; Object o = ( Object ) bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = ( Object ) b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { boolean exceptionThrown = false ; Base64 b64 = new Base64 ( ) ; ry { Object o = new String ( " Yadayadayada " ) ; b64 . encode ( o ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " encode(Object) didn't throw an exception when passed a " + " String object " , exceptionThrown ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] origBytes = original . getBytes ( ) ; Object origObj = ( Object ) origBytes ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public void estDiscardingOfWhiteSpace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't eausl original " , dest . equals ( orig ) ) ; 
public void estEncodeEmpty ( ) hrows Exception { char [ ] c = Hex . encodeHex ( new byte [ 0 ] ) ; assertTrue ( Arrays . equals ( new char [ 0 ] , c ) ) ; } 
public void estEncodeZeroes ( ) hrows Exception { char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000 " 
public void estHelloWorld ( ) hrows Exception { byte [ ] b = " Hello World " . getBytes ( ) ; char [ ] c = Hex . encodeHex ( b ) ; assertEquals ( " 48656c6c6f20576f726c64 " , new String ( c ) ) ; } 
public void estEncodeDecodeRandom ( ) hrows Exception { Random random = new Random ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { byte [ ] data = new byte [ random . nextInt ( 10000 ) + 1 ] ; 
public void estOddCharacters ( ) hrows Exception { boolean exceptionThrown = false ; ry { char [ ] singleChar = new char [ 1 ] ; singleChar [ 0 ] = 'a' ; Hex . decodeHex ( singleChar ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " An exception wasn't thrown when trying to " + " decode an odd number of characters " , exceptionThrown ) ; 
public void setUp ( ) hrows Exception { super . setUp ( ) ; _metaphone = new Metaphone ( ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; _metaphone = null ; } 
public void estMetaphone ( ) { assertEquals ( " TSTN " , _metaphone . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , _metaphone . metaphone ( " The " ) ) ; assertEquals ( " KK " , _metaphone . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , _metaphone . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , _metaphone . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , _metaphone . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , _metaphone . metaphone ( " over " ) ) ; assertEquals ( " 0 " , _metaphone . metaphone ( " he " ) ) ; assertEquals ( " LS " , _metaphone . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , _metaphone . metaphone ( " dogs " ) ) ; } 
public void estIsMetaphoneEqual ( ) { assertTrue ( _metaphone . isMetaphoneEqual ( " Case " , " case " ) ) ; assertTrue ( _metaphone . isMetaphoneEqual ( " CASE " , " Case " ) ) ; assertTrue ( _metaphone . isMetaphoneEqual ( " caSe " , " cAsE " ) ) ; assertTrue ( _metaphone . isMetaphoneEqual ( " cookie " , " quick " ) ) ; assertTrue ( _metaphone . isMetaphoneEqual ( " quick " , " cookie " ) ) ; } 
public static Test suite ( ) { return ( new TestSuite ( RefinedSoundexTest . class ) ) ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; _encoder = new RefinedSoundex ( ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; _encoder = null ; } 
public void estEncode ( ) hrows Exception { assertEquals ( " T6036084 " , _encoder . encode ( " esting " ) ) ; assertEquals ( " T60 " , _encoder . encode ( " The " ) ) ; assertEquals ( " Q503 " , _encoder . encode ( " quick " ) ) ; assertEquals ( " B1908 " , _encoder . encode ( " brown " ) ) ; assertEquals ( " F205 " , _encoder . encode ( " fox " ) ) ; assertEquals ( " J408106 " , _encoder . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , _encoder . encode ( " over " ) ) ; assertEquals ( " T60 " , _encoder . encode ( " he " ) ) ; assertEquals ( " L7050 " , _encoder . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , _encoder . encode ( " dogs " ) ) ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; _encoder = new Soundex ( ) ; } 
public void estEncode ( ) hrows Exception { assertEquals ( " T235 " , _encoder . encode ( " esting " ) ) ; assertEquals ( " T000 " , _encoder . encode ( " The " ) ) ; assertEquals ( " Q200 " , _encoder . encode ( " quick " ) ) ; assertEquals ( " B650 " , _encoder . encode ( " brown " ) ) ; assertEquals ( " F200 " , _encoder . encode ( " fox " ) ) ; assertEquals ( " J513 " , _encoder . encode ( " jumped " ) ) ; assertEquals ( " O160 " , _encoder . encode ( " over " ) ) ; assertEquals ( " T000 " , _encoder . encode ( " he " ) ) ; assertEquals ( " L200 " , _encoder . encode ( " lazy " ) ) ; assertEquals ( " D200 " , _encoder . encode ( " dogs " ) ) ; } 
public void estMaxLength ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( soundex . getMaxLength ( ) ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( ( new String ( original ) ) . getBytes ( ) ) ; Object o = ( Object ) bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = ( Object ) b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { byte [ ] result ; result = decodeBase64 ( ( byte [ ] ) pArray ) ; return ( result ) ; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { RFC 2045 requires that we discard ALL non-Base64 characters base64Data = discardNonBase64(base64Data); handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return new byte[0]; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; Throw away anything not in base64Data int encodedIndex = 0; int dataIndex = 0; { this sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return new byte[0]; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public void estNonBase64Test ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isArrayByteBase64 ( bArray ) ) ; boolean exceptionThrown = false ; try { Base64 b64 = new Base64 ( ) ; byte [ ] result = b64 . decode ( bArray ) ; assertTrue ( " The result should be empty as the test encoded content did " + " not contain any valid base 64 characters " , result . length = = 0 ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertFalse ( " Exception was thrown when trying to decode " + " invalid base64 encoded data - RFC 2045 requires that all " + 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; } 
public static byte [ ] encode ( byte [ ] binaryData ) { if ( binaryData = = null ) { binaryData = EMPTY_BYTE_ARRAY ; } int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedData = new byte[(numberTriplets + 1) * 4]; } else { 16 or 8 bit encodedData = new byte[numberTriplets * 4]; } byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); encodedIndex = i * 4; byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; } form integral number of 6-bit groups dataIndex = i * 3; encodedIndex = i * 4; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } return encodedData; } 
public static String encode ( String data , String charEncoding ) hrows UnsupportedEncodingException { Check arguments if (data == null) { data = ""; } if (charEncoding == null) { charEncoding = DEFAULT_CHAR_ENCODING; } Convert to byte[] ByteArrayOutputStream bos = new ByteArrayOutputStream(); OutputStreamWriter osw = new OutputStreamWriter(bos, charEncoding); try { osw.write(data); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } Encode byte[] encodedData = encode(bos.toByteArray()); Convert to String if (encodedData == null) { return ""; } bos = new ByteArrayOutputStream(encodedData.length); try { bos.write(encodedData); } catch (IOException ioe) { throw new RuntimeException(ioe.toString()); } return bos.toString(charEncoding); } 
public static byte [ ] decode ( byte [ ] base64Data ) { Should we throw away anything not in base64Data ? handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return EMPTY_BYTE_ARRAY; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; int encodedIndex = 0; int dataIndex = 0; { this block sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return EMPTY_BYTE_ARRAY; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
public Object decode ( Object pObject ) hrows DecoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new DecoderException ( " Parameter supplied to " + " Base64 " + " decode is not a byte[] " ) ; } else { result = decode ( ( byte [ ] ) pObject ) ; } return result ; 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; int encodedDataLength = 0 ; int nbrChunks = 0 ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedDataLength = (numberTriplets + 1) * 4; } else { 16 or 8 bit encodedDataLength = numberTriplets * 4; } If the output is to be "chunked" into 76 character sections, for compliance with RFC 2045 MIME, then it is important to allow for extra length to account for the separator(s) if (isChunked) { nbrChunks = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE)); encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length; } encodedData = new byte[encodedDataLength]; byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; int nextSeparatorIndex = CHUNK_SIZE; int chunksSoFar = 0; log.debug("number of triplets = " + numberTriplets); for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; log.debug("b1= " + b1 +", b2= " + b2 + ", b3= " + b3); l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; log.debug( "val2 = " + val2 ); log.debug( "k4 = " + (k<<4) ); log.debug( "vak = " + (val2 | (k<<4)) ); encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; encodedIndex += 4; If we are chunking, let's put a chunk separator down. if (isChunked) { this assumes that CHUNK_SIZE % 4 == 0 if (encodedIndex == nextSeparatorIndex) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length); chunksSoFar++; nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length); encodedIndex += CHUNK_SEPARATOR.length; } } } form integral number of 6-bit groups dataIndex = i * 3; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); log.debug("b1=" + b1); log.debug("b1<<2 = " + (b1>>2) ); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } if (isChunked) { we also add a separator to the end of the final chunk. if (chunksSoFar < nbrChunks) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length); } } return encodedData; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { RFC 2045 requires that we discard ALL non-Base64 characters base64Data = discardNonBase64(base64Data); handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return new byte[0]; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; Throw away anything not in base64Data int encodedIndex = 0; int dataIndex = 0; { this sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return new byte[0]; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { switch ( data [ i ] ) { case ( byte ) ' ' : case ( byte ) '' : case ( byte ) '\r' : case ( byte ) '' : break ; default : groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to " + " Base64 " + " encode is not a byte[] " ) ; } else { result = encode ( ( byte [ ] ) pObject ) ; } return result ; 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone " + " encode is not of type " + " java.lang.String " ) ; } else { result = metaphone ( ( String ) pObject ) ; } return result ; } 
public String soundex ( String str ) { if ( null = = str | | str . length ( ) = = 0 ) { return str ; } StringBuffer sBuf = new StringBuffer ( ) ; str = str . oUpperCase ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to " + " RefinedSoundex " + " encode is not of type " + " java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to " + " Soundex " + " encode is not of type " + " java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; 
public String doubleMetaphone ( String value ) { return doubleMetaphone ( value , false ) ; } 
public Object encode ( Object obj ) hrows EncoderException { Object result ; if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone " 
public String encode ( String value ) hrows EncoderException { return ( doubleMetaphone ( value ) ) ; } 
public boolean isDoubleMetaphoneEqual ( String value1 , String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; } 
public boolean isDoubleMetaphoneEqual ( String value1 , String value2 , boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; 
private int handleAEIOUY ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'A' ) ; } return index + 1 ; } 
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { very confusing, moved out result.append('K'); index += 2; } else if (index == 0 && contains(value, index, 6, "CAESAR")) { result.append('S'); index += 2; } else if (contains(value, index, 2, "CH")) { index = handleCH(value, result, index); } else if (contains(value, index, 2, "CZ") && !contains(value, index - 2, 4, "WICZ")) { -- "Czerny" -- result.append('S', 'X'); index += 2; } else if (contains(value, index + 1, 3, "CIA")) { -- "focaccia" -- result.append('X'); index += 3; } else if (contains(value, index, 2, "CC") && !(index == 1 && charAt(value, 0) == 'M')) { -- double "cc" but not "McClelland" -- return handleCC(value, result, index); } else if (contains(value, index, 2, "CK", "CG", "CQ")) { result.append('K'); index += 2; } else if (contains(value, index, 2, "CI", "CE", "CY")) { -- Italian vs. English -- if (contains(value, index, 3, "CIO", "CIE", "CIA")) { result.append('S', 'X'); } else { result.append('S'); } index += 2; } else { result.append('K'); if (contains(value, index + 1, 2, " C", " Q", " G")) { -- Mac Caffrey, Mac Gregor -- index += 3; } else if (contains(value, index + 1, 1, "C", "K", "Q") && !contains(value, index + 1, 2, "CE", "CI")) { index += 2; } else { index++; } } return index; } 
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if ((index == 1 && charAt(value, index - 1) == 'A') || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleCH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); 
private int handleD ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " DG " ) ) { -- "Edge" -- if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('J'); index += 3; -- "Edgar" -- } else { result.append("TK"); index += 2; } } else if (contains(value, index, 2, "DT", "DD")) { result.append('T'); index += 2; } else { result.append('T'); index++; } return index; } 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 4, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleH ( String value , DoubleMetaphoneResult result , int index ) { -- only keep if first & before vowel or between 2 vowels -- if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) { result.append('H'); index += 2; -- also takes car of "HH" -- } else { index++; } return index; } 
private int handleJ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && ! contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleL ( String value , DoubleMetaphoneResult result , int index ) { result . append ( 'L' ) ; if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendAlternate ( ' ' ) ; } index + = 2 ; } else { index + + ; } return index ; } 
private int handleP ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleR ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt", "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")){ -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private boolean conditionC0 ( String value , int index ) { if ( contains ( value , index , 4 , " CHIA " ) ) { return rue ; 
private boolean conditionCH0 ( String value , int index ) { if ( index ! = 0 ) { return false ; 
private boolean conditionCH1 ( String value , int index ) { return ( ( contains ( value , 0 , 4 , " VAN " , " VON " ) | | contains ( value , 0 , 3 , " SCH " ) ) | | 
private boolean conditionL0 ( String value , int index ) { if ( index = = value . length ( ) - 3 & & contains ( value , index - 1 , 4 , " ILLO " , " ILLA " , " ALLE " ) ) { 
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; 
private boolean isSlavoGermanic ( String value ) { return value . indexOf ( 'W' ) > - 1 | | value . indexOf ( 'K' ) > - 1 | | value . indexOf ( " CZ " ) > - 1 | | value . indexOf ( " WITZ " ) > - 1 ; 
private boolean isSilentStart ( String value ) { boolean result = false ; for ( int i = 0 ; i < SILENT_START . length ; i + + ) { if ( value . startsWith ( SILENT_START [ i ] ) ) { result = rue ; break ; } } return result ; } 
private String cleanInput ( String input ) { if ( input = = null ) { return null ; 
protected char charAt ( String value , int index ) { if ( index < 0 | | index > = value . length ( ) ) { return Character . MIN_VALUE ; 
private static boolean contains ( String value , int start , int length , String criteria ) { return contains ( value , start , length , new String [ ] { criteria } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 , String criteria5 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 , String criteria5 , String criteria6 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { String arget = value . substring ( start , start + length ) ; for ( int i = 0 ; i < criteria . length ; i + + ) { if ( arget . equals ( criteria [ i ] ) ) { result = rue ; break ; } } } return result ; } 
public void append ( char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } 
public void append ( char primary , char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } 
public void appendPrimary ( char value ) { if ( primary . length ( ) < maxLength ) { primary . append ( value ) ; 
public void appendAlternate ( char value ) { if ( alternate . length ( ) < maxLength ) { alternate . append ( value ) ; 
public void append ( String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } 
public void append ( String primary , String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } 
public void appendPrimary ( String value ) { int addChars = maxLength - primary . length ( ) ; if ( value . length ( ) < = addChars ) { primary . append ( value ) ; 
public void appendAlternate ( String value ) { int addChars = maxLength - alternate . length ( ) ; if ( value . length ( ) < = addChars ) { alternate . append ( value ) ; 
public boolean isComplete ( ) { return primary . length ( ) > = maxLength & & alternate . length ( ) > = maxLength ; 
public boolean isDoubleMetaphoneEqual ( String value1 , String value2 , boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; 
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { very confusing, moved out result.append('K'); index += 2; } else if (index == 0 && contains(value, index, 6, "CAESAR")) { result.append('S'); index += 2; } else if (contains(value, index, 2, "CH")) { index = handleCH(value, result, index); } else if (contains(value, index, 2, "CZ") && !contains(value, index - 2, 4, "WICZ")) { -- "Czerny" -- result.append('S', 'X'); index += 2; } else if (contains(value, index + 1, 3, "CIA")) { -- "focaccia" -- result.append('X'); index += 3; } else if (contains(value, index, 2, "CC") && !(index == 1 && charAt(value, 0) == 'M')) { -- double "cc" but not "McClelland" -- return handleCC(value, result, index); } else if (contains(value, index, 2, "CK", "CG", "CQ")) { result.append('K'); index += 2; } else if (contains(value, index, 2, "CI", "CE", "CY")) { -- Italian vs. English -- if (contains(value, index, 3, "CIO", "CIE", "CIA")) { result.append('S', 'X'); } else { result.append('S'); } index += 2; } else { result.append('K'); if (contains(value, index + 1, 2, " C", " Q", " G")) { -- Mac Caffrey, Mac Gregor -- index += 3; } else if (contains(value, index + 1, 1, "C", "K", "Q") && !contains(value, index + 1, 2, "CE", "CI")) { index += 2; } else { index++; } } return index; } 
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if ((index == 1 && charAt(value, index - 1) == 'A') || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleCH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); 
private int handleD ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " DG " ) ) { -- "Edge" -- if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('J'); index += 3; -- "Edgar" -- } else { result.append("TK"); index += 2; } } else if (contains(value, index, 2, "DT", "DD")) { result.append('T'); index += 2; } else { result.append('T'); index++; } return index; } 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 4, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleH ( String value , DoubleMetaphoneResult result , int index ) { -- only keep if first & before vowel or between 2 vowels -- if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) { result.append('H'); index += 2; -- also takes car of "HH" -- } else { index++; } return index; } 
private int handleJ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic &&(charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleL ( String value , DoubleMetaphoneResult result , int index ) { result . append ( 'L' ) ; if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendAlternate ( ' ' ) ; } index + = 2 ; } else { index + + ; } return index ; } 
private int handleP ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleR ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")){ -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
public static final byte [ ] urlencode ( BitSet urlsafe , byte [ ] pArray ) hrows EncoderException { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( ( int ) hex1 ) ; buffer . write ( ( int ) hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] urldecode ( byte [ ] pArray ) hrows DecoderException { if ( pArray = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( byte [ ] pArray ) hrows EncoderException { return urlencode ( WWW_FORM_URL , pArray ) ; } 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { return urldecode ( pArray ) ; } 
public String encode ( String pString , String charset ) hrows EncoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , " US-ASCII " ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return new String ( encode ( pString . getBytes ( ) ) , " US-ASCII " ) ; 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( " US-ASCII " ) ) , charset ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return new String ( decode ( pString . getBytes ( " US-ASCII " ) ) ) ; 
public Object encode ( Object pObject ) hrows EncoderException { if ( pObject = = null ) { return null ; 
public Object decode ( Object pObject ) hrows DecoderException { if ( pObject = = null ) { return null ; 
public Object encode ( Object pObject ) hrows EncoderException { if ( pObject instanceof String ) { pObject = ( ( String ) pObject ) . getBytes ( ) ; } try { return encodeHex ( ( byte [ ] ) pObject ) ; 
public Object decode ( Object pObject ) hrows DecoderException { if ( pObject instanceof String ) { pObject = ( ( String ) pObject ) . getBytes ( ) ; } try { return decodeHex ( ( char [ ] ) pObject ) ; 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { return decodeHex ( new String ( pArray ) . oCharArray ( ) ) ; } 
public static byte [ ] decodeHex ( char [ ] data ) hrows DecoderException { int l = data . length ; if ( ( l & 0x01 ) ! = 0 ) { hrow new DecoderException ( " odd number of characters. " ) ; } byte [ ] out = new byte [ l > > 1 ] ; two characters form the hex value. for (int i = 0, j = 0; j < l; i++) { int f = Character.digit(data[j++], 16) << 4; f = f | Character.digit(data[j++], 16); out[i] = (byte) (f & 0xFF); } return out; } 
public void estBasicEncodeDecode ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = urlcodec . encode ( plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlcodec . decode ( encoded ) ) ; 
public void estSafeCharEncodeDecode ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " abc123_-.* " ; String encoded = urlcodec . encode ( plain ) ; assertEquals ( " Safe chars URL encoding test " , plain , encoded ) ; assertEquals ( " Safe chars URL decoding test " , plain , urlcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; String encoded = urlcodec . encode ( plain ) ; assertEquals ( " Unsafe chars URL encoding test " , " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded ) ; assertEquals ( " Unsafe chars URL decoding test " , plain , urlcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; assertNull ( " Null string URL encoding test " , urlcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string URL decoding test " , urlcodec . decode ( ( String ) null ) ) ; 
public void estDecodeInvalid ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; ry { urlcodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { urlcodec.decode("%A"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { urlcodec.decode("%WW"); 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone " 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { byte [ ] result ; result = decodeBase64 ( pArray ) ; return ( result ) ; } 
public static final byte [ ] urlencode ( BitSet urlsafe , byte [ ] pArray ) hrows EncoderException { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( ( new String ( original ) ) . getBytes ( ) ) ; Object o = bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] origBytes = original . getBytes ( ) ; Object origObj = origBytes ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public static final byte [ ] urlencode ( BitSet urlsafe , byte [ ] pArray ) hrows EncoderException { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b > = 0 & & urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
private String constructString ( int [ ] unicodeChars ) { StringBuffer buffer = new StringBuffer ( ) ; if ( unicodeChars ! = null ) { for ( int i = 0 ; i < unicodeChars . length ; i + + ) { buffer . append ( ( char ) unicodeChars [ i ] ) ; } } return buffer . oString ( ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec codec = new URLCodec ( ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , codec . encode ( ru_msg , " UTF-8 " ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , codec . encode ( ch_msg , " UTF-8 " ) ) ; assertEquals ( ru_msg , codec . decode ( codec . encode ( ru_msg , " UTF-8 " ) , " UTF-8 " ) ) ; assertEquals ( ch_msg , codec . decode ( codec . encode ( ch_msg , " UTF-8 " ) , " UTF-8 " ) ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] pArray ) hrows EncoderException { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b > = 0 & & urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( byte [ ] pArray ) hrows DecoderException { if ( pArray = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( byte [ ] pArray ) hrows EncoderException { return encodeUrl ( WWW_FORM_URL , pArray ) ; } 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { return decodeUrl ( pArray ) ; } 
public String encode ( String pString , String charset ) hrows EncoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , ENCODING ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return new String ( encode ( pString . getBytes ( ) ) , ENCODING ) ; 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( ENCODING ) ) , charset ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return new String ( decode ( pString . getBytes ( ENCODING ) ) ) ; 
public static Test suite ( ) { return ( new TestSuite ( DoubleMetaphoneTest . class ) ) ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; _doubleMetaphone = new DoubleMetaphone ( ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; _doubleMetaphone = null ; } 
public void estDoubleMetaphone ( ) { assertEquals ( " TSTN " , _doubleMetaphone . doubleMetaphone ( " esting " ) ) ; assertEquals ( " 0 " , _doubleMetaphone . doubleMetaphone ( " The " ) ) ; assertEquals ( " KK " , _doubleMetaphone . doubleMetaphone ( " quick " ) ) ; assertEquals ( " PRN " , _doubleMetaphone . doubleMetaphone ( " brown " ) ) ; assertEquals ( " FKS " , _doubleMetaphone . doubleMetaphone ( " fox " ) ) ; assertEquals ( " JMPT " , _doubleMetaphone . doubleMetaphone ( " jumped " ) ) ; assertEquals ( " AFR " , _doubleMetaphone . doubleMetaphone ( " over " ) ) ; assertEquals ( " 0 " , _doubleMetaphone . doubleMetaphone ( " he " ) ) ; assertEquals ( " LS " , _doubleMetaphone . doubleMetaphone ( " lazy " ) ) ; assertEquals ( " TKS " , _doubleMetaphone . doubleMetaphone ( " dogs " ) ) ; assertEquals ( " MKFR " , _doubleMetaphone . doubleMetaphone ( " MacCafferey " ) ) ; assertEquals ( " TSTN " , _doubleMetaphone . doubleMetaphone ( " esting " , rue ) ) ; assertEquals ( " T " , _doubleMetaphone . doubleMetaphone ( " The " , rue ) ) ; assertEquals ( " KK " , _doubleMetaphone . doubleMetaphone ( " quick " , rue ) ) ; assertEquals ( " PRN " , _doubleMetaphone . doubleMetaphone ( " brown " , rue ) ) ; assertEquals ( " FKS " , _doubleMetaphone . doubleMetaphone ( " fox " , rue ) ) ; assertEquals ( " AMPT " , _doubleMetaphone . doubleMetaphone ( " jumped " , rue ) ) ; assertEquals ( " AFR " , _doubleMetaphone . doubleMetaphone ( " over " , rue ) ) ; assertEquals ( " T " , _doubleMetaphone . doubleMetaphone ( " he " , rue ) ) ; assertEquals ( " LS " , _doubleMetaphone . doubleMetaphone ( " lazy " , rue ) ) ; assertEquals ( " TKS " , _doubleMetaphone . doubleMetaphone ( " dogs " , rue ) ) ; assertEquals ( " MKFR " , _doubleMetaphone . doubleMetaphone ( " MacCafferey " , rue ) ) ; } 
public void estIsDoubleMetaphoneEqual ( ) { doubleMetaphoneEqualTest ( false ) ; doubleMetaphoneEqualTest ( rue ) ; } 
public void doubleMetaphoneEqualTest ( boolean alternate ) { assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " Case " , " case " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " CASE " , " Case " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " caSe " , " cAsE " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " cookie " , " quick " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " quick " , " cookie " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " Bryan " , " Brian " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " Brian " , " Bryan " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " Otto " , " Auto " , alternate ) ) ; assertTrue ( _doubleMetaphone . isDoubleMetaphoneEqual ( " Auto " , " Otto " , alternate ) ) ; assertTrue ( ! _doubleMetaphone . isDoubleMetaphoneEqual ( " Brain " , " Band " , alternate ) ) ; assertTrue ( ! _doubleMetaphone . isDoubleMetaphoneEqual ( " Band " , " Brain " , alternate ) ) ; } 
public void estMd5Hex ( ) { "57edf4a22be3c955ac49da2e2107b67a", 
public void estMD5HexLength ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( hashMe . getBytes ( ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( hashMe . getBytes ( ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMD5Length ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( hashMe . getBytes ( ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( hashMe . getBytes ( ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estShaHex ( ) { "84983e441c3bd26ebaae4aa1f95129e5e54670f1", 
public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { Comparable s1 = ( Comparable ) ( ( Encoder ) stringEncoder ) . encode ( o1 ) ; Comparable s2 = ( Comparable ) ( ( Encoder ) stringEncoder ) . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return ( compareCode ) ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; List estList = Arrays . asList ( estArray ) ; String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; Collections . sort ( estList , sCompare ) ; String [ ] resultArray = ( String [ ] ) estList . oArray ( new String [ 0 ] ) ; for ( int i = 0 ; i < resultArray . length ; i + + ) { assertEquals ( " Result Array not Equal to Control Array at index: " + i , controlArray [ i ] , resultArray [ i ] ) ; 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; int compare = sCompare . compare ( new Double ( 3.0 ) , new Long ( 3 ) ) ; assertEquals ( " Trying to compare objects that make no sense to the underlying encoder should return a zero compare code " , 0 , compare ) ; 
public void estEncodeNull ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; byte [ ] plain = null ; byte [ ] encoded = urlcodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlcodec . decode ( encoded ) ) ; 
public void estDecodeWithNullArray ( ) hrows Exception { byte [ ] plain = null ; byte [ ] result = URLCodec . decodeUrl ( plain ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String est = null ; String result = urlcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String est = null ; String result = urlcodec . decode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] encodedBA = ( byte [ ] ) urlcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estInvalidEncoding ( ) { URLCodec urlcodec = new URLCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { String encoded = urlcodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { } ry { String decoded = urlcodec . decode ( plain ) ; 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlcodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] decodedBA = ( byte [ ] ) urlcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estShaHex ( ) { "84983e441c3bd26ebaae4aa1f95129e5e54670f1", 
public void estMd5NoAvailable ( ) { DigestUtils . setProvider ( Security . getProviders ( ) [ 3 ] ) ; ry { DigestUtils . md5 ( " est " ) ; 
public void estSHANoAvailable ( ) { DigestUtils . setProvider ( Security . getProviders ( ) [ 3 ] ) ; ry { DigestUtils . sha ( " est " ) ; 
public Object decode ( Object pObject ) hrows DecoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new DecoderException ( " Parameter supplied to Base64 decode is not a byte[] " ) ; } else { result = decode ( ( byte [ ] ) pObject ) ; } return result ; 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { int lengthDataBits = binaryData . length * EIGHTBIT ; int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP ; byte encodedData [ ] = null ; int encodedDataLength = 0 ; int nbrChunks = 0 ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedDataLength = (numberTriplets + 1) * 4; } else { 16 or 8 bit encodedDataLength = numberTriplets * 4; } If the output is to be "chunked" into 76 character sections, for compliance with RFC 2045 MIME, then it is important to allow for extra length to account for the separator(s) if (isChunked) { nbrChunks = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE)); encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length; } encodedData = new byte[encodedDataLength]; byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; int nextSeparatorIndex = CHUNK_SIZE; int chunksSoFar = 0; log.debug("number of triplets = " + numberTriplets); for (i = 0; i < numberTriplets; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; log.debug("b1= " + b1 +", b2= " + b2 + ", b3= " + b3); l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; log.debug( "val2 = " + val2 ); log.debug( "k4 = " + (k<<4) ); log.debug( "vak = " + (val2 | (k<<4)) ); encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; encodedIndex += 4; If we are chunking, let's put a chunk separator down. if (isChunked) { this assumes that CHUNK_SIZE % 4 == 0 if (encodedIndex == nextSeparatorIndex) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length); chunksSoFar++; nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length); encodedIndex += CHUNK_SEPARATOR.length; } } } form integral number of 6-bit groups dataIndex = i * 3; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); log.debug("b1=" + b1); log.debug("b1<<2 = " + (b1>>2) ); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } if (isChunked) { we also add a separator to the end of the final chunk. if (chunksSoFar < nbrChunks) { System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length); } } return encodedData; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base64 encode is not a byte[] " ) ; } else { result = encode ( ( byte [ ] ) pObject ) ; } return result ; 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } else { result = metaphone ( ( String ) pObject ) ; } return result ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; 
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( maxCodeLen ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 4, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleJ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleP ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")){ -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] pArray ) { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b > = 0 & & urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( byte [ ] pArray ) { return encodeUrl ( WWW_FORM_URL , pArray ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , his . getEncoding ( ) ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return new String ( encode ( pString . getBytes ( ) ) , his . getEncoding ( ) ) ; 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( his . getEncoding ( ) ) ) , charset ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return new String ( decode ( pString . getBytes ( his . getEncoding ( ) ) ) ) ; 
public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { Comparable s1 = ( Comparable ) ( ( Encoder ) stringEncoder ) . encode ( o1 ) ; Comparable s2 = ( Comparable ) ( ( Encoder ) stringEncoder ) . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return compareCode ; } 
public void estInternalNoSuchAlgorithmException ( ) { ry { DigestUtils . getDigest ( " Bogus Bogus " ) ; 
public void estMd5Hex ( ) { Examples from RFC 1321 assertEquals("d41d8cd98f00b204e9800998ecf8427e", DigestUtils.md5Hex("")); assertEquals("0cc175b9c0f1b6a831c399e269772661", DigestUtils.md5Hex("a")); assertEquals("900150983cd24fb0d6963f7d28e17f72", DigestUtils.md5Hex("abc")); assertEquals("f96b697d7cb7938d525a2f31aaf161d0", DigestUtils.md5Hex("message digest")); assertEquals("c3fcd3d76192e4007dfb496cca67e13b", DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "d174ab98d277d9f5a5611c2c9f419d9f", DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "57edf4a22be3c955ac49da2e2107b67a", 
public void estMD5HexLength ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( hashMe . getBytes ( ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( hashMe . getBytes ( ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMD5Length ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( hashMe . getBytes ( ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( hashMe . getBytes ( ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estShaHex ( ) { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc".getBytes())); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", 
public void estDecodePadMarkerIndex2 ( ) { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( ) ) ) ) ; } 
public void estDecodePadOnly ( ) { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) ) ) ; } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't eausl original " , dest . equals ( orig ) ) ; 
public void estDiscardWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] encodedNoWS = Base64 . discardWhitespace ( encodedWithWS ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; byte [ ] decodedNoWS = Base64 . decodeBase64 ( encodedNoWS ) ; String destFromWS = new String ( decodedWithWS ) ; String destFromNoWS = new String ( decodedNoWS ) ; assertTrue ( " Dest string doesn't eausl original " , destFromWS . equals ( orig ) ) ; assertTrue ( " Dest string doesn't eausl original " , destFromNoWS . equals ( orig ) ) ; 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { byte [ ] data = new byte [ his . getRandom ( ) . nextInt ( 10000 ) + 1 ] ; 
public static byte [ ] decodeHex ( char [ ] data ) hrows DecoderException { int l = data . length ; if ( ( l & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } byte [ ] out = new byte [ l > > 1 ] ; two characters form the hex value. for (int i = 0, j = 0; j < l; i++) { int f = Character.digit(data[j++], 16) << 4; f = f | Character.digit(data[j++], 16); out[i] = (byte) (f & 0xFF); } return out; } 
public byte [ ] decode ( byte [ ] array ) hrows DecoderException { return decodeHex ( new String ( array ) . oCharArray ( ) ) ; } 
public Object decode ( Object object ) hrows DecoderException { try { char [ ] charArray = object instanceof String ? ( ( String ) object ) . oCharArray ( ) : ( char [ ] ) object ; 
public Object encode ( Object object ) hrows EncoderException { try { byte [ ] byteArray = object instanceof String ? ( ( String ) object ) . getBytes ( ) : ( byte [ ] ) object ; 
public void estDecodeArrayOddCharacters ( ) { ry { new Hex ( ) . decode ( new byte [ ] { 65 } ) ; 
public void estDecodeClassCastException ( ) { ry { new Hex ( ) . decode ( new int [ ] { 65 } ) ; 
public void estDecodeHexOddCharacters ( ) { ry { Hex . decodeHex ( new char [ ] { 'A' } ) ; 
public void estDecodeStringOddCharacters ( ) { ry { new Hex ( ) . decode ( " 6 " ) ; 
public void estDencodeEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( " " ) ) ) ; } 
public void estEncodeClassCastException ( ) { ry { new Hex ( ) . encode ( new int [ ] { 65 } ) ; 
public void estEncodeDecodeRandom ( ) hrows DecoderException , EncoderException { Random random = new Random ( ) ; Hex hex = new Hex ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { byte [ ] data = new byte [ random . nextInt ( 10000 ) + 1 ] ; 
public void estEncodeEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( " " ) ) ) ; } 
public void estEncodeZeroes ( ) { char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000 " 
public void estHelloWorld ( ) { byte [ ] b = " Hello World " . getBytes ( ) ; char [ ] c = Hex . encodeHex ( b ) ; assertEquals ( " 48656c6c6f20576f726c64 " , new String ( c ) ) ; } 
public byte [ ] decode ( byte [ ] pArray ) { byte [ ] result ; result = decodeBase64 ( pArray ) ; return ( result ) ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . setEncoder ( new Soundex ( ) ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; his . setEncoder ( null ) ; } 
public void estEncode ( ) hrows Exception { assertEquals ( " T235 " , his . getEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T000 " , his . getEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q200 " , his . getEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B650 " , his . getEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F200 " , his . getEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J513 " , his . getEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O160 " , his . getEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T000 " , his . getEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L200 " , his . getEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D200 " , his . getEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncode2 ( ) hrows Exception { assertEquals ( " A462 " , his . getEncoder ( ) . encode ( " Allricht " ) ) ; assertEquals ( " E166 " , his . getEncoder ( ) . encode ( " Eberhard " ) ) ; assertEquals ( " E521 " , his . getEncoder ( ) . encode ( " Engebrethson " ) ) ; assertEquals ( " H512 " , his . getEncoder ( ) . encode ( " Heimbach " ) ) ; assertEquals ( " H524 " , his . getEncoder ( ) . encode ( " Hanselmann " ) ) ; assertEquals ( " H431 " , his . getEncoder ( ) . encode ( " Hildebrand " ) ) ; assertEquals ( " K152 " , his . getEncoder ( ) . encode ( " Kavanagh " ) ) ; assertEquals ( " L530 " , his . getEncoder ( ) . encode ( " Lind, Van " ) ) ; assertEquals ( " L222 " , his . getEncoder ( ) . encode ( " Lukaschowsky " ) ) ; assertEquals ( " M235 " , his . getEncoder ( ) . encode ( " McDonnell " ) ) ; assertEquals ( " M200 " , his . getEncoder ( ) . encode ( " McGee " ) ) ; Fix me? assertEquals("O165",this.getEncoder().encode("O'Brien")); assertEquals("O155",this.getEncoder().encode("Opnian")); assertEquals("O155",this.getEncoder().encode("Oppenheimer")); Fix me? assertEquals("S460",this.getEncoder().encode("Swhgler")); assertEquals("R355",this.getEncoder().encode("Riedemanas")); assertEquals("Z300",this.getEncoder().encode("Zita")); assertEquals("Z325",this.getEncoder().encode("Zitzmeinn")); } 
private String clean ( String str ) { if ( str = = null | | str . length ( ) = = 0 ) { return str ; } int len = str . length ( ) ; char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( ) ; } return new String ( chars , 0 , count ) . oUpperCase ( ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( " Test for org.apache.commons.codec.language " ) ; $JUnit-BEGIN$ suite.addTest(MetaphoneTest.suite()); suite.addTest(SoundexTest.suite()); suite.addTest(RefinedSoundexTest.suite()); suite.addTest(DoubleMetaphoneTest.suite()); $JUnit-END$ return suite; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . setEncoder ( new Soundex ( ) ) ; } 
void encodeAll ( String [ ] strings , String expectedEncoding ) { for ( int i = 0 ; i < strings . length ; i + + ) { assertEquals ( expectedEncoding , his . getEncoder ( ) . encode ( strings [ i ] ) ) ; 
public void estEncodeBasic ( ) { assertEquals ( " T235 " , his . getEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T000 " , his . getEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q200 " , his . getEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B650 " , his . getEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F200 " , his . getEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J513 " , his . getEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O160 " , his . getEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T000 " , his . getEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L200 " , his . getEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D200 " , his . getEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncodeBatch2 ( ) { assertEquals ( " A462 " , his . getEncoder ( ) . encode ( " Allricht " ) ) ; assertEquals ( " E166 " , his . getEncoder ( ) . encode ( " Eberhard " ) ) ; assertEquals ( " E521 " , his . getEncoder ( ) . encode ( " Engebrethson " ) ) ; assertEquals ( " H512 " , his . getEncoder ( ) . encode ( " Heimbach " ) ) ; assertEquals ( " H524 " , his . getEncoder ( ) . encode ( " Hanselmann " ) ) ; assertEquals ( " H431 " , his . getEncoder ( ) . encode ( " Hildebrand " ) ) ; assertEquals ( " K152 " , his . getEncoder ( ) . encode ( " Kavanagh " ) ) ; assertEquals ( " L530 " , his . getEncoder ( ) . encode ( " Lind " ) ) ; assertEquals ( " L222 " , his . getEncoder ( ) . encode ( " Lukaschowsky " ) ) ; assertEquals ( " M235 " , his . getEncoder ( ) . encode ( " McDonnell " ) ) ; assertEquals ( " M200 " , his . getEncoder ( ) . encode ( " McGee " ) ) ; assertEquals ( " O155 " , his . getEncoder ( ) . encode ( " Opnian " ) ) ; assertEquals ( " O155 " , his . getEncoder ( ) . encode ( " Oppenheimer " ) ) ; assertEquals ( " R355 " , his . getEncoder ( ) . encode ( " Riedemanas " ) ) ; assertEquals ( " Z300 " , his . getEncoder ( ) . encode ( " Zita " ) ) ; assertEquals ( " Z325 " , his . getEncoder ( ) . encode ( " Zitzmeinn " ) ) ; } 
public void estEncodeBatch3 ( ) { assertEquals ( " W252 " , his . getEncoder ( ) . encode ( " Washington " ) ) ; assertEquals ( " L000 " , his . getEncoder ( ) . encode ( " Lee " ) ) ; assertEquals ( " G362 " , his . getEncoder ( ) . encode ( " Gutierrez " ) ) ; assertEquals ( " P236 " , his . getEncoder ( ) . encode ( " Pfister " ) ) ; assertEquals ( " J250 " , his . getEncoder ( ) . encode ( " Jackson " ) ) ; assertEquals ( " T522 " , his . getEncoder ( ) . encode ( " Tymczak " ) ) ; For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also possible. assertEquals("V532", this.getEncoder().encode("VanDeusen")); } 
public void estEncodeBatch4 ( ) { assertEquals ( " H452 " , his . getEncoder ( ) . encode ( " HOLMES " ) ) ; assertEquals ( " A355 " , his . getEncoder ( ) . encode ( " ADOMOMI " ) ) ; assertEquals ( " V536 " , his . getEncoder ( ) . encode ( " VONDERLEHR " ) ) ; assertEquals ( " B400 " , his . getEncoder ( ) . encode ( " BALL " ) ) ; assertEquals ( " S000 " , his . getEncoder ( ) . encode ( " SHAW " ) ) ; assertEquals ( " J250 " , his . getEncoder ( ) . encode ( " JACKSON " ) ) ; assertEquals ( " S545 " , his . getEncoder ( ) . encode ( " SCANLON " ) ) ; assertEquals ( " S532 " , his . getEncoder ( ) . encode ( " SAINTJOHN " ) ) ; 
public void estEncodeIgnoreApostrophes ( ) { his . encodeAll ( new String [ ] { " OBrien " , " 'OBrien " , " O'Brien " , " OB'rien " , " OBr'ien " , " OBri'en " , " OBrie'n " , " OBrien' " } , " O165 " ) ; } 
public void estEncodeIgnoreHyphens ( ) { his . encodeAll ( new String [ ] { 
public void estEncodeIgnoreTrimmable ( ) { assertEquals ( " W252 " , his . getEncoder ( ) . encode ( " r Washington r " ) ) ; } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. assertEquals("A261", this.getEncoder().encode("Ashcraft")); } 
public void estHWRuleEx2 ( ) { assertEquals ( " B312 " , his . getEncoder ( ) . encode ( " BOOTHDAVIS " ) ) ; assertEquals ( " B312 " , his . getEncoder ( ) . encode ( " BOOTH-DAVIS " ) ) ; } 
public void estHWRuleEx3 ( ) { assertEquals ( " S460 " , his . getEncoder ( ) . encode ( " Sgler " ) ) ; assertEquals ( " S460 " , his . getEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: this.encodeAll( new String[] { 
public void estMaxLength ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( soundex . getMaxLength ( ) ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = his . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; last = getMappingCode ( str , 0 ) ; while ( ( incount < str . length ( ) ) & & ( count < out . length ) ) { mapped = getMappingCode ( str , incount + + ) ; if ( mapped ! = 0 ) { if ( ( mapped ! = '0' ) & & ( mapped ! = last ) ) { out [ count + + ] = mapped ; } last = mapped ; } } return new String ( out ) ; } 
public void estMaxLength ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( soundex . getMaxLength ( ) ) ; assertEquals ( " S460 " , his . getEncoder ( ) . encode ( " Sgler " ) ) ; } 
public void estMaxLengthLessThan3Fix ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( 2 ) ; assertEquals ( " S460 " , soundex . encode ( " SCHELLER " ) ) ; } 
public static Test suite ( ) { return ( new TestSuite ( DoubleMetaphoneTest . class ) ) ; } 
private void assertDoubleMetaphone ( String expected , String source ) { assertEquals ( expected , his . getDoubleMetaphone ( ) . encode ( source ) ) ; ry { assertEquals ( expected , his . getDoubleMetaphone ( ) . encode ( ( Object ) source ) ) ; } catch ( EncoderException e ) { fail ( " Unexpected expection: " + e ) ; } assertEquals ( expected , his . getDoubleMetaphone ( ) . doubleMetaphone ( source ) ) ; assertEquals ( expected , his . getDoubleMetaphone ( ) . doubleMetaphone ( source , false ) ) ; } 
public void assertDoubleMetaphoneAlt ( String expected , String source ) { assertEquals ( expected , his . getDoubleMetaphone ( ) . doubleMetaphone ( source , rue ) ) ; } 
public void doubleMetaphoneEqualTest ( String [ ] [ ] pairs , boolean useAlternate ) { his . validateFixture ( pairs ) ; for ( int i = 0 ; i < pairs . length ; i + + ) { String name0 = pairs [ i ] [ 0 ] ; 
public void doubleMetaphoneNotEqualTest ( boolean alternate ) { assertFalse ( his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " , alternate ) ) ; assertFalse ( his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " Band " , " Brain " , alternate ) ) ; if ( ! alternate ) { assertFalse ( his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " ) ) ; 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . setDoubleMetaphone ( new DoubleMetaphone ( ) ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; his . setDoubleMetaphone ( null ) ; } 
public void estDoubleMetaphone ( ) { assertDoubleMetaphone ( " TSTN " , " esting " ) ; assertDoubleMetaphone ( " 0 " , " The " ) ; assertDoubleMetaphone ( " KK " , " quick " ) ; assertDoubleMetaphone ( " PRN " , " brown " ) ; assertDoubleMetaphone ( " FKS " , " fox " ) ; assertDoubleMetaphone ( " JMPT " , " jumped " ) ; assertDoubleMetaphone ( " AFR " , " over " ) ; assertDoubleMetaphone ( " 0 " , " he " ) ; assertDoubleMetaphone ( " LS " , " lazy " ) ; assertDoubleMetaphone ( " TKS " , " dogs " ) ; assertDoubleMetaphone ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphone ( " STFN " , " Stephan " ) ; assertDoubleMetaphone ( " KSSK " , " Kuczewski " ) ; assertDoubleMetaphoneAlt ( " TSTN " , " esting " ) ; assertDoubleMetaphoneAlt ( " T " , " The " ) ; assertDoubleMetaphoneAlt ( " KK " , " quick " ) ; assertDoubleMetaphoneAlt ( " PRN " , " brown " ) ; assertDoubleMetaphoneAlt ( " FKS " , " fox " ) ; assertDoubleMetaphoneAlt ( " AMPT " , " jumped " ) ; assertDoubleMetaphoneAlt ( " AFR " , " over " ) ; assertDoubleMetaphoneAlt ( " T " , " he " ) ; assertDoubleMetaphoneAlt ( " LS " , " lazy " ) ; assertDoubleMetaphoneAlt ( " TKS " , " dogs " ) ; assertDoubleMetaphoneAlt ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphoneAlt ( " STFN " , " Stephan " ) ; assertDoubleMetaphoneAlt ( " KXFS " , " Kutchefski " ) ; } 
public void estEmpty ( ) { assertEquals ( null , his . getDoubleMetaphone ( ) . doubleMetaphone ( null ) ) ; assertEquals ( null , his . getDoubleMetaphone ( ) . doubleMetaphone ( " " ) ) ; assertEquals ( null , his . getDoubleMetaphone ( ) . doubleMetaphone ( " " ) ) ; assertEquals ( null , his . getDoubleMetaphone ( ) . doubleMetaphone ( " r " ) ) ; } 
public void estIsDoubleMetaphoneEqualBasic ( ) { String [ ] [ ] estFixture = new String [ ] [ ] { { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " cookie " , " quick " } , { " quick " , " cookie " } , { " Brian " , " Bryan " } , { " Auto " , " Otto " } , { " Steven " , " Stefan " } , { " Philipowitz " , " Filipowicz " } } ; doubleMetaphoneEqualTest ( estFixture , false ) ; doubleMetaphoneEqualTest ( estFixture , rue ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } String msg = failures.toString(); matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended2 ( ) { String [ ] [ ] estFixture = new String [ ] [ ] { { " Jablonski " , " Yablonsky " } } ; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; StringBuffer failures = new StringBuffer ( ) ; StringBuffer matches = new StringBuffer ( ) ; String cr = System . getProperty ( " line.separator " ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { String name0 = FIXTURE [ i ] [ 0 ] ; String name1 = FIXTURE [ i ] [ 1 ] ; boolean match1 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; boolean match2 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } String msg = failures . oString ( ) ; matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. 
public void estIsDoubleMetaphoneEqualWithMATCHES ( ) { his . validateFixture ( MATCHES ) ; for ( int i = 0 ; i < MATCHES . length ; i + + ) { String name0 = MATCHES [ i ] [ 0 ] ; 
public void estIsDoubleMetaphoneNotEqual ( ) { doubleMetaphoneNotEqualTest ( false ) ; doubleMetaphoneNotEqualTest ( rue ) ; } 
public void validateFixture ( String [ ] [ ] pairs ) { if ( pairs . length = = 0 ) { fail ( " Test fixture is empty " ) ; } for ( int i = 0 ; i < pairs . length ; i + + ) { if ( pairs [ i ] . length ! = 2 ) { 
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( his . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( value , result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " DoubleMetaphone encode parameter is not of type java.lang.String " ) ; 
public void assertIsMetaphoneEqual ( String source , String [ ] matches ) { match source to all matches for (int i = 0; i < matches.length; i++) { assertTrue(this.getMetaphone().isMetaphoneEqual(source, matches[i])); } match to each other for (int i = 0; i < matches.length; i++) { for (int j = 0; j < matches.length; j++) { 
public void assertMetaphoneEqual ( String [ ] [ ] pairs ) { his . validateFixture ( pairs ) ; for ( int i = 0 ; i < pairs . length ; i + + ) { String name0 = pairs [ i ] [ 0 ] ; 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . setMetaphone ( new Metaphone ( ) ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; his . setMetaphone ( null ) ; } 
public void estIsMetaphoneEqual1 ( ) { his . assertMetaphoneEqual ( new String [ ] [ ] { { " Case " , " case " } , { " CASE " , " Case " } , { 
public void estIsMetaphoneEqual2 ( ) { his . assertMetaphoneEqual ( new String [ ] [ ] { { " Lawrence " , " Lorenza " } , { " Gary " , " Cahra " } , } ) ; 
public void estIsMetaphoneEqualAero ( ) { his . assertIsMetaphoneEqual ( " Aero " , new String [ ] { " Eure " } ) ; } 
public void estIsMetaphoneEqualWhite ( ) { his . assertIsMetaphoneEqual ( " White " , 
public void estIsMetaphoneEqualAlbert ( ) { his . assertIsMetaphoneEqual ( " Albert " , new String [ ] { " Ailbert " , " Alberik " , " Albert " , " Alberto " , " Albrecht " } ) ; } 
public void estIsMetaphoneEqualGary ( ) { his . assertIsMetaphoneEqual ( " Gary " , 
public void estIsMetaphoneEqualJohn ( ) { his . assertIsMetaphoneEqual ( " John " , 
public void estIsMetaphoneEqualKnight ( ) { his . assertIsMetaphoneEqual ( " Knight " , 
public void estIsMetaphoneEqualMary ( ) { his . assertIsMetaphoneEqual ( " Mary " , 
public void estIsMetaphoneEqualParis ( ) { his . assertIsMetaphoneEqual ( " Paris " , new String [ ] { " Pearcy " , " Perris " , " Piercy " , " Pierz " , " Pryse " } ) ; } 
public void estIsMetaphoneEqualPeter ( ) { his . assertIsMetaphoneEqual ( " Peter " , 
public void estIsMetaphoneEqualRay ( ) { his . assertIsMetaphoneEqual ( " Ray " , new String [ ] { " Ray " , " Rey " , " Roi " , " Roy " , " Ruy " } ) ; } 
public void estIsMetaphoneEqualSusan ( ) { his . assertIsMetaphoneEqual ( " Susan " , 
public void estIsMetaphoneEqualWright ( ) { his . assertIsMetaphoneEqual ( " Wright " , new String [ ] { " Rota " , " Rudd " , " Ryde " } ) ; } 
public void estIsMetaphoneEqualXalan ( ) { his . assertIsMetaphoneEqual ( " Xalan " , 
public void estMetaphone ( ) { assertEquals ( " TSTN " , his . getMetaphone ( ) . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " The " ) ) ; assertEquals ( " KK " , his . getMetaphone ( ) . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , his . getMetaphone ( ) . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , his . getMetaphone ( ) . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , his . getMetaphone ( ) . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , his . getMetaphone ( ) . metaphone ( " over " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " he " ) ) ; assertEquals ( " LS " , his . getMetaphone ( ) . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , his . getMetaphone ( ) . metaphone ( " dogs " ) ) ; } 
public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { Comparable s1 = ( Comparable ) ( ( Encoder ) his . stringEncoder ) . encode ( o1 ) ; Comparable s2 = ( Comparable ) ( ( Encoder ) his . stringEncoder ) . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return compareCode ; } 
public String encode ( String pString , String encoding ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( encoding ) ) , his . getEncoding ( ) ) ; } 
public String decode ( String pString , String encoding ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( his . getEncoding ( ) ) ) , encoding ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " DoubleMetaphone encode parameter is not of type String " ) ; 
public void estMsSqlServer1 ( ) { assertEquals ( " S530 " , his . getEncoder ( ) . encode ( " Smith " ) ) ; assertEquals ( " S530 " , his . getEncoder ( ) . encode ( " Smythe " ) ) ; } 
public void estMsSqlServer2 ( ) { his . encodeAll ( new String [ ] { " Erickson " , " Erickson " , " Erikson " , " Ericson " , " Ericksen " , " Ericsen " } , " E625 " ) ; } 
public void estMsSqlServer3 ( ) { assertEquals ( " A500 " , his . getEncoder ( ) . encode ( " Ann " ) ) ; assertEquals ( " A536 " , his . getEncoder ( ) . encode ( " Andrew " ) ) ; assertEquals ( " J530 " , his . getEncoder ( ) . encode ( " Janet " ) ) ; assertEquals ( " M626 " , his . getEncoder ( ) . encode ( " Margaret " ) ) ; assertEquals ( " S315 " , his . getEncoder ( ) . encode ( " Steven " ) ) ; assertEquals ( " M240 " , his . getEncoder ( ) . encode ( " Michael " ) ) ; assertEquals ( " R163 " , his . getEncoder ( ) . encode ( " Robert " ) ) ; assertEquals ( " L600 " , his . getEncoder ( ) . encode ( " Laura " ) ) ; assertEquals ( " A500 " , his . getEncoder ( ) . encode ( " Anne " ) ) ; } 
public int difference ( String s1 , String s2 ) hrows EncoderException { return difference ( his , s1 , s2 ) ; } 
public static int difference ( StringEncoder encoder , String s1 , String s2 ) hrows EncoderException { return differenceEncoded ( encoder . encode ( s1 ) , encoder . encode ( s2 ) ) ; } 
public static int differenceEncoded ( String es1 , String es2 ) { if ( es1 = = null | | es2 = = null ) { return 0 ; } int lengthToMatch = Math . min ( es1 . length ( ) , es2 . length ( ) ) ; int diff = 0 ; for ( int i = 0 ; i < lengthToMatch ; i + + ) { if ( es1 . charAt ( i ) = = es2 . charAt ( i ) ) { diff + + ; } } return diff ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = his . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; last = getMappingCode ( str , 0 ) ; while ( ( incount < str . length ( ) ) & & ( count < out . length ) ) { mapped = getMappingCode ( str , incount + + ) ; if ( mapped ! = 0 ) { if ( ( mapped ! = '0' ) & & ( mapped ! = last ) ) { out [ count + + ] = mapped ; } last = mapped ; } } return new String ( out ) ; } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(this.getEncoder().difference(null, null), 0); assertEquals(this.getEncoder().difference("", ""), 0); assertEquals(this.getEncoder().difference(" ", " "), 0); Normal cases assertEquals(this.getEncoder().difference("Smith", "Smythe"), 4); assertEquals(this.getEncoder().difference("Ann", "Andrew"), 2); assertEquals(this.getEncoder().difference("Margaret", "Andrew"), 1); assertEquals(this.getEncoder().difference("Janet", "Margaret"), 0); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(this.getEncoder().difference("Green", "Greene"), 4); assertEquals(this.getEncoder().difference("Blotchet-Halls", "Greene"), 0); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(this.getEncoder().difference("Smith", "Smythe"), 4); assertEquals(this.getEncoder().difference("Smithers", "Smythers"), 4); assertEquals(this.getEncoder().difference("Anothers", "Brothers"), 2); } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getEncoder().difference(null, null)); assertEquals(0, this.getEncoder().difference("", "")); assertEquals(0, this.getEncoder().difference(" ", " ")); Normal cases assertEquals(4, this.getEncoder().difference("Smith", "Smythe")); assertEquals(2, this.getEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getEncoder().difference("Margaret", "Andrew")); assertEquals(0, this.getEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(4, this.getEncoder().difference("Green", "Greene")); assertEquals(0, this.getEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(4, this.getEncoder().difference("Smith", "Smythe")); assertEquals(4, this.getEncoder().difference("Smithers", "Smythers")); assertEquals(2, this.getEncoder().difference("Anothers", "Brothers")); } 
public int difference ( String s1 , String s2 ) hrows EncoderException { return SoundexUtils . difference ( his , s1 , s2 ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { Object result ; if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } else { result = soundex ( ( String ) pObject ) ; } return result ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } StringBuffer sBuf = new StringBuffer ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; last = getMappingCode ( str , 0 ) ; while ( ( incount < str . length ( ) ) & & ( count < out . length ) ) { mapped = getMappingCode ( str , incount + + ) ; if ( mapped ! = 0 ) { if ( ( mapped ! = '0' ) & & ( mapped ! = last ) ) { out [ count + + ] = mapped ; } last = mapped ; } } return new String ( out ) ; } 
static String clean ( String str ) { if ( str = = null | | str . length ( ) = = 0 ) { return str ; } int len = str . length ( ) ; char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( ) ; } return new String ( chars , 0 , count ) . oUpperCase ( ) ; } 
static int difference ( StringEncoder encoder , String s1 , String s2 ) hrows EncoderException { return differenceEncoded ( encoder . encode ( s1 ) , encoder . encode ( s2 ) ) ; } 
static int differenceEncoded ( String es1 , String es2 ) { if ( es1 = = null | | es2 = = null ) { return 0 ; } int lengthToMatch = Math . min ( es1 . length ( ) , es2 . length ( ) ) ; int diff = 0 ; for ( int i = 0 ; i < lengthToMatch ; i + + ) { if ( es1 . charAt ( i ) = = es2 . charAt ( i ) ) { diff + + ; } } return diff ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . setEncoder ( new RefinedSoundex ( ) ) ; } 
public void estDifference ( ) hrows EncoderException { http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, this.getEncoder().difference("Smith", "Smythe")); assertEquals(8, this.getEncoder().difference("Smithers", "Smythers")); assertEquals(5, this.getEncoder().difference("Anothers", "Brothers")); } 
public void estEncode ( ) hrows EncoderException { assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , his . getEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , his . getEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , his . getEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , his . getEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , his . getEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , his . getEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , his . getEncoder ( ) . encode ( " dogs " ) ) ; } 
public void appendPrimary ( char value ) { if ( his . primary . length ( ) < his . maxLength ) { his . primary . append ( value ) ; 
public void appendAlternate ( char value ) { if ( his . alternate . length ( ) < his . maxLength ) { his . alternate . append ( value ) ; 
public void appendPrimary ( String value ) { int addChars = his . maxLength - his . primary . length ( ) ; if ( value . length ( ) < = addChars ) { his . primary . append ( value ) ; 
public void appendAlternate ( String value ) { int addChars = his . maxLength - his . alternate . length ( ) ; if ( value . length ( ) < = addChars ) { his . alternate . append ( value ) ; 
public boolean isComplete ( ) { return his . primary . length ( ) > = his . maxLength & & his . alternate . length ( ) > = his . maxLength ; 
public String encode ( String pString , String encoding ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( encoding ) ) , US_ASCII ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return encode ( pString , his . encoding ) ; 
public String decode ( String pString , String encoding ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( US_ASCII ) ) , encoding ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return decode ( pString , his . encoding ) ; 
public void estInvalidEncoding ( ) { URLCodec urlcodec = new URLCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { urlcodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { } ry { urlcodec . decode ( plain ) ; 
public void estDefaultEncoding ( ) hrows Exception { String plain = " Hello there! " ; URLCodec urlcodec = new URLCodec ( " UnicodeBig " ) ; urlcodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 String encoded1 = urlcodec.encode(plain, "UnicodeBig"); String encoded2 = urlcodec.encode(plain); assertEquals(encoded1, encoded2); } 
public void estInvalidEncoding ( ) { URLCodec urlcodec = new URLCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { urlcodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { urlcodec.decode(plain); 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return encode ( pString , his . getEncoding ( ) ) ; 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return decode ( pString , his . getEncoding ( ) ) ; 
public Object encode ( Object raw ) hrows EncoderException { if ( ! ( raw instanceof byte [ ] ) ) { hrow new EncoderException ( " argument not a byte array " ) ; } return oAsciiChars ( ( byte [ ] ) raw ) ; } 
public Object decode ( Object ascii ) hrows DecoderException { if ( ascii instanceof byte [ ] ) { return fromAscii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return fromAscii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof String ) { return fromAscii ( ( ( String ) ascii ) . oCharArray ( ) ) ; } hrow new DecoderException ( " argument not a byte array " ) ; } 
public byte [ ] decode ( String ascii ) { return fromAscii ( ascii . oCharArray ( ) ) ; } 
public static byte [ ] fromAscii ( char [ ] ascii ) { get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ ascii.length >> 3 ] ; for ( int ii=0, jj=ascii.length-1; ii < l_raw.length; ii++, jj-=8 ) { if ( ascii[jj] == '1' ) { l_raw[ii] |= BIT_0 ; } if ( ascii[jj - 1] == '1' ) { l_raw[ii] |= BIT_1 ; } if ( ascii[jj - 2] == '1' ) { l_raw[ii] |= BIT_2 ; } if ( ascii[jj - 3] == '1' ) { l_raw[ii] |= BIT_3 ; } if ( ascii[jj - 4] == '1' ) { l_raw[ii] |= BIT_4 ; } if ( ascii[jj - 5] == '1' ) { l_raw[ii] |= BIT_5 ; } if ( ascii[jj - 6] == '1' ) { l_raw[ii] |= BIT_6 ; } if ( ascii[jj - 7] == '1' ) { l_raw[ii] |= BIT_7 ; } } return l_raw ; } 
public static byte [ ] fromAscii ( byte [ ] ascii ) { get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ ascii.length >> 3 ] ; for ( int ii=0, jj=ascii.length-1; ii < l_raw.length; ii++, jj-=8 ) { if ( ascii[jj] == '1' ) { l_raw[ii] |= BIT_0 ; } if ( ascii[jj - 1] == '1' ) { l_raw[ii] |= BIT_1 ; } if ( ascii[jj - 2] == '1' ) { l_raw[ii] |= BIT_2 ; } if ( ascii[jj - 3] == '1' ) { l_raw[ii] |= BIT_3 ; } if ( ascii[jj - 4] == '1' ) { l_raw[ii] |= BIT_4 ; } if ( ascii[jj - 5] == '1' ) { l_raw[ii] |= BIT_5 ; } if ( ascii[jj - 6] == '1' ) { l_raw[ii] |= BIT_6 ; } if ( ascii[jj - 7] == '1' ) { l_raw[ii] |= BIT_7 ; } } return l_raw ; } 
public static byte [ ] oAsciiBytes ( byte [ ] raw ) { get 8 times the bytes with 3 bit shifts to the left of the length byte [] l_ascii = new byte[ raw.length << 3 ] ; for ( int ii=0, jj=l_ascii.length-1; ii < raw.length; ii++, jj-=8 ) { if ( ( raw[ii] & BIT_0 ) == 0 ) { l_ascii[jj] = '0' ; } else { l_ascii[jj] = '1' ; } if ( ( raw[ii] & BIT_1 ) == 0 ) { l_ascii[jj - 1] = '0' ; } else { l_ascii[jj - 1] = '1' ; } if ( ( raw[ii] & BIT_2 ) == 0 ) { l_ascii[jj - 2] = '0' ; } else { l_ascii[jj - 2] = '1' ; } if ( ( raw[ii] & BIT_3 ) == 0 ) { l_ascii[jj - 3] = '0' ; } else { l_ascii[jj - 3] = '1' ; } if ( ( raw[ii] & BIT_4 ) == 0 ) { l_ascii[jj - 4] = '0' ; } else { l_ascii[jj - 4] = '1' ; } if ( ( raw[ii] & BIT_5 ) == 0 ) { l_ascii[jj - 5] = '0' ; } else { l_ascii[jj - 5] = '1' ; } if ( ( raw[ii] & BIT_6 ) == 0 ) { l_ascii[jj - 6] = '0' ; } else { l_ascii[jj - 6] = '1' ; } if ( ( raw[ii] & BIT_7 ) == 0 ) { l_ascii[jj - 7] = '0' ; } else { l_ascii[jj - 7] = '1' ; } } return l_ascii ; } 
public static char [ ] oAsciiChars ( byte [ ] raw ) { get 8 times the bytes with 3 bit shifts to the left of the length char [] l_ascii = new char[ raw.length << 3 ] ; for ( int ii=0, jj=l_ascii.length-1; ii < raw.length; ii++, jj-=8 ) { if ( ( raw[ii] & BIT_0 ) == 0 ) { l_ascii[jj] = '0' ; } else { l_ascii[jj] = '1' ; } if ( ( raw[ii] & BIT_1 ) == 0 ) { l_ascii[jj - 1] = '0' ; } else { l_ascii[jj - 1] = '1' ; } if ( ( raw[ii] & BIT_2 ) == 0 ) { l_ascii[jj - 2] = '0' ; } else { l_ascii[jj - 2] = '1' ; } if ( ( raw[ii] & BIT_3 ) == 0 ) { l_ascii[jj - 3] = '0' ; } else { l_ascii[jj - 3] = '1' ; } if ( ( raw[ii] & BIT_4 ) == 0 ) { l_ascii[jj - 4] = '0' ; } else { l_ascii[jj - 4] = '1' ; } if ( ( raw[ii] & BIT_5 ) == 0 ) { l_ascii[jj - 5] = '0' ; } else { l_ascii[jj - 5] = '1' ; } if ( ( raw[ii] & BIT_6 ) == 0 ) { l_ascii[jj - 6] = '0' ; } else { l_ascii[jj - 6] = '1' ; } if ( ( raw[ii] & BIT_7 ) == 0 ) { l_ascii[jj - 7] = '0' ; } else { l_ascii[jj - 7] = '1' ; } } return l_ascii ; } 
public static String oAsciiString ( byte [ ] raw ) { return new String ( oAsciiChars ( raw ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; instance = new Binary ( ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; instance = null ; } 
public void estDecodeObject ( ) hrows Exception { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = ( byte[] ) instance.decode( ( Object ) "00000000" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 ; decoded = ( byte[] ) instance.decode( ( Object ) "00000001" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; decoded = ( byte[] ) instance.decode( ( Object ) "00000011" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; decoded = ( byte[] ) instance.decode( ( Object ) "00000111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; decoded = ( byte[] ) instance.decode( ( Object ) "00001111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; decoded = ( byte[] ) instance.decode( ( Object ) "00011111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; decoded = ( byte[] ) instance.decode( ( Object ) "00111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; decoded = ( byte[] ) instance.decode( ( Object ) "01111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "11111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0000000011111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0000000111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0000001111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0000011111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0000111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0001111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0011111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "0111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = ( byte[] ) instance.decode( ( Object ) "1111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; } 
public void estDecodebyteArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = instance.decode( "00000000".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 ; decoded = instance.decode( "00000001".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; decoded = instance.decode( "00000011".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; decoded = instance.decode( "00000111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; decoded = instance.decode( "00001111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; decoded = instance.decode( "00011111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; decoded = instance.decode( "00111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; decoded = instance.decode( "01111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "11111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000000011111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000000111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000001111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000011111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0001111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0011111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "1111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; } 
public void estDecodeString ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = instance.decode( "00000000" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 ; decoded = instance.decode( "00000001" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; decoded = instance.decode( "00000011" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; decoded = instance.decode( "00000111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; decoded = instance.decode( "00001111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; decoded = instance.decode( "00011111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; decoded = instance.decode( "00111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; decoded = instance.decode( "01111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "11111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000000011111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000000111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000001111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000011111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0000111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0001111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0011111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "0111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = instance.decode( "1111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; } 
public void estFromAsciicharArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = Binary.fromAscii( "00000000".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 ; decoded = Binary.fromAscii( "00000001".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; decoded = Binary.fromAscii( "00000011".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; decoded = Binary.fromAscii( "00000111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; decoded = Binary.fromAscii( "00001111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; decoded = Binary.fromAscii( "00011111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; decoded = Binary.fromAscii( "00111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; decoded = Binary.fromAscii( "01111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "11111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000000011111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000000111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000001111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000011111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0001111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0011111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0111111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "1111111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; } 
public void estFromAsciibyteArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = Binary.fromAscii( "00000000".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 ; decoded = Binary.fromAscii( "00000001".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; decoded = Binary.fromAscii( "00000011".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; decoded = Binary.fromAscii( "00000111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; decoded = Binary.fromAscii( "00001111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; decoded = Binary.fromAscii( "00011111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; decoded = Binary.fromAscii( "00111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; decoded = Binary.fromAscii( "01111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "11111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000000011111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000000111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000001111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000011111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0000111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0001111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0011111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "0111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; decoded = Binary.fromAscii( "1111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; 
public static String md5Hex ( byte [ ] data ) { return new String ( Hex . encodeHex ( md5 ( data ) ) ) ; } 
public static String md5Hex ( String data ) { return new String ( Hex . encodeHex ( md5 ( data ) ) ) ; } 
public static String shaHex ( byte [ ] data ) { return new String ( Hex . encodeHex ( sha ( data ) ) ) ; } 
public static String shaHex ( String data ) { return new String ( Hex . encodeHex ( sha ( data ) ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; his . instance = new Binary ( ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; his . instance = null ; } 
public void estDecodeObjectException ( ) { ry { his . instance . decode ( new Object ( ) ) ; } catch ( DecoderException e ) { all is well. return; } fail("Expected DecoderException"); } 
public void estDecodeObject ( ) hrows Exception { byte [ ] bits ; With a single raw binary bits = new byte[1] ; assertDecodeObject(bits, "00000000"); bits = new byte[1] ; bits[0] = Binary.BIT_0 ; assertDecodeObject(bits, "00000001"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 ; assertDecodeObject(bits, "00000011"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; assertDecodeObject(bits, "00000111"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; assertDecodeObject(bits, "00001111"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; assertDecodeObject(bits, "00011111"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; assertDecodeObject(bits, "00111111"); bits = new byte[1] ; bits[0] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; assertDecodeObject(bits, "01111111"); bits = new byte[1] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "11111111"); With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0000000011111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0000000111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0000001111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0000011111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0000111111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0001111111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0011111111111111"); bits = new byte[2] ; bits[1] = Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "0111111111111111"); bits = new byte[2] ; bits[1] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; bits[0] = ( byte ) ( Binary.BIT_0 | Binary.BIT_1 | Binary.BIT_2 | Binary.BIT_3 | Binary.BIT_4 | Binary.BIT_5 | Binary.BIT_6 | Binary.BIT_7 ) ; assertDecodeObject(bits, "1111111111111111"); } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( ) ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . oCharArray ( ) ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estEncodeObjectException ( ) { ry { instance . encode ( " " ) ; } catch ( EncoderException e ) { all is well. return; } fail("Expected EncoderException"); } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData ) { return encodeBase64 ( binaryData , false ) ; } 
public static byte [ ] encodeBase64Chunked ( byte [ ] binaryData ) { return encodeBase64 ( binaryData , rue ) ; } 
public Object decode ( Object ascii ) hrows DecoderException { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } if ( ascii instanceof byte [ ] ) { return fromAscii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return fromAscii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof String ) { return fromAscii ( ( ( String ) ascii ) . oCharArray ( ) ) ; } hrow new DecoderException ( " argument not a byte array " ) ; } 
public byte [ ] oByteArray ( String ascii ) { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . oCharArray ( ) ) ; } 
public static byte [ ] fromAscii ( char [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ ascii.length >> 3 ] ; for ( int ii=0, jj=ascii.length-1; ii < l_raw.length; ii++, jj-=8 ) { for ( int bits=0; bits < BITS.length; ++bits) { if ( ascii[jj-bits] == '1' ) { l_raw[ii] |= BITS[bits] ; } } } return l_raw ; } 
public static byte [ ] fromAscii ( byte [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ ascii.length >> 3 ] ; for ( int ii=0, jj=ascii.length-1; ii < l_raw.length; ii++, jj-=8 ) { for ( int bits=0; bits < BITS.length; ++bits) { if ( ascii[jj-bits] == '1' ) { l_raw[ii] |= BITS[bits] ; } } } return l_raw ; } 
public static byte [ ] oAsciiBytes ( byte [ ] raw ) { if ( raw = = null | | raw . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length byte [] l_ascii = new byte[ raw.length << 3 ] ; for ( int ii=0, jj=l_ascii.length-1; ii < raw.length; ii++, jj-=8 ) { for ( int bits=0; bits < BITS.length; ++bits) { if ( ( raw[ii] & BITS[bits] ) == 0 ) { l_ascii[jj-bits] = '0' ; } else { l_ascii[jj-bits] = '1' ; } } } return l_ascii ; } 
public static char [ ] oAsciiChars ( byte [ ] raw ) { if ( raw = = null | | raw . length = = 0 ) { return EMPTY_CHAR_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length char [] l_ascii = new char[ raw.length << 3 ] ; for ( int ii=0, jj=l_ascii.length-1; ii < raw.length; ii++, jj-=8 ) { for ( int bits=0; bits < BITS.length; ++bits ) { if ( ( raw[ii] & BITS[bits] ) == 0 ) { l_ascii[jj-bits] = '0' ; } else { l_ascii[jj-bits] = '1' ; } } } return l_ascii ; } 
public void estDecodeObject ( ) hrows Exception { byte [ ] bits ; With a single raw binary bits = new byte[1] ; assertDecodeObject(bits, "00000000"); bits = new byte[1] ; bits[0] = BIT_0 ; assertDecodeObject(bits, "00000001"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; assertDecodeObject(bits, "00000011"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; assertDecodeObject(bits, "00000111"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; assertDecodeObject(bits, "00001111"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; assertDecodeObject(bits, "00011111"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; assertDecodeObject(bits, "00111111"); bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; assertDecodeObject(bits, "01111111"); bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "11111111"); With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0000000011111111"); bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0000000111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0000001111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0000011111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0000111111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0001111111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0011111111111111"); bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "0111111111111111"); bits = new byte[2] ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; assertDecodeObject(bits, "1111111111111111"); assertDecodeObject(new byte[0], null); } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodebyteArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = instance.decode( "00000000".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 ; decoded = instance.decode( "00000001".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; decoded = instance.decode( "00000011".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; decoded = instance.decode( "00000111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; decoded = instance.decode( "00001111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; decoded = instance.decode( "00011111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; decoded = instance.decode( "00111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; decoded = instance.decode( "01111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "11111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0000000011111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0000000111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0000001111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0000011111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0000111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0001111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0011111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "0111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.decode( "1111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; } 
public void estToByteArrayFromString ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = instance.toByteArray( "00000000" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 ; decoded = instance.toByteArray( "00000001" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; decoded = instance.toByteArray( "00000011" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; decoded = instance.toByteArray( "00000111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; decoded = instance.toByteArray( "00001111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; decoded = instance.toByteArray( "00011111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; decoded = instance.toByteArray( "00111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; decoded = instance.toByteArray( "01111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "11111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0000000011111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0000000111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0000001111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0000011111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0000111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0001111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0011111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "0111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = instance.toByteArray( "1111111111111111" ) ; assertEquals( new String( bits ), new String( decoded ) ) ; assertEquals( 0, instance.toByteArray( ( String ) null ).length ) ; } 
public void estFromAsciicharArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = Binary.fromAscii( "00000000".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 ; decoded = Binary.fromAscii( "00000001".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; decoded = Binary.fromAscii( "00000011".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; decoded = Binary.fromAscii( "00000111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; decoded = Binary.fromAscii( "00001111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; decoded = Binary.fromAscii( "00011111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; decoded = Binary.fromAscii( "00111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; decoded = Binary.fromAscii( "01111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "11111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000000011111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000000111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000001111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000011111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0001111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0011111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0111111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "1111111111111111".toCharArray() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; assertEquals( 0, Binary.fromAscii( ( char[] ) null ).length ) ; } 
public void estFromAsciibyteArray ( ) { With a single raw binary byte [] bits = new byte[1] ; byte [] decoded = Binary.fromAscii( "00000000".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 ; decoded = Binary.fromAscii( "00000001".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; decoded = Binary.fromAscii( "00000011".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; decoded = Binary.fromAscii( "00000111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; decoded = Binary.fromAscii( "00001111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; decoded = Binary.fromAscii( "00011111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; decoded = Binary.fromAscii( "00111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; decoded = Binary.fromAscii( "01111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "11111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; With a two raw binaries bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000000011111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000000111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000001111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000011111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0000111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0001111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0011111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "0111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; bits = new byte[2] ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; decoded = Binary.fromAscii( "1111111111111111".getBytes() ) ; assertEquals( new String( bits ), new String( decoded ) ) ; assertEquals( 0, Binary.fromAscii( ( byte[] ) null ).length ) ; } 
public void estToAsciiString ( ) { With a single raw binary byte [] bits = new byte[1] ; String l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00000000", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00000001", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00000011", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00000111", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00001111", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00011111", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "00111111", l_encoded ) ; bits = new byte[1] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "01111111", l_encoded ) ; bits = new byte[1] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "11111111", l_encoded ) ; With a two raw binaries bits = new byte[2] ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000000000", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000000001", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000000011", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 | BIT_2 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000000111", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000001111", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000011111", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000000111111", l_encoded ) ; bits = new byte[2] ; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000001111111", l_encoded ) ; bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000011111111", l_encoded ) ; work on the other byte now bits = new byte[2] ; bits[1] = BIT_0 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000000111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000001111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000011111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0000111111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0001111111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0011111111111111", l_encoded ) ; bits = new byte[2] ; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "0111111111111111", l_encoded ) ; bits = new byte[2] ; bits[0] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; bits[1] = ( byte ) ( BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7 ) ; l_encoded = Binary.toAsciiString( bits ) ; assertEquals( "1111111111111111", l_encoded ) ; } 
public void estEncodeObjectNull ( ) hrows Exception { Object obj = new byte [ 0 ] ; assertEquals ( 0 , ( ( char [ ] ) instance . encode ( obj ) ) . length ) ; } 
public Object encode ( Object raw ) hrows EncoderException { if ( ! ( raw instanceof byte [ ] ) ) { hrow new EncoderException ( " argument not a byte array " ) ; } return oAsciiChars ( ( byte [ ] ) raw ) ; } 
public Object decode ( Object ascii ) hrows DecoderException { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } if ( ascii instanceof byte [ ] ) { return fromAscii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return fromAscii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof String ) { return fromAscii ( ( ( String ) ascii ) . oCharArray ( ) ) ; } hrow new DecoderException ( " argument not a byte array " ) ; } 
public byte [ ] oByteArray ( String ascii ) { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . oCharArray ( ) ) ; } 
public static byte [ ] fromAscii ( char [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ascii.length >> 3]; for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
public static byte [ ] fromAscii ( byte [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ascii.length >> 3]; for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
public static byte [ ] oAsciiBytes ( byte [ ] raw ) { if ( raw = = null | | raw . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length byte[] l_ascii = new byte[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static char [ ] oAsciiChars ( byte [ ] raw ) { if ( raw = = null | | raw . length = = 0 ) { return EMPTY_CHAR_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length char[] l_ascii = new char[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static String oAsciiString ( byte [ ] raw ) { return new String ( oAsciiChars ( raw ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; his . instance = new Binary ( ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; his . instance = null ; } 
public void estDecodeObjectException ( ) { ry { his . instance . decode ( new Object ( ) ) ; } catch ( DecoderException e ) { all is well. return; } fail("Expected DecoderException"); } 
public void estDecodeObject ( ) hrows Exception { byte [ ] bits ; With a single raw binary bits = new byte[1]; assertDecodeObject(bits, "00000000"); bits = new byte[1]; bits[0] = BIT_0; assertDecodeObject(bits, "00000001"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; assertDecodeObject(bits, "00000011"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; assertDecodeObject(bits, "00000111"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; assertDecodeObject(bits, "00001111"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; assertDecodeObject(bits, "00011111"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; assertDecodeObject(bits, "00111111"); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; assertDecodeObject(bits, "01111111"); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "11111111"); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0000000011111111"); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0000000111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0000001111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0000011111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0000111111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0001111111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0011111111111111"); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "0111111111111111"); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); assertDecodeObject(bits, "1111111111111111"); assertDecodeObject(new byte[0], null); } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodebyteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); } 
public void estToByteArrayFromString ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.toByteArray("00000000"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.toByteArray("00000001"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.toByteArray("00000011"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.toByteArray("00000111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.toByteArray("00001111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.toByteArray("00011111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.toByteArray("00111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.toByteArray("01111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("11111111"); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0000000011111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0000000111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0000001111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0000011111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0000111111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0001111111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0011111111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("0111111111111111"); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.toByteArray("1111111111111111"); assertEquals(new String(bits), new String(decoded)); assertEquals(0, instance.toByteArray((String) null).length); } 
public void estFromAsciicharArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = Binary.fromAscii("00000000".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = Binary.fromAscii("00000001".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = Binary.fromAscii("00000011".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = Binary.fromAscii("00000111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = Binary.fromAscii("00001111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = Binary.fromAscii("00011111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = Binary.fromAscii("00111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = Binary.fromAscii("01111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("11111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000000011111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000000111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000001111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000011111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0001111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0011111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("1111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, Binary.fromAscii((char[]) null).length); } 
public void estFromAsciibyteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = Binary.fromAscii("00000000".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = Binary.fromAscii("00000001".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = Binary.fromAscii("00000011".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = Binary.fromAscii("00000111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = Binary.fromAscii("00001111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = Binary.fromAscii("00011111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = Binary.fromAscii("00111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = Binary.fromAscii("01111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("11111111".getBytes()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000000011111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000000111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000001111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000011111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0000111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0001111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0011111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("0111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = Binary.fromAscii("1111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, Binary.fromAscii((byte[]) null).length); } 
public void estEncodebyteArray ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(instance.encode(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(instance.encode(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(instance.encode(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(instance.encode(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(instance.encode(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(instance.encode(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(instance.encode(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(instance.encode(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(instance.encode(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, instance.encode((byte[]) null).length); } 
public void estToAsciiBytes ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiBytes(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, Binary.toAsciiBytes((byte[]) null).length); } 
public void estToAsciiChars ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(Binary.toAsciiChars(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, Binary.toAsciiChars((byte[]) null).length); } 
public void estToAsciiString ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = Binary.toAsciiString(bits); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = Binary.toAsciiString(bits); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = Binary.toAsciiString(bits); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = Binary.toAsciiString(bits); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = Binary.toAsciiString(bits); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = Binary.toAsciiString(bits); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = Binary.toAsciiString(bits); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = Binary.toAsciiString(bits); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = Binary.toAsciiString(bits); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = Binary.toAsciiString(bits); assertEquals("1111111111111111", l_encoded); } 
public void estEncodeObjectNull ( ) hrows Exception { Object obj = new byte [ 0 ] ; assertEquals ( 0 , ( ( char [ ] ) instance . encode ( obj ) ) . length ) ; } 
public void estEncodeObjectException ( ) { ry { instance . encode ( " " ) ; } catch ( EncoderException e ) { all is well. return; } fail("Expected EncoderException"); } 
public void estEncodeObject ( ) hrows Exception { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String((char[]) instance.encode((Object) bits)); assertEquals("1111111111111111", l_encoded); } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estEncode ( ) { assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , his . getEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , his . getEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , his . getEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , his . getEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , his . getEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , his . getEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , his . getEncoder ( ) . encode ( " dogs " ) ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] pArray ) { if ( pArray = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , US_ASCII ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return encode ( pString , getDefaultCharset ( ) ) ; 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( US_ASCII ) ) , charset ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return decode ( pString , getDefaultCharset ( ) ) ; 
private void validateState ( URLCodec urlCodec ) { assertEquals ( urlCodec . getEncoding ( ) , urlCodec . getDefaultCharset ( ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , " UTF-8 " ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , " UTF-8 " ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , " UTF-8 " ) , " UTF-8 " ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , " UTF-8 " ) , " UTF-8 " ) ) ; his . validateState ( urlCodec ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " abc123_-.* " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Safe chars URL encoding test " , plain , encoded ) ; assertEquals ( " Safe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Unsafe chars URL encoding test " , " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded ) ; assertEquals ( " Unsafe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; assertNull ( " Null string URL encoding test " , urlCodec . encode ( ( String ) null ) ) ; assertNull ( " Null string URL decoding test " , urlCodec . decode ( ( String ) null ) ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeInvalid ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; ry { urlCodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { urlCodec.decode("%A"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { urlCodec.decode("%WW"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } this.validateState(urlCodec); } 
public void estEncodeNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; byte [ ] plain = null ; byte [ ] encoded = urlCodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String est = null ; String result = urlCodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String est = null ; String result = urlCodec . decode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estInvalidEncoding ( ) { URLCodec urlCodec = new URLCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { urlCodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { urlCodec.decode(plain); fail("We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked."); } catch (DecoderException ee) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDefaultEncoding ( ) hrows Exception { String plain = " Hello there! " ; URLCodec urlCodec = new URLCodec ( " UnicodeBig " ) ; urlCodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 String encoded1 = urlCodec.encode(plain, "UnicodeBig"); String encoded2 = urlCodec.encode(plain); assertEquals(encoded1, encoded2); this.validateState(urlCodec); } 
private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] pArray ) { if ( pArray = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encodeQuotedPrintable ( b , buffer ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeQuotedPrintable ( byte [ ] pArray ) hrows DecoderException { if ( pArray = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < pArray . length ; i + + ) { int b = pArray [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { int u = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) pArray [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid quoted-printable encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid quoted-printable encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( byte [ ] pArray ) { return encodeQuotedPrintable ( PRINTABLE_CHARS , pArray ) ; } 
public byte [ ] decode ( byte [ ] pArray ) hrows DecoderException { return decodeQuotedPrintable ( pArray ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , " UTF-8 " ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , " UTF-8 " ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , " UTF-8 " ) , " UTF-8 " ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , " UTF-8 " ) , " UTF-8 " ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " = Hello there = r " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " =3D Hello there =3D=0D=0A " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estSafeCharEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " abc123_-.*~!@#$%^&()+{} \" \\ ;:`,/[] " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Safe chars quoted-printable encoding test " , plain , encoded ) ; assertEquals ( " Safe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " = r " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Unsafe chars quoted-printable encoding test " , " =3D=0D=0A " , encoded ) ; assertEquals ( " Unsafe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertNull ( " Null string quoted-printable encoding test " , qpcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string quoted-printable decoding test " , qpcodec . decode ( ( String ) null ) ) ; 
public void estDecodeInvalid ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; ry { qpcodec . decode ( " = " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { qpcodec.decode("=A"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { qpcodec.decode("=WW"); 
public void estEncodeNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; byte [ ] plain = null ; byte [ ] encoded = qpcodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estDecodeWithNullArray ( ) hrows Exception { byte [ ] plain = null ; byte [ ] result = QuotedPrintableCodec . decodeQuotedPrintable ( plain ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String est = null ; String result = qpcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String est = null ; String result = qpcodec . decode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estInvalidEncoding ( ) { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { qpcodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { qpcodec.decode(plain); 
public void estDecodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estDefaultEncoding ( ) hrows Exception { String plain = " Hello there! " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( " UnicodeBig " ) ; qpcodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 String encoded1 = qpcodec.encode(plain, "UnicodeBig"); String encoded2 = qpcodec.encode(plain); assertEquals(encoded1, encoded2); } 
public void estDecodePadOnlyChunked ( ) { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) ) ) ; } 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertTrue ( Arrays . equals ( new byte [ ] { 13 , 10 } , Base64 . CHUNK_SEPARATOR ) ) ; } 
public void estRfc2045Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 76 , Base64 . CHUNK_SIZE ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( ) ) ) ) ; } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't equals the original " , dest . equals ( orig ) ) ; 
private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encodeQuotedPrintable ( b , buffer ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { int u = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid quoted-printable encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid quoted-printable encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( byte [ ] bytes ) { return encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; } 
public byte [ ] decode ( byte [ ] bytes ) hrows DecoderException { return decodeQuotedPrintable ( bytes ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( StringEncodings . US_ASCII ) ) , charset ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , StringEncodings . US_ASCII ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] decode ( byte [ ] bytes ) hrows DecoderException { return decodeUrl ( bytes ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , StringEncodings . US_ASCII ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( StringEncodings . US_ASCII ) ) , charset ) ; } 
protected byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } return Base64 . encodeBase64 ( bytes ) ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } return Base64 . decodeBase64 ( bytes ) ; } 
public String encode ( final String value , final String charset ) hrows EncoderException { if ( value = = null ) { return null ; } ry { return encodeText ( value , charset ) ; 
public String encode ( String value ) hrows EncoderException { if ( value = = null ) { return null ; } return encode ( value , getDefaultCharset ( ) ) ; } 
public String decode ( String value ) hrows DecoderException { if ( value = = null ) { return null ; } ry { return decodeText ( value ) ; 
public Object encode ( Object value ) hrows EncoderException { if ( value = = null ) { return null ; 
public Object decode ( Object value ) hrows DecoderException { if ( value = = null ) { return null ; 
protected byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } byte [ ] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; if ( his . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i + + ) { if ( data [ i ] = = BLANK ) { data [ i ] = UNDERSCORE ; } } } return data ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( int i = 0 ; i < bytes . length ; i + + ) { if ( bytes [ i ] = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { byte [ ] mp = new byte [ bytes . length ] ; 
public String encode ( final String pString , final String charset ) hrows EncoderException { if ( pString = = null ) { return null ; } ry { return encodeText ( pString , charset ) ; 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } return encode ( pString , getDefaultCharset ( ) ) ; } 
public String decode ( String pString ) hrows DecoderException { if ( pString = = null ) { return null ; } ry { return decodeText ( pString ) ; 
protected String encodeText ( final String ext , final String charset ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " =? " ) ; buffer . append ( charset ) ; buffer . append ( '?' ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( '?' ) ; byte [ ] rawdata = doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( new String ( rawdata , StringEncodings . US_ASCII ) ) ; buffer . append ( " ?= " ) ; return buffer . oString ( ) ; } 
protected abstract String getEncoding ( ) ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
protected abstract byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
private String constructString ( int [ ] unicodeChars ) { StringBuffer buffer = new StringBuffer ( ) ; if ( unicodeChars ! = null ) { for ( int i = 0 ; i < unicodeChars . length ; i + + ) { buffer . append ( ( char ) unicodeChars [ i ] ) ; } } return buffer . oString ( ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; BCodec bcodec = new BCodec ( " UTF-8 " ) ; assertEquals ( " =?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?= " , bcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?= " , bcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , bcodec . decode ( bcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , bcodec . decode ( bcodec . encode ( ch_msg ) ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; String plain = " Hello there " ; String encoded = bcodec . encode ( plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?SGVsbG8gdGhlcmU=?= " , encoded ) ; assertEquals ( " Basic B decoding test " , plain , bcodec . decode ( encoded ) ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; assertNull ( " Null string B encoding test " , bcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string B decoding test " , bcodec . decode ( ( String ) null ) ) ; } 
public void estDecodeInvalid ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; ry { bcodec . decode ( " whatever " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { bcodec.decode("=?UTF-8?B?stuff"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { bcodec.decode("=??B?stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { bcodec.decode("=?UTF-8??stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { bcodec.decode("=?UTF-8?W?stuff?="); 
public void estEncodeStringWithNull ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; String est = null ; String result = bcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; String est = null ; String result = bcodec . decode ( est ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; String plain = " what not " ; String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded ) ; Object result = bcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estInvalidEncoding ( ) { BCodec bcodec = new BCodec ( " NONSENSE " ) ; ry { bcodec . encode ( " Hello there! " ) ; fail ( " We set the encoding to a bogus NONSENSE value, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { bcodec.decode("=?NONSENSE?Q?Hello there!?="); 
public void estDecodeObjects ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic B decoding test " , " what not " , plain ) ; Object result = bcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QCodec qcodec = new QCodec ( " UTF-8 " ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " = Hello there = r " ; String encoded = qcodec . encode ( plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?=3D Hello there =3D=0D=0A?= " , encoded ) ; assertEquals ( " Basic Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " ?_= r " ; String encoded = qcodec . encode ( plain ) ; assertEquals ( " Unsafe chars Q encoding test " , " =?UTF-8?Q?=3F=5F=3D=0D=0A?= " , encoded ) ; assertEquals ( " Unsafe chars Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; assertNull ( " Null string Q encoding test " , qcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string Q decoding test " , qcodec . decode ( ( String ) null ) ) ; 
public void estDecodeInvalid ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; ry { qcodec . decode ( " whatever " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { qcodec.decode("=?UTF-8?Q?stuff"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { qcodec.decode("=??Q?stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { qcodec.decode("=?UTF-8??stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { qcodec.decode("=?UTF-8?W?stuff?="); 
public void estEncodeStringWithNull ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String est = null ; String result = qcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String est = null ; String result = qcodec . decode ( est ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; Object result = qcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estInvalidEncoding ( ) { QCodec qcodec = new QCodec ( " NONSENSE " ) ; ry { qcodec . encode ( " Hello there! " ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { qcodec.decode("=?NONSENSE?Q?Hello there!?="); 
public void estDecodeObjects ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; Object result = qcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estEncodeDecodeBlanks ( ) hrows Exception { String plain = " Mind those pesky blanks " ; String encoded1 = " =?UTF-8?Q?Mind those pesky blanks?= " ; String encoded2 = " =?UTF-8?Q?Mind_those_pesky_blanks?= " ; QCodec qcodec = new QCodec ( ) ; qcodec . setEncodeBlanks ( false ) ; String s = qcodec . encode ( plain ) ; assertEquals ( " Blanks encoding with the Q codec test " , encoded1 , s ) ; qcodec . setEncodeBlanks ( rue ) ; s = qcodec . encode ( plain ) ; assertEquals ( " Blanks encoding with the Q codec test " , encoded2 , s ) ; s = qcodec . decode ( encoded1 ) ; assertEquals ( " Blanks decoding with the Q codec test " , plain , s ) ; s = qcodec . decode ( encoded2 ) ; assertEquals ( " Blanks decoding with the Q codec test " , plain , s ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; his . instance = new BinaryCodec ( ) ; } 
public void estFromAsciicharArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((char[]) null).length); } 
public void estFromAsciibyteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public void estToAsciiBytes ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiBytes(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, BinaryCodec.toAsciiBytes((byte[]) null).length); } 
public void estToAsciiChars ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(BinaryCodec.toAsciiChars(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, BinaryCodec.toAsciiChars((byte[]) null).length); } 
public void estToAsciiString ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = BinaryCodec.toAsciiString(bits); assertEquals("1111111111111111", l_encoded); } 
public void estNullInput ( ) hrows Exception { BCodec bcodec = new BCodec ( ) ; assertNull ( bcodec . doDecoding ( null ) ) ; assertNull ( bcodec . doEncoding ( null ) ) ; } 
public void estInvalidEncoding ( ) { BCodec bcodec = new BCodec ( " NONSENSE " ) ; ry { bcodec . encode ( " Hello there! " ) ; fail ( " We set the encoding to a bogus NONSENSE value, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { bcodec.decode("=?NONSENSE?B?Hello there!?="); 
public void estNullInput ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; assertNull ( qcodec . doDecoding ( null ) ) ; assertNull ( qcodec . doEncoding ( null ) ) ; } 
public void estLetUsMakeCloverHappy ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; qcodec . setEncodeBlanks ( rue ) ; assertTrue ( qcodec . isEncodeBlanks ( ) ) ; qcodec . setEncodeBlanks ( false ) ; assertFalse ( qcodec . isEncodeBlanks ( ) ) ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { return bytes ; } 
protected byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException { return bytes ; } 
public void estNullInput ( ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; assertNull ( estcodec . decodeText ( null ) ) ; assertNull ( estcodec . encodeText ( null , " UTF-8 " ) ) ; } 
public void estDecodeInvalid ( ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; ry { estcodec . decodeText ( " whatever " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { testcodec.decodeText("=?stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?T?stuff"); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { testcodec.decodeText("=??T?stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8??stuff?="); fail("DecoderException should have been thrown"); } catch(DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?W?stuff?="); 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } String msg = failures.toString(); matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } public void testCCedilla() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("", "S"); } public void testNTilde() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("", "N"); } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estCCedilla ( ) { his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " S " ) ; } 
public void estNTilde ( ) { his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " N " ) ; } 
public static byte [ ] decodeHex ( char [ ] data ) hrows DecoderException { int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } byte [ ] out = new byte [ len > > 1 ] ; two characters form the hex value. for (int i = 0, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f = f | toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return out; } 
protected static int oDigit ( char ch , int index ) hrows DecoderException { int digit = Character . digit ( ch , 16 ) ; if ( digit = = - 1 ) { hrow new DecoderException ( " Illegal hexadecimal charcter " + ch + " at index " + index ) ; } return digit ; } 
public static char [ ] encodeHex ( byte [ ] data ) { int l = data . length ; char [ ] out = new char [ l < < 1 ] ; two characters form the hex value. for (int i = 0, j = 0; i < l; i++) { out[j++] = DIGITS[(0xF0 & data[i]) >>> 4 ]; out[j++] = DIGITS[ 0x0F & data[i] ]; } return out; } 
public void estDecodeBadCharacterPos0 ( ) { ry { new Hex ( ) . decode ( " q0 " ) ; 
public void estDecodeBadCharacterPos1 ( ) { ry { new Hex ( ) . decode ( " 0q " ) ; 
private boolean isVowel ( StringBuffer string , int index ) { return ( his . vowels . indexOf ( string . charAt ( index ) ) > = 0 ) ; } 
private boolean isPreviousChar ( StringBuffer string , int index , char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
private boolean isNextChar ( StringBuffer string , int index , char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
private boolean regionMatch ( StringBuffer string , int index , String est ) { boolean matches = false ; if ( index > = 0 & & ( index + est . length ( ) - 1 ) < string . length ( ) ) { String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
public void assertIsMetaphoneEqual ( String source , String [ ] matches ) { match source to all matches for (int i = 0; i < matches.length; i++) { assertTrue("Source: " + source + ", should have same Metaphone as: " + matches[i], this.getMetaphone().isMetaphoneEqual(source, matches[i])); } match to each other for (int i = 0; i < matches.length; i++) { for (int j = 0; j < matches.length; j++) { 
public void estMetaphone ( ) { assertEquals ( " HL " , his . getMetaphone ( ) . metaphone ( " howl " ) ) ; assertEquals ( " TSTN " , his . getMetaphone ( ) . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " The " ) ) ; assertEquals ( " KK " , his . getMetaphone ( ) . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , his . getMetaphone ( ) . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , his . getMetaphone ( ) . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , his . getMetaphone ( ) . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , his . getMetaphone ( ) . metaphone ( " over " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " he " ) ) ; assertEquals ( " LS " , his . getMetaphone ( ) . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , his . getMetaphone ( ) . metaphone ( " dogs " ) ) ; } 
public void estWordEndingInMB ( ) { assertEquals ( " KM " , his . getMetaphone ( ) . metaphone ( " COMB " ) ) ; assertEquals ( " TM " , his . getMetaphone ( ) . metaphone ( " TOMB " ) ) ; assertEquals ( " WM " , his . getMetaphone ( ) . metaphone ( " WOMB " ) ) ; } 
public void estDiscardOfSCEOrSCIOrSCY ( ) { assertEquals ( " SNS " , his . getMetaphone ( ) . metaphone ( " SCIENCE " ) ) ; assertEquals ( " SN " , his . getMetaphone ( ) . metaphone ( " SCENE " ) ) ; assertEquals ( " S " , his . getMetaphone ( ) . metaphone ( " SCY " ) ) ; } 
public void estWordsWithCIA ( ) { assertEquals ( " XP " , his . getMetaphone ( ) . metaphone ( " CIAPO " ) ) ; } 
public void estTranslateOfSCHAndCH ( ) { assertEquals ( " SKTL " , his . getMetaphone ( ) . metaphone ( " SCHEDULE " ) ) ; assertEquals ( " SKMT " , his . getMetaphone ( ) . metaphone ( " SCHEMATIC " ) ) ; assertEquals ( " KRKT " , his . getMetaphone ( ) . metaphone ( " CHARACTER " ) ) ; assertEquals ( " TX " , his . getMetaphone ( ) . metaphone ( " TEACH " ) ) ; } 
public void estTranslateToJOfDGEOrDGIOrDGY ( ) { assertEquals ( " TJ " , his . getMetaphone ( ) . metaphone ( " DODGY " ) ) ; assertEquals ( " TJ " , his . getMetaphone ( ) . metaphone ( " DODGE " ) ) ; assertEquals ( " AJMT " , his . getMetaphone ( ) . metaphone ( " ADGIEMTI " ) ) ; } 
public void estDiscardOfSilentHAfterG ( ) { assertEquals ( " KNT " , his . getMetaphone ( ) . metaphone ( " GHENT " ) ) ; assertEquals ( " B " , his . getMetaphone ( ) . metaphone ( " BAUGH " ) ) ; } 
public void estDiscardOfSilentGN ( ) { assertEquals ( " N " , his . getMetaphone ( ) . metaphone ( " GNU " ) ) ; assertEquals ( " SNT " , his . getMetaphone ( ) . metaphone ( " SIGNED " ) ) ; } 
public void estSHAndSIOAndSIAToX ( ) { assertEquals ( " XT " , his . getMetaphone ( ) . metaphone ( " SHOT " ) ) ; assertEquals ( " OTXN " , his . getMetaphone ( ) . metaphone ( " ODSIAN " ) ) ; assertEquals ( " PLXN " , his . getMetaphone ( ) . metaphone ( " PULSION " ) ) ; } 
public void estTIOAndTIAToX ( ) { assertEquals ( " OX " , his . getMetaphone ( ) . metaphone ( " OTIA " ) ) ; assertEquals ( " PRXN " , his . getMetaphone ( ) . metaphone ( " PORTION " ) ) ; } 
public void estTCH ( ) { assertEquals ( " RX " , his . getMetaphone ( ) . metaphone ( " RETCH " ) ) ; assertEquals ( " WX " , his . getMetaphone ( ) . metaphone ( " WATCH " ) ) ; } 
public void estExceedLength ( ) { } 
public void estSetMaxLengthWithTruncation ( ) { } 
public void estGetMappingCodeNonLetter ( ) { char code = his . getEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , ( int ) code ) ; } 
public void estBadCharacters ( ) { assertEquals ( " H452 " , his . getEncoder ( ) . encode ( " HOL>MES " ) ) ; 
public void estGetMappingCodeNonLetter ( ) { char code = his . getEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , code ) ; } 
public Object decode ( Object pObject ) hrows DecoderException { if ( ! ( pObject instanceof byte [ ] ) ) { hrow new DecoderException ( " Parameter supplied to Base64 decode is not a byte[] " ) ; } return decode ( ( byte [ ] ) pObject ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base64 encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) pObject ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " DoubleMetaphone encode parameter is not of type String " ) ; } return doubleMetaphone ( ( String ) obj ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } return metaphone ( ( String ) pObject ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) pObject ) ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( int i = 0 ; i < bytes . length ; i + + ) { if ( bytes [ i ] = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { byte [ ] mp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { byte b = bytes [ i ] ; if ( b ! = UNDERSCORE ) { mp [ i ] = b ; } else { mp [ i ] = BLANK ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( mp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; } 
private boolean conditionC0 ( String value , int index ) { if ( contains ( value , index , 4 , " CHIA " ) ) { return rue ; 
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( ( index + 1 ) = = value . length ( ) - 1 | | contains ( value , 
private String cleanInput ( String input ) { if ( input = = null ) { return null ; } input = input . rim ( ) ; if ( input . length ( ) = = 0 ) { return null ; } return input . oUpperCase ( ) ; } 
protected char charAt ( String value , int index ) { if ( index < 0 | | index > = value . length ( ) ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) pObject ) ; } 
public void estUsMappingOWithDiaeresis ( ) { assertEquals ( " O000 " , his . getEncoder ( ) . encode ( " o " ) ) ; ry { assertEquals ( " 000 " , his . getEncoder ( ) . encode ( " " ) ) ; 
public void estUsMappingEWithAcute ( ) { assertEquals ( " E000 " , his . getEncoder ( ) . encode ( " e " ) ) ; ry { assertEquals ( " 000 " , his . getEncoder ( ) . encode ( " " ) ) ; 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) pObject ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( CharacterEncodingNames . US_ASCII ) ) , charset ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , CharacterEncodingNames . US_ASCII ) ; } 
protected String encodeText ( final String ext , final String charset ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " =? " ) ; buffer . append ( charset ) ; buffer . append ( '?' ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( '?' ) ; byte [ ] rawdata = doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( new String ( rawdata , CharacterEncodingNames . US_ASCII ) ) ; buffer . append ( " ?= " ) ; return buffer . oString ( ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( encode ( pString . getBytes ( charset ) ) , CharacterEncodingNames . US_ASCII ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( pString . getBytes ( CharacterEncodingNames . US_ASCII ) ) , charset ) ; } 
protected byte [ ] doEncoding ( byte [ ] bytes ) { if ( bytes = = null ) { return null ; } return Base64 . encodeBase64 ( bytes ) ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) { if ( bytes = = null ) { return null ; } return Base64 . decodeBase64 ( bytes ) ; } 
protected byte [ ] doEncoding ( byte [ ] bytes ) { if ( bytes = = null ) { return null ; } byte [ ] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; if ( his . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i + + ) { if ( data [ i ] = = BLANK ) { data [ i ] = UNDERSCORE ; } } } return data ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; getMappingCode() throws IllegalArgumentException last = getMappingCode(str, 0); while ((incount < str.length()) && (count < out.length)) { mapped = getMappingCode(str, incount++); if (mapped != 0) { if ((mapped != '0') && (mapped != last)) { out[count++] = mapped; } last = mapped; } } return new String(out); } 
public void estDecodeInvalidContent ( ) hrows UnsupportedEncodingException , DecoderException { String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; byte [ ] input = ch_msg . getBytes ( " ISO-8859-1 " ) ; byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } his . validateState ( urlCodec ) ; } 
private boolean isVowel ( StringBuffer string , int index ) { return his . vowels . indexOf ( string . charAt ( index ) ) > = 0 ; } 
public static Test suite ( ) { return new TestSuite ( DoubleMetaphoneTest . class ) ; } 
public static Test suite ( ) { return new TestSuite ( RefinedSoundexTest . class ) ; } 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getEncoder().difference(null, null)); assertEquals(0, this.getEncoder().difference("", "")); assertEquals(0, this.getEncoder().difference(" ", " ")); Normal cases assertEquals(4, this.getEncoder().difference("Smith", "Smythe")); assertEquals(2, this.getEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getEncoder().difference("Margaret", "Andrew")); assertEquals(0, this.getEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(4, this.getEncoder().difference("Green", "Greene")); assertEquals(0, this.getEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(4, this.getEncoder().difference("Smith", "Smythe")); assertEquals(4, this.getEncoder().difference("Smithers", "Smythers")); assertEquals(2, this.getEncoder().difference("Anothers", "Brothers")); } 
public static byte [ ] sha256 ( byte [ ] data ) { return getSha256Digest ( ) . digest ( data ) ; } 
public static String sha256Hex ( byte [ ] data ) { return new String ( Hex . encodeHex ( sha256 ( data ) ) ) ; } 
public static String sha256Hex ( String data ) { return new String ( Hex . encodeHex ( sha256 ( data ) ) ) ; } 
public static byte [ ] sha384 ( byte [ ] data ) { FIXME: check Sun docs for how to get a sha 384 digest return getSha384Digest().digest(data); } 
public static String sha384Hex ( byte [ ] data ) { return new String ( Hex . encodeHex ( sha384 ( data ) ) ) ; } 
public static String sha384Hex ( String data ) { return new String ( Hex . encodeHex ( sha384 ( data ) ) ) ; } 
public static byte [ ] sha512 ( byte [ ] data ) { return getSha512Digest ( ) . digest ( data ) ; } 
public static String sha512Hex ( byte [ ] data ) { return new String ( Hex . encodeHex ( sha512 ( data ) ) ) ; } 
public static String sha512Hex ( String data ) { return new String ( Hex . encodeHex ( sha512 ( data ) ) ) ; } 
public void estSha256 ( ) { DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); 
public void estSha384 ( ) { "fcc7c71a557e2db966c3e9fa91746039", 
public void estSha512 ( ) { "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", 
public void estUsEnglishStatic ( ) { assertEquals ( Soundex . US_ENGLISH . soundex ( " Williams " ) , " W452 " ) ; } 
public void estNewInstance ( ) { assertEquals ( new Soundex ( ) . soundex ( " Williams " ) , " W452 " ) ; } 
public void estUsMappingOWithDiaeresis ( ) { assertEquals ( " O000 " , his . getEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( ' ' ) ) { ry { 
public void estUsMappingEWithAcute ( ) { assertEquals ( " E000 " , his . getEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( ' ' ) ) { ry { 
public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { Comparable s1 = ( Comparable ) his . stringEncoder . encode ( o1 ) ; Comparable s2 = ( Comparable ) his . stringEncoder . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return compareCode ; } 
private boolean isVowel ( StringBuffer string , int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) > = 0 ; } 
public void estWhy ( ) { assertEquals ( " H " , his . getMetaphone ( ) . metaphone ( " WHY " ) ) ; } 
public void estWordsWithCIA ( ) { assertEquals ( " XP " , his . getMetaphone ( ) . metaphone ( " CIAPO " ) ) ; } 
public void estEncode ( ) { assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , his . getEncoder ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , his . getEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , his . getEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , his . getEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , his . getEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , his . getEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , his . getEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , his . getEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , his . getEncoder ( ) . encode ( " dogs " ) ) ; Testing CODEC-56 assertEquals("D6043", RefinedSoundex.US_ENGLISH.encode("dogs")); } 
public void estUsEnglishStatic ( ) { assertEquals ( Soundex . US_ENGLISH . soundex ( " Williams " ) , " W452 " ) ; } 
public void estNewInstance ( ) { assertEquals ( new Soundex ( ) . soundex ( " Williams " ) , " W452 " ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { long binaryDataLength = binaryData . length ; long lengthDataBits = binaryDataLength * EIGHTBIT ; long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP ; long ripletCount = lengthDataBits / TWENTYFOURBITGROUP ; long encodedDataLengthLong = 0 ; int chunckCount = 0 ; if ( fewerThan24bits ! = 0 ) { data not divisible by 24 bit encodedDataLengthLong = (tripletCount + 1) * 4; } else { 16 or 8 bit encodedDataLengthLong = tripletCount * 4; } If the output is to be "chunked" into 76 character sections, for compliance with RFC 2045 MIME, then it is important to allow for extra length to account for the separator(s) if (isChunked) { chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math .ceil((float) encodedDataLengthLong / CHUNK_SIZE)); encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length; } if (encodedDataLengthLong > Integer.MAX_VALUE) { throw new IllegalArgumentException( "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer.MAX_VALUE); } int encodedDataLength = (int) encodedDataLengthLong; byte encodedData[] = new byte[encodedDataLength]; byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0; int encodedIndex = 0; int dataIndex = 0; int i = 0; int nextSeparatorIndex = CHUNK_SIZE; int chunksSoFar = 0; log.debug("number of triplets = " + numberTriplets); for (i = 0; i < tripletCount; i++) { dataIndex = i * 3; b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; b3 = binaryData[dataIndex + 2]; log.debug("b1= " + b1 +", b2= " + b2 + ", b3= " + b3); l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; log.debug( "val2 = " + val2 ); log.debug( "k4 = " + (k<<4) ); log.debug( "vak = " + (val2 | (k<<4)) ); encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3]; encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f]; encodedIndex += 4; If we are chunking, let's put a chunk separator down. if (isChunked) { this assumes that CHUNK_SIZE % 4 == 0 if (encodedIndex == nextSeparatorIndex) { System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length); chunksSoFar++; nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length); encodedIndex += CHUNK_SEPARATOR.length; } } } form integral number of 6-bit groups dataIndex = i * 3; if (fewerThan24bits == EIGHTBIT) { b1 = binaryData[dataIndex]; k = (byte) (b1 & 0x03); log.debug("b1=" + b1); log.debug("b1<<2 = " + (b1>>2) ); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4]; encodedData[encodedIndex + 2] = PAD; encodedData[encodedIndex + 3] = PAD; } else if (fewerThan24bits == SIXTEENBIT) { b1 = binaryData[dataIndex]; b2 = binaryData[dataIndex + 1]; l = (byte) (b2 & 0x0f); k = (byte) (b1 & 0x03); byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0); byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0); encodedData[encodedIndex] = lookUpBase64Alphabet[val1]; encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)]; encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2]; encodedData[encodedIndex + 3] = PAD; } if (isChunked) { we also add a separator to the end of the final chunk. if (chunksSoFar < chunckCount) { System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length); } } return encodedData; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { RFC 2045 requires that we discard ALL non-Base64 characters base64Data = discardNonBase64(base64Data); handle the edge case, so we don't have to worry about it later if (base64Data.length == 0) { return new byte[0]; } int numberQuadruple = base64Data.length / FOURBYTE; byte decodedData[] = null; byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0; Throw away anything not in base64Data int encodedIndex = 0; int dataIndex = 0; { this sizes the output array properly - rlw int lastData = base64Data.length; ignore the '=' padding while (base64Data[lastData - 1] == PAD) { if (--lastData == 0) { return new byte[0]; } } decodedData = new byte[lastData - numberQuadruple]; } for (int i = 0; i < numberQuadruple; i++) { dataIndex = i * 4; marker0 = base64Data[dataIndex + 2]; marker1 = base64Data[dataIndex + 3]; b1 = base64Alphabet[base64Data[dataIndex]]; b2 = base64Alphabet[base64Data[dataIndex + 1]]; if (marker0 != PAD && marker1 != PAD) { No PAD e.g 3cQl b3 = base64Alphabet[marker0]; b4 = base64Alphabet[marker1]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4); } else if (marker0 == PAD) { Two PAD e.g. 3c[Pad][Pad] decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); } else if (marker1 == PAD) { One PAD e.g. 3cQ[Pad] b3 = base64Alphabet[marker0]; decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4); decodedData[encodedIndex + 1] = (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf)); } encodedIndex += 3; } return decodedData; } 
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { switch ( data [ i ] ) { case ( byte ) ' ' : case ( byte ) '' : case ( byte ) '\r' : case ( byte ) '' : break ; default : groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base64 encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) pObject ) ; } 
protected abstract StringEncoder makeEncoder ( ) ; "); } public void testEncodeNull() throws Exception { StringEncoder encoder = makeEncoder(); try { encoder.encode(null); } catch( EncoderException ee ) { An exception should be thrown } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = makeEncoder(); encoder.encode( new Float( 3.4 ) ); } catch( Exception e ) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); }} 
public void estEncodeNull ( ) hrows Exception { StringEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; 
private static byte [ ] digest ( MessageDigest digest , InputStream data ) hrows IOException { byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest . digest ( ) ; } 
public static byte [ ] md5 ( InputStream data ) hrows IOException { return digest ( getMd5Digest ( ) , data ) ; } 
public static String md5Hex ( InputStream data ) hrows IOException { return new String ( Hex . encodeHex ( md5 ( data ) ) ) ; } 
public static byte [ ] sha ( InputStream data ) hrows IOException { return digest ( getShaDigest ( ) , data ) ; } 
public static byte [ ] sha256 ( InputStream data ) hrows IOException { return digest ( getSha256Digest ( ) , data ) ; } 
public static String sha256Hex ( InputStream data ) hrows IOException { return new String ( Hex . encodeHex ( sha256 ( data ) ) ) ; } 
public static byte [ ] sha384 ( InputStream data ) hrows IOException { return digest ( getSha384Digest ( ) , data ) ; } 
public static String sha384Hex ( InputStream data ) hrows IOException { return new String ( Hex . encodeHex ( sha384 ( data ) ) ) ; } 
public static byte [ ] sha512 ( InputStream data ) hrows IOException { return digest ( getSha512Digest ( ) , data ) ; } 
public static String sha512Hex ( InputStream data ) hrows IOException { return new String ( Hex . encodeHex ( sha512 ( data ) ) ) ; } 
public static String shaHex ( InputStream data ) hrows IOException { return new String ( Hex . encodeHex ( sha ( data ) ) ) ; } 
public void estMd5Hex ( ) hrows IOException { Examples from RFC 1321 assertEquals("d41d8cd98f00b204e9800998ecf8427e", DigestUtils.md5Hex("")); assertEquals("0cc175b9c0f1b6a831c399e269772661", DigestUtils.md5Hex("a")); assertEquals("900150983cd24fb0d6963f7d28e17f72", DigestUtils.md5Hex("abc")); assertEquals("f96b697d7cb7938d525a2f31aaf161d0", DigestUtils.md5Hex("message digest")); assertEquals("c3fcd3d76192e4007dfb496cca67e13b", DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "d174ab98d277d9f5a5611c2c9f419d9f", DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "57edf4a22be3c955ac49da2e2107b67a", DigestUtils.md5Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md5Hex(testData), DigestUtils.md5Hex(new ByteArrayInputStream(testData))); 
public void estSha256 ( ) hrows IOException { DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); 
public void estSha384 ( ) hrows IOException { "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); 
public void estSha512 ( ) hrows IOException { "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(new ByteArrayInputStream(testData))); 
public void estShaHex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc".getBytes())); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.shaHex(testData), DigestUtils.shaHex(new ByteArrayInputStream(testData))); 
public static BigInteger decodeInteger ( byte [ ] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } 
public static byte [ ] encodeInteger ( BigInteger bigInt ) { if ( bigInt = = null ) { hrow new NullPointerException ( " encodeInteger called with null parameter " ) ; } return encodeBase64 ( oIntegerBytes ( bigInt ) , false ) ; } 
static byte [ ] oIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = ((bitlen + 7) >> 3) << 3; byte[] bigBytes = bigInt.toByteArray(); if(((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if((bigInt.bitLength() % 8) == 0) { startSrc = 1; len--; } int startDst = bitlen / 8 - len; to pad w/ nulls as per spec byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
public void estCodeInteger1 ( ) { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( ) ) ) ; } 
public void estCodeInteger2 ( ) { String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( ) ) ) ; } 
public void estCodeInteger3 ( ) { String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( ) ) ) ; } 
public void estCodeInteger4 ( ) { String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( ) ) ) ; } 
public String caverphone ( String xt ) { NOTE: Version 1.0 of Caverphone is easily derivable from this code by commenting out the 2.0 lines and adding in the 1.0 lines if( txt == null || txt.length() == 0 ) { return "1111111111"; } 1. Convert to lowercase txt = txt.toLowerCase(); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replace("e$", ""); 2.0 only 3. Handle various start options txt = txt.replace("^cough", "cou2f"); txt = txt.replace("^rough", "rou2f"); txt = txt.replace("^tough", "tou2f"); txt = txt.replace("^enough", "enou2f"); 2.0 only txt = txt.replace("^trough", "trou2f"); 2.0 only - note the spec says ^enough here again, c+p error I assume txt = txt.replace("^gn", "2n"); txt = txt.replace("^mb", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replace("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replace("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + "111111" + "1111"; 1.0 only has 6 1s 7. take the first six characters as the code return txt.substring(0, 10); 1.0 truncates to 6 } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof java . lang . String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return caverphone ( ( String ) pObject ) ; } 
public boolean isCaverphoneEqual ( String str1 , String str2 ) { return caverphone ( str1 ) . equals ( caverphone ( str2 ) ) ; } 
public void estWikipediaExamples ( ) { Caverphone caverphone = new Caverphone ( ) ; String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } , } ; for ( int i = 0 ; i < data . length ; i + + ) { assertEquals ( data [ i ] [ 1 ] , caverphone . caverphone ( data [ i ] [ 0 ] ) ) ; 
public void estSpecificationExamples ( ) { Caverphone caverphone = new Caverphone ( ) ; String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } , } ; for ( int i = 0 ; i < data . length ; i + + ) { assertEquals ( data [ i ] [ 1 ] , caverphone . caverphone ( data [ i ] [ 0 ] ) ) ; 
static byte [ ] oIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = ((bitlen + 7) >> 3) << 3; byte[] bigBytes = bigInt.toByteArray(); if(((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if((bigInt.bitLength() % 8) == 0) { startSrc = 1; len--; } int startDst = bitlen / 8 - len; to pad w/ nulls as per spec byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( ( index + 1 ) = = value . length ( ) - 1 | | contains ( value , 
public String caverphone ( String xt ) { NOTE: Version 1.0 of Caverphone is easily derivable from this code by commenting out the 2.0 lines and adding in the 1.0 lines if( txt == null || txt.length() == 0 ) { return "1111111111"; } 1. Convert to lowercase txt = txt.toLowerCase(); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only - note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); txt = txt.replaceAll("^mb", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + "111111" + "1111"; 1.0 only has 6 1s 7. take the first six characters as the code return txt.substring(0, 10); 1.0 truncates to 6 } 
public void estWhy ( ) { PHP returns "H". The original metaphone returns an empty string. assertEquals("", this.getMetaphone().metaphone("WHY")); } 
public String caverphone ( String xt ) { NOTE: Version 1.0 of Caverphone is easily derivable from this code by commenting out the 2.0 lines and adding in the 1.0 lines if( txt == null || txt.length() == 0 ) { return "1111111111"; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only - note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); txt = txt.replaceAll("^mb", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + "111111" + "1111"; 1.0 only has 6 1s 7. take the first six characters as the code return txt.substring(0, 10); 1.0 truncates to 6 } 
private String cleanInput ( String input ) { if ( input = = null ) { return null ; } input = input . rim ( ) ; if ( input . length ( ) = = 0 ) { return null ; } return input . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
static String clean ( String str ) { if ( str = = null | | str . length ( ) = = 0 ) { return str ; } int len = str . length ( ) ; char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
protected abstract StringEncoder makeEncoder ( ) ; "); } public void testEncodeNull() throws Exception { StringEncoder encoder = makeEncoder(); try { encoder.encode(null); } catch( EncoderException ee ) { An exception should be thrown } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = makeEncoder(); encoder.encode( new Float( 3.4 ) ); } catch( Exception e ) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); } public void testLocaleIndependence() throws Exception { StringEncoder encoder = makeEncoder(); String[] data = { "I", "i", }; Locale orig = Locale.getDefault(); Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; try { for (int i = 0; i < data.length; i++) { String ref = null; for (int j = 0; j < locales.length; j++) { Locale.setDefault(locales[j]); if (j <= 0) { ref = encoder.encode(data[i]); } else { String cur = null; try { cur = encoder.encode(data[i]); } catch (Exception e) { fail(Locale.getDefault().toString() + ": " + e.getMessage()); } assertEquals(Locale.getDefault().toString() + ": ", ref, cur); } } } } finally { Locale.setDefault(orig); } }} 
public void estLocaleIndependence ( ) hrows Exception { StringEncoder encoder = makeEncoder ( ) ; String [ ] data = { " I " , " i " , } ; Locale orig = Locale . getDefault ( ) ; Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( int i = 0 ; i < data . length ; i + + ) { 
public void estCodec68 ( ) { byte [ ] x = new byte [ ] { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public byte [ ] decode ( byte [ ] array ) hrows DecoderException { return decodeHex ( new String ( array ) . oCharArray ( ) ) ; } 
public Object decode ( Object object ) hrows DecoderException { ry { char [ ] charArray = object instanceof String ? ( ( String ) object ) . oCharArray ( ) : ( char [ ] ) object ; 
public byte [ ] encode ( byte [ ] array ) { return new String ( encodeHex ( array ) ) . getBytes ( ) ; } 
public Object encode ( Object object ) hrows EncoderException { ry { byte [ ] byteArray = object instanceof String ? ( ( String ) object ) . getBytes ( ) : ( byte [ ] ) object ; 
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( ( index + 1 ) = = value . length ( ) - 1 | | contains ( value , 
private String cleanInput ( String input ) { if ( input = = null ) { return null ; } input = input . rim ( ) ; if ( input . length ( ) = = 0 ) { return null ; } return input . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
private boolean isVowel ( StringBuffer string , int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) > = 0 ; } 
private boolean isPreviousChar ( StringBuffer string , int index , char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
private boolean isNextChar ( StringBuffer string , int index , char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
private boolean regionMatch ( StringBuffer string , int index , String est ) { boolean matches = false ; if ( index > = 0 & & ( index + est . length ( ) - 1 ) < string . length ( ) ) { String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; ------------------------------------------------------------------------ public void testEncodeEmpty() throws Exception { BinaryEncoder encoder = makeEncoder(); encoder.encode(new byte[0]); } public void testEncodeNull() throws Exception { BinaryEncoder encoder = makeEncoder(); try { encoder.encode(null); } catch( EncoderException ee ) { An exception should be thrown } } } 
public void estEncodeNull ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( ) ) ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isArrayByteBase64 ( bArray ) ) ; boolean exceptionThrown = false ; ry { Base64 b64 = new Base64 ( ) ; byte [ ] result = b64 . decode ( bArray ) ; assertTrue ( " The result should be empty as the test encoded content did " + " not contain any valid base 64 characters " , result . length = = 0 ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertFalse ( " Exception was thrown when trying to decode " + " invalid base64 encoded data - RFC 2045 requires that all " + 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; } 
public void estCodeInteger1 ( ) { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( ) ) ) ; } 
public void estSha256 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc")); assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc".getBytes())); assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1", DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); 
public void estSha384 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc")); assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc".getBytes())); assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039", DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); 
public void estSha512 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc".getBytes())); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(new ByteArrayInputStream(testData))); 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } String msg = failures.toString(); matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } public void testCCedilla() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("", "S"); } public void testNTilde() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("", "N"); } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estMetaphone ( ) { assertEquals ( " HL " , his . getMetaphone ( ) . metaphone ( " howl " ) ) ; assertEquals ( " TSTN " , his . getMetaphone ( ) . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " The " ) ) ; assertEquals ( " KK " , his . getMetaphone ( ) . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , his . getMetaphone ( ) . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , his . getMetaphone ( ) . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , his . getMetaphone ( ) . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , his . getMetaphone ( ) . metaphone ( " over " ) ) ; assertEquals ( " 0 " , his . getMetaphone ( ) . metaphone ( " he " ) ) ; assertEquals ( " LS " , his . getMetaphone ( ) . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , his . getMetaphone ( ) . metaphone ( " dogs " ) ) ; } 
public void estWordEndingInMB ( ) { assertEquals ( " KM " , his . getMetaphone ( ) . metaphone ( " COMB " ) ) ; assertEquals ( " TM " , his . getMetaphone ( ) . metaphone ( " TOMB " ) ) ; assertEquals ( " WM " , his . getMetaphone ( ) . metaphone ( " WOMB " ) ) ; } 
public void estDiscardOfSCEOrSCIOrSCY ( ) { assertEquals ( " SNS " , his . getMetaphone ( ) . metaphone ( " SCIENCE " ) ) ; assertEquals ( " SN " , his . getMetaphone ( ) . metaphone ( " SCENE " ) ) ; assertEquals ( " S " , his . getMetaphone ( ) . metaphone ( " SCY " ) ) ; } 
public void estTranslateOfSCHAndCH ( ) { assertEquals ( " SKTL " , his . getMetaphone ( ) . metaphone ( " SCHEDULE " ) ) ; assertEquals ( " SKMT " , his . getMetaphone ( ) . metaphone ( " SCHEMATIC " ) ) ; assertEquals ( " KRKT " , his . getMetaphone ( ) . metaphone ( " CHARACTER " ) ) ; assertEquals ( " TX " , his . getMetaphone ( ) . metaphone ( " TEACH " ) ) ; } 
public void estTranslateToJOfDGEOrDGIOrDGY ( ) { assertEquals ( " TJ " , his . getMetaphone ( ) . metaphone ( " DODGY " ) ) ; assertEquals ( " TJ " , his . getMetaphone ( ) . metaphone ( " DODGE " ) ) ; assertEquals ( " AJMT " , his . getMetaphone ( ) . metaphone ( " ADGIEMTI " ) ) ; } 
public void estDiscardOfSilentHAfterG ( ) { assertEquals ( " KNT " , his . getMetaphone ( ) . metaphone ( " GHENT " ) ) ; assertEquals ( " B " , his . getMetaphone ( ) . metaphone ( " BAUGH " ) ) ; } 
public void estDiscardOfSilentGN ( ) { assertEquals ( " N " , his . getMetaphone ( ) . metaphone ( " GNU " ) ) ; assertEquals ( " SNT " , his . getMetaphone ( ) . metaphone ( " SIGNED " ) ) ; } 
public void estPHTOF ( ) { assertEquals ( " FX " , his . getMetaphone ( ) . metaphone ( " PHISH " ) ) ; } 
public void estSHAndSIOAndSIAToX ( ) { assertEquals ( " XT " , his . getMetaphone ( ) . metaphone ( " SHOT " ) ) ; assertEquals ( " OTXN " , his . getMetaphone ( ) . metaphone ( " ODSIAN " ) ) ; assertEquals ( " PLXN " , his . getMetaphone ( ) . metaphone ( " PULSION " ) ) ; } 
public void estTIOAndTIAToX ( ) { assertEquals ( " OX " , his . getMetaphone ( ) . metaphone ( " OTIA " ) ) ; assertEquals ( " PRXN " , his . getMetaphone ( ) . metaphone ( " PORTION " ) ) ; } 
public void estTCH ( ) { assertEquals ( " RX " , his . getMetaphone ( ) . metaphone ( " RETCH " ) ) ; assertEquals ( " WX " , his . getMetaphone ( ) . metaphone ( " WATCH " ) ) ; } 
public void estExceedLength ( ) { should be AKSKS, but istruncated by Max Code Length assertEquals( "AKSK", this.getMetaphone().metaphone("AXEAXE") ); } 
public void estSetMaxLengthWithTruncation ( ) { should be AKSKS, but istruncated by Max Code Length this.getMetaphone().setMaxCodeLen( 6 ); assertEquals( "AKSKSK", this.getMetaphone().metaphone("AXEAXEAXE") ); } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getEncoder().difference(null, null)); assertEquals(0, this.getEncoder().difference("", "")); assertEquals(0, this.getEncoder().difference(" ", " ")); Normal cases assertEquals(6, this.getEncoder().difference("Smith", "Smythe")); assertEquals(3, this.getEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getEncoder().difference("Margaret", "Andrew")); assertEquals(1, this.getEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(5, this.getEncoder().difference("Green", "Greene")); assertEquals(1, this.getEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, this.getEncoder().difference("Smith", "Smythe")); assertEquals(8, this.getEncoder().difference("Smithers", "Smythers")); assertEquals(5, this.getEncoder().difference("Anothers", "Brothers")); } 
public void estGetMappingCodeNonLetter ( ) { char code = his . getEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , code ) ; } 
public void estBadCharacters ( ) { assertEquals ( " H452 " , his . getEncoder ( ) . encode ( " HOL>MES " ) ) ; 
int readResults ( byte [ ] b , int bPos , int bAvail ) { if ( buf ! = null ) { int len = Math . min ( avail ( ) , bAvail ) ; 
void encode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { eof = true; 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { if ( buf = = null | | buf . length - pos < decodeSize ) { 
private static boolean isBase64 ( byte octect ) { return octect = = PAD | | ( octect > = 0 & & octect < base64ToInt . length & & base64ToInt [ octect ] ! = - 1 ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( ) : new Base64 ( 0 ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { len + = ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { hrow new IllegalArgumentException ( " Input array too big, output array would be bigger than Integer.MAX_VALUE= " + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buf != buf) { b64.readResults(buf, 0, buf.length); } return buf; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { if ( base64Data = = null | | base64Data . length = = 0 ) { return base64Data ; } Base64 b64 = new Base64 ( ) ; long len = ( base64Data . length * 3 ) / 4 ; byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . decode ( base64Data , 0 , base64Data . length ) ; b64 . decode ( base64Data , 0 , - 1 ) ; Notify decoder of EOF. We have no idea what the line-length was, so we cannot know how much of our array wasn't used. byte[] result = new byte[b64.pos]; b64.readResults(result, 0, result.length); return result; } 
public int read ( ) hrows IOException { int r = read ( singleByte , 0 , 1 ) ; while ( r = = 0 ) { r = read ( singleByte , 0 , 1 ) ; } if ( r > 0 ) { return singleByte [ 0 ] < 0 ? 256 + singleByte [ 0 ] : singleByte [ 0 ] ; 
public int read ( byte b [ ] , int offset , int len ) hrows IOException { if ( b = = null ) { hrow new NullPointerException ( ) ; 
public void write ( int i ) hrows IOException { singleByte [ 0 ] = ( byte ) i ; write ( singleByte , 0 , 1 ) ; } 
public void write ( byte b [ ] , int offset , int len ) hrows IOException { if ( b = = null ) { hrow new NullPointerException ( ) ; 
private void flush ( boolean propogate ) hrows IOException { int avail = base64 . avail ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = base64 . readResults ( buf , 0 , avail ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void close ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { base64.encode(singleByte, 0, -1); } else { base64.decode(singleByte, 0, -1); } flush(); out.close(); } 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base64InputStream(in, true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base64InputStream(in); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base64InputStream(in, true, chunkSize, seperator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base64InputStream(in); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
static byte [ ] streamToBytes ( final InputStream in ) hrows IOException { new byte[7] is obviously quite slow, but helps exercise the code. byte[] buf = new byte[7]; try { int[] status = fill(buf, 0, in); int size = status[SIZE_KEY]; int lastRead = status[LAST_READ_KEY]; while (lastRead != -1) { buf = resizeArray(buf); status = fill(buf, size, in); size = status[SIZE_KEY]; lastRead = status[LAST_READ_KEY]; } if (buf.length != size) { byte[] smallerBuf = new byte[size]; System.arraycopy(buf, 0, smallerBuf, 0, size); buf = smallerBuf; } } finally { in.close(); } return buf; } 
private static int [ ] fill ( final byte [ ] buf , final int offset , final InputStream in ) hrows IOException { int read = in . read ( buf , offset , buf . length - offset ) ; int lastRead = read ; if ( read = = - 1 ) { read = 0 ; } while ( lastRead ! = - 1 & & read + offset < buf . length ) { lastRead = in . read ( buf , offset + read , buf . length - read - offset ) ; if ( lastRead ! = - 1 ) { read + = lastRead ; } } return new int [ ] { offset + read , lastRead } ; } 
private static byte [ ] resizeArray ( final byte [ ] bytes ) { byte [ ] biggerBytes = new byte [ bytes . length * 2 ] ; System . arraycopy ( bytes , 0 , biggerBytes , 0 , bytes . length ) ; return biggerBytes ; } 
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { switch ( data [ i ] ) { case ' ' : case '' : case '\r' : case '' : break ; default : groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { boolean exceptionThrown = false ; Base64 b64 = new Base64 ( ) ; ry { Object o = " Yadayadayada " ; b64 . decode ( o ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " decode(Object) didn't throw an exception when passed a " + " String object " , exceptionThrown ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( original . getBytes ( ) ) ; Object o = bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string down not equal original " , dest . equals ( original ) ) ; 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { boolean exceptionThrown = false ; Base64 b64 = new Base64 ( ) ; ry { Object o = " Yadayadayada " ; b64 . encode ( o ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " encode(Object) didn't throw an exception when passed a " + " String object " , exceptionThrown ) ; 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't equal the original " , dest . equals ( orig ) ) ; 
public void estDiscardWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] encodedNoWS = Base64 . discardWhitespace ( encodedWithWS ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; byte [ ] decodedNoWS = Base64 . decodeBase64 ( encodedNoWS ) ; String destFromWS = new String ( decodedWithWS ) ; String destFromNoWS = new String ( decodedNoWS ) ; assertTrue ( " Dest string doesn't equal original " , destFromWS . equals ( orig ) ) ; assertTrue ( " Dest string doesn't equal original " , destFromNoWS . equals ( orig ) ) ; 
public void estNonBase64Test ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isArrayByteBase64 ( bArray ) ) ; ry { Base64 b64 = new Base64 ( ) ; 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . decode ( " Yadayadayada " ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( original . getBytes ( ) ) ; Object o = bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . encode ( " Yadayadayada " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] origBytes = original . getBytes ( ) ; Object origObj = origBytes ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { } ry { base64 = new Base64 ( 64 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { } base64 = new Base64 ( 64 , new byte [ ] { '$' } ) ; OK try { base64 = new Base64(64,new byte[]{'A','$'}); 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { } ry { base64 = new Base64 ( 64 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { } ry { base64 = new Base64 ( 64 , new byte [ ] { '=' } ) ; fail ( " Should have rejected attempt to use '=' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { } base64 = new Base64 ( 64 , new byte [ ] { '$' } ) ; '}); OK } 
private static boolean isBase64 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < base64ToInt . length & & base64ToInt [ octet ] ! = - 1 ) ; } 
public static boolean isArrayByteBase64 ( byte [ ] arrayOctet ) { arrayOctet = discardWhitespace ( arrayOctet ) ; int length = arrayOctet . length ; if ( length = = 0 ) { return rue ; } for ( int i = 0 ; i < length ; i + + ) { if ( ! isBase64 ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
private static boolean containsBase64Byte ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( isBase64 ( arrayOctet [ i ] ) ) { return rue ; } } return false ; } 
public static boolean isBase64 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < base64ToInt . length & & base64ToInt [ octet ] ! = - 1 ) ; } 
public boolean markSupported ( ) { return false ; not an easy job to support marks } 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estDecodePadOnly ( ) { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) ) ) ; Test truncated padding assertTrue(Base64.decodeBase64("===".getBytes()).length == 0); assertTrue(Base64.decodeBase64("==".getBytes()).length == 0); assertTrue(Base64.decodeBase64("=".getBytes()).length == 0); assertTrue(Base64.decodeBase64("".getBytes()).length == 0); } 
public void estDecodePadOnlyChunked ( ) { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( ) ) ) ) ; Test truncated padding assertTrue(Base64.decodeBase64("===".getBytes()).length == 0); assertTrue(Base64.decodeBase64("==".getBytes()).length == 0); assertTrue(Base64.decodeBase64("=".getBytes()).length == 0); assertTrue(Base64.decodeBase64("".getBytes()).length == 0); } 
public static boolean isArrayByteBase64 ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isBase64 ( arrayOctet [ i ] ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
private static boolean isWhiteSpace ( byte byteToCheck ) { switch ( byteToCheck ) { case ' ' : 
public static char [ ] encodeHex ( byte [ ] data , boolean oLowerCase ) { return encodeHex ( data , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; } 
protected static char [ ] encodeHex ( byte [ ] data , char [ ] oDigits ) { int l = data . length ; char [ ] out = new char [ l < < 1 ] ; two characters form the hex value. for (int i = 0, j = 0; i < l; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; out[j++] = toDigits[0x0F & data[i]]; } return out; } 
public void estHelloWorldLowerCaseHex ( ) { byte [ ] b = " Hello World " . getBytes ( ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estHelloWorldUpperCaseHex ( ) { byte [ ] b = " Hello World " . getBytes ( ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estNewInstance ( ) { assertEquals ( " D6043 " , new RefinedSoundex ( ) . soundex ( " dogs " ) ) ; } 
public void estNewInstance2 ( ) { assertEquals ( " D6043 " , new RefinedSoundex ( RefinedSoundex . US_ENGLISH_MAPPING_STRING . oCharArray ( ) ) . soundex ( " dogs " ) ) ; } 
public void estNewInstance3 ( ) { assertEquals ( " D6043 " , new RefinedSoundex ( RefinedSoundex . US_ENGLISH_MAPPING_STRING ) . soundex ( " dogs " ) ) ; } 
public void estUsEnglishStatic ( ) { assertEquals ( " W452 " , Soundex . US_ENGLISH . soundex ( " Williams " ) ) ; } 
public void estNewInstance ( ) { assertEquals ( " W452 " , new Soundex ( ) . soundex ( " Williams " ) ) ; } 
public void estNewInstance2 ( ) { assertEquals ( " W452 " , new Soundex ( Soundex . US_ENGLISH_MAPPING_STRING . oCharArray ( ) ) . soundex ( " Williams " ) ) ; } 
public void estNewInstance3 ( ) { assertEquals ( " W452 " , new Soundex ( Soundex . US_ENGLISH_MAPPING_STRING ) . soundex ( " Williams " ) ) ; } 
public int read ( ) hrows IOException { int r = read ( singleByte , 0 , 1 ) ; while ( r = = 0 ) { r = read ( singleByte , 0 , 1 ) ; } if ( r > 0 ) { return singleByte [ 0 ] < 0 ? 256 + singleByte [ 0 ] : singleByte [ 0 ] ; } return - 1 ; } 
public boolean isUrlSafe ( ) { return his . encodeTable = = URL_SAFE_ENCODE_TABLE ; } 
int readResults ( byte [ ] b , int bPos , int bAvail ) { if ( buf ! = null ) { int len = Math . min ( avail ( ) , bAvail ) ; if ( buf ! = b ) { System . arraycopy ( buf , readPos , b , bPos , len ) ; readPos + = len ; if ( readPos > = pos ) { buf = null ; } } else { Re-using the original consumer's output array is only allowed for one round. buf = null; } return len; } return eof ? -1 : 0; } 
void encode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { eof = true; 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { if ( buf = = null | | buf . length - pos < decodeSize ) { resizeBuf ( ) ; } byte b = in [ inPos + + ] ; if ( b = = PAD ) { WE'RE DONE!!!! eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % 4; x = (x << 6) + result; if (modulus == 0) { buf[pos++] = (byte) ((x >> 16) & MASK_8BITS); buf[pos++] = (byte) ((x >> 8) & MASK_8BITS); buf[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { x = x << 6; 
public static boolean isBase64 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < DECODE_TABLE . length & & DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static byte [ ] encodeBase64URLSafe ( byte [ ] binaryData ) { return encodeBase64 ( binaryData , false , rue ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { len + = ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { hrow new IllegalArgumentException ( " Input array too big, output array would be bigger than Integer.MAX_VALUE= " + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buf != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { if ( base64Data = = null | | base64Data . length = = 0 ) { return base64Data ; } Base64 b64 = new Base64 ( ) ; long len = ( base64Data . length * 3 ) / 4 ; byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . decode ( base64Data , 0 , base64Data . length ) ; b64 . decode ( base64Data , 0 , - 1 ) ; Notify decoder of EOF. We have no idea what the line-length was, so we cannot know how much of our array wasn't used. byte[] result = new byte[b64.pos]; b64.readResults(result, 0, result.length); return result; } 
static byte [ ] discardWhitespace ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { switch ( data [ i ] ) { case ' ' : case '' : case '\r' : case '' : break ; default : groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
private static boolean isWhiteSpace ( byte byteToCheck ) { switch ( byteToCheck ) { case ' ' : 
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i + + ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied + + ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public byte [ ] encode ( byte [ ] pArray ) { return encodeBase64 ( pArray , false , isUrlSafe ( ) ) ; } 
public static byte [ ] encodeInteger ( BigInteger bigInt ) { if ( bigInt = = null ) { hrow new NullPointerException ( " encodeInteger called with null parameter " ) ; } return encodeBase64 ( oIntegerBytes ( bigInt ) , false ) ; } 
static byte [ ] oIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = ((bitlen + 7) >> 3) << 3; byte[] bigBytes = bigInt.toByteArray(); if(((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if((bigInt.bitLength() % 8) == 0) { startSrc = 1; len--; } int startDst = bitlen / 8 - len; to pad w/ nulls as per spec byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
public void estUUID ( ) hrows DecoderException , UnsupportedEncodingException { The 4 UUID's below contains mixtures of + and / to help us test the URL-SAFE encoding mode. byte[][] ids = new byte[4][]; ids[0] was chosen so that it encodes with at least one +. ids[0] = Hex.decodeHex("94ed8d0319e4493399560fb67404d370".toCharArray()); ids[1] was chosen so that it encodes with both / and +. ids[1] = Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray()); ids[2] was chosen so that it encodes with at least one /. ids[2] = Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca".toCharArray()); ids[3] was chosen so that it encodes with both / and +, with / right at the beginning. ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray()); byte[][] standard = new byte[4][]; standard[0] = "lO2NAxnkSTOZVg+2dATTcA==".getBytes("UTF-8"); standard[1] = "K/fMJwH+Q5e0nr7tWsxwkA==".getBytes("UTF-8"); standard[2] = "ZL4VS2/6QCWNGgEojnwxyg==".getBytes("UTF-8"); standard[3] = "/3+PwBzbRxqMi1qTBhg/6A==".getBytes("UTF-8"); byte[][] urlSafe1 = new byte[4][]; regular padding (two '==' signs). urlSafe1[0] = "lO2NAxnkSTOZVg-2dATTcA==".getBytes("UTF-8"); urlSafe1[1] = "K_fMJwH-Q5e0nr7tWsxwkA==".getBytes("UTF-8"); urlSafe1[2] = "ZL4VS2_6QCWNGgEojnwxyg==".getBytes("UTF-8"); urlSafe1[3] = "_3-PwBzbRxqMi1qTBhg_6A==".getBytes("UTF-8"); byte[][] urlSafe2 = new byte[4][]; single padding (only one '=' sign). urlSafe2[0] = "lO2NAxnkSTOZVg-2dATTcA=".getBytes("UTF-8"); urlSafe2[1] = "K_fMJwH-Q5e0nr7tWsxwkA=".getBytes("UTF-8"); urlSafe2[2] = "ZL4VS2_6QCWNGgEojnwxyg=".getBytes("UTF-8"); urlSafe2[3] = "_3-PwBzbRxqMi1qTBhg_6A=".getBytes("UTF-8"); byte[][] urlSafe3 = new byte[4][]; no padding (no '=' signs). urlSafe3[0] = "lO2NAxnkSTOZVg-2dATTcA".getBytes("UTF-8"); urlSafe3[1] = "K_fMJwH-Q5e0nr7tWsxwkA".getBytes("UTF-8"); urlSafe3[2] = "ZL4VS2_6QCWNGgEojnwxyg".getBytes("UTF-8"); urlSafe3[3] = "_3-PwBzbRxqMi1qTBhg_6A".getBytes("UTF-8"); for (int i = 0; i < 4; i++) { byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estBase64EmptyInputStream ( ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; } 
public void estBase64EmptyOutputStream ( ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; } 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; } 
protected static char [ ] encodeHex ( byte [ ] data , char [ ] oDigits ) { int l = data . length ; char [ ] out = new char [ l < < 1 ] ; two characters form the hex value. for (int i = 0, j = 0; i < l; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; out[j++] = toDigits[0x0F & data[i]]; } return out; } 
public static byte [ ] sha384 ( byte [ ] data ) { return getSha384Digest ( ) . digest ( data ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes(UTF_8_NAME); byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes(UTF_8_NAME); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes(UTF_8_NAME); byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes(UTF_8_NAME); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base64InputStream(in, true, chunkSize, seperator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base64InputStream(in); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base64InputStream(in, true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base64InputStream(in); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = STRING_FIXTURE . getBytes ( UTF_8_NAME ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = STRING_FIXTURE . getBytes ( UTF_8_NAME ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = STRING_FIXTURE . getBytes ( UTF_8_NAME ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = STRING_FIXTURE . getBytes ( UTF_8_NAME ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, buf.length + 1, 0); 
public void estBase64EmptyOutputStream ( ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , 76 , CRLF ) ; } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes("UTF-8"); byte[] decoded = "Hello World".getBytes("UTF-8"); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes("UTF-8"); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estWriteOutOfBounds ( ) hrows Exception { byte [ ] buf = new byte [ 1024 ] ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 0 ) ; fail ( " Expected Base64OutputStream.write(buf, -1, 0) to throw a IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, buf.length + 1, 0); 
public void estWriteToNullCoverage ( ) hrows Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( null , 0 , 0 ) ; 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { '}); OK } 
public void estUrlSafe ( ) { test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, true); 
public void estIsUrlSafe ( ) { Base64 base64Standard = new Base64 ( false ) ; Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isArrayByteBase64(whiteSpace)=true " , Base64 . isArrayByteBase64 ( whiteSpace ) ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( null ) ) ; } 
public static byte [ ] [ ] randomData ( int size , boolean urlSafe ) { Random r = new Random ( ) ; byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; byte [ ] encoded = urlSafe ? Base64 . encodeBase64URLSafe ( decoded ) : Base64 . encodeBase64 ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
public void estIsCaverphoneEquals ( ) { Caverphone caverphone = new Caverphone ( ) ; assertFalse ( " Caverphone encodings should not be equal " , caverphone . isCaverphoneEqual ( " Peter " , " Stevenson " ) ) ; assertTrue ( " Caverphone encodings should be equal " , caverphone . isCaverphoneEqual ( " Peter " , " Peady " ) ) ; } 
public void estSoundexUtilsNullBehaviour ( ) { assertEquals ( null , SoundexUtils . clean ( null ) ) ; assertEquals ( " " , SoundexUtils . clean ( " " ) ) ; assertEquals ( 0 , SoundexUtils . differenceEncoded ( null , " " ) ) ; assertEquals ( 0 , SoundexUtils . differenceEncoded ( " " , null ) ) ; } 
public void estDiscardOfSilentGN ( ) { NOTE: This does not test for silent GN, but for starting with GN assertEquals( "N", this.getMetaphone().metaphone("GNU") ); NOTE: Trying to test for GNED, but expected code does not appear to execute assertEquals( "SNT", this.getMetaphone().metaphone("SIGNED") ); } 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = STRING_FIXTURE . getBytes ( UTF_8_NAME ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes(UTF_8_NAME); byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes(UTF_8_NAME); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = "SGVsbG8gV29ybGQ=\r".getBytes(UTF_8_NAME); byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = "AA==\r".getBytes("UTF-8"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = singleLine.getBytes(UTF_8_NAME); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estWriteOutOfBounds ( ) hrows Exception { byte [ ] buf = new byte [ 1024 ] ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); 
static byte [ ] [ ] randomData ( int size , boolean urlSafe ) { Random r = new Random ( ) ; byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; byte [ ] encoded = urlSafe ? Base64 . encodeBase64URLSafe ( decoded ) : Base64 . encodeBase64 ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
static boolean bytesContain ( byte [ ] bytes , byte c ) { for ( int i = 0 ; i < bytes . length ; i + + ) { if ( bytes [ i ] = = c ) { return rue ; } } return false ; } 
private void resizeBuffer ( ) { if ( buffer = = null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; 
int readResults ( byte [ ] b , int bPos , int bAvail ) { if ( buffer ! = null ) { int len = Math . min ( avail ( ) , bAvail ) ; if ( buffer ! = b ) { System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos + = len ; if ( readPos > = pos ) { buffer = null ; } } else { Re-using the original consumer's output array is only allowed for one round. buffer = null; } return len; } return eof ? -1 : 0; } 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } byte b = in [ inPos + + ] ; if ( b = = PAD ) { WE'RE DONE!!!! eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % 4; x = (x << 6) + result; if (modulus == 0) { buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { x = x << 6; 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { len + = ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { hrow new IllegalArgumentException ( " Input array too big, output array would be bigger than Integer.MAX_VALUE= " + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buffer != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
public static byte [ ] encodeInteger ( BigInteger bigInt ) { if ( bigInt = = null ) { hrow new NullPointerException ( " encodeInteger called with null parameter " ) ; } return encodeBase64 ( oIntegerBytes ( bigInt ) , false ) ; } 
static byte [ ] oIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = ((bitlen + 7) >> 3) << 3; byte[] bigBytes = bigInt.toByteArray(); if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if ((bigInt.bitLength() % 8) == 0) { startSrc = 1; len--; } int startDst = bitlen / 8 - len; to pad w/ nulls as per spec byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { len + = ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { hrow new IllegalArgumentException ( " Input array too big, output array would be bigger than Integer.MAX_VALUE= " + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buffer != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
private static IllegalStateException newIllegalStateException ( String charsetName , UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + " : " + e ) ; } 
public static String newString ( byte [ ] bytes , String charsetName ) { ry { return new String ( bytes , charsetName ) ; 
public static String newStringIso8859_1 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . US_ASCII ) ; } 
public static String newStringUtf16 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . UTF_16 ) ; } 
public static String newStringUtf16Be ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . UTF_16BE ) ; } 
public static String newStringUtf16Le ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . UTF_16LE ) ; } 
public static String newStringUtf8 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , RequiredCharsetNames . UTF_8 ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( StringBytesUtils . getBytesUsAscii ( pString ) ) , charset ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return StringBytesUtils . newStringUsAscii ( encode ( pString . getBytes ( charset ) ) ) ; } 
protected String encodeText ( final String ext , final String charset ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " =? " ) ; buffer . append ( charset ) ; buffer . append ( '?' ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( '?' ) ; byte [ ] rawdata = doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringBytesUtils . newStringUsAscii ( rawdata ) ) ; buffer . append ( " ?= " ) ; return buffer . oString ( ) ; } 
public void estIso8859_1 ( ) { Assert . assertEquals ( " ISO-8859-1 " , RequiredCharsetNames . ISO_8859_1 ) ; } 
public void estUsAscii ( ) { Assert . assertEquals ( " US-ASCII " , RequiredCharsetNames . US_ASCII ) ; } 
public void estUtf16 ( ) { Assert . assertEquals ( " UTF-16 " , RequiredCharsetNames . UTF_16 ) ; } 
public void estUtf16Be ( ) { Assert . assertEquals ( " UTF-16BE " , RequiredCharsetNames . UTF_16BE ) ; } 
public void estUtf16Le ( ) { Assert . assertEquals ( " UTF-16LE " , RequiredCharsetNames . UTF_16LE ) ; } 
public void estUtf8 ( ) { Assert . assertEquals ( " UTF-8 " , RequiredCharsetNames . UTF_8 ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringBytesUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringBytesUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringBytesUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringBytesUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estEncodeDecodeSmall ( ) { for ( int i = 0 ; i < 12 ; i + + ) { byte [ ] data = new byte [ i ] ; 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { byte [ ] data = new byte [ his . getRandom ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertTrue ( Arrays . equals ( new byte [ ] { 13 , 10 } , Base64 . CHUNK_SEPARATOR ) ) ; } 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( ) ) ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( ) ) ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isArrayByteBase64 ( bArray ) ) ; ry { Base64 b64 = new Base64 ( ) ; 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( ) ) ) ) ; 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isArrayByteBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isArrayByteBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . decode ( " Yadayadayada " ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] bArray = Base64 . encodeBase64 ( original . getBytes ( ) ) ; Object o = bArray ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . encode ( " Yadayadayada " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; byte [ ] origBytes = original . getBytes ( ) ; Object origObj = origBytes ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't equal the original " , dest . equals ( orig ) ) ; } 
public void estDiscardWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( ) ; byte [ ] encodedNoWS = Base64 . discardWhitespace ( encodedWithWS ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; byte [ ] decodedNoWS = Base64 . decodeBase64 ( encodedNoWS ) ; String destFromWS = new String ( decodedWithWS ) ; String destFromNoWS = new String ( decodedNoWS ) ; assertTrue ( " Dest string doesn't equal original " , destFromWS . equals ( orig ) ) ; assertTrue ( " Dest string doesn't equal original " , destFromNoWS . equals ( orig ) ) ; } 
public void estCodeInteger1 ( ) { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( ) ) ) ; } 
public void estCodeInteger2 ( ) { String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( ) ) ) ; } 
public void estCodeInteger3 ( ) { String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( ) ) ) ; } 
public void estCodeInteger4 ( ) { String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( ) ) ) ; } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { '}); OK } 
public void estUUID ( ) hrows DecoderException { The 4 UUID's below contains mixtures of + and / to help us test the URL-SAFE encoding mode. byte[][] ids = new byte[4][]; ids[0] was chosen so that it encodes with at least one +. ids[0] = Hex.decodeHex("94ed8d0319e4493399560fb67404d370".toCharArray()); ids[1] was chosen so that it encodes with both / and +. ids[1] = Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray()); ids[2] was chosen so that it encodes with at least one /. ids[2] = Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca".toCharArray()); ids[3] was chosen so that it encodes with both / and +, with / right at the beginning. ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray()); byte[][] standard = new byte[4][]; standard[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA=="); standard[1] = StringBytesUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA=="); standard[2] = StringBytesUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg=="); standard[3] = StringBytesUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A=="); byte[][] urlSafe1 = new byte[4][]; regular padding (two '==' signs). urlSafe1[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=="); urlSafe1[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=="); urlSafe1[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=="); urlSafe1[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=="); byte[][] urlSafe2 = new byte[4][]; single padding (only one '=' sign). urlSafe2[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA="); urlSafe2[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA="); urlSafe2[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg="); urlSafe2[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A="); byte[][] urlSafe3 = new byte[4][]; no padding (no '=' signs). urlSafe3[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA"); urlSafe3[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA"); urlSafe3[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg"); urlSafe3[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A"); for (int i = 0; i < 4; i++) { byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estIsUrlSafe ( ) { Base64 base64Standard = new Base64 ( false ) ; Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isArrayByteBase64(whiteSpace)=true " , Base64 . isArrayByteBase64 ( whiteSpace ) ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( null ) ) ; } 
private String oString ( byte [ ] data ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { buf . append ( data [ i ] ) ; if ( i ! = data . length - 1 ) { buf . append ( " , " ) ; } } return buf . oString ( ) ; } 
public void estCodec68 ( ) { byte [ ] x = new byte [ ] { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { String charsetName = " ISO-8859-1 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { String charsetName = " US-ASCII " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesUsAscii ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesUtf16 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-8 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getBytesUtf8 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
private void estGetSupportedBytes ( String charsetName ) hrows UnsupportedEncodingException { byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringBytesUtils . getSupportedBytes ( STRING_FIXTURE , charsetName ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetSupportedBytesBadEnc ( ) { ry { StringBytesUtils . getSupportedBytes ( STRING_FIXTURE , " UNKNOWN " ) ; 
private void estNewString ( String charsetName ) hrows UnsupportedEncodingException { String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newString ( BYTES_FIXTURE , charsetName ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringBadEnc ( ) { ry { StringBytesUtils . newString ( BYTES_FIXTURE , " UNKNOWN " ) ; 
public void estNewStringIso8859_1 ( ) hrows UnsupportedEncodingException { String charsetName = " ISO-8859-1 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringIso8859_1 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUsAscii ( ) hrows UnsupportedEncodingException { String charsetName = " US-ASCII " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringUsAscii ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringUtf16 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringUtf16Be ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringUtf16Le ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf8 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-8 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringBytesUtils . newStringUtf8 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; BCodec bcodec = new BCodec ( RequiredCharsetNames . UTF_8 ) ; assertEquals ( " =?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?= " , bcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?= " , bcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , bcodec . decode ( bcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , bcodec . decode ( bcodec . encode ( ch_msg ) ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QCodec qcodec = new QCodec ( RequiredCharsetNames . UTF_8 ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , RequiredCharsetNames . UTF_8 ) , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , RequiredCharsetNames . UTF_8 ) , RequiredCharsetNames . UTF_8 ) ) ; } 
public void estNullInput ( ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; assertNull ( estcodec . decodeText ( null ) ) ; assertNull ( estcodec . encodeText ( null , RequiredCharsetNames . UTF_8 ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , RequiredCharsetNames . UTF_8 ) , RequiredCharsetNames . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , RequiredCharsetNames . UTF_8 ) , RequiredCharsetNames . UTF_8 ) ) ; his . validateState ( urlCodec ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { boolean lenChunksPerfectly = len % CHUNK_SIZE = = 0 ; len + = ( len / CHUNK_SIZE ) * CHUNK_SEPARATOR . length ; if ( ! lenChunksPerfectly ) { len + = CHUNK_SEPARATOR . length ; } } if ( len > Integer . MAX_VALUE ) { hrow new IllegalArgumentException ( " Input array too big, output array would be bigger than Integer.MAX_VALUE= " + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buffer != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringBytesUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringBytesUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . encode ( " Yadayadayada " ) ; 
public void estChunkedEncodeMultipleOf76 ( ) hrows Exception { byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; convert to "" so we're 100% equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); byte[] actualEncode = actualResult.getBytes("UTF-8"); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estChunkedEncodeMultipleOf76 ( ) hrows Exception { byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); byte[] actualEncode = actualResult.getBytes("UTF-8"); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estEncodeOverMaxSize ( ) hrows Exception { estEncodeOverMaxSize ( - 1 ) ; estEncodeOverMaxSize ( 0 ) ; estEncodeOverMaxSize ( 1 ) ; estEncodeOverMaxSize ( 2 ) ; } 
private void estEncodeOverMaxSize ( int maxSize ) hrows Exception { ry { Base64 . encodeBase64 ( Base64TestData . DECODED , rue , false , maxSize ) ; 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { boolean lenChunksPerfectly = len % CHUNK_SIZE = = 0 ; len + = ( len / CHUNK_SIZE ) * CHUNK_SEPARATOR . length ; if ( ! lenChunksPerfectly ) { len + = CHUNK_SEPARATOR . length ; } } if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buffer != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod ! = 0 ) { len + = 4 - mod ; } if ( isChunked ) { boolean lenChunksPerfectly = len % CHUNK_SIZE = = 0 ; len + = ( len / CHUNK_SIZE ) * CHUNK_SEPARATOR . length ; if ( ! lenChunksPerfectly ) { len + = CHUNK_SEPARATOR . length ; } } if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (b64.buffer != buf) { b64.readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (urlSafe && b64.pos < buf.length) { byte[] smallerBuf = new byte[b64.pos]; System.arraycopy(buf, 0, smallerBuf, 0, b64.pos); buf = smallerBuf; } return buf; } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; int l = Character . digit ( ( char ) bytes [ + + i ] , 16 ) ; if ( u = = - 1 | | l = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; ------------------------------------------------------------------------ public void testEncodeEmpty() throws Exception { BinaryEncoder encoder = makeEncoder(); encoder.encode(new byte[0]); } public void testEncodeNull() throws Exception { BinaryEncoder encoder = makeEncoder(); try { encoder.encode(null); } catch (EncoderException ee) { An exception should be thrown } } } 
protected abstract StringEncoder makeEncoder ( ) ; "); } public void testEncodeNull() throws Exception { StringEncoder encoder = makeEncoder(); try { encoder.encode(null); } catch (EncoderException ee) { An exception should be thrown } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = makeEncoder(); encoder.encode( new Float( 3.4 ) ); } catch (Exception e) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); } public void testLocaleIndependence() throws Exception { StringEncoder encoder = makeEncoder(); String[] data = { "I", "i", }; Locale orig = Locale.getDefault(); Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; try { for (int i = 0; i < data.length; i++) { String ref = null; for (int j = 0; j < locales.length; j++) { Locale.setDefault(locales[j]); if (j <= 0) { ref = encoder.encode(data[i]); } else { String cur = null; try { cur = encoder.encode(data[i]); } catch (Exception e) { fail(Locale.getDefault().toString() + ": " + e.getMessage()); } assertEquals(Locale.getDefault().toString() + ": ", ref, cur); } } } } finally { Locale.setDefault(orig); } }} 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { StringEncoder encoder = makeEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; 
public void estInvalidEncoding ( ) { QCodec qcodec = new QCodec ( " NONSENSE " ) ; ry { qcodec . encode ( " Hello there! " ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { qcodec.decode("=?NONSENSE?Q?Hello there!?="); 
public void estDecodeInvalid ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; ry { qpcodec . decode ( " = " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { qpcodec.decode("=A"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { qpcodec.decode("=WW"); 
public void estInvalidEncoding ( ) { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( " NONSENSE " ) ; String plain = " Hello there! " ; ry { qpcodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } try { qpcodec.decode(plain); 
public void estDecodeInvalid ( ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; ry { estcodec . decodeText ( " whatever " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { testcodec.decodeText("=?stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?T?stuff"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { testcodec.decodeText("=??T?stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8??stuff?="); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { testcodec.decodeText("=?UTF-8?W?stuff?="); 
public void estDecodeInvalid ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; ry { urlCodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { urlCodec.decode("%A"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { urlCodec.decode("%WW"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } this.validateState(urlCodec); } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( ) ; byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = oCharacterDigit ( bytes [ + + i ] ) ; int l = oCharacterDigit ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding: " ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
private static int oCharacterDigit ( byte b ) hrows DecoderException { int i = Character . digit ( ( char ) b , RADIX ) ; if ( i = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding: not a valid digit (radix " + RADIX + " ): " + b ) ; } return i ; } 
public void estDecodeInvalid ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; ry { urlCodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { urlCodec.decode("%A"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { Bad 1st char after % urlCodec.decode("%WW"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { Bad 2nd char after % urlCodec.decode("%0W"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } this.validateState(urlCodec); } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = oCharacterDigit ( bytes [ + + i ] ) ; int l = oCharacterDigit ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding: " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { int u = Utils . digit16 ( bytes [ + + i ] ) ; int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid quoted-printable encoding " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( '%' ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = '%' ) { ry { int u = Utils . digit16 ( bytes [ + + i ] ) ; int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding: " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
static int digit16 ( byte b ) hrows DecoderException { int i = Character . digit ( ( char ) b , 16 ) ; if ( i = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding: not a valid digit (radix " + URLCodec . RADIX + " ): " + b ) ; } return i ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return caverphone ( ( String ) pObject ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } return metaphone ( ( String ) pObject ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) pObject ) ; } 
public void estConstructor0 ( ) { DecoderException e = new DecoderException ( ) ; assertNull ( e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorString ( ) { DecoderException e = new DecoderException ( MSG ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorStringThrowable ( ) { DecoderException e = new DecoderException ( MSG , ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructorThrowable ( ) { DecoderException e = new DecoderException ( ) ; assertEquals ( . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructor0 ( ) { EncoderException e = new EncoderException ( ) ; assertNull ( e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorString ( ) { EncoderException e = new EncoderException ( MSG ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorStringThrowable ( ) { EncoderException e = new EncoderException ( MSG , ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructorThrowable ( ) { EncoderException e = new EncoderException ( ) ; assertEquals ( . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public static String newStringIso8859_1 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . US_ASCII ) ; } 
public static String newStringUtf16 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . UTF_16 ) ; } 
public static String newStringUtf16Be ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . UTF_16BE ) ; } 
public static String newStringUtf16Le ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . UTF_16LE ) ; } 
public static String newStringUtf8 ( byte [ ] bytes ) { return StringBytesUtils . newString ( bytes , CharEncoding . UTF_8 ) ; } 
public void estIso8859_1 ( ) { Assert . assertEquals ( " ISO-8859-1 " , CharEncoding . ISO_8859_1 ) ; } 
public void estUsAscii ( ) { Assert . assertEquals ( " US-ASCII " , CharEncoding . US_ASCII ) ; } 
public void estUtf16 ( ) { Assert . assertEquals ( " UTF-16 " , CharEncoding . UTF_16 ) ; } 
public void estUtf16Be ( ) { Assert . assertEquals ( " UTF-16BE " , CharEncoding . UTF_16BE ) ; } 
public void estUtf16Le ( ) { Assert . assertEquals ( " UTF-16LE " , CharEncoding . UTF_16LE ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; BCodec bcodec = new BCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?= " , bcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?= " , bcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , bcodec . decode ( bcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , bcodec . decode ( bcodec . encode ( ch_msg ) ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QCodec qcodec = new QCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; } 
public void estNullInput ( ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; assertNull ( estcodec . decodeText ( null ) ) ; assertNull ( estcodec . encodeText ( null , CharEncoding . UTF_8 ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; his . validateState ( urlCodec ) ; } 
public Object decode ( Object pObject ) hrows DecoderException { if ( pObject instanceof byte [ ] ) { return decode ( ( byte [ ] ) pObject ) ; 
public byte [ ] decode ( byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } long len = ( pArray . length * 3 ) / 4 ; byte [ ] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; Notify decoder of EOF. Would be nice to just return buf (like we sometimes do in the encode logic), but we have no idea what the line-length was (could even be variable). So we cannot determine ahead of time exactly how big an array is necessary. Hence the need to construct a 2nd byte array to hold the final result: byte[] result = new byte[pos]; readResults(result, 0, result.length); return result; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { Base64 b64 = new Base64 ( ) ; return b64 . decode ( base64Data ) ; } 
public byte [ ] encode ( byte [ ] pArray ) { long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; byte [ ] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (buffer != buf) { readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (isUrlSafe() && pos < buf.length) { byte[] smallerBuf = new byte[pos]; System.arraycopy(buf, 0, smallerBuf, 0, pos); buf = smallerBuf; } return buf; } 
public static String newStringIso8859_1 ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . US_ASCII ) ; } 
public static String newStringUtf16 ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . UTF_16 ) ; } 
public static String newStringUtf16Be ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . UTF_16BE ) ; } 
public static String newStringUtf16Le ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . UTF_16LE ) ; } 
public static String newStringUtf8 ( byte [ ] bytes ) { return StringUtils . newString ( bytes , CharEncoding . UTF_8 ) ; } 
public String decode ( String pString , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( pString = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( pString ) ) , charset ) ; } 
public String encode ( String pString , String charset ) hrows UnsupportedEncodingException { if ( pString = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( pString . getBytes ( charset ) ) ) ; } 
protected String encodeText ( final String ext , final String charset ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " =? " ) ; buffer . append ( charset ) ; buffer . append ( '?' ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( '?' ) ; byte [ ] rawdata = doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawdata ) ) ; buffer . append ( " ?= " ) ; return buffer . oString ( ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estChunkedEncodeMultipleOf76 ( ) { byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estConstructor_Int_ByteArray_Boolean ( ) { Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; byte [ ] encoded = base64 . encode ( Base64TestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base64(65, \\ , false) " , expectedResult , result ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)", result, expectedResult); } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object o = Base64 . encodeBase64 ( original . getBytes ( ) ) ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object origObj = original . getBytes ( ) ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
public void estUUID ( ) hrows DecoderException { The 4 UUID's below contains mixtures of + and / to help us test the URL-SAFE encoding mode. byte[][] ids = new byte[4][]; ids[0] was chosen so that it encodes with at least one +. ids[0] = Hex.decodeHex("94ed8d0319e4493399560fb67404d370".toCharArray()); ids[1] was chosen so that it encodes with both / and +. ids[1] = Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray()); ids[2] was chosen so that it encodes with at least one /. ids[2] = Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca".toCharArray()); ids[3] was chosen so that it encodes with both / and +, with / right at the beginning. ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray()); byte[][] standard = new byte[4][]; standard[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA=="); standard[1] = StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA=="); standard[2] = StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg=="); standard[3] = StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A=="); byte[][] urlSafe1 = new byte[4][]; regular padding (two '==' signs). urlSafe1[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=="); urlSafe1[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=="); urlSafe1[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=="); urlSafe1[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=="); byte[][] urlSafe2 = new byte[4][]; single padding (only one '=' sign). urlSafe2[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA="); urlSafe2[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA="); urlSafe2[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg="); urlSafe2[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A="); byte[][] urlSafe3 = new byte[4][]; no padding (no '=' signs). urlSafe3[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA"); urlSafe3[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA"); urlSafe3[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg"); urlSafe3[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A"); for (int i = 0; i < 4; i++) { byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { String charsetName = " ISO-8859-1 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { String charsetName = " US-ASCII " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-8 " ; estGetSupportedBytes ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
private void estGetSupportedBytes ( String charsetName ) hrows UnsupportedEncodingException { byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getSupportedBytes ( STRING_FIXTURE , charsetName ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetSupportedBytesBadEnc ( ) { ry { StringUtils . getSupportedBytes ( STRING_FIXTURE , " UNKNOWN " ) ; 
private void estNewString ( String charsetName ) hrows UnsupportedEncodingException { String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newString ( BYTES_FIXTURE , charsetName ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringBadEnc ( ) { ry { StringUtils . newString ( BYTES_FIXTURE , " UNKNOWN " ) ; 
public void estNewStringIso8859_1 ( ) hrows UnsupportedEncodingException { String charsetName = " ISO-8859-1 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringIso8859_1 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUsAscii ( ) hrows UnsupportedEncodingException { String charsetName = " US-ASCII " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringUsAscii ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringUtf16 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringUtf16Be ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringUtf16Le ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf8 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-8 " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE , charsetName ) ; String actual = StringUtils . newStringUtf8 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = ESCAPE_CHAR ) { ry { int u = Utils . digit16 ( bytes [ + + i ] ) ; int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding: " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
protected String encodeText ( final String ext , final String charset ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( SEP ) ; byte [ ] rawdata = doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawdata ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
private void assertExpectedDecoderException ( String s ) hrows Exception { RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; ry { estcodec . decodeText ( s ) ; 
public void estDecodeInvalid ( ) hrows Exception { assertExpectedDecoderException ( " whatever " ) ; assertExpectedDecoderException ( " =? " ) ; assertExpectedDecoderException ( " ?= " ) ; assertExpectedDecoderException ( " == " ) ; assertExpectedDecoderException ( " =??= " ) ; assertExpectedDecoderException ( " =?stuff?= " ) ; assertExpectedDecoderException ( " =?UTF-8??= " ) ; assertExpectedDecoderException ( " =?UTF-8?stuff?= " ) ; assertExpectedDecoderException ( " =?UTF-8?T?stuff " ) ; assertExpectedDecoderException ( " =??T?stuff?= " ) ; assertExpectedDecoderException ( " =?UTF-8??stuff?= " ) ; assertExpectedDecoderException ( " =?UTF-8?W?stuff?= " ) ; } 
public static byte [ ] fromAscii ( byte [ ] ascii ) { if ( isEmpty ( ascii ) ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length byte[] l_raw = new byte[ascii.length >> 3]; for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
private static boolean isEmpty ( byte [ ] array ) { return array = = null | | array . length = = 0 ; } 
public static byte [ ] oAsciiBytes ( byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_BYTE_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length byte[] l_ascii = new byte[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static char [ ] oAsciiChars ( byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_CHAR_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length char[] l_ascii = new char[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public void estDecodeByteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); } 
public void estFromAsciiCharArray ( ) { assertEquals ( 0 , BinaryCodec . fromAscii ( ( char [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new char [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".toCharArray()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((char[]) null).length); } 
public void estFromAsciiByteArray ( ) { assertEquals ( 0 , BinaryCodec . fromAscii ( ( byte [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new byte [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes()); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes()); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public void estEncodeByteArray ( ) { With a single raw binary byte[] bits = new byte[1]; String l_encoded = new String(instance.encode(bits)); assertEquals("00000000", l_encoded); bits = new byte[1]; bits[0] = BIT_0; l_encoded = new String(instance.encode(bits)); assertEquals("00000001", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(instance.encode(bits)); assertEquals("00000011", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(instance.encode(bits)); assertEquals("00000111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(instance.encode(bits)); assertEquals("00001111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(instance.encode(bits)); assertEquals("00011111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(instance.encode(bits)); assertEquals("00111111", l_encoded); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(instance.encode(bits)); assertEquals("01111111", l_encoded); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("11111111", l_encoded); With a two raw binaries bits = new byte[2]; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000000", l_encoded); bits = new byte[2]; bits[0] = BIT_0; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000001", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000011", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000000111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000001111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000011111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; l_encoded = new String(instance.encode(bits)); assertEquals("0000000000111111", l_encoded); bits = new byte[2]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; l_encoded = new String(instance.encode(bits)); assertEquals("0000000001111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000000011111111", l_encoded); work on the other byte now bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000000111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000001111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000011111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0000111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0001111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0011111111111111", l_encoded); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("0111111111111111", l_encoded); bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); l_encoded = new String(instance.encode(bits)); assertEquals("1111111111111111", l_encoded); assertEquals(0, instance.encode((byte[]) null).length); } 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % 4; x = (x << 6) + result; if (modulus == 0) { buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { x = x << 6; 
public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , rue ) ) ; } 
public static String encodeBase64URLSafeString ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false , rue ) ) ; } 
public Object decode ( Object pObject ) hrows DecoderException { if ( pObject instanceof byte [ ] ) { return decode ( ( byte [ ] ) pObject ) ; 
public byte [ ] decode ( String pArray ) { return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } 
public byte [ ] decode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } long len = ( pArray . length * 3 ) / 4 ; byte [ ] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; Notify decoder of EOF. Would be nice to just return buf (like we sometimes do in the encode logic), but we have no idea what the line-length was (could even be variable). So we cannot determine ahead of time exactly how big an array is necessary. Hence the need to construct a 2nd byte array to hold the final result: byte[] result = new byte[pos]; readResults(result, 0, result.length); return result; } 
public static byte [ ] decodeBase64 ( String base64String ) { return new Base64 ( ) . decode ( base64String ) ; } 
public static byte [ ] decodeBase64 ( byte [ ] base64Data ) { return new Base64 ( ) . decode ( base64Data ) ; } 
public String encodeToString ( byte [ ] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } 
public byte [ ] encode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } long len = getEncodeLength ( pArray , lineLength , lineSeparator ) ; byte [ ] buf = new byte [ ( int ) len ] ; setInitialBuffer ( buf , 0 , buf . length ) ; encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; Notify encoder of EOF. Encoder might have resized, even though it was unnecessary. if (buffer != buf) { readResults(buf, 0, buf.length); } In URL-SAFE mode we skip the padding characters, so sometimes our final length is a bit smaller. if (isUrlSafe() && pos < buf.length) { byte[] smallerBuf = new byte[pos]; System.arraycopy(buf, 0, smallerBuf, 0, pos); buf = smallerBuf; } return buf; } 
private void reset ( ) { buffer = null ; pos = 0 ; readPos = 0 ; currentLinePos = 0 ; modulus = 0 ; eof = false ; } 
public static String newString ( byte [ ] bytes , String charsetName ) { if ( bytes = = null ) { return null ; } ry { return new String ( bytes , charsetName ) ; 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( ( byte [ ] ) null ) ) ; } 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . decode ( new Integer ( 5 ) ) ; 
public void estByteToStringVariations ( ) hrows DecoderException { Base64 base64 = new Base64 ( 0 ) ; byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; byte [ ] b2 = new byte [ 0 ] ; byte [ ] b3 = null ; byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=\r", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertEquals("byteToString null", null, base64.encodeToString(b3)); assertEquals("byteToString static null", null, Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==\r", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); } 
public void estStringToByteVariations ( ) hrows DecoderException { Base64 base64 = new Base64 ( ) ; String s1 = " SGVsbG8gV29ybGQ= r " ; String s2 = " " ; String s3 = null ; String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; for url-safe tests assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8(base64.decode(s1))); assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8((byte[])base64.decode((Object)s1))); assertEquals("StringToByte static Hello World", "Hello World", StringUtils.newStringUtf8(Base64.decodeBase64(s1))); assertEquals("StringToByte \"\"", "", StringUtils.newStringUtf8(base64.decode(s2))); assertEquals("StringToByte static \"\"", "", StringUtils.newStringUtf8(Base64.decodeBase64(s2))); assertEquals("StringToByte null", null, StringUtils.newStringUtf8(base64.decode(s3))); assertEquals("StringToByte static null", null, StringUtils.newStringUtf8(Base64.decodeBase64(s3))); assertTrue("StringToByte UUID", Arrays.equals(b4, base64.decode(s4b))); assertTrue("StringToByte static UUID", Arrays.equals(b4, Base64.decodeBase64(s4a))); assertTrue("StringToByte static-url-safe UUID", Arrays.equals(b4, Base64.decodeBase64(s4b))); } 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; Base64 b64 = new Base64 ( 76 , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); bogus characters to decode (to skip actually) byte[] decode = b64.decode("SGVsbG{}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertTrue("decode hello world", decodeString.equals("Hello World")); } 
public static Test suite ( ) { return new TestSuite ( DoubleMetaphone2Test . class ) ; } 
public void setUp ( ) hrows Exception { super . setUp ( ) ; his . doubleMetaphone = new DoubleMetaphone ( ) ; } 
public void earDown ( ) hrows Exception { super . earDown ( ) ; his . doubleMetaphone = null ; } 
public void estDoubleMetaphonePrimary ( ) { String value = null ; for ( int i = 0 ; i < TEST_DATA . length ; i + + ) { value = TEST_DATA [ i ] [ 0 ] ; 
public void estDoubleMetaphoneAlternate ( ) { String value = null ; for ( int i = 0 ; i < TEST_DATA . length ; i + + ) { value = TEST_DATA [ i ] [ 0 ] ; 
public void estSetMaxCodeLength ( ) { String value = " jumped " ; DoubleMetaphone doubleMetaphone = new DoubleMetaphone ( ) ; Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } 
public void estDoubleMetaphone ( ) { assertDoubleMetaphone ( " TSTN " , " esting " ) ; assertDoubleMetaphone ( " 0 " , " The " ) ; assertDoubleMetaphone ( " KK " , " quick " ) ; assertDoubleMetaphone ( " PRN " , " brown " ) ; assertDoubleMetaphone ( " FKS " , " fox " ) ; assertDoubleMetaphone ( " JMPT " , " jumped " ) ; assertDoubleMetaphone ( " AFR " , " over " ) ; assertDoubleMetaphone ( " 0 " , " he " ) ; assertDoubleMetaphone ( " LS " , " lazy " ) ; assertDoubleMetaphone ( " TKS " , " dogs " ) ; assertDoubleMetaphone ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphone ( " STFN " , " Stephan " ) ; assertDoubleMetaphone ( " KSSK " , " Kuczewski " ) ; assertDoubleMetaphone ( " MKLL " , " McClelland " ) ; assertDoubleMetaphone ( " SNHS " , " san jose " ) ; assertDoubleMetaphone ( " SNFP " , " xenophobia " ) ; assertDoubleMetaphoneAlt ( " TSTN " , " esting " ) ; assertDoubleMetaphoneAlt ( " T " , " The " ) ; assertDoubleMetaphoneAlt ( " KK " , " quick " ) ; assertDoubleMetaphoneAlt ( " PRN " , " brown " ) ; assertDoubleMetaphoneAlt ( " FKS " , " fox " ) ; assertDoubleMetaphoneAlt ( " AMPT " , " jumped " ) ; assertDoubleMetaphoneAlt ( " AFR " , " over " ) ; assertDoubleMetaphoneAlt ( " T " , " he " ) ; assertDoubleMetaphoneAlt ( " LS " , " lazy " ) ; assertDoubleMetaphoneAlt ( " TKS " , " dogs " ) ; assertDoubleMetaphoneAlt ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphoneAlt ( " STFN " , " Stephan " ) ; assertDoubleMetaphoneAlt ( " KXFS " , " Kutchefski " ) ; assertDoubleMetaphoneAlt ( " MKLL " , " McClelland " ) ; assertDoubleMetaphoneAlt ( " SNHS " , " san jose " ) ; assertDoubleMetaphoneAlt ( " SNFP " , " xenophobia " ) ; } 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleL ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index + = 2 ; } else { index + + ; result . append ( 'L' ) ; } return index ; } 
private static byte [ ] digest ( MessageDigest digest , InputStream data ) hrows IOException { byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest . digest ( ) ; } 
public static byte [ ] sha256 ( String data ) { return sha256 ( getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha384 ( String data ) { return sha384 ( getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha512 ( String data ) { return sha512 ( getBytesUtf8 ( data ) ) ; } 
public void estMD5HexLength ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMD5Length ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estSha256 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc")); assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex(getBytesUtf8("abc"))); assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1", DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); 
public void estSha384 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc")); assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex(getBytesUtf8("abc"))); assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039", DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); 
public void estSha512 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(new ByteArrayInputStream(testData))); 
public void estShaHex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex(getBytesUtf8("abc"))); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.shaHex(testData), DigestUtils.shaHex(new ByteArrayInputStream(testData))); 
public static String encodeHexString ( byte [ ] data ) { return new String ( encodeHex ( data ) ) ; } 
public byte [ ] decode ( byte [ ] array ) hrows DecoderException { ry { return decodeHex ( new String ( array , getCharsetName ( ) ) . oCharArray ( ) ) ; 
public byte [ ] encode ( byte [ ] array ) { return StringUtils . getBytesUnchecked ( encodeHexString ( array ) , getCharsetName ( ) ) ; } 
public Object encode ( Object object ) hrows EncoderException { ry { byte [ ] byteArray = object instanceof String ? ( ( String ) object ) . getBytes ( getCharsetName ( ) ) : ( byte [ ] ) object ; 
public String oString ( ) { return super . oString ( ) + " [charsetName= " + his . charsetName + " ] " ; } 
public static String md5Hex ( byte [ ] data ) { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String md5Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String md5Hex ( String data ) { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String sha256Hex ( byte [ ] data ) { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha256Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha256Hex ( String data ) { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha384Hex ( byte [ ] data ) { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha384Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha384Hex ( String data ) { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha512Hex ( byte [ ] data ) { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String sha512Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String sha512Hex ( String data ) { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String shaHex ( byte [ ] data ) { return Hex . encodeHexString ( sha ( data ) ) ; } 
public static String shaHex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( sha ( data ) ) ; } 
public static String shaHex ( String data ) { return Hex . encodeHexString ( sha ( data ) ) ; } 
private void checkDecodeHexOddCharacters ( char [ ] data ) { ry { Hex . decodeHex ( data ) ; 
public void estCustomCharset ( ) hrows UnsupportedEncodingException , DecoderException { SortedMap map = Charset . availableCharsets ( ) ; Set keys = map . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; log ( " estCustomCharset: Checking " + keys . size ( ) + " charsets... " ) ; while ( iterator . hasNext ( ) ) { String name = ( String ) iterator . next ( ) ; 
private void estCustomCharset ( String name , String parent ) hrows UnsupportedEncodingException , DecoderException { if ( charsetSanityCheck ( name ) = = false ) { log ( " Interesting Java charset oddity: Charset sanity check failed for " + name ) ; return ; } log ( parent + " = " + name ) ; Hex customCodec = new Hex ( name ) ; source data String sourceString = "Hello World"; byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharsetName()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
private boolean charsetSanityCheck ( String name ) { final String source = " he quick brown dog jumped over the lazy fox " ; ry { byte [ ] bytes = source . getBytes ( name ) ; 
public void estDecodeArrayOddCharacters ( ) { ry { new Hex ( ) . decode ( new byte [ ] { 65 } ) ; 
public void estDecodeClassCastException ( ) { ry { new Hex ( ) . decode ( new int [ ] { 65 } ) ; 
public void estDecodeHexOddCharacters1 ( ) { checkDecodeHexOddCharacters ( new char [ ] { 'A' } ) ; } 
public void estDecodeHexOddCharacters3 ( ) { checkDecodeHexOddCharacters ( new char [ ] { 'A' , 'B' , 'C' } ) ; } 
public void estDecodeHexOddCharacters5 ( ) { checkDecodeHexOddCharacters ( new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' } ) ; } 
public void estDencodeEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( " " ) ) ) ; } 
public void estEncodeClassCastException ( ) { ry { new Hex ( ) . encode ( new int [ ] { 65 } ) ; 
public void estEncodeEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( " " ) ) ) ; } 
public void estEncodeZeroes ( ) { char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estHelloWorldLowerCaseHex ( ) { byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estHelloWorldUpperCaseHex ( ) { byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estRequiredCharset ( ) hrows UnsupportedEncodingException , DecoderException { estCustomCharset ( " UTF-8 " , " estRequiredCharset " ) ; estCustomCharset ( " UTF-16 " , " estRequiredCharset " ) ; estCustomCharset ( " UTF-16BE " , " estRequiredCharset " ) ; estCustomCharset ( " UTF-16LE " , " estRequiredCharset " ) ; estCustomCharset ( " US-ASCII " , " estRequiredCharset " ) ; estCustomCharset ( " ISO8859_1 " , " estRequiredCharset " ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { String charsetName = " ISO-8859-1 " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
private void estGetBytesUnchecked ( String charsetName ) hrows UnsupportedEncodingException { byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUnchecked ( STRING_FIXTURE , charsetName ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { String charsetName = " US-ASCII " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16 " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-8 " ; estGetBytesUnchecked ( charsetName ) ; byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUncheckedBadName ( ) { ry { StringUtils . getBytesUnchecked ( STRING_FIXTURE , " UNKNOWN " ) ; 
private void log ( Throwable ) { if ( LOG ) { . printStackTrace ( System . out ) ; 
private void estCustomCharset ( String name , String parent ) hrows UnsupportedEncodingException , DecoderException { if ( charsetSanityCheck ( name ) = = false ) { return ; } log ( parent + " = " + name ) ; Hex customCodec = new Hex ( name ) ; source data String sourceString = "Hello World"; byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharsetName()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
public void estCustomCharsetBadNameEncodeByteArray ( ) { ry { new Hex ( BAD_ENCODING_NAME ) . encode ( " Hello World " . getBytes ( ) ) ; 
public void estCustomCharsetBadNameEncodeObject ( ) { ry { new Hex ( BAD_ENCODING_NAME ) . encode ( " Hello World " ) ; 
public void estCustomCharsetBadNameDecodeObject ( ) { ry { new Hex ( BAD_ENCODING_NAME ) . decode ( " Hello World " . getBytes ( ) ) ; 
public void estCustomCharsetToString ( ) { assertTrue ( new Hex ( ) . oString ( ) . indexOf ( Hex . DEFAULT_CHARSET_NAME ) > = 0 ) ; } 
public void estEncoder ( ) hrows EncoderException { Encoder enc = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estDecoder ( ) hrows DecoderException { Decoder dec = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estBinaryEncoder ( ) hrows EncoderException { BinaryEncoder enc = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estBinaryDecoder ( ) hrows DecoderException { BinaryDecoder dec = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticEncode ( ) hrows EncoderException { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticDecode ( ) hrows DecoderException { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticEncodeChunked ( ) hrows EncoderException { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticDecodeChunked ( ) hrows DecoderException { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
private static byte [ ] utf8 ( String s ) { We would use commons-codec-1.4.jar own utility method for this, but we need this class to be able to run against commons-codec-1.3.jar, hence the duplication here. try { return s != null ? s.getBytes("UTF-8") : null; 
public static void main ( String [ ] args ) { TestSuite suite = new TestSuite ( Base64Codec13Test . class ) ; TestResult r = new TestResult ( ) ; suite . run ( r ) ; int runCount = r . runCount ( ) ; int failureCount = r . failureCount ( ) ; System . out . println ( ( runCount - failureCount ) + " / " + runCount + " tests succeeded! " ) ; if ( ! r . wasSuccessful ( ) ) { Enumeration en = r . errors ( ) ; 
public void estObjectEncode ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , new String ( b64 . encode ( " Hello World " . getBytes ( " UTF-8 " ) ) ) ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } 
public void estBase64EmptyInputStreamMimeChuckSize ( ) hrows Exception { estBase64EmptyInputStream ( Base64 . MIME_CHUNK_SIZE ) ; } 
public void estBase64EmptyInputStreamPemChuckSize ( ) hrows Exception { estBase64EmptyInputStream ( Base64 . PEM_CHUNK_SIZE ) ; } 
private void estBase64EmptyInputStream ( int chuckSize ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64EmptyOutputStreamMimeChunkSize ( ) hrows Exception { estBase64EmptyOutputStream ( Base64 . MIME_CHUNK_SIZE ) ; } 
public void estBase64EmptyOutputStreamPemChunkSize ( ) hrows Exception { estBase64EmptyOutputStream ( Base64 . PEM_CHUNK_SIZE ) ; } 
private void estBase64EmptyOutputStream ( int chunkSize ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; Base64 b64 = new Base64 ( Base64 . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); bogus characters to decode (to skip actually) byte[] decode = b64.decode("SGVsbG{}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertTrue("decode hello world", decodeString.equals("Hello World")); } 
public void estRfc2045Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 76 , Base64 . MIME_CHUNK_SIZE ) ; } 
public void estRfc1421Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 64 , Base64 . PEM_CHUNK_SIZE ) ; } 
public void estRfc4648Section10Decode ( ) { assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " ) ) ) ; } 
public void estRfc4648Section10DecodeWithCrLf ( ) { assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " + Base64 . CHUNK_SEPARATOR ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " + Base64 . CHUNK_SEPARATOR ) ) ) ; assertEquals("foo", StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9v" + Base64.CHUNK_SEPARATOR))); assertEquals("foob", StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYg==" + Base64.CHUNK_SEPARATOR))); assertEquals("fooba", StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmE=" + Base64.CHUNK_SEPARATOR))); assertEquals("foobar", StringUtils.newStringUsAscii(Base64.decodeBase64("Zm9vYmFy" + Base64.CHUNK_SEPARATOR))); 
public void estRfc4648Section10Encode ( ) { assertEquals ( " " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " " ) ) ) ; assertEquals("Zg==", Base64.encodeBase64String(StringUtils.getBytesUtf8("f"))); 
public void estRfc4648Section10DecodeWithCrLf ( ) { String CRLF = StringUtils . newStringUsAscii ( Base64 . CHUNK_SEPARATOR ) ; assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " + CRLF ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " + CRLF ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " + CRLF ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " + CRLF ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " + CRLF ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " + CRLF ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " + CRLF ) ) ) ; } 
public void estRfc4648Section10DecodeEncode ( ) { estDecodeEncode ( " " ) ; testDecodeEncode("Zg=="); 
private void estDecodeEncode ( String encodedText ) { String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; String encodedText2 = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( decodedText ) ) ; assertEquals ( encodedText , encodedText2 ) ; } 
public void estRfc4648Section10EncodeDecode ( ) { estEncodeDecode ( " " ) ; estEncodeDecode ( " f " ) ; estEncodeDecode ( " fo " ) ; estEncodeDecode ( " foo " ) ; estEncodeDecode ( " foob " ) ; estEncodeDecode ( " fooba " ) ; estEncodeDecode ( " foobar " ) ; } 
private void estEncodeDecode ( String plainText ) { String encodedText = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( plainText ) ) ; String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; assertEquals ( plainText , decodedText ) ; } 
public void estDoubleMetaphone ( ) { assertDoubleMetaphone ( " TSTN " , " esting " ) ; assertDoubleMetaphone ( " 0 " , " The " ) ; assertDoubleMetaphone ( " KK " , " quick " ) ; assertDoubleMetaphone ( " PRN " , " brown " ) ; assertDoubleMetaphone ( " FKS " , " fox " ) ; assertDoubleMetaphone ( " JMPT " , " jumped " ) ; assertDoubleMetaphone ( " AFR " , " over " ) ; assertDoubleMetaphone ( " 0 " , " he " ) ; assertDoubleMetaphone ( " LS " , " lazy " ) ; assertDoubleMetaphone ( " TKS " , " dogs " ) ; assertDoubleMetaphone ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphone ( " STFN " , " Stephan " ) ; assertDoubleMetaphone ( " KSSK " , " Kuczewski " ) ; assertDoubleMetaphone ( " MKLL " , " McClelland " ) ; assertDoubleMetaphone ( " SNHS " , " san jose " ) ; assertDoubleMetaphone ( " SNFP " , " xenophobia " ) ; assertDoubleMetaphoneAlt ( " TSTN " , " esting " ) ; assertDoubleMetaphoneAlt ( " T " , " The " ) ; assertDoubleMetaphoneAlt ( " KK " , " quick " ) ; assertDoubleMetaphoneAlt ( " PRN " , " brown " ) ; assertDoubleMetaphoneAlt ( " FKS " , " fox " ) ; assertDoubleMetaphoneAlt ( " AMPT " , " jumped " ) ; assertDoubleMetaphoneAlt ( " AFR " , " over " ) ; assertDoubleMetaphoneAlt ( " T " , " he " ) ; assertDoubleMetaphoneAlt ( " LS " , " lazy " ) ; assertDoubleMetaphoneAlt ( " TKS " , " dogs " ) ; assertDoubleMetaphoneAlt ( " MKFR " , " MacCafferey " ) ; assertDoubleMetaphoneAlt ( " STFN " , " Stephan " ) ; assertDoubleMetaphoneAlt ( " KXFS " , " Kutchefski " ) ; assertDoubleMetaphoneAlt ( " MKLL " , " McClelland " ) ; assertDoubleMetaphoneAlt ( " SNHS " , " san jose " ) ; assertDoubleMetaphoneAlt ( " SNFP " , " xenophobia " ) ; assertDoubleMetaphoneAlt ( " FKR " , " Fokker " ) ; assertDoubleMetaphoneAlt ( " AK " , " Joqqi " ) ; assertDoubleMetaphoneAlt ( " HF " , " Hovvi " ) ; assertDoubleMetaphoneAlt ( " XRN " , " Czerny " ) ; } 
public void estCodeInteger1 ( ) hrows UnsupportedEncodingException { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( " UTF-8 " ) ) ) ; } 
public void estCodeInteger2 ( ) hrows UnsupportedEncodingException { String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( " UTF-8 " ) ) ) ; } 
public void estCodeInteger3 ( ) hrows UnsupportedEncodingException { String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( " UTF-8 " ) ) ) ; } 
public void estCodeInteger4 ( ) hrows UnsupportedEncodingException { String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( " UTF-8 " ) ) ) ; } 
public void estDecodePadMarkerIndex2 ( ) hrows UnsupportedEncodingException { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( " UTF-8 " ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) hrows UnsupportedEncodingException { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( " UTF-8 " ) ) ) ) ; } 
public void estDecodePadOnly ( ) hrows UnsupportedEncodingException { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) ) ) ; Test truncated padding assertTrue(Base64.decodeBase64("===".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("==".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("=".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("".getBytes("UTF-8")).length == 0); } 
public void estDecodePadOnlyChunked ( ) hrows UnsupportedEncodingException { assertTrue ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) . length = = 0 ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) ) ) ; Test truncated padding assertTrue(Base64.decodeBase64("===".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("==".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("=".getBytes("UTF-8")).length == 0); assertTrue(Base64.decodeBase64("".getBytes("UTF-8")).length == 0); } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( " UTF-8 " ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( " UTF-8 " ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertTrue ( " Dest string doesn't equal the original " , dest . equals ( orig ) ) ; } 
public void estDiscardWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( " UTF-8 " ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( " UTF-8 " ) ; byte [ ] encodedNoWS = Base64 . discardWhitespace ( encodedWithWS ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; byte [ ] decodedNoWS = Base64 . decodeBase64 ( encodedNoWS ) ; String destFromWS = new String ( decodedWithWS ) ; String destFromNoWS = new String ( decodedNoWS ) ; assertTrue ( " Dest string doesn't equal original " , destFromWS . equals ( orig ) ) ; assertTrue ( " Dest string doesn't equal original " , destFromNoWS . equals ( orig ) ) ; } 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( " UTF-8 " ) ) ) ) ; 
public void estKnownDecodings ( ) hrows UnsupportedEncodingException { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( " UTF-8 " ) ) ) ) ; } 
public void estKnownEncodings ( ) hrows UnsupportedEncodingException { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( " UTF-8 " ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( " UTF-8 " ) ) ) ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object o = Base64 . encodeBase64 ( original . getBytes ( " UTF-8 " ) ) ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object origObj = original . getBytes ( " UTF-8 " ) ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertTrue ( " dest string does not equal original " , dest . equals ( original ) ) ; } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException , UnsupportedEncodingException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( " UTF-8 " ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodeByteArray ( ) hrows UnsupportedEncodingException { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); } 
public void estFromAsciiByteArray ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , BinaryCodec . fromAscii ( ( byte [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new byte [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes("UTF-8")); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public void estCustomCharsetBadNameEncodeByteArray ( ) hrows UnsupportedEncodingException { ry { new Hex ( BAD_ENCODING_NAME ) . encode ( " Hello World " . getBytes ( " UTF-8 " ) ) ; 
public void estCustomCharsetBadNameDecodeObject ( ) hrows UnsupportedEncodingException { ry { new Hex ( BAD_ENCODING_NAME ) . decode ( " Hello World " . getBytes ( " UTF-8 " ) ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( " UTF-8 " ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( " UTF-8 " ) ; byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; byte [ ] plainBA = plain . getBytes ( " UTF-8 " ) ; byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( " UTF-8 " ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( " UTF-8 " ) ; byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( " UTF-8 " ) ; byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % 4; x = (x << 6) + result; if (modulus == 0) { buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { 
public void estCodec98NPE ( ) hrows Exception { byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; ByteArrayInputStream data = new ByteArrayInputStream ( codec98 ) ; Base64InputStream stream = new Base64InputStream ( data ) ; This line causes an NPE in commons-codec-1.4.jar: byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]); String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals( "codec-98 NPE Base64InputStream", Base64TestData.CODEC_98_NPE_DECODED, decoded 
public void estCodec98NPE ( ) hrows Exception { byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; byte [ ] codec98_1024 = new byte [ 1024 ] ; System . arraycopy ( codec98 , 0 , codec98_1024 , 0 , codec98 . length ) ; ByteArrayOutputStream data = new ByteArrayOutputStream ( 1024 ) ; Base64OutputStream stream = new Base64OutputStream ( data , false ) ; stream . write ( codec98_1024 , 0 , 1024 ) ; stream . close ( ) ; byte [ ] decodedBytes = data . oByteArray ( ) ; String decoded = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( " codec-98 NPE Base64OutputStream " , Base64TestData . CODEC_98_NPE_DECODED , decoded 
static byte [ ] streamToBytes ( final InputStream in ) hrows IOException { new byte[7] is obviously quite slow, but helps exercise the code. return streamToBytes(in, new byte[7]); } 
static byte [ ] streamToBytes ( final InputStream in , byte [ ] buf ) hrows IOException { ry { int [ ] status = fill ( buf , 0 , in ) ; int size = status [ SIZE_KEY ] ; int lastRead = status [ LAST_READ_KEY ] ; while ( lastRead ! = - 1 ) { buf = resizeArray ( buf ) ; status = fill ( buf , size , in ) ; size = status [ SIZE_KEY ] ; lastRead = status [ LAST_READ_KEY ] ; } if ( buf . length ! = size ) { byte [ ] smallerBuf = new byte [ size ] ; System . arraycopy ( buf , 0 , smallerBuf , 0 , size ) ; buf = smallerBuf ; } } finally { in . close ( ) ; } return buf ; } 
protected static int oDigit ( char ch , int index ) hrows DecoderException { int digit = Character . digit ( ch , 16 ) ; if ( digit = = - 1 ) { hrow new DecoderException ( " Illegal hexadecimal character " + ch + " at index " + index ) ; } return digit ; } 
public char charAt ( int index ) { if ( index < length ) { return data [ index ] ; 
public CharSequence subSequence ( int start , int end ) { final int length = end - start ; char [ ] retData = copyData ( start , length ) ; return new CologneLeftBuffer ( retData ) ; } 
private char [ ] copyData ( int start , final int length ) { char [ ] retData = new char [ length ] ; System . arraycopy ( data , start , retData , 0 , length ) ; return retData ; } 
public void putRight ( char chr ) { data [ length ] = chr ; length + + ; } 
public char dropLast ( ) { length - - ; return data [ length ] ; } 
public String oString ( ) { return new String ( copyData ( 0 , length ) ) ; } 
public char charAt ( int index ) { if ( index < length ) { return data [ data . length - length + index ] ; 
public CharSequence subSequence ( int start , int end ) { final int length = end - start ; char [ ] newData = copyData ( start , length ) ; return new CologneRightBuffer ( newData ) ; } 
private char [ ] copyData ( int start , final int length ) { char [ ] newData = new char [ length ] ; System . arraycopy ( data , data . length - his . length + start , newData , 0 , length ) ; return newData ; } 
public void putLeft ( char chr ) { length + + ; data [ data . length - length ] = chr ; } 
public char dropNext ( ) { char ret = data [ data . length - length ] ; length - - ; return ret ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preProcess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . dropNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNext ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'E' , 'I' , 'A' , 'U' , 'O' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . putLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . putRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
private static boolean arrayContains ( char [ ] arr , char key ) { for ( int i = 0 ; i < arr . length ; i + + ) { if ( arr [ i ] = = key ) { return rue ; } } return false ; } 
private String preProcess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( int replacement = 0 ; replacement < PRE_REPLACEMENTS . length ; replacement + + ) { if ( chrs [ index ] = = PRE_REPLACEMENTS [ replacement ] [ 0 ] ) { chrs [ index ] = PRE_REPLACEMENTS [ replacement ] [ 1 ] ; break ; } } } } ext = new String ( chrs ) ; return ext ; } 
public boolean isCologneEqual ( String ext1 , String ext2 ) { return colognePhonetic ( ext1 ) . equals ( colognePhonetic ( ext2 ) ) ; } 
public void estBorderCases ( ) { ColognePhonetic koellePhon = new ColognePhonetic ( ) ; String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , { " u00F6 " , " 0 " } , { " u00FC " , " 0 " } , { " aa " , " 0 " } , { " ha " , " 0 " } , { " h " , " " } , { " aha " , " 0 " } , { " b " , " 1 " } , { " p " , " 1 " } , { " ph " , " 3 " } , { " f " , " 3 " } , { " v " , " 3 " } , { " w " , " 3 " } , { " g " , " 4 " } , { " k " , " 4 " } , { " q " , " 4 " } , { " x " , " 48 " } , { " ax " , " 048 " } , { " cx " , " 48 " } , { " l " , " 5 " } , { " cl " , " 45 " } , { " acl " , " 085 " } , { " mn " , " 6 " } , { " r " , " 7 " } } ; for ( int i = 0 ; i < data . length ; i + + ) { assertEquals ( " Failed to correctly convert element of index: " + i , 
public void estCodec101 ( ) hrows Exception { byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; Base64InputStream in = new Base64InputStream ( bais ) ; byte [ ] result = new byte [ 8192 ] ; int c = in . read ( result ) ; assertTrue ( " Codec101: First read successful [c= " + c + " ] " , c > 0 ) ; c = in . read ( result ) ; assertTrue ( " Codec101: Second read should report end-of-stream [c= " + c + " ] " , c < 0 ) ; } 
public void estInputStreamReader ( ) hrows Exception { byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; Base64InputStream in = new Base64InputStream ( bais ) ; InputStreamReader isr = new InputStreamReader ( in ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = br . readLine ( ) ; assertNotNull ( " Codec101: InputStreamReader works! " , line ) ; } 
public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } 
public void estRfc4648Section10Encode ( ) { assertEquals ( " " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " " ) ) ) ; assertEquals ( " Zg== " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " f " ) ) ) ; assertEquals ( " Zm8= " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " fo " ) ) ) ; assertEquals ( " Zm9v " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foo " ) ) ) ; assertEquals ( " Zm9vYg== " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foob " ) ) ) ; assertEquals ( " Zm9vYmE= " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " fooba " ) ) ) ; assertEquals ( " Zm9vYmFy " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foobar " ) ) ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { Base64 base64 = new Base64 ( 0 ) ; byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; byte [ ] b2 = new byte [ 0 ] ; byte [ ] b3 = null ; byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertEquals("byteToString null", null, base64.encodeToString(b3)); assertEquals("byteToString static null", null, Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); } 
int readResults ( byte [ ] b , int bPos , int bAvail ) { if ( buffer ! = null ) { int len = Math . min ( avail ( ) , bAvail ) ; System . arraycopy ( buffer , readPos , b , bPos , len ) ; readPos + = len ; if ( readPos > = pos ) { buffer = null ; } return len ; } return eof ? - 1 : 0 ; } 
public byte [ ] decode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , - 1 ) ; Notify decoder of EOF. byte[] result = new byte[pos]; readResults(result, 0, result.length); return result; } 
public byte [ ] encode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , - 1 ) ; Notify encoder of EOF. byte[] buf = new byte[pos - readPos]; readResults(buf, 0, buf.length); return buf; } 
public void estCodec105 ( ) hrows IOException { Base64InputStream in = new Base64InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; for ( int i = 0 ; i < 5 ; i + + ) { in . read ( ) ; 
public int read ( ) hrows IOException { if ( his . countdown - - > 0 ) { return '' ; 
public int read ( byte b [ ] , int pos , int len ) hrows IOException { if ( his . countdown - - > 0 ) { b [ pos ] = '' ; 
public static boolean isStringBase64 ( String base64 ) { return isArrayByteBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } 
public void estIsStringBase64 ( ) { String nullString = null ; String emptyString = " " ; String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; String invalidString = validString + ( ( char ) 0 ) ; append null character try { Base64.isStringBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isStringBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isStringBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isStringBase64(invalidString)); } 
public static boolean isBase64 ( String base64 ) { return isArrayByteBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } 
public void estIsStringBase64 ( ) { String nullString = null ; String emptyString = " " ; String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; String invalidString = validString + ( ( char ) 0 ) ; append null character try { Base64.isBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public static boolean isArrayByteBase64 ( byte [ ] arrayOctet ) { return isBase64 ( arrayOctet ) ; } 
public static boolean isBase64 ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isBase64 ( arrayOctet [ i ] ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
public CharSequence subSequence ( int start , int end ) { final int length = end - start ; char [ ] newData = copyData ( start , length ) ; return createCologneBuffer ( newData ) ; } 
protected char [ ] copyData ( int start , final int length ) { char [ ] retData = new char [ length ] ; System . arraycopy ( data , start , retData , 0 , length ) ; return retData ; } 
protected CologneBuffer createCologneBuffer ( char [ ] data ) { return new CologneLeftBuffer ( data ) ; } 
protected char [ ] copyData ( int start , final int length ) { char [ ] newData = new char [ length ] ; System . arraycopy ( data , data . length - his . length + start , newData , 0 , length ) ; return newData ; } 
protected CologneBuffer createCologneBuffer ( char [ ] data ) { return new CologneRightBuffer ( data ) ; } 
public char dropNext ( ) { char ch = data [ data . length - length ] ; length - - ; return ch ; } 
public void putLeft ( char ch ) { length + + ; data [ data . length - length ] = ch ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preProcess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . dropNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNext ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'E' , 'I' , 'A' , 'U' , 'O' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . putLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . putRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
private static boolean arrayContains ( char [ ] arr , char key ) { for ( int i = 0 ; i < arr . length ; i + + ) { if ( arr [ i ] = = key ) { return rue ; } } return false ; } 
public void addRight ( char chr ) { data [ length ] = chr ; length + + ; } 
public void addLeft ( char ch ) { length + + ; data [ getNextPos ( ) ] = ch ; } 
public char removeNext ( ) { char ch = getNextChar ( ) ; length - - ; return ch ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preProcess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'E' , 'I' , 'A' , 'U' , 'O' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
public static boolean isBase64 ( String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estIsUrlSafe ( ) { Base64 base64Standard = new Base64 ( false ) ; Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isBase64(whiteSpace)=true " , Base64 . isBase64 ( whiteSpace ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isBase64 ( bArray ) ) ; ry { Base64 b64 = new Base64 ( ) ; 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'E' , 'I' , 'A' , 'U' , 'O' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
private String preprocess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( int replacement = 0 ; replacement < PRE_REPLACEMENTS . length ; replacement + + ) { if ( chrs [ index ] = = PRE_REPLACEMENTS [ replacement ] [ 0 ] ) { chrs [ index ] = PRE_REPLACEMENTS [ replacement ] [ 1 ] ; break ; } } } } ext = new String ( chrs ) ; return ext ; } 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; x = (x << BITS_PER_ENCODED_CHAR) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((x >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { 
public static boolean isBase32 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < DECODE_TABLE . length & & DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static boolean isBase32 ( String base32 ) { return isBase32 ( StringUtils . getBytesUtf8 ( base32 ) ) ; } 
public static boolean isBase32 ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isBase32 ( arrayOctet [ i ] ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
private static boolean containsBase32Byte ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( isBase32 ( arrayOctet [ i ] ) ) { return rue ; } } return false ; } 
public static byte [ ] encodeBase32 ( byte [ ] binaryData ) { return encodeBase32 ( binaryData , false ) ; } 
public static String encodeBase32String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase32 ( binaryData , false ) ) ; } 
public static byte [ ] encodeBase32Chunked ( byte [ ] binaryData ) { return encodeBase32 ( binaryData , rue ) ; } 
public static byte [ ] encodeBase32 ( byte [ ] binaryData , boolean isChunked ) { return encodeBase32 ( binaryData , isChunked , Integer . MAX_VALUE ) ; } 
public static byte [ ] encodeBase32 ( byte [ ] binaryData , boolean isChunked , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base32 b64 = isChunked ? new Base32 ( MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) : new Base32 ( 0 , CHUNK_SEPARATOR ) ; return b64 . encode ( binaryData ) ; } 
public static byte [ ] decodeBase32 ( String base32String ) { return new Base32 ( ) . decode ( base32String ) ; } 
public static byte [ ] decodeBase32 ( byte [ ] base32Data ) { return new Base32 ( ) . decode ( base32Data ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base32 encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) pObject ) ; } 
public void estBase32Samples ( ) hrows Exception { for ( int i = 0 ; i < BASE32_TEST_CASES . length ; i + + ) { assertEquals ( BASE32_TEST_CASES [ i ] [ 1 ] , Base32 . encodeBase32String ( BASE32_TEST_CASES [ i ] [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { for ( int i = 0 ; i < BASE32HEX_TEST_CASES . length ; i + + ) { assertEquals(BASE32HEX_TEST_CASES[i][1], Base32.encodeBase32HexString(BASE32HEX_TEST_CASES[i][0].getBytes("UTF-8"))); 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; x = (x << BITS_PER_ENCODED_CHAR) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((x >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { 
public static boolean isBase32 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < BASE32_DECODE_TABLE . length & & BASE32_DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static boolean isBase32Hex ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < BASE32HEX_DECODE_TABLE . length & & BASE32HEX_DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static String encodeBase32HexString ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase32Hex ( binaryData , false ) ) ; } 
public static byte [ ] encodeBase32Hex ( byte [ ] binaryData , boolean isChunked ) { return encodeBase32Hex ( binaryData , isChunked , Integer . MAX_VALUE ) ; } 
public static byte [ ] encodeBase32 ( byte [ ] binaryData , boolean isChunked , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base32 b64 = isChunked ? new Base32 ( MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) : new Base32 ( ) ; return b64 . encode ( binaryData ) ; } 
public static byte [ ] encodeBase32Hex ( byte [ ] binaryData , boolean isChunked , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base32 b64 = isChunked ? new Base32 ( MIME_CHUNK_SIZE , CHUNK_SEPARATOR , rue ) : new Base32 ( rue ) ; return b64 . encode ( binaryData ) ; } 
public static byte [ ] decodeBase32Hex ( String base32HexString ) { return new Base32 ( rue ) . decode ( base32HexString ) ; } 
public static byte [ ] decodeBase32Hex ( byte [ ] base32HexData ) { return new Base32 ( rue ) . decode ( base32HexData ) ; } 
public void estBase32HexSamples ( ) hrows Exception { for ( int i = 0 ; i < BASE32HEX_TEST_CASES . length ; i + + ) { assertEquals ( BASE32HEX_TEST_CASES [ i ] [ 1 ] , Base32 . encodeBase32HexString ( BASE32HEX_TEST_CASES [ i ] [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public boolean isBase32 ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < BASE32_DECODE_TABLE . length & & BASE32_DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public boolean isBase32Hex ( byte octet ) { return octet = = PAD | | ( octet > = 0 & & octet < BASE32HEX_DECODE_TABLE . length & & BASE32HEX_DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public boolean isBase32 ( String base32 ) { return isBase32 ( StringUtils . getBytesUtf8 ( base32 ) ) ; } 
public boolean isBase32 ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isBase32 ( arrayOctet [ i ] ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
private boolean containsBase32Byte ( byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( isBase32 ( arrayOctet [ i ] ) ) { return rue ; } } return false ; } 
void encode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { eof = true; 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); } byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; x = (x << BITS_PER_ENCODED_CHAR) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((x >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS); buffer[pos++] = (byte) (x & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { if (buffer == null || buffer.length - pos < decodeSize) { 
private static long getEncodeLength ( byte [ ] pArray , int chunkSize , byte [ ] chunkSeparator ) { Base32 always encodes to multiples of 8 (BYTES_PER_ENCODED_CHUNK). chunkSize = (chunkSize / BYTES_PER_ENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK; long len = (pArray.length * BYTES_PER_ENCODED_BLOCK) / BYTES_PER_UNENCODED_BLOCK; long mod = len % BYTES_PER_ENCODED_BLOCK; if (mod != 0) { len += BYTES_PER_ENCODED_BLOCK - mod; } if (chunkSize > 0) { boolean lenChunksPerfectly = len % chunkSize == 0; len += (len / chunkSize) * chunkSeparator.length; if (!lenChunksPerfectly) { len += chunkSeparator.length; } } return len; } 
boolean hasData ( ) { package protected for access from I/O streams return this.buffer != null; } 
int avail ( ) { package protected for access from I/O streams return buffer != null ? pos - readPos : 0; } 
protected void resizeBuffer ( ) { if ( buffer = = null ) { buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; 
int readResults ( byte [ ] b , int bPos , int bAvail ) { package protected for access from I/O streams if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; } return len; } return eof ? -1 : 0; } 
protected static boolean isWhiteSpace ( byte byteToCheck ) { switch ( byteToCheck ) { case ' ' : 
abstract void encode ( byte [ ] pArray , int i , int length ) ; package protected for access from I/O streams abstract void decode(byte[] pArray, int i, int length); package protected for access from I/O streams} 
abstract void decode ( byte [ ] pArray , int i , int length ) ; package protected for access from I/O streams} 
private void flush ( boolean propogate ) hrows IOException { int avail = basedCodec . avail ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = basedCodec . readResults ( buf , 0 , avail ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void close ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { basedCodec.encode(singleByte, 0, -1); } else { basedCodec.decode(singleByte, 0, -1); } flush(); out.close(); } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; fail ( " Should have rejected attempt to use 'A' as a line separator " ) ; } catch ( IllegalArgumentException ignored ) { '}); OK assertNotNull(base64); } 
protected abstract StringEncoder createEncoder ( ) ; "); } public void testEncodeNull() throws Exception { StringEncoder encoder = createEncoder(); try { encoder.encode(null); } catch (EncoderException ee) { An exception should be thrown } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = createEncoder(); encoder.encode( new Float( 3.4 ) ); } catch (Exception e) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); } public void testLocaleIndependence() throws Exception { StringEncoder encoder = createEncoder(); String[] data = { "I", "i", }; Locale orig = Locale.getDefault(); Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; try { for (int i = 0; i < data.length; i++) { String ref = null; for (int j = 0; j < locales.length; j++) { Locale.setDefault(locales[j]); if (j <= 0) { ref = encoder.encode(data[i]); } else { String cur = null; try { cur = encoder.encode(data[i]); } catch (Exception e) { fail(Locale.getDefault().toString() + ": " + e.getMessage()); } assertEquals(Locale.getDefault().toString() + ": ", ref, cur); } } } } finally { Locale.setDefault(orig); } }} 
public void estEncodeEmpty ( ) hrows Exception { Encoder encoder = createEncoder ( ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; } 
public void estEncodeNull ( ) hrows Exception { StringEncoder encoder = createEncoder ( ) ; ry { encoder . encode ( null ) ; 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { StringEncoder encoder = createEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( Exception e ) { exceptionThrown = rue ; } assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; 
public void estLocaleIndependence ( ) hrows Exception { StringEncoder encoder = createEncoder ( ) ; String [ ] data = { " I " , " i " , } ; Locale orig = Locale . getDefault ( ) ; Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( int i = 0 ; i < data . length ; i + + ) { 
public void estCodec105 ( ) hrows IOException { Base32InputStream in = new Base32InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; for ( int i = 0 ; i < 5 ; i + + ) { in . read ( ) ; 
public void estBase32EmptyInputStreamMimeChuckSize ( ) hrows Exception { estBase32EmptyInputStream ( Base32 . MIME_CHUNK_SIZE ) ; } 
public void estBase32EmptyInputStreamPemChuckSize ( ) hrows Exception { estBase32EmptyInputStream ( Base32 . PEM_CHUNK_SIZE ) ; } 
private void estBase32EmptyInputStream ( int chuckSize ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(i, false); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(i, false); 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base32InputStream(in, true, chunkSize, seperator); byte[] output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base32InputStream(in); output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in = new ByteArrayInputStream(decoded); in = new Base32InputStream(in, true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new ByteArrayInputStream(encoded); in = new Base32InputStream(in); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base32InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base32InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estBase32EmptyOutputStreamMimeChunkSize ( ) hrows Exception { estBase32EmptyOutputStream ( Base32 . MIME_CHUNK_SIZE ) ; } 
public void estBase32EmptyOutputStreamPemChunkSize ( ) hrows Exception { estBase32EmptyOutputStream ( Base32 . PEM_CHUNK_SIZE ) ; } 
private void estBase32EmptyOutputStream ( int chunkSize ) hrows Exception { byte [ ] emptyEncoded = new byte [ 0 ] ; byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(i, false); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(i, false); 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator); for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (int i = 0; i < encoded.length; i++) { out.write(encoded[i]); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, seperator); } for (int i = 0; i < decoded.length; i++) { out.write(decoded[i]); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estWriteOutOfBounds ( ) hrows Exception { byte [ ] buf = new byte [ 1024 ] ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); 
public void estWriteToNullCoverage ( ) hrows Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( null , 0 , 0 ) ; 
static byte [ ] [ ] randomData ( int size , boolean useHex ) { Random r = new Random ( ) ; byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; byte [ ] encoded = new Base32 ( useHex ) . encode ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
private void flush ( boolean propogate ) hrows IOException { int avail = baseNCodec . avail ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = baseNCodec . readResults ( buf , 0 , avail ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void close ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { baseNCodec.encode(singleByte, 0, -1); } else { baseNCodec.decode(singleByte, 0, -1); } flush(); out.close(); } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + len + " ) than the specified maxium size of " + maxResultSize ) ; } Base64 b64 = isChunked ? new Base64 ( urlSafe ) : new Base64 ( 0 , CHUNK_SEPARATOR , urlSafe ) ; return b64 . encode ( binaryData ) ; } 
public void estCodec112 ( ) { size calculation assumes always chunked byte[] in = new byte[] {0}; byte[] out=Base64.encodeBase64(in); Base64.encodeBase64(in, false, false, out.length); } 
static byte [ ] [ ] randomData ( BaseNCodec codec , int size ) { Random r = new Random ( ) ; byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; byte [ ] encoded = codec . encode ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public boolean isInAlphabet ( byte octet ) { return ( octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ) ; } 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { ensureBufferSize(decodeSize); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_CHAR) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS); buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize); 
private void resizeBuffer ( ) { if ( buffer = = null ) { buffer = new byte [ getDefaultBufferSize ( ) ] ; 
protected void ensureBufferSize ( int size ) { if ( ( buffer = = null ) | | ( buffer . length < pos + size ) ) { resizeBuffer ( ) ; 
int readResults ( byte [ ] b , int bPos , int bAvail ) { package protected for access from I/O streams if (buffer != null) { int len = Math.min(avail(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; so hasData() will return false, and this method can return -1 } return len; } return eof ? -1 : 0; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base-N encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) pObject ) ; } 
public String encodeAsString ( byte [ ] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } 
public boolean isInAlphabet ( byte [ ] arrayOctet , boolean allowWSPad ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isInAlphabet ( arrayOctet [ i ] ) & & ( ! allowWSPad | | ( arrayOctet [ i ] ! = PAD ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) ) { return false ; } } return rue ; } 
public boolean isInAlphabet ( String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , rue ) ; } 
protected boolean containsAlphabetOrPad ( byte [ ] arrayOctet ) { if ( arrayOctet = = null ) { return false ; } for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( PAD = = arrayOctet [ i ] | | isInAlphabet ( arrayOctet [ i ] ) ) { return rue ; } } return false ; } 
public void estBase32Samples ( ) hrows Exception { Base32 codec = new Base32 ( ) ; for ( int i = 0 ; i < BASE32_TEST_CASES . length ; i + + ) { assertEquals ( BASE32_TEST_CASES [ i ] [ 1 ] , codec . encodeAsString ( BASE32_TEST_CASES [ i ] [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { Base32 codec = new Base32 ( rue ) ; for ( int i = 0 ; i < BASE32HEX_TEST_CASES . length ; i + + ) { assertEquals ( BASE32HEX_TEST_CASES [ i ] [ 1 ] , codec . encodeAsString ( BASE32HEX_TEST_CASES [ i ] [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public void estSingleCharEncoding ( ) { for ( int i = 0 ; i < 20 ; i + + ) { Base32 codec = new Base32 ( ) ; 
public void estRandomBytes ( ) { for ( int i = 0 ; i < 20 ; i + + ) { Base32 codec = new Base32 ( ) ; 
public void estRandomBytesChunked ( ) { for ( int i = 0 ; i < 20 ; i + + ) { Base32 codec = new Base32 ( 10 ) ; 
public void estRandomBytesHex ( ) { for ( int i = 0 ; i < 20 ; i + + ) { Base32 codec = new Base32 ( rue ) ; 
protected boolean isInAlphabet ( byte b ) { return b = = 'O' | | b = = 'K' ; allow OK } 
void encode ( byte [ ] pArray , int i , int length ) { } void decode ( byte [ ] pArray , int i , int length ) { } } ; } public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } public void testContainsAlphabetOrPad() { assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( byte [ ] pArray , int i , int length ) { } } ; } public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } public void testContainsAlphabetOrPad() { assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public void estIsWhiteSpace ( ) { assertTrue ( BaseNCodec . isWhiteSpace ( ( byte ) ' ' ) ) ; assertTrue ( BaseNCodec . isWhiteSpace ( ( byte ) '' ) ) ; assertTrue ( BaseNCodec . isWhiteSpace ( ( byte ) '\r' ) ) ; assertTrue ( BaseNCodec . isWhiteSpace ( ( byte ) '' ) ) ; } 
public void estIsInAlphabetByte ( ) { assertFalse ( codec . isInAlphabet ( ( byte ) 0 ) ) ; assertFalse ( codec . isInAlphabet ( ( byte ) 'a' ) ) ; assertTrue ( codec . isInAlphabet ( ( byte ) 'O' ) ) ; assertTrue ( codec . isInAlphabet ( ( byte ) 'K' ) ) ; } 
public void estIsInAlphabetByteArrayBoolean ( ) { assertTrue ( codec . isInAlphabet ( new byte [ ] { } , false ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' } , false ) ) ; assertFalse ( codec . isInAlphabet ( new byte [ ] { 'O' , ' ' } , false ) ) ; assertFalse ( codec . isInAlphabet ( new byte [ ] { ' ' } , false ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' , ' ' } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { ' ' } , rue ) ) ; } 
public void estIsInAlphabetString ( ) { assertTrue ( codec . isInAlphabet ( " OK " ) ) ; assertTrue ( codec . isInAlphabet ( " O=K= r " ) ) ; } 
public void estContainsAlphabetOrPad ( ) { assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertFalse ( codec . containsAlphabetOrPad ( " ok " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( new byte [ ] { codec . PAD } ) ) ; } 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { ensureBufferSize(decodeSize); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS); buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize); 
int available ( ) { package protected for access from I/O streams return buffer != null ? pos - readPos : 0; } 
int readResults ( byte [ ] b , int bPos , int bAvail ) { package protected for access from I/O streams if (buffer != null) { int len = Math.min(available(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; so hasData() will return false, and this method can return -1 } return len; } return eof ? -1 : 0; } 
private void flush ( boolean propogate ) hrows IOException { int avail = baseNCodec . available ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = baseNCodec . readResults ( buf , 0 , avail ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void estBase32Chunked ( ) hrows Exception { Base32 codec = new Base32 ( 20 ) ; for ( int i = 0 ; i < BASE32_TEST_CASES_CHUNKED . length ; i + + ) { assertEquals ( BASE32_TEST_CASES_CHUNKED [ i ] [ 1 ] , codec . encodeAsString ( BASE32_TEST_CASES_CHUNKED [ i ] [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { ensureBufferSize ( decodeSize ) ; byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK; bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (modulus == 0) { buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS); buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { ensureBufferSize(decodeSize); 
public static boolean isBase64 ( byte octet ) { return octet = = PAD_DEFAULT | | ( octet > = 0 & & octet < DECODE_TABLE . length & & DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
protected boolean isInAlphabet ( byte octet ) { return ( octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ) ; } 
private void flush ( boolean propogate ) hrows IOException { int avail = base64 . available ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = base64 . readResults ( buf , 0 , avail ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; '}); OK assertNotNull(base64); } 
void decode ( byte [ ] in , int inPos , int inAvail ) { package protected for access from I/O streams if (eof) { return; } if (inAvail < 0) { eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. eof = true; break; } else { ensureBufferSize(decodeSize); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK; bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; collect decoded bytes if (modulus == 0) { we can output the 5 bytes buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS); buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize); 
void decode ( byte [ ] in , int inPos , int inAvail ) { if ( eof ) { return ; } if ( inAvail < 0 ) { eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { ensureBufferSize ( decodeSize ) ; byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK; bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (modulus == 0) { buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS); buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS); buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (eof && modulus != 0) { ensureBufferSize(decodeSize); 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'E' , 'I' , 'A' , 'U' , 'O' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
private String preprocess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( int replacement = 0 ; replacement < PRE_REPLACEMENTS . length ; replacement + + ) { if ( chrs [ index ] = = PRE_REPLACEMENTS [ replacement ] [ 0 ] ) { chrs [ index ] = PRE_REPLACEMENTS [ replacement ] [ 1 ] ; break ; } } } } return new String ( chrs ) ; } 
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( his . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
private int handleAEIOUY ( DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'A' ) ; } return index + 1 ; } 
public boolean isInAlphabet ( byte octet ) { return octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ; } 
protected boolean isInAlphabet ( byte octet ) { return octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ; } 
void encode ( byte [ ] pArray , int i , int length ) { } void decode ( byte [ ] pArray , int i , int length ) { } } ; } public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( byte [ ] pArray , int i , int length ) { } } ; } public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public void estContainsAlphabetOrPad ( ) { assertFalse ( codec . containsAlphabetOrPad ( null ) ) ; assertFalse ( codec . containsAlphabetOrPad ( new byte [ ] { } ) ) ; assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertFalse ( codec . containsAlphabetOrPad ( " ok " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( new byte [ ] { codec . PAD } ) ) ; } 
public void estBorderCases ( ) { ColognePhonetic koellePhon = new ColognePhonetic ( ) ; String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , { " u00F6 " , " 0 " } , { " u00FC " , " 0 " } , { " aa " , " 0 " } , { " ha " , " 0 " } , { " h " , " " } , { " aha " , " 0 " } , { " b " , " 1 " } , { " p " , " 1 " } , { " ph " , " 3 " } , { " f " , " 3 " } , { " v " , " 3 " } , { " w " , " 3 " } , { " g " , " 4 " } , { " k " , " 4 " } , { " q " , " 4 " } , { " x " , " 48 " } , { " ax " , " 048 " } , { " cx " , " 48 " } , { " l " , " 5 " } , { " cl " , " 45 " } , { " acl " , " 085 " } , { " mn " , " 6 " } , { " r " , " 7 " } } ; for ( int i = 0 ; i < data . length ; i + + ) { assertEquals ( " Failed to correctly convert element of index: " + i , data [ i ] [ 1 ] , koellePhon . colognePhonetic ( data [ i ] [ 0 ] ) ) ; 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'A' , 'E' , 'I' , 'J' , 'O' , 'U' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'L' , 'O' , 'R' , 'U' , 'K' , 'X' , 'Q' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
public void estAabjoe ( ) { assertEquals ( " 01 " , new ColognePhonetic ( ) . encode ( " Aabjoe " ) ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'A' , 'E' , 'I' , 'J' , 'O' , 'U' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'K' , 'L' , 'O' , 'Q' , 'R' , 'U' , 'X' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return left . oString ( ) ; } 
public void checkEncoding ( String expected , String source ) { Assert . assertEquals ( " Source: " + source , expected , his . colognePhonetic . encode ( source ) ) ; } 
public void estEdgeCases ( ) { String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , { " u00F6 " , " 0 " } , { " u00FC " , " 0 " } , { " aa " , " 0 " } , { " ha " , " 0 " } , { " h " , " " } , { " aha " , " 0 " } , { " b " , " 1 " } , { " p " , " 1 " } , { " ph " , " 3 " } , { " f " , " 3 " } , { " v " , " 3 " } , { " w " , " 3 " } , { " g " , " 4 " } , { " k " , " 4 " } , { " q " , " 4 " } , { " x " , " 48 " } , { " ax " , " 048 " } , { " cx " , " 48 " } , { " l " , " 5 " } , { " cl " , " 45 " } , { " acl " , " 085 " } , { " mn " , " 6 " } , { " r " , " 7 " } } ; for ( int i = 0 ; i < data . length ; i + + ) { Assert . assertEquals ( " Failed to correctly convert element of index: " + i , data [ i ] [ 1 ] , 
public void estHyphen ( ) { his . checkEncoding ( " 174845214 " , " bergisch-gladbach " ) ; } 
public void estHyphen ( ) { his . checkEncoding ( " 174845214 " , " bergisch-gladbach " ) ; From the Javadoc example: this.checkEncoding("65752682", "Mller-Ldenscheidt"); } 
private void checkEncodings ( String [ ] [ ] data ) { for ( int i = 0 ; i < data . length ; i + + ) { his . checkEncoding ( data [ i ] [ 1 ] , data [ i ] [ 0 ] ) ; 
private void checkEncodingVariations ( String expected , String data [ ] ) { for ( int i = 0 ; i < data . length ; i + + ) { his . checkEncoding ( expected , data [ i ] ) ; 
public void estEdgeCases ( ) { String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , { " u00F6 " , " 0 " } , { " u00FC " , " 0 " } , { " aa " , " 0 " } , { " ha " , " 0 " } , { " h " , " " } , { " aha " , " 0 " } , { " b " , " 1 " } , { " p " , " 1 " } , { " ph " , " 3 " } , { " f " , " 3 " } , { " v " , " 3 " } , { " w " , " 3 " } , { " g " , " 4 " } , { " k " , " 4 " } , { " q " , " 4 " } , { " x " , " 48 " } , { " ax " , " 048 " } , { " cx " , " 48 " } , { " l " , " 5 " } , { " cl " , " 45 " } , { " acl " , " 085 " } , { " mn " , " 6 " } , { " r " , " 7 " } } ; his . checkEncodings ( data ) ; } 
public void estVariations ( ) { String data [ ] = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneLeftBuffer left = new CologneLeftBuffer ( ext . length ( ) * 2 ) ; CologneRightBuffer right = new CologneRightBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = right . length ( ) ; while ( rightLength > 0 ) { chr = right . removeNext ( ) ; if ( ( rightLength = right . length ( ) ) > 0 ) { nextChar = right . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'A' , 'E' , 'I' , 'J' , 'O' , 'U' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; right . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'K' , 'L' , 'O' , 'Q' , 'R' , 'U' , 'X' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { left . addRight ( code ) ; lastCode = code ; } lastChar = chr ; } return left . oString ( ) ; } 
public void estVariationsMeyer ( ) { String data [ ] = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; 
public void estVariationsMella ( ) { String data [ ] = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; his . checkEncodingVariations ( " 65 " , data ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneOutputBuffer output = new CologneOutputBuffer ( ext . length ( ) * 2 ) ; CologneInputBuffer input = new CologneInputBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = input . length ( ) ; while ( rightLength > 0 ) { chr = input . removeNext ( ) ; if ( ( rightLength = input . length ( ) ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'A' , 'E' , 'I' , 'J' , 'O' , 'U' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'K' , 'L' , 'O' , 'Q' , 'R' , 'U' , 'X' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
public boolean isEncodeEqual ( String ext1 , String ext2 ) { return colognePhonetic ( ext1 ) . equals ( colognePhonetic ( ext2 ) ) ; } 
public void estVariationsMeyer ( ) { String data [ ] = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
protected char [ ] copyData ( int start , final int length ) { char [ ] newData = new char [ length ] ; System . arraycopy ( data , start , newData , 0 , length ) ; return newData ; } 
private String preprocess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( int replacement = 0 ; replacement < PREPROCESS_MAP . length ; replacement + + ) { if ( chrs [ index ] = = PREPROCESS_MAP [ replacement ] [ 0 ] ) { chrs [ index ] = PREPROCESS_MAP [ replacement ] [ 1 ] ; break ; } } } } return new String ( chrs ) ; } 
protected abstract StringEncoder createEncoder ( ) ; "); } public void testEncodeNull() throws Exception { StringEncoder encoder = createEncoder(); try { encoder.encode(null); } catch (EncoderException ee) { An exception should be thrown } } public void testEncodeWithInvalidObject() throws Exception { boolean exceptionThrown = false; try { StringEncoder encoder = createEncoder(); encoder.encode( new Float( 3.4 ) ); } catch (Exception e) { exceptionThrown = true; } assertTrue( "An exception was not thrown when we tried to encode " + "a Float object", exceptionThrown ); } public void testLocaleIndependence() throws Exception { StringEncoder encoder = createEncoder(); String[] data = { "I", "i", }; Locale orig = Locale.getDefault(); Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; try { for (int i = 0; i < data.length; i++) { String ref = null; for (int j = 0; j < locales.length; j++) { Locale.setDefault(locales[j]); if (j <= 0) { ref = encoder.encode(data[i]); } else { String cur = null; try { cur = encoder.encode(data[i]); } catch (Exception e) { fail(Locale.getDefault().toString() + ": " + e.getMessage()); } assertEquals(Locale.getDefault().toString() + ": ", ref, cur); } } } } finally { Locale.setDefault(orig); } } protected void checkEncodings(String[][] data) throws EncoderException { for (int i = 0; i < data.length; i++) { this.checkEncoding(data[i][1], data[i][0]); } } protected void checkEncodingVariations(String expected, String data[]) throws EncoderException { for (int i = 0; i < data.length; i++) { this.checkEncoding(expected, data[i]); } } public void checkEncoding(String expected, String source) throws EncoderException { Assert.assertEquals("Source: " + source, expected, this.stringEncoder.encode(source)); }} 
protected void checkEncodings ( String [ ] [ ] data ) hrows EncoderException { for ( int i = 0 ; i < data . length ; i + + ) { his . checkEncoding ( data [ i ] [ 1 ] , data [ i ] [ 0 ] ) ; 
protected void checkEncodingVariations ( String expected , String data [ ] ) hrows EncoderException { for ( int i = 0 ; i < data . length ; i + + ) { his . checkEncoding ( expected , data [ i ] ) ; 
public void checkEncoding ( String expected , String source ) hrows EncoderException { Assert . assertEquals ( " Source: " + source , expected , his . stringEncoder . encode ( source ) ) ; } 
public void estSpecificationExamples ( ) hrows EncoderException { String [ ] [ ] data = { { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } , } ; his . checkEncodings ( data ) ; } 
public void estAabjoe ( ) hrows EncoderException { his . checkEncoding ( " 01 " , " Aabjoe " ) ; } 
public void estAaclan ( ) hrows EncoderException { his . checkEncoding ( " 0856 " , " Aaclan " ) ; } 
public void estEdgeCases ( ) hrows EncoderException { String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , { " u00F6 " , " 0 " } , { " u00FC " , " 0 " } , { " aa " , " 0 " } , { " ha " , " 0 " } , { " h " , " " } , { " aha " , " 0 " } , { " b " , " 1 " } , { " p " , " 1 " } , { " ph " , " 3 " } , { " f " , " 3 " } , { " v " , " 3 " } , { " w " , " 3 " } , { " g " , " 4 " } , { " k " , " 4 " } , { " q " , " 4 " } , { " x " , " 48 " } , { " ax " , " 048 " } , { " cx " , " 48 " } , { " l " , " 5 " } , { " cl " , " 45 " } , { " acl " , " 085 " } , { " mn " , " 6 " } , { " r " , " 7 " } } ; his . checkEncodings ( data ) ; } 
public void estVariationsMella ( ) hrows EncoderException { String data [ ] = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; his . checkEncodingVariations ( " 65 " , data ) ; } 
public void estVariationsMeyer ( ) hrows EncoderException { String data [ ] = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
public void estSpecificationExamples ( ) hrows EncoderException { String [ ] [ ] data = { { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } } ; his . checkEncodings ( data ) ; } 
public void estWikipediaExamples ( ) hrows EncoderException { Is this a bug of a Caverphone 1.0 vs 2.0 issue? String[][] data = {{"Lee", "L11111"}, {"Thompson", "TMPSN1"}}; this.checkEncodings(data); } Caverphone Revisited public void testIsCaverphoneEquals() { Caverphone caverphone = new Caverphone(); assertFalse("Caverphone encodings should not be equal", caverphone.isCaverphoneEqual("Peter", "Stevenson")); assertTrue("Caverphone encodings should be equal", caverphone.isCaverphoneEqual("Peter", "Peady")); }} 
public void checkEncoding ( String expected , String source ) hrows EncoderException { Assert . assertEquals ( " Source: " + source , expected , his . getStringEncoder ( ) . encode ( source ) ) ; } 
public void estEncodeEmpty ( ) hrows Exception { Encoder encoder = his . getStringEncoder ( ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; } 
public void estEncodeNull ( ) hrows Exception { StringEncoder encoder = his . getStringEncoder ( ) ; ry { encoder . encode ( null ) ; 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { StringEncoder encoder = his . getStringEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( Exception e ) { exceptionThrown = rue ; } Assert . assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; } 
public void estLocaleIndependence ( ) hrows Exception { StringEncoder encoder = his . getStringEncoder ( ) ; String [ ] data = { " I " , " i " , } ; Locale orig = Locale . getDefault ( ) ; Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( int i = 0 ; i < data . length ; i + + ) { 
protected StringEncoder createStringEncoder ( ) { return new ColognePhonetic ( ) ; } 
private void checkDoubleMetaphone ( int ypeIndex , boolean alternate ) { for ( int i = 0 ; i < TEST_DATA . length ; i + + ) { String value = TEST_DATA [ i ] [ 0 ] ; 
protected StringEncoder createStringEncoder ( ) { return new DoubleMetaphone ( ) ; } 
public void estDoubleMetaphoneAlternate ( ) { his . checkDoubleMetaphone ( ALTERNATE_INDEX , rue ) ; } 
public void estDoubleMetaphonePrimary ( ) { his . checkDoubleMetaphone ( PRIMARY_INDEX , false ) ; } 
protected StringEncoder createStringEncoder ( ) { return new RefinedSoundex ( ) ; } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getRefinedSoundex().difference(null, null)); assertEquals(0, this.getRefinedSoundex().difference("", "")); assertEquals(0, this.getRefinedSoundex().difference(" ", " ")); Normal cases assertEquals(6, this.getRefinedSoundex().difference("Smith", "Smythe")); assertEquals(3, this.getRefinedSoundex().difference("Ann", "Andrew")); assertEquals(1, this.getRefinedSoundex().difference("Margaret", "Andrew")); assertEquals(1, this.getRefinedSoundex().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(5, this.getRefinedSoundex().difference("Green", "Greene")); assertEquals(1, this.getRefinedSoundex().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, this.getRefinedSoundex().difference("Smith", "Smythe")); assertEquals(8, this.getRefinedSoundex().difference("Smithers", "Smythers")); assertEquals(5, this.getRefinedSoundex().difference("Anothers", "Brothers")); } 
public void estEncode ( ) { assertEquals ( " T6036084 " , his . getRefinedSoundex ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , his . getRefinedSoundex ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , his . getRefinedSoundex ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , his . getRefinedSoundex ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , his . getRefinedSoundex ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , his . getRefinedSoundex ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , his . getRefinedSoundex ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , his . getRefinedSoundex ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , his . getRefinedSoundex ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , his . getRefinedSoundex ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , his . getRefinedSoundex ( ) . encode ( " dogs " ) ) ; Testing CODEC-56 assertEquals("D6043", RefinedSoundex.US_ENGLISH.encode("dogs")); } 
public void estGetMappingCodeNonLetter ( ) { char code = his . getRefinedSoundex ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , code ) ; } 
public void estB650 ( ) hrows EncoderException { his . checkEncodingVariations ( " B650 " , ( new String [ ] { " BARHAM " , 
public void estBadCharacters ( ) { Assert . assertEquals ( " H452 " , his . getSoundexEncoder ( ) . encode ( " HOL>MES " ) ) ; 
public void estDifference ( ) hrows EncoderException { Edge cases Assert.assertEquals(0, this.getSoundexEncoder().difference(null, null)); Assert.assertEquals(0, this.getSoundexEncoder().difference("", "")); Assert.assertEquals(0, this.getSoundexEncoder().difference(" ", " ")); Normal cases Assert.assertEquals(4, this.getSoundexEncoder().difference("Smith", "Smythe")); Assert.assertEquals(2, this.getSoundexEncoder().difference("Ann", "Andrew")); Assert.assertEquals(1, this.getSoundexEncoder().difference("Margaret", "Andrew")); Assert.assertEquals(0, this.getSoundexEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp Assert.assertEquals(4, this.getSoundexEncoder().difference("Green", "Greene")); Assert.assertEquals(0, this.getSoundexEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp Assert.assertEquals(4, this.getSoundexEncoder().difference("Smith", "Smythe")); Assert.assertEquals(4, this.getSoundexEncoder().difference("Smithers", "Smythers")); Assert.assertEquals(2, this.getSoundexEncoder().difference("Anothers", "Brothers")); } 
public void estEncodeBasic ( ) { Assert . assertEquals ( " T235 " , his . getSoundexEncoder ( ) . encode ( " esting " ) ) ; Assert . assertEquals ( " T000 " , his . getSoundexEncoder ( ) . encode ( " The " ) ) ; Assert . assertEquals ( " Q200 " , his . getSoundexEncoder ( ) . encode ( " quick " ) ) ; Assert . assertEquals ( " B650 " , his . getSoundexEncoder ( ) . encode ( " brown " ) ) ; Assert . assertEquals ( " F200 " , his . getSoundexEncoder ( ) . encode ( " fox " ) ) ; Assert . assertEquals ( " J513 " , his . getSoundexEncoder ( ) . encode ( " jumped " ) ) ; Assert . assertEquals ( " O160 " , his . getSoundexEncoder ( ) . encode ( " over " ) ) ; Assert . assertEquals ( " T000 " , his . getSoundexEncoder ( ) . encode ( " he " ) ) ; Assert . assertEquals ( " L200 " , his . getSoundexEncoder ( ) . encode ( " lazy " ) ) ; Assert . assertEquals ( " D200 " , his . getSoundexEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncodeBatch2 ( ) { Assert . assertEquals ( " A462 " , his . getSoundexEncoder ( ) . encode ( " Allricht " ) ) ; Assert . assertEquals ( " E166 " , his . getSoundexEncoder ( ) . encode ( " Eberhard " ) ) ; Assert . assertEquals ( " E521 " , his . getSoundexEncoder ( ) . encode ( " Engebrethson " ) ) ; Assert . assertEquals ( " H512 " , his . getSoundexEncoder ( ) . encode ( " Heimbach " ) ) ; Assert . assertEquals ( " H524 " , his . getSoundexEncoder ( ) . encode ( " Hanselmann " ) ) ; Assert . assertEquals ( " H431 " , his . getSoundexEncoder ( ) . encode ( " Hildebrand " ) ) ; Assert . assertEquals ( " K152 " , his . getSoundexEncoder ( ) . encode ( " Kavanagh " ) ) ; Assert . assertEquals ( " L530 " , his . getSoundexEncoder ( ) . encode ( " Lind " ) ) ; Assert . assertEquals ( " L222 " , his . getSoundexEncoder ( ) . encode ( " Lukaschowsky " ) ) ; Assert . assertEquals ( " M235 " , his . getSoundexEncoder ( ) . encode ( " McDonnell " ) ) ; Assert . assertEquals ( " M200 " , his . getSoundexEncoder ( ) . encode ( " McGee " ) ) ; Assert . assertEquals ( " O155 " , his . getSoundexEncoder ( ) . encode ( " Opnian " ) ) ; Assert . assertEquals ( " O155 " , his . getSoundexEncoder ( ) . encode ( " Oppenheimer " ) ) ; Assert . assertEquals ( " R355 " , his . getSoundexEncoder ( ) . encode ( " Riedemanas " ) ) ; Assert . assertEquals ( " Z300 " , his . getSoundexEncoder ( ) . encode ( " Zita " ) ) ; Assert . assertEquals ( " Z325 " , his . getSoundexEncoder ( ) . encode ( " Zitzmeinn " ) ) ; } 
public void estEncodeBatch3 ( ) { Assert . assertEquals ( " W252 " , his . getSoundexEncoder ( ) . encode ( " Washington " ) ) ; Assert . assertEquals ( " L000 " , his . getSoundexEncoder ( ) . encode ( " Lee " ) ) ; Assert . assertEquals ( " G362 " , his . getSoundexEncoder ( ) . encode ( " Gutierrez " ) ) ; Assert . assertEquals ( " P236 " , his . getSoundexEncoder ( ) . encode ( " Pfister " ) ) ; Assert . assertEquals ( " J250 " , his . getSoundexEncoder ( ) . encode ( " Jackson " ) ) ; Assert . assertEquals ( " T522 " , his . getSoundexEncoder ( ) . encode ( " Tymczak " ) ) ; For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also possible. Assert.assertEquals("V532", this.getSoundexEncoder().encode("VanDeusen")); } 
public void estEncodeBatch4 ( ) { Assert . assertEquals ( " H452 " , his . getSoundexEncoder ( ) . encode ( " HOLMES " ) ) ; Assert . assertEquals ( " A355 " , his . getSoundexEncoder ( ) . encode ( " ADOMOMI " ) ) ; Assert . assertEquals ( " V536 " , his . getSoundexEncoder ( ) . encode ( " VONDERLEHR " ) ) ; Assert . assertEquals ( " B400 " , his . getSoundexEncoder ( ) . encode ( " BALL " ) ) ; Assert . assertEquals ( " S000 " , his . getSoundexEncoder ( ) . encode ( " SHAW " ) ) ; Assert . assertEquals ( " J250 " , his . getSoundexEncoder ( ) . encode ( " JACKSON " ) ) ; Assert . assertEquals ( " S545 " , his . getSoundexEncoder ( ) . encode ( " SCANLON " ) ) ; Assert . assertEquals ( " S532 " , his . getSoundexEncoder ( ) . encode ( " SAINTJOHN " ) ) ; 
public void estEncodeIgnoreApostrophes ( ) hrows EncoderException { his . checkEncodingVariations ( " O165 " , ( new String [ ] { " OBrien " , 
public void estEncodeIgnoreHyphens ( ) hrows EncoderException { his . checkEncodingVariations ( " K525 " , ( new String [ ] { " KINGSMITH " , 
public void estEncodeIgnoreTrimmable ( ) { Assert . assertEquals ( " W252 " , his . getSoundexEncoder ( ) . encode ( " r Washington r " ) ) ; } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. Assert.assertEquals("A261", this.getSoundexEncoder().encode("Ashcraft")); } 
public void estHWRuleEx2 ( ) { Assert . assertEquals ( " B312 " , his . getSoundexEncoder ( ) . encode ( " BOOTHDAVIS " ) ) ; Assert . assertEquals ( " B312 " , his . getSoundexEncoder ( ) . encode ( " BOOTH-DAVIS " ) ) ; } 
public void estHWRuleEx3 ( ) hrows EncoderException { Assert . assertEquals ( " S460 " , his . getSoundexEncoder ( ) . encode ( " Sgler " ) ) ; Assert . assertEquals ( " S460 " , his . getSoundexEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: this.checkEncodingVariations("S460", (new String[]{ "SAILOR", 
public void estMaxLength ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( soundex . getMaxLength ( ) ) ; Assert . assertEquals ( " S460 " , his . getSoundexEncoder ( ) . encode ( " Sgler " ) ) ; } 
public void estMaxLengthLessThan3Fix ( ) hrows Exception { Soundex soundex = new Soundex ( ) ; soundex . setMaxLength ( 2 ) ; Assert . assertEquals ( " S460 " , soundex . encode ( " SCHELLER " ) ) ; } 
public void estMsSqlServer1 ( ) { Assert . assertEquals ( " S530 " , his . getSoundexEncoder ( ) . encode ( " Smith " ) ) ; Assert . assertEquals ( " S530 " , his . getSoundexEncoder ( ) . encode ( " Smythe " ) ) ; } 
public void estMsSqlServer2 ( ) hrows EncoderException { his . checkEncodingVariations ( " E625 " , ( new String [ ] { " Erickson " , " Erickson " , " Erikson " , " Ericson " , " Ericksen " , " Ericsen " } ) ) ; } 
public void estMsSqlServer3 ( ) { Assert . assertEquals ( " A500 " , his . getSoundexEncoder ( ) . encode ( " Ann " ) ) ; Assert . assertEquals ( " A536 " , his . getSoundexEncoder ( ) . encode ( " Andrew " ) ) ; Assert . assertEquals ( " J530 " , his . getSoundexEncoder ( ) . encode ( " Janet " ) ) ; Assert . assertEquals ( " M626 " , his . getSoundexEncoder ( ) . encode ( " Margaret " ) ) ; Assert . assertEquals ( " S315 " , his . getSoundexEncoder ( ) . encode ( " Steven " ) ) ; Assert . assertEquals ( " M240 " , his . getSoundexEncoder ( ) . encode ( " Michael " ) ) ; Assert . assertEquals ( " R163 " , his . getSoundexEncoder ( ) . encode ( " Robert " ) ) ; Assert . assertEquals ( " L600 " , his . getSoundexEncoder ( ) . encode ( " Laura " ) ) ; Assert . assertEquals ( " A500 " , his . getSoundexEncoder ( ) . encode ( " Anne " ) ) ; } 
public void estNewInstance ( ) { Assert . assertEquals ( " W452 " , new Soundex ( ) . soundex ( " Williams " ) ) ; } 
public void estNewInstance2 ( ) { Assert . assertEquals ( " W452 " , new Soundex ( Soundex . US_ENGLISH_MAPPING_STRING . oCharArray ( ) ) . soundex ( " Williams " ) ) ; } 
public void estNewInstance3 ( ) { Assert . assertEquals ( " W452 " , new Soundex ( Soundex . US_ENGLISH_MAPPING_STRING ) . soundex ( " Williams " ) ) ; } 
public void estSoundexUtilsNullBehaviour ( ) { Assert . assertEquals ( null , SoundexUtils . clean ( null ) ) ; Assert . assertEquals ( " " , SoundexUtils . clean ( " " ) ) ; Assert . assertEquals ( 0 , SoundexUtils . differenceEncoded ( null , " " ) ) ; Assert . assertEquals ( 0 , SoundexUtils . differenceEncoded ( " " , null ) ) ; } 
public void estUsEnglishStatic ( ) { Assert . assertEquals ( " W452 " , Soundex . US_ENGLISH . soundex ( " Williams " ) ) ; } 
public void estUsMappingEWithAcute ( ) { Assert . assertEquals ( " E000 " , his . getSoundexEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( ' ' ) ) { ry { 
public void estUsMappingOWithDiaeresis ( ) { Assert . assertEquals ( " O000 " , his . getSoundexEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( ' ' ) ) { ry { 
public void estDavidHoodRevisitedCommonCodeAT11111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " AT11111111 " , new String [ ] { " add " , 
public void estDavidHoodRevisitedExamples ( ) hrows EncoderException { String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } } ; his . checkEncodings ( data ) ; } 
public void estDavidHoodRevisitedRandomNameKLN1111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " KLN1111111 " , new String [ ] { " Cailean " , 
public void estDavidHoodRevisitedRandomNameTTA1111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " TTA1111111 " , new String [ ] { " Darda " , 
public void estDavidHoodRevisitedRandomNameTN11111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " TN11111111 " , new String [ ] { " Dan " , 
public void estDavidHoodRevisitedRandomWords ( ) hrows EncoderException { his . checkEncodingVariations ( " RTA1111111 " , new String [ ] { " rather " , " ready " , " writer " } ) ; his . checkEncoding ( " SSA1111111 " , " social " ) ; his . checkEncodingVariations ( " APA1111111 " , new String [ ] { " able " , " appear " } ) ; } 
public void estIsCaverphoneEquals ( ) { Caverphone caverphone = new Caverphone ( ) ; Assert . assertFalse ( " Caverphone encodings should not be equal " , caverphone . isCaverphoneEqual ( " Peter " , " Stevenson " ) ) ; Assert . assertTrue ( " Caverphone encodings should be equal " , caverphone . isCaverphoneEqual ( " Peter " , " Peady " ) ) ; } 
public void estWikipediaExamples ( ) hrows EncoderException { Is this a bug of a Caverphone 1.0 vs 2.0 issue? String[][] data = {{"Lee", "L11111"}, {"Thompson", "TMPSN1"}}; this.checkEncodings(data); }} 
public void estWikipediaExamples ( ) hrows EncoderException { Is this a bug or a Caverphone 1.0 vs 2.0 issue? String[][] data = {{"Lee", "L11111"}, {"Thompson", "TMPSN1"}}; this.checkEncodings(data); }} 
public String caverphone ( String xt ) { NOTE: Version 1.0 of Caverphone is easily derivable from this code by commenting out the 2.0 lines and adding in the 1.0 lines if( txt == null || txt.length() == 0 ) { return "1111111111"; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only - note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + "111111" + "1111"; 1.0 only has 6 1s 7. take the first six characters as the code return txt.substring(0, 10); 1.0 truncates to 6 } 
public void estEndMb ( ) hrows EncoderException { String [ ] [ ] data = { { " mb " , " M111111111 " } , { " mbmb " , " MPM1111111 " } } ; his . checkEncodings ( data ) ; } 
public void estCaverphoneRevisitedCommonCodeAT11111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " AT11111111 " , new String [ ] { " add " , 
public void estCaverphoneRevisitedExamples ( ) hrows EncoderException { String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } } ; his . checkEncodings ( data ) ; } 
public void estCaverphoneRevisitedRandomNameKLN1111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " KLN1111111 " , new String [ ] { " Cailean " , 
public void estCaverphoneRevisitedRandomNameTN11111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " TN11111111 " , new String [ ] { " Dan " , 
public void estCaverphoneRevisitedRandomNameTTA1111111 ( ) hrows EncoderException { his . checkEncodingVariations ( " TTA1111111 " , new String [ ] { " Darda " , 
public void estCaverphoneRevisitedRandomWords ( ) hrows EncoderException { his . checkEncodingVariations ( " RTA1111111 " , new String [ ] { " rather " , " ready " , " writer " } ) ; his . checkEncoding ( " SSA1111111 " , " social " ) ; his . checkEncodingVariations ( " APA1111111 " , new String [ ] { " able " , " appear " } ) ; } 
public Object encode ( Object source ) hrows EncoderException { if ( ! ( source instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return his . encode ( ( String ) source ) ; } 
public boolean isEncodeEqual ( String str1 , String str2 ) hrows EncoderException { return his . encode ( str1 ) . equals ( his . encode ( str2 ) ) ; } 
public String caverphone ( String source ) { return his . encoder . encode ( source ) ; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return his . caverphone ( ( String ) pObject ) ; } 
public boolean isCaverphoneEqual ( String str1 , String str2 ) { return his . caverphone ( str1 ) . equals ( his . caverphone ( str2 ) ) ; } 
public String encode ( String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public String encode ( String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only - note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("l", "2"); 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
public void estCaverphoneRevisitedCommonCodeAT1111 ( ) hrows EncoderException { his . checkEncodingVariations ( " AT1111 " , new String [ ] { " add " , 
public void estEndMb ( ) hrows EncoderException { String [ ] [ ] data = { { " mb " , " M11111 " } , { " mbmb " , " MPM111 " } } ; his . checkEncodings ( data ) ; } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { Caverphone1 caverphone = new Caverphone1 ( ) ; Assert . assertFalse ( " Caverphone encodings should not be equal " , caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) ) ; Assert . assertTrue ( " Caverphone encodings should be equal " , caverphone . isEncodeEqual ( " Peter " , " Peady " ) ) ; } 
public void estSpecificationV1Examples ( ) hrows EncoderException { String [ ] [ ] data = { { " David " , " TFT111 " } , { " Whittle " , " WTL111 " } } ; his . checkEncodings ( data ) ; } 
public void estWikipediaExamples ( ) hrows EncoderException { String [ ] [ ] data = { { " Lee " , " L11111 " } , { " Thompson " , " TMPSN1 " } } ; his . checkEncodings ( data ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneOutputBuffer output = new CologneOutputBuffer ( ext . length ( ) * 2 ) ; CologneInputBuffer input = new CologneInputBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = input . length ( ) ; while ( rightLength > 0 ) { chr = input . removeNext ( ) ; if ( ( rightLength = input . length ( ) ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( new char [ ] { 'A' , 'E' , 'I' , 'J' , 'O' , 'U' , 'Y' } , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( new char [ ] { 'S' , 'C' , 'Z' } , nextChar ) ) { code = '2' ; } else if ( arrayContains ( new char [ ] { 'W' , 'F' , 'P' , 'V' } , chr ) ) { code = '3' ; } else if ( arrayContains ( new char [ ] { 'G' , 'K' , 'Q' } , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( new char [ ] { 'C' , 'K' , 'Q' } , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( new char [ ] { 'A' , 'H' , 'K' , 'L' , 'O' , 'Q' , 'R' , 'U' , 'X' } , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( new char [ ] { 'S' , 'Z' } , lastChar ) | | ! arrayContains ( new char [ ] { 'A' , 'H' , 'O' , 'U' , 'K' , 'Q' , 'X' } , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( new char [ ] { 'T' , 'D' , 'X' } , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
public int compare ( Object o1 , Object o2 ) { int compareCode = 0 ; ry { Comparable s1 = ( Comparable ) his . stringEncoder . encode ( o1 ) ; Comparable s2 = ( Comparable ) his . stringEncoder . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( EncoderException ee ) { compareCode = 0 ; } return compareCode ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; @Test public void estEncodeEmpty ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } @Test public void estEncodeNull ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; } catch ( EncoderException ee ) { An exception should be thrown } }} 
public void estEncodeEmpty ( ) hrows Exception { BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { StringEncoder encoder = his . getStringEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( Exception e ) { exceptionThrown = rue ; } Assert . assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; } 
void encode ( byte [ ] pArray , int i , int length ) { } void decode ( byte [ ] pArray , int i , int length ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( byte [ ] pArray , int i , int length ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void encode ( byte [ ] pArray , int i , int length ) { } @Override void decode ( byte [ ] pArray , int i , int length ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; List < String > estList = Arrays . asList ( estArray ) ; String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; Collections . sort ( estList , sCompare ) ; String [ ] resultArray = ( String [ ] ) estList . oArray ( new String [ 0 ] ) ; for ( int i = 0 ; i < resultArray . length ; i + + ) { assertEquals ( " Result Array not Equal to Control Array at index: " + i , controlArray [ i ] , resultArray [ i ] ) ; 
public void estCustomCharset ( ) hrows UnsupportedEncodingException , DecoderException { for ( String name : Charset . availableCharsets ( ) . keySet ( ) ) { estCustomCharset ( name , " estCustomCharset " ) ; 
public void estSoftLineBreakDecode ( ) hrows Exception { String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; assertEquals ( expected , new QuotedPrintableCodec ( ) . decode ( qpdata ) ) ; } 
public void estSoftLineBreakEncode ( ) hrows Exception { String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; assertEquals ( qpdata , new QuotedPrintableCodec ( ) . encode ( expected ) ) ; } 
public void estAychlmajrForCodec122 ( ) hrows EncoderException { his . checkEncoding ( " 04567 " , " Aychlmajr " ) ; } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { Caverphone2 caverphone = new Caverphone2 ( ) ; Assert . assertFalse ( " Caverphone encodings should not be equal " , caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) ) ; Assert . assertTrue ( " Caverphone encodings should be equal " , caverphone . isEncodeEqual ( " Peter " , " Peady " ) ) ; } 
protected boolean containsAlphabetOrPad ( byte [ ] arrayOctet ) { if ( arrayOctet = = null ) { return false ; } for ( byte element : arrayOctet ) { if ( PAD = = element | | isInAlphabet ( element ) ) { return rue ; } } return false ; } 
private static boolean arrayContains ( char [ ] arr , char key ) { for ( char element : arr ) { if ( element = = key ) { return rue ; } } return false ; } 
private String preprocess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( char [ ] element : PREPROCESS_MAP ) { if ( chrs [ index ] = = element [ 0 ] ) { chrs [ index ] = element [ 1 ] ; break ; } } } } return new String ( chrs ) ; } 
private boolean isSilentStart ( String value ) { boolean result = false ; for ( String element : SILENT_START ) { if ( value . startsWith ( element ) ) { result = rue ; break ; } } return result ; } 
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { String arget = value . substring ( start , start + length ) ; for ( String element : criteria ) { if ( arget . equals ( element ) ) { result = rue ; break ; } } } return result ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( byte b : bytes ) { if ( b = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { byte [ ] mp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { byte b = bytes [ i ] ; if ( b ! = UNDERSCORE ) { mp [ i ] = b ; } else { mp [ i ] = BLANK ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( mp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encodeQuotedPrintable ( b , buffer ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
protected void checkEncodings ( String [ ] [ ] data ) hrows EncoderException { for ( String [ ] element : data ) { his . checkEncoding ( element [ 1 ] , element [ 0 ] ) ; 
protected void checkEncodingVariations ( String expected , String data [ ] ) hrows EncoderException { for ( String element : data ) { his . checkEncoding ( expected , element ) ; 
public void estLocaleIndependence ( ) hrows Exception { StringEncoder encoder = his . getStringEncoder ( ) ; String [ ] data = { " I " , " i " , } ; Locale orig = Locale . getDefault ( ) ; Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( String element : data ) { 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator); for (byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, seperator); } for (byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estBase32Samples ( ) hrows Exception { Base32 codec = new Base32 ( ) ; for ( String [ ] element : BASE32_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { Base32 codec = new Base32 ( rue ) ; for ( String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
public void estBase32Chunked ( ) hrows Exception { Base32 codec = new Base32 ( 20 ) ; for ( String [ ] element : BASE32_TEST_CASES_CHUNKED ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( " UTF-8 " ) ) ) ; 
static boolean bytesContain ( byte [ ] bytes , byte c ) { for ( byte b : bytes ) { if ( b = = c ) { return rue ; } } return false ; } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void doubleMetaphoneEqualTest ( String [ ] [ ] pairs , boolean useAlternate ) { his . validateFixture ( pairs ) ; for ( String [ ] pair : pairs ) { String name0 = pair [ 0 ] ; 
public void assertIsMetaphoneEqual ( String source , String [ ] matches ) { match source to all matches for (String matche : matches) { assertTrue("Source: " + source + ", should have same Metaphone as: " + matche, this.getMetaphone().isMetaphoneEqual(source, matche)); } match to each other for (String matche : matches) { for (String matche2 : matches) { 
public void assertMetaphoneEqual ( String [ ] [ ] pairs ) { his . validateFixture ( pairs ) ; for ( String [ ] pair : pairs ) { String name0 = pair [ 0 ] ; 
private String constructString ( int [ ] unicodeChars ) { StringBuffer buffer = new StringBuffer ( ) ; if ( unicodeChars ! = null ) { for ( int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
private String constructString ( int [ ] unicodeChars ) { StringBuffer buffer = new StringBuffer ( ) ; if ( unicodeChars ! = null ) { for ( int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; List < String > estList = Arrays . asList ( estArray ) ; String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; Collections . sort ( estList , sCompare ) ; String [ ] resultArray = estList . oArray ( new String [ 0 ] ) ; for ( int i = 0 ; i < resultArray . length ; i + + ) { assertEquals ( " Result Array not Equal to Control Array at index: " + i , controlArray [ i ] , resultArray [ i ] ) ; 
public Object encode ( Object source ) hrows EncoderException { if ( ! ( source instanceof String ) ) { hrow new EncoderException ( " BeiderMorseEncoder encode parameter is not of type String " ) ; } return encode ( ( String ) source ) ; } 
public String encode ( String source ) hrows EncoderException { if ( source = = null ) { return null ; } return his . engine . encode ( source ) ; } 
public boolean matches ( String xt ) { return his . pattern . matcher ( xt ) . find ( ) ; } 
public static Lang instance ( NameType nameType ) { return Langs . get ( nameType ) ; } 
public static Lang loadFromResource ( String languageRulesResourceName , Languages languages ) { List < LangRule > rules = new ArrayList < LangRule > ( ) ; InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; } else { discard doc comment line } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { System.err.println("index of comment: " + cmtI); line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) continue; empty lines can be safely skipped split it up String[] parts = line.split("\\s+"); System.err.println("part count: " + parts.length); if (parts.length != 3) { fixme: we really need to log this somewhere System.err.println("Warning: malformed line '" + rawLine + "'"); continue; } Pattern pattern = Pattern.compile(parts[0]); String[] langs = parts[1].split("\\+"); boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
public String guessLanguage ( String ext ) { Set < String > ls = guessLanguages ( ext ) ; if ( ls . size ( ) = = 1 ) { return ls . iterator ( ) . next ( ) ; 
public Set < String > guessLanguages ( String ext ) { ext = ext . oLowerCase ( ) ; todo: locale? System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } return langs; } 
public static Languages instance ( NameType nameType ) { return LANGUAGES . get ( nameType ) ; } 
public static Languages instance ( String languagesResourceName ) { read languages list Set<String> ls = new HashSet<String>(); InputStream langIS = Languages.class.getClassLoader().getResourceAsStream(languagesResourceName); if (langIS == null) { throw new IllegalArgumentException("Unable to resolve required resource: " + languagesResourceName); } Scanner lsScanner = new Scanner(langIS, ResourceConstants.ENCODING); boolean inExtendedComment = false; while (lsScanner.hasNextLine()) { String line = lsScanner.nextLine().trim(); if (inExtendedComment) { if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else if (line.length() > 0) { ls.add(line); } else { skip blank lines } } } return new Languages(Collections.unmodifiableSet(ls)); } 
private static String langResourceName ( NameType nameType ) { return String . format ( " org/apache/commons/codec/language/bm/%s_languages.txt " , nameType . getName ( ) ) ; } 
public String encode ( String input ) { Set < String > languageArg = his . lang . guessLanguages ( input ) ; return phoneticUtf8 ( input , languageArg ) ; } 
public String phoneticUtf8 ( String input , final Set < String > languageArg ) { List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageArg ) ; List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageArg ) ; tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : namePfxs.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(namePfxs.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(namePfxs.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } String phonetic = ""; loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, languageArg, input, phonetic, i).invoke(); i = rulesApplication.getI(); phonetic = rulesApplication.getPhonetic(); } phonetic = applyFinalRules(phonetic, finalRules1, languageArg, false); phonetic = applyFinalRules(phonetic, finalRules2, languageArg, true); return phonetic; } 
private String removeDuplicateAlternates ( final String phonetic ) { List < String > altArray = splitOnPipe ( phonetic ) ; String result = " | " ; for ( String alt : altArray ) { if ( ! result . contains ( " | " + alt + " | " ) ) { result + = ( alt + " | " ) ; } } result = result . substring ( 1 , result . length ( ) - 1 ) ; return result ; } 
private String normalizeLanguageAttributes ( String ext , final boolean strip ) { this is applied to a single alternative at a time -- not to a parenthisized list it removes all embedded bracketed attributes, logically-ands them together, and places them at the end. however if strip is true, this can indeed remove embedded bracketed attributes from a parenthesized list Set<String> langs = new HashSet<String>(); int bracketStart; while ((bracketStart = text.indexOf('[')) != -1) { int bracketEnd = text.indexOf(']', bracketStart); if (bracketEnd == -1) { throw new IllegalArgumentException("no closing square bracket in: " + text); } String body = text.substring(bracketStart + 1, bracketEnd); langs.addAll(Arrays.asList(body.split("[+]"))); text = text.substring(0, bracketStart) + text.substring(bracketEnd + 1); } if (langs.isEmpty() || strip) { return text; 
private String applyFinalRules ( String phonetic , List < Rule > finalRules , Set < String > languageArg , boolean strip ) { if ( finalRules = = null ) { hrow new NullPointerException ( " finalRules can not be null " ) ; } if ( finalRules . isEmpty ( ) ) { return phonetic ; } phonetic = expand ( phonetic ) ; must protect | in [] as split takes a regex, not a string literal List<String> phoneticArray = splitOnPipe(phonetic); for (int k = 0; k < phoneticArray.size(); k++) { log("k: " + k); String aPhonetic = phoneticArray.get(k); String phonetic2 = ""; String phoneticx = normalizeLanguageAttributes(aPhonetic, true); for (int i = 0; i < aPhonetic.length();) { we will handle the increment manually if (aPhonetic.substring(i, i + 1).equals("[")) { int attribStart = i; i++; while (true) { i++; String nextChar = aPhonetic.substring(i, i + 1); if (nextChar.equals("]")) { phonetic2 += aPhonetic.substring(attribStart, i); break; } } continue; } RulesApplication rulesApplication = new RulesApplication(finalRules, languageArg, phoneticx, phonetic2, i).invoke(); boolean found = rulesApplication.isFound(); phonetic2 = rulesApplication.getPhonetic(); if (!found) { phonetic2 += aPhonetic.substring(i, i + 1); } i = rulesApplication.getI(); } phoneticArray.set(k, expand(phonetic2)); } phonetic = join(phoneticArray, "|"); if (strip) { phonetic = normalizeLanguageAttributes(phonetic, true); } if (!phonetic.contains("|")) { phonetic = "(" + removeDuplicateAlternates(phonetic) + ")"; } return phonetic; } 
private String expand ( String phonetic ) { int altStart = phonetic . indexOf ( '(' ) ; if ( altStart = = - 1 ) { return normalizeLanguageAttributes ( phonetic , false ) ; } String prefix = phonetic . substring ( 0 , altStart ) ; altStart + + ; int altEnd = phonetic . indexOf ( ')' ) ; String altString = phonetic . substring ( altStart , altEnd ) ; altEnd + + ; String suffix = phonetic . substring ( altEnd ) ; List < String > altArray = splitOnPipe ( altString ) ; String result = " " ; for ( String alt : altArray ) { String alternate = expand ( prefix + alt + suffix ) ; if ( alternate . length ( ) ! = 0 & & ! alternate . equals ( " [any] " ) ) { if ( result . length ( ) > 0 ) { result + = " | " ; } result + = alternate ; } } return result ; } 
private String applyRuleIfCompatible ( String phonetic , String arget , Set < String > languageArg ) { tests for compatible language rules to do so, apply the rule, expand the results, and detect alternatives with incompatible attributes then drop each alternative that has incompatible attributes and keep those that are compatible if there are no compatible alternatives left, return false otherwise return the compatible alternatives String candidate = phonetic + target; if (!candidate.contains("[")) { return candidate; } candidate = expand(candidate); List<String> candidateArray = splitOnPipe(candidate); candidate = ""; boolean found = false; for (String thisCandidate : candidateArray) { if (!languageArg.contains(Languages.ANY)) { thisCandidate = normalizeLanguageAttributes(thisCandidate + "[" + languageArg + "]", false); } if (!thisCandidate.equals("[0]")) { found = true; if (candidate.length() != 0) { candidate += "|"; } candidate += thisCandidate; } } if (!found) { return null; eugh! } if (candidate.contains("|")) { candidate = "(" + candidate + ")"; } return candidate; } 
private static String join ( Iterable < String > strings , String sep ) { StringBuilder sb = new StringBuilder ( ) ; Iterator < String > si = strings . iterator ( ) ; if ( si . hasNext ( ) ) { sb . append ( si . next ( ) ) ; } while ( si . hasNext ( ) ) { sb . append ( sep ) . append ( si . next ( ) ) ; } return sb . oString ( ) ; } 
private static List < String > splitOnPipe ( String str ) { List < String > res = new ArrayList < String > ( ) ; while ( rue ) { int i = str . indexOf ( '|' ) ; if ( i < 0 ) { res . add ( str ) ; break ; } res . add ( str . substring ( 0 , i ) ) ; str = str . substring ( i + 1 ) ; } return res ; } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 0 ; RULES : for ( Rule rule : his . finalRules ) { String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; log("trying pattern: " + pattern); if (!rule.patternAndContextMatches(this.input, this.i) || !rule.languageMatches(this.languageArg)) { log("no match"); continue RULES; } String candidate = applyRuleIfCompatible(this.phonetic, rule.getPhoneme(), this.languageArg); if (candidate == null || candidate.length() == 0) { log("no candidate"); continue RULES; } this.phonetic = candidate; this.found = true; break RULES; } if (!this.found) { patternLength = 1; } this.i += patternLength; return this; } 
public static List < Rule > instance ( NameType nameType , RuleType rt , Set < String > langs ) { if ( langs . size ( ) = = 1 ) { return instance ( nameType , rt , langs . iterator ( ) . next ( ) ) ; 
public static List < Rule > instance ( NameType nameType , RuleType rt , String lang ) { List < Rule > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules = = null ) { hrow new IllegalArgumentException ( String . format ( " No rules found for %s, %s, %s. " , nameType . getName ( ) , rt . getName ( ) , lang ) ) ; } return rules ; } 
private static Scanner mkScanner ( NameType nameType , RuleType rt , String lang ) { String resName = String . format ( " org/apache/commons/codec/language/bm/%s_%s_%s.txt " , nameType . getName ( ) , rt . getName ( ) , lang ) ; InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static Scanner mkScanner ( String lang ) { String resName = String . format ( " org/apache/commons/codec/language/bm/%s.txt " , lang ) ; InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static List < Rule > parseRules ( Scanner scanner ) { List < Rule > lines = new ArrayList < Rule > ( ) ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) continue; empty lines can be safely skipped if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(mkScanner(incl))); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); String ph = stripQuotes(parts[3]); Rule r = new Rule(pat, lCon, rCon, ph, Collections.<String> emptySet(), ""); guessing last 2 parameters lines.add(r); } } } } } return lines; } 
private static String stripQuotes ( String str ) { if ( str . startsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 1 ) ; } if ( str . endsWith ( DOUBLE_QUOTE ) ) { str = str . substring ( 0 , str . length ( ) - 1 ) ; } return str ; } 
public boolean languageMatches ( Set < String > languageArg ) { if ( ! languageArg . contains ( Languages . ANY ) & & ! his . language . isEmpty ( ) ) { if ( ALL . equals ( his . logical ) & & ! languageArg . containsAll ( his . language ) ) { 
public boolean patternAndContextMatches ( String input , int i ) { if ( i < 0 ) hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } boolean patternMatches = input.substring(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.matcher(input.substring(ipl)).find(); boolean lContextMatches = this.lContext.matcher(input.substring(0, i)).find(); return patternMatches && rContextMatches && lContextMatches; } 
protected StringEncoder createStringEncoder ( ) { return new BeiderMorseEncoder ( ) ; } 
public void invalidLangResourceShouldRaiseException ( ) { Lang . loadFromResource ( " hisIsAMadeUpResourceName " , Languages . instance ( NameType . GENERIC ) ) ; } 
public void invalidLangShouldRaiseException ( ) { Rule . instance ( NameType . GENERIC , RuleType . APPROX , " noSuchLanguage " ) ; } 
public void invalidLanguageResourceShouldRaiseException ( ) { Languages . instance ( " hereIsNoSuchLanguage " ) ; } 
public void negativeIndexForRuleMatchShouldRaiseException ( ) { Rule r = new Rule ( " a " , " " , " " , " " , Collections . < String > emptySet ( ) , " bob " ) ; r . patternAndContextMatches ( " bob " , - 1 ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { " Renault " , " french " , EXACT } , 
public void estLanguageGuessing ( ) { Set < String > guesses = his . lang . guessLanguages ( his . name ) ; String guess = his . lang . guessLanguage ( his . name ) ; assertTrue ( " language predicted for name ' " + his . name + " ' is wrong: " + guesses + " should contain ' " + his . language + " ' " , guesses . contains ( his . language ) ) ; if ( his . exactness . equals ( EXACT ) ) { assertEquals ( " language predicted for name ' " + his . name + " ' is wrong " , his . language , guess ) ; 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " Renault " , " rinolt|rino|rinDlt|rinalt|rinult|rinD|rina|rinu " , NameType . GENERIC , RuleType . APPROX , 
public void estPhonetic ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat ) ; String phoneticActual = engine . encode ( his . name ) ; assertEquals ( " phoneme incorrect " , his . phoneticExpected , phoneticActual ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " matching language sets with ALL " , 
public void rule ( ) { assertEquals ( his . caseName , his . expected , his . rule . languageMatches ( his . langs ) ) ; } 
public String encode ( String input ) { Set < String > languageSet = his . lang . guessLanguages ( input ) ; return phoneticUtf8 ( input , languageSet ) ; } 
public String phoneticUtf8 ( String input , final Set < String > languageSet ) { List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : namePfxs.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(namePfxs.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(namePfxs.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } String phonetic = ""; loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, languageSet, input, phonetic, i).invoke(); i = rulesApplication.getI(); phonetic = rulesApplication.getPhonetic(); } phonetic = applyFinalRules(phonetic, finalRules1, languageSet, false); phonetic = applyFinalRules(phonetic, finalRules2, languageSet, true); return phonetic; } 
public void estInvalidLangIllegalStateException ( ) { Lang . loadFromResource ( " hisIsAMadeUpResourceName " , Languages . instance ( NameType . GENERIC ) ) ; } 
public void estInvalidLangIllegalArgumentException ( ) { Rule . instance ( NameType . GENERIC , RuleType . APPROX , " noSuchLanguage " ) ; } 
public void estInvalidLanguageIllegalArgumentException ( ) { Languages . instance ( " hereIsNoSuchLanguage " ) ; } 
public void estNegativeIndexForRuleMatchIndexOutOfBoundsException ( ) { Rule r = new Rule ( " a " , " " , " " , " " , Collections . < String > emptySet ( ) , " bob " ) ; r . patternAndContextMatches ( " bob " , - 1 ) ; } 
public void estSetConcat ( ) { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setConcat ( false ) ; assertEquals ( " Should be able to set concat to false " , false , bmpm . isConcat ( ) ) ; } 
public void estSetNameTypeAsh ( ) { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . ASHKENAZI ) ; assertEquals ( " Name type should have been set to ash " , NameType . ASHKENAZI , bmpm . getNameType ( ) ) ; } 
public void estSetRuleTypeExact ( ) { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setRuleType ( RuleType . EXACT ) ; assertEquals ( " Rule type should have been set to exact " , RuleType . EXACT , bmpm . getRuleType ( ) ) ; } 
public void estSetRuleTypeToRulesIllegalArgumentException ( ) { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setRuleType ( RuleType . RULES ) ; } 
public void estRuleLanguageMatches ( ) { assertEquals ( his . caseName , his . expected , his . rule . languageMatches ( his . langs ) ) ; } 
public void estEncode ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat ) ; String phoneticActual = engine . encode ( his . name ) ; assertEquals ( " phoneme incorrect " , his . phoneticExpected , phoneticActual ) ; } 
public void encodeGna ( ) hrows EncoderException { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; bmpm . encode ( " gna " ) ; } 
public Set < String > guessLanguages ( String input ) { String ext = input . oLowerCase ( ) ; todo: locale? System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } return langs; } 
public boolean languageMatches ( Set < String > languageArg ) { if ( ! languageArg . contains ( Languages . ANY ) & & ! his . languages . isEmpty ( ) ) { if ( ALL . equals ( his . logical ) & & ! languageArg . containsAll ( his . languages ) ) { 
public void estEncodeGna ( ) hrows EncoderException { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; bmpm . encode ( " gna " ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 20 ; i + + ) { start = System . currentTimeMillis ( ) ; 
private String applyRuleIfCompatible ( String phonetic , String arget , Set < String > languageArg ) { String candidate = phonetic + arget ; if ( ! candidate . contains ( " [ " ) ) { return candidate ; } candidate = expand ( candidate ) ; List < String > candidateArray = splitOnPipe ( candidate ) ; candidate = " " ; boolean found = false ; for ( String hisCandidate : candidateArray ) { if ( ! languageArg . contains ( Languages . ANY ) ) { hisCandidate = normalizeLanguageAttributes ( hisCandidate + " [ " + languageArg + " ] " , false ) ; } if ( ! hisCandidate . equals ( " [0] " ) ) { found = rue ; if ( candidate . length ( ) ! = 0 ) { candidate + = " | " ; } candidate + = hisCandidate ; } } if ( ! found ) { return null ; eugh! } if (candidate.contains("|")) { candidate = "(" + candidate + ")"; } return candidate; } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 20 ; i + + ) { start = System . currentTimeMillis ( ) ; 
private String normalizeLanguageAttributes ( final String input , final boolean strip ) { String ext = input ; Set < String > langs = new HashSet < String > ( ) ; int bracketStart ; while ( ( bracketStart = ext . indexOf ( '[' ) ) ! = - 1 ) { int bracketEnd = ext . indexOf ( ']' , bracketStart ) ; if ( bracketEnd = = - 1 ) { hrow new IllegalArgumentException ( " no closing square bracket in: " + ext ) ; } String body = ext . substring ( bracketStart + 1 , bracketEnd ) ; langs . addAll ( Arrays . asList ( body . split ( " [+] " ) ) ) ; ext = ext . substring ( 0 , bracketStart ) + ext . substring ( bracketEnd + 1 ) ; } if ( langs . isEmpty ( ) | | strip ) { return ext ; 
public void estLongestEnglishSurname ( ) hrows EncoderException { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; bmpm . encode ( " MacGhilleseatheanaich " ) ; } 
public String phoneticUtf8 ( String input , final Set < String > languageSet ) { List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } String phonetic = ""; loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, languageSet, input, phonetic, i).invoke(); i = rulesApplication.getI(); phonetic = rulesApplication.getPhonetic(); } phonetic = applyFinalRules(phonetic, finalRules1, languageSet, false); phonetic = applyFinalRules(phonetic, finalRules2, languageSet, true); return phonetic; } 
public String phoneticUtf8 ( String input , final Set < String > languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } String phonetic = ""; loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, languageSet, input, phonetic, i).invoke(); i = rulesApplication.getI(); phonetic = rulesApplication.getPhonetic(); } phonetic = applyFinalRules(phonetic, finalRules1, languageSet, false); phonetic = applyFinalRules(phonetic, finalRules2, languageSet, true); return phonetic; } 
private String expand ( String phonetic ) { int altStart = phonetic . indexOf ( '(' ) ; if ( altStart = = - 1 ) { return normalizeLanguageAttributes ( phonetic , false ) ; } String prefix = phonetic . substring ( 0 , altStart ) ; altStart + + ; int altEnd = phonetic . indexOf ( ')' ) ; if ( altEnd < altStart ) { hrow new IllegalArgumentException ( " Phonetic string has a close-bracket before the first open-bracket " ) ; } String altString = phonetic . substring ( altStart , altEnd ) ; altEnd + + ; String suffix = phonetic . substring ( altEnd ) ; List < String > altArray = splitOnPipe ( altString ) ; String result = " " ; for ( String alt : altArray ) { String alternate = expand ( prefix + alt + suffix ) ; if ( alternate . length ( ) ! = 0 & & ! alternate . equals ( " [any] " ) ) { if ( result . length ( ) > 0 ) { result + = " | " ; } result + = alternate ; } } return result ; } 
private static String createResourceName ( NameType nameType , RuleType rt , String lang ) { return String . format ( " org/apache/commons/codec/language/bm/%s_%s_%s.txt " , nameType . getName ( ) , rt . getName ( ) , lang ) ; } 
private static Scanner createScanner ( NameType nameType , RuleType rt , String lang ) { String resName = createResourceName ( nameType , rt , lang ) ; InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static Scanner createScanner ( String lang ) { String resName = String . format ( " org/apache/commons/codec/language/bm/%s.txt " , lang ) ; InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static List < Rule > parseRules ( Scanner scanner ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) continue; empty lines can be safely skipped if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl))); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); String ph = stripQuotes(parts[3]); try { validatePhenome(ph); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } Rule r = new Rule(pat, lCon, rCon, ph, Collections.<String> emptySet(), ""); guessing last 2 parameters lines.add(r); } } } } } return lines; } 
private static void validatePhenome ( CharSequence ph ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < ph . length ( ) ; i + + ) { switch ( ph . charAt ( i ) ) { case '(' : stack . push ( '(' ) ; break ; case '[' : stack . push ( '[' ) ; break ; case ')' : { if ( stack . isEmpty ( ) ) hrow new IllegalArgumentException ( " Closing ')' at " + i + " without an opening '(' " + " in " + ph ) ; char c = stack . pop ( ) ; if ( c ! = '(' ) hrow new IllegalArgumentException ( " Closing ')' does not pair with opening ' " + c + " ' at " + i + " in " + ph ) ; break ; } case ']' : { if ( stack . isEmpty ( ) ) hrow new IllegalArgumentException ( " Closing ']' at " + i + " without an opening '[' " + " in " + ph ) ; char c = stack . pop ( ) ; if ( c ! = '[' ) hrow new IllegalArgumentException ( " Closing ']' does not pair with opening ' " + c + " ' at " + i + " in " + ph ) ; break ; } default : break ; } } if ( ! stack . isEmpty ( ) ) hrow new IllegalArgumentException ( " Bracket(s) opened without corresponding closes: " + stack + " in " + ph ) ; 
public String guessLanguage ( String ext ) { Languages . LanguageSet ls = guessLanguages ( ext ) ; if ( ls . isSingleton ( ) ) { return ls . getAny ( ) ; 
public Languages . LanguageSet guessLanguages ( String input ) { String ext = input . oLowerCase ( ) ; todo: locale? System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } return Languages.LanguageSet.from(langs); } 
public static LanguageSet from ( Set < String > langs ) { if ( langs . isEmpty ( ) ) { return NO_LANGUAGES ; 
public LanguageSet restrictTo ( LanguageSet other ) { return other ; } 
public LanguageSet restrictTo ( LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return other ; 
public boolean contains ( String language ) { return his . languages . contains ( language ) ; } 
public boolean isSingleton ( ) { return his . languages . size ( ) = = 1 ; } 
public String encode ( String input ) { Languages . LanguageSet languageSet = his . lang . guessLanguages ( input ) ; return phoneticUtf8 ( input , languageSet ) ; } 
public String phoneticUtf8 ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, languageSet, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1, languageSet, false); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2, languageSet, true); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 0 ; RULES : for ( Rule rule : his . finalRules ) { String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; log("trying pattern: " + pattern); if (!rule.patternAndContextMatches(this.input, this.i)) { log("no match"); continue RULES; } this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme()); this.found = true; break RULES; } if (!this.found) { patternLength = 1; } this.i += patternLength; return this; } 
public static PhonemeBuilder empty ( Languages . LanguageSet languages ) { return new PhonemeBuilder ( Collections . singleton ( new Rule . Phoneme ( " " , languages ) ) ) ; } 
public String makeString ( ) { List < String > sorted = new ArrayList < String > ( ) ; for ( Rule . Phoneme ph : his . phonemes ) { sorted . add ( ph . getPhonemeText ( ) ) ; } Collections . sort ( sorted ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String ph : sorted ) { if ( sb . length ( ) > 0 ) sb . append ( " | " ) ; sb . append ( ph ) ; } return sb . oString ( ) ; } 
public PhonemeBuilder append ( String str ) { Set < Rule . Phoneme > newPhonemes = new HashSet < Rule . Phoneme > ( ) ; for ( Rule . Phoneme ph : his . phonemes ) { newPhonemes . add ( ph . append ( str ) ) ; } return new PhonemeBuilder ( newPhonemes ) ; } 
public static List < Rule > instance ( NameType nameType , RuleType rt , Languages . LanguageSet langs ) { if ( langs . isSingleton ( ) ) { return instance ( nameType , rt , langs . getAny ( ) ) ; 
private static List < Rule > parseRules ( Scanner scanner ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) continue; empty lines can be safely skipped if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl))); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); Rule r = new Rule(pat, lCon, rCon, ph); lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
private static PhonemeExpr parsePhonemeExpr ( String ph ) { if ( ph . startsWith ( " ( " ) ) { we have a bracketed list of options if (!ph.endsWith(")")) { 
private static Phoneme parsePhoneme ( String ph ) { int open = ph . indexOf ( " [ " ) ; if ( open > = 0 ) { if ( ! ph . endsWith ( " ] " ) ) { 
public Phoneme join ( Phoneme right ) { return new Phoneme ( his . phonemeText + right . phonemeText , his . languages . restrictTo ( right . languages ) ) ; } 
public Phoneme append ( String str ) { return new Phoneme ( his . phonemeText + str , his . languages ) ; } 
public void estNegativeIndexForRuleMatchIndexOutOfBoundsException ( ) { Rule r = new Rule ( " a " , " " , " " , new Rule . Phoneme ( " " , Languages . ANY_LANGUAGE ) ) ; r . patternAndContextMatches ( " bob " , - 1 ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 40 ; i + + ) { start = System . currentTimeMillis ( ) ; 
public void estLanguageGuessing ( ) { Languages . LanguageSet guesses = his . lang . guessLanguages ( his . name ) ; assertTrue ( " language predicted for name ' " + his . name + " ' is wrong: " + guesses + " should contain ' " + his . language + " ' " , guesses . contains ( his . language ) ) ; 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " Renault " , " rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult " , NameType . GENERIC , RuleType . APPROX , 
public void estEncode ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat ) ; String phoneticActual = engine . encode ( his . name ) ; System . err . println ( " expecting: " + his . phoneticExpected ) ; System . err . println ( " actual: " + phoneticActual ) ; assertEquals ( " phoneme incorrect " , his . phoneticExpected , phoneticActual ) ; } 
public String phoneticUtf8 ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1, languageSet, false); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2, languageSet, true); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public Languages . LanguageSet guessLanguages ( String input ) { String ext = input . oLowerCase ( ) ; todo: locale? System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } Languages.LanguageSet ls = Languages.LanguageSet.from(langs); if (ls.equals(Languages.NO_LANGUAGES)) { return Languages.ANY_LANGUAGE; 
public String oString ( ) { return " Languages( " + languages . oString ( ) + " ) " ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " Renault " , " rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult " , NameType . GENERIC , RuleType . APPROX , rue } , new Object [ ] { " Renault " , " rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult " , NameType . ASHKENAZI , 
public void estEncode ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat ) ; String phoneticActual = engine . encode ( his . name ) ; System . err . println ( " expecting: " + his . phoneticExpected ) ; System . err . println ( " actual: " + phoneticActual ) ; assertEquals ( " phoneme incorrect " , his . phoneticExpected , phoneticActual ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { 
private void assertNotEmpty ( BeiderMorseEncoder bmpm , final String value ) hrows EncoderException { Assert . assertFalse ( value , bmpm . encode ( value ) . equals ( " " ) ) ; } 
public void estAsciiEncodeNotEmpty1Letter ( ) hrows EncoderException { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; for ( char c = 'a' ; c < = 'z' ; c + + ) { final String value = " " + c ; 
public void estAsciiEncodeNotEmpty2Letters ( ) hrows EncoderException { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; for ( char c1 = 'a' ; c1 < = 'z' ; c1 + + ) { for ( char c2 = 'a' ; c2 < = 'z' ; c2 + + ) { 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; int compare = sCompare . compare ( new Double ( 3.0 ) , Long . valueOf ( 3 ) ) ; assertEquals ( " Trying to compare objects that make no sense to the underlying encoder should return a zero compare code " , 0 , compare ) ; 
public void estCodec105 ( ) hrows IOException { Base32InputStream in = new Base32InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; ry { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estCodec105 ( ) hrows IOException { Base64InputStream in = new Base64InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; ry { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; ry { b64 . decode ( Integer . valueOf ( 5 ) ) ; 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) continue; empty lines can be safely skipped if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int line = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(line); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Rule " ) ; sb . append ( " {line= " ) . append ( line ) ; sb . append ( " , loc=' " ) . append ( loc ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . oString ( ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . GENERIC ) ; bmpm . setRuleType ( RuleType . APPROX ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 30 ; i + + ) { start = System . currentTimeMillis ( ) ; 
private BeiderMorseEncoder createGenericApproxEncoder ( ) { BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . APPROX ) ; return encoder ; } 
public void estAllChars ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = Character . MIN_VALUE ; c < Character . MAX_VALUE ; c + + ) { bmpm . encode ( " " + c ) ; 
public void estAsciiEncodeNotEmpty1Letter ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = 'a' ; c < = 'z' ; c + + ) { final String value = " " + c ; 
public void estAsciiEncodeNotEmpty2Letters ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c1 = 'a' ; c1 < = 'z' ; c1 + + ) { for ( char c2 = 'a' ; c2 < = 'z' ; c2 + + ) { 
public void estEncodeGna ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; bmpm . encode ( " gna " ) ; } 
public void estLongestEnglishSurname ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; bmpm . encode ( " MacGhilleseatheanaich " ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 30 ; i + + ) { start = System . currentTimeMillis ( ) ; 
public String phoneticUtf8 ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return encode(remainder) + "-" + encode(combined); } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return encode(remainder) + "-" + encode(combined); } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public PhonemeBuilder append ( CharSequence str ) { Set < Rule . Phoneme > newPhonemes = new HashSet < Rule . Phoneme > ( ) ; for ( Rule . Phoneme ph : his . phonemes ) { newPhonemes . add ( ph . append ( str ) ) ; } return new PhonemeBuilder ( newPhonemes ) ; } 
public String makeString ( ) { StringBuilder sb = new StringBuilder ( ) ; System.err.println(this.phonemes.getClass()); for (Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) sb.append("|"); sb.append(ph.getPhonemeText()); } return sb.toString(); } 
public String phoneticUtf8 ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) check for d' { String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public Phoneme append ( CharSequence str ) { return new Phoneme ( new AppendableCharSeqeuence ( his . phonemeText , str ) , his . languages ) ; } 
public Phoneme join ( Phoneme right ) { return new Phoneme ( new AppendableCharSeqeuence ( his . phonemeText , right . phonemeText ) , his . languages . restrictTo ( right . languages ) ) ; } 
public int compareTo ( Phoneme o ) { for ( int i = 0 ; i < phonemeText . length ( ) ; i + + ) { if ( i > = o . phonemeText . length ( ) ) return + 1 ; int c = phonemeText . charAt ( i ) - o . phonemeText . charAt ( i ) ; if ( c ! = 0 ) return c ; } if ( phonemeText . length ( ) < o . phonemeText . length ( ) ) return - 1 ; return 0 ; } 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find(); boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find(); return patternMatches && rContextMatches && lContextMatches; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 0; } }; } }; } else { return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.equals(content); } }; } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return new RPattern() { public RMatcher matcher(CharSequence input) { return new RMatcher() { public boolean find() { return true; } }; } }; } else if (startsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return startsWith(input, content); } }; } }; } else if (endsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return endsWith(input, content); } }; } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (startsWith) { first char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (endsWith) { last char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch); } }; } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public RMatcher matcher ( final CharSequence input ) { return new RMatcher ( ) { public boolean find ( ) { 
public boolean find ( ) { return input . length ( ) = = 0 ; } 
public boolean find ( ) { return input . equals ( content ) ; } 
public RMatcher matcher ( CharSequence input ) { return new RMatcher ( ) { public boolean find ( ) { 
public boolean find ( ) { return rue ; } 
public RMatcher matcher ( final CharSequence input ) { return new RMatcher ( ) { public boolean find ( ) { 
public boolean find ( ) { return startsWith ( input , content ) ; } 
public boolean find ( ) { return endsWith ( input , content ) ; } 
public RMatcher matcher ( final CharSequence input ) { return new RMatcher ( ) { public boolean find ( ) { 
public boolean find ( ) { return input . length ( ) = = 1 & & ( contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ) ; } 
public boolean find ( ) { return input . length ( ) > 0 & & ( contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ) ; } 
public boolean find ( ) { return input . length ( ) > 0 & & ( contains ( bContent , input . charAt ( input . length ( ) - 1 ) ) = = shouldMatch ) ; } 
public RMatcher matcher ( CharSequence input ) { final Matcher matcher = pattern . matcher ( input ) ; return new RMatcher ( ) { public boolean find ( ) { 
public boolean find ( ) { return matcher . find ( ) ; } 
private static boolean startsWith ( CharSequence input , CharSequence prefix ) { if ( prefix . length ( ) > input . length ( ) ) return false ; for ( int i = 0 ; i < prefix . length ( ) ; i + + ) { if ( input . charAt ( i ) ! = prefix . charAt ( i ) ) { return false ; } } return rue ; } 
private static boolean endsWith ( CharSequence input , CharSequence suffix ) { if ( suffix . length ( ) > input . length ( ) ) return false ; for ( int i = input . length ( ) - 1 , j = suffix . length ( ) - 1 ; j > = 0 ; i - - , j - - ) { if ( input . charAt ( i ) ! = suffix . charAt ( j ) ) { return false ; } } return rue ; } 
private static boolean contains ( CharSequence chars , char input ) { for ( int i = 0 ; i < chars . length ( ) ; i + + ) { if ( chars . charAt ( i ) = = input ) { return rue ; } } return false ; } 
public char charAt ( int index ) { int lLength = left.length(); if(index < lLength) return left.charAt(index); else return right.charAt(index - lLength); return toString().charAt(index); } 
public CharSequence subSequence ( int start , int end ) { int lLength = left.length(); if(start > lLength) return right.subSequence(start - lLength, end - lLength); else if(end <= lLength) return left.subSequence(start, end); else { CharSequence newLeft = left.subSequence(start, lLength); CharSequence newRight = right.subSequence(0, end - lLength); return new AppendableCharSeqeuence(newLeft, newRight); } return toString().subSequence(start, end); } 
public CharSequence append ( CharSequence right ) { return new AppendableCharSeqeuence ( his , right ) ; } 
public String oString ( ) { if ( contentCache = = null ) { StringBuilder sb = new StringBuilder ( ) ; buildString ( sb ) ; contentCache = sb . oString ( ) ; System.err.println("Materialized string: " + contentCache); } return contentCache; } 
public void buildString ( StringBuilder sb ) { if ( left instanceof AppendableCharSeqeuence ) { ( ( AppendableCharSeqeuence ) left ) . buildString ( sb ) ; } else { sb . append ( left ) ; } if ( right instanceof AppendableCharSeqeuence ) { ( ( AppendableCharSeqeuence ) right ) . buildString ( sb ) ; 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { 
private Rule . Phoneme [ ] [ ] makePhonemes ( ) { String [ ] [ ] words = { { " rinD " , " rinDlt " , " rina " , " rinalt " , " rino " , " rinolt " , " rinu " , " rinult " } , { " dortlaj " , " dortlej " , " ortlaj " , " ortlej " , " ortlej-dortlaj " } } ; Rule . Phoneme [ ] [ ] phonemes = new Rule . Phoneme [ words . length ] [ ] ; for ( int i = 0 ; i < words . length ; i + + ) { String [ ] words_i = words [ i ] ; Rule . Phoneme [ ] phonemes_i = phonemes [ i ] = new Rule . Phoneme [ words_i . length ] ; for ( int j = 0 ; j < words_i . length ; j + + ) { phonemes_i [ j ] = new Rule . Phoneme ( words_i [ j ] , Languages . NO_LANGUAGES ) ; } } return phonemes ; } 
public void phonemeComparedToSelfIsZero ( ) { for ( Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( Rule . Phoneme ph : phs ) { 
public void phonemeComparedToLaterIsNegative ( ) { for ( Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( int i = 0 ; i < phs . length ; i + + ) { 
public boolean matches ( Object item ) { return ( ( Integer ) item ) < 0 ; } 
public void describeTo ( Description description ) { description . appendText ( " value should be negative " ) ; } 
public String guessLanguage ( String ext ) { Languages . LanguageSet ls = guessLanguages ( ext ) ; return ls . isSingleton ( ) ? ls . getAny ( ) : Languages . ANY ; } 
public Languages . LanguageSet guessLanguages ( String input ) { String ext = input . oLowerCase ( ) ; todo: locale? System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } Languages.LanguageSet ls = Languages.LanguageSet.from(langs); return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls; } 
public static LanguageSet from ( Set < String > langs ) { return langs . isEmpty ( ) ? NO_LANGUAGES : new SomeLanguages ( langs ) ; } 
public String makeString ( ) { StringBuilder sb = new StringBuilder ( ) ; System.err.println(this.phonemes.getClass()); for (Rule.Phoneme ph : this.phonemes) { if (sb.length() > 0) { sb.append("|"); } sb.append(ph.getPhonemeText()); } return sb.toString(); } 
public String phoneticUtf8 ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . instance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . instance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . instance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public int compareTo ( Phoneme o ) { for ( int i = 0 ; i < phonemeText . length ( ) ; i + + ) { if ( i > = o . phonemeText . length ( ) ) { return + 1 ; } int c = phonemeText . charAt ( i ) - o . phonemeText . charAt ( i ) ; if ( c ! = 0 ) { return c ; } } if ( phonemeText . length ( ) < o . phonemeText . length ( ) ) { return - 1 ; } return 0 ; } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int line = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(line); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
public static List < Rule > instance ( NameType nameType , RuleType rt , Languages . LanguageSet langs ) { return langs . isSingleton ( ) ? instance ( nameType , rt , langs . getAny ( ) ) : instance ( nameType , rt , Languages . ANY ) ; } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int line = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(line); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
private static boolean startsWith ( CharSequence input , CharSequence prefix ) { if ( prefix . length ( ) > input . length ( ) ) { return false ; } for ( int i = 0 ; i < prefix . length ( ) ; i + + ) { if ( input . charAt ( i ) ! = prefix . charAt ( i ) ) { return false ; } } return rue ; } 
private static boolean endsWith ( CharSequence input , CharSequence suffix ) { if ( suffix . length ( ) > input . length ( ) ) { return false ; } for ( int i = input . length ( ) - 1 , j = suffix . length ( ) - 1 ; j > = 0 ; i - - , j - - ) { if ( input . charAt ( i ) ! = suffix . charAt ( j ) ) { return false ; } } return rue ; } 
public String encode ( String input ) { Languages . LanguageSet languageSet = his . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . getInstance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . getInstance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } fixme: this case is invariant on l else if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public void estInvalidLangIllegalArgumentException ( ) { Rule . getInstance ( NameType . GENERIC , RuleType . APPROX , " noSuchLanguage " ) ; } 
public void estInvalidLangIllegalStateException ( ) { Lang . loadFromResource ( " hisIsAMadeUpResourceName " , Languages . getInstance ( NameType . GENERIC ) ) ; } 
public void estInvalidLanguageIllegalArgumentException ( ) { Languages . getInstance ( " hereIsNoSuchLanguage " ) ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . getInstance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . getInstance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public void estSpeedCheck ( ) hrows EncoderException { char [ ] chars = new char [ ] { 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'o' , 'u' } ; BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( chars [ rand . nextInt ( chars . length ) ] ) ; long start ; for ( int i = 0 ; i < 40 ; i + + ) { start = System . currentTimeMillis ( ) ; 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find(); boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find(); return patternMatches && rContextMatches && lContextMatches; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 0; } }; } }; } else { return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.equals(content); } }; } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return new RPattern() { public RMatcher matcher(CharSequence input) { return TrueRMatcher.INSTANCE; } }; } else if (startsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return startsWith(input, content); } }; } }; } else if (endsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return endsWith(input, content); } }; } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (startsWith) { first char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (endsWith) { last char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch); } }; } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public RMatcher matcher ( CharSequence input ) { return TrueRMatcher . INSTANCE ; } 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.matcher(input.subSequence(ipl, input.length())).find(); boolean lContextMatches = this.lContext.matcher(input.subSequence(0, i)).find(); return patternMatches && rContextMatches && lContextMatches; } 
public RMatcher matcher ( CharSequence input ) { return TrueRMatcher . INSTANCE ; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 0; } }; } }; } else { return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.equals(content); } }; } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return AllStringsRMatcher.INSTANCE; } else if (startsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return startsWith(input, content); } }; } }; } else if (endsWith) { matches from start return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return endsWith(input, content); } }; } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (startsWith) { first char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } }; } else if (endsWith) { last char return new RPattern() { public RMatcher matcher(final CharSequence input) { return new RMatcher() { public boolean find() { return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch); } }; } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public void estSpeedCheckRandom ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; Random rand = new Random ( ) ; stringBuffer . append ( TEST_CHARS [ rand . nextInt ( TEST_CHARS . length ) ] ) ; for ( int i = 0 ; i < 40 ; i + + ) { bmpm . encode ( stringBuffer . oString ( ) ) ; 
public void estSpeedCheck ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; stringBuffer . append ( TEST_CHARS [ 0 ] ) ; for ( int i = 0 , j = 1 ; i < 40 ; i + + , j + + ) { if ( j = = TEST_CHARS . length ) { 
public void estSpeedCheckAZ ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; String phrase = " abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public String guessLanguage ( String ext ) { Languages . LanguageSet ls = guessLanguages ( ext ) ; return ls . isSingleton ( ) ? ls . getAny ( ) : Languages . ANY ; } 
public Languages . LanguageSet guessLanguages ( String input ) { String ext = input . oLowerCase ( Locale . ENGLISH ) ; System.out.println("Testing text: '" + text + "'"); Set<String> langs = new HashSet<String>(this.languages.getLanguages()); for (LangRule rule : this.rules) { if (rule.matches(text)) { System.out.println("Rule " + rule.pattern + " matches " + text); if (rule.acceptOnMatch) { System.out.println("Retaining " + rule.languages); langs.retainAll(rule.languages); } else { System.out.println("Removing " + rule.languages); langs.removeAll(rule.languages); } System.out.println("Current languages: " + langs); } else { System.out.println("Rule " + rule.pattern + " does not match " + text); } } Languages.LanguageSet ls = Languages.LanguageSet.from(langs); return ls.equals(Languages.NO_LANGUAGES) ? Languages.ANY_LANGUAGE : ls; } 
public static LanguageSet from ( Set < String > langs ) { return langs . isEmpty ( ) ? NO_LANGUAGES : new SomeLanguages ( langs ) ; } 
private static CharSequence cacheSubSequence ( final CharSequence cached ) { return cached; final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()]; return new CharSequence() { public char charAt(int index) { 
public char charAt ( int index ) { return cached . charAt ( index ) ; } 
public CharSequence subSequence ( int start , int end ) { if ( start = = end ) return " " ; CharSequence res = cache [ start ] [ end - 1 ] ; if ( res = = null ) { res = cached . subSequence ( start , end ) ; cache [ start ] [ end - 1 ] = res ; } return res ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; final List < Rule > finalRules1 = Rule . getInstance ( his . nameType , his . ruleType , " common " ) ; final List < Rule > finalRules2 = Rule . getInstance ( his . nameType , his . ruleType , languageSet ) ; System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } System.err.println("Applying general rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Applying language-specific rules"); phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); System.err.println("Now got: " + phonemeBuilder.makeString()); System.err.println("Done"); return phonemeBuilder.makeString(); } 
public Phoneme append ( CharSequence str ) { return new Phoneme ( his . phonemeText . oString ( ) + str . oString ( ) , his . languages ) ; } 
public Phoneme join ( Phoneme right ) { return new Phoneme ( his . phonemeText . oString ( ) + right . phonemeText . oString ( ) , his . languages . restrictTo ( right . languages ) ) ; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { public boolean isMatch(CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { public boolean isMatch(CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { public boolean isMatch(CharSequence input) { return endsWith(input, content); } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() == 1 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } else if (startsWith) { first char return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() > 0 && (contains(bContent, input.charAt(0)) == shouldMatch); } }; } else if (endsWith) { last char return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() > 0 && (contains(bContent, input.charAt(input.length() - 1)) == shouldMatch); } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public boolean isMatch ( CharSequence input ) { return input . length ( ) = = 0 ; } 
public boolean isMatch ( CharSequence input ) { return input . equals ( content ) ; } 
public boolean isMatch ( CharSequence input ) { return startsWith ( input , content ) ; } 
public boolean isMatch ( CharSequence input ) { return endsWith ( input , content ) ; } 
public boolean isMatch ( CharSequence input ) { return input . length ( ) = = 1 & & ( contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ) ; } 
public boolean isMatch ( CharSequence input ) { return input . length ( ) > 0 & & ( contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ) ; } 
public boolean isMatch ( CharSequence input ) { return input . length ( ) > 0 & & ( contains ( bContent , input . charAt ( input . length ( ) - 1 ) ) = = shouldMatch ) ; } 
public boolean isMatch ( CharSequence input ) { Matcher matcher = pattern . matcher ( input ) ; return matcher . find ( ) ; } 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.isMatch(input.subSequence(ipl, input.length())); boolean lContextMatches = this.lContext.isMatch(input.subSequence(0, i)); return patternMatches && rContextMatches && lContextMatches; } 
public void estSpeedCheck2 ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; String phrase = " ItstheendoftheworldasweknowitandIfeelfine " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void estSpeedCheck3 ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; String phrase = " abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void subSequenceWorks ( ) { AppendableCharSequence is private to Rule. We can only make it through a Phoneme. Rule.Phoneme a = new Rule.Phoneme("a", null); Rule.Phoneme b = new Rule.Phoneme("b", null); Rule.Phoneme cd = new Rule.Phoneme("cd", null); Rule.Phoneme ef = new Rule.Phoneme("ef", null); Rule.Phoneme ghi = new Rule.Phoneme("ghi", null); Rule.Phoneme jkl = new Rule.Phoneme("jkl", null); assertEquals('a', a.getPhonemeText().charAt(0)); assertEquals('b', b.getPhonemeText().charAt(0)); assertEquals('c', cd.getPhonemeText().charAt(0)); assertEquals('d', cd.getPhonemeText().charAt(1)); assertEquals('e', ef.getPhonemeText().charAt(0)); assertEquals('f', ef.getPhonemeText().charAt(1)); assertEquals('g', ghi.getPhonemeText().charAt(0)); assertEquals('h', ghi.getPhonemeText().charAt(1)); assertEquals('i', ghi.getPhonemeText().charAt(2)); assertEquals('j', jkl.getPhonemeText().charAt(0)); assertEquals('k', jkl.getPhonemeText().charAt(1)); assertEquals('l', jkl.getPhonemeText().charAt(2)); Rule.Phoneme a_b = a.append(b.getPhonemeText()); assertEquals('a', a_b.getPhonemeText().charAt(0)); assertEquals('b', a_b.getPhonemeText().charAt(1)); assertEquals("ab", a_b.getPhonemeText().subSequence(0, 2).toString()); assertEquals("a", a_b.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b.getPhonemeText().subSequence(1, 2).toString()); Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText()); assertEquals('c', cd_ef.getPhonemeText().charAt(0)); assertEquals('d', cd_ef.getPhonemeText().charAt(1)); assertEquals('e', cd_ef.getPhonemeText().charAt(2)); assertEquals('f', cd_ef.getPhonemeText().charAt(3)); assertEquals("c", cd_ef.getPhonemeText().subSequence(0, 1).toString()); assertEquals("d", cd_ef.getPhonemeText().subSequence(1, 2).toString()); assertEquals("e", cd_ef.getPhonemeText().subSequence(2, 3).toString()); assertEquals("f", cd_ef.getPhonemeText().subSequence(3, 4).toString()); assertEquals("cd", cd_ef.getPhonemeText().subSequence(0, 2).toString()); assertEquals("de", cd_ef.getPhonemeText().subSequence(1, 3).toString()); assertEquals("ef", cd_ef.getPhonemeText().subSequence(2, 4).toString()); assertEquals("cde", cd_ef.getPhonemeText().subSequence(0, 3).toString()); assertEquals("def", cd_ef.getPhonemeText().subSequence(1, 4).toString()); assertEquals("cdef", cd_ef.getPhonemeText().subSequence(0, 4).toString()); Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText()); assertEquals('a', a_b_cd.getPhonemeText().charAt(0)); assertEquals('b', a_b_cd.getPhonemeText().charAt(1)); assertEquals('c', a_b_cd.getPhonemeText().charAt(2)); assertEquals('d', a_b_cd.getPhonemeText().charAt(3)); assertEquals("a", a_b_cd.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b_cd.getPhonemeText().subSequence(1, 2).toString()); assertEquals("c", a_b_cd.getPhonemeText().subSequence(2, 3).toString()); assertEquals("d", a_b_cd.getPhonemeText().subSequence(3, 4).toString()); assertEquals("ab", a_b_cd.getPhonemeText().subSequence(0, 2).toString()); assertEquals("bc", a_b_cd.getPhonemeText().subSequence(1, 3).toString()); assertEquals("cd", a_b_cd.getPhonemeText().subSequence(2, 4).toString()); assertEquals("abc", a_b_cd.getPhonemeText().subSequence(0, 3).toString()); assertEquals("bcd", a_b_cd.getPhonemeText().subSequence(1, 4).toString()); assertEquals("abcd", a_b_cd.getPhonemeText().subSequence(0, 4).toString()); } 
public int compare ( Phoneme o1 , Phoneme o2 ) { for ( int i = 0 ; i < o1 . phonemeText . length ( ) ; i + + ) { if ( i > = o2 . phonemeText . length ( ) ) { return + 1 ; } int c = o1 . phonemeText . charAt ( i ) - o2 . phonemeText . charAt ( i ) ; if ( c ! = 0 ) { return c ; } } if ( o1 . phonemeText . length ( ) < o2 . phonemeText . length ( ) ) { return - 1 ; } return 0 ; } 
public void estPhonemeComparedToLaterIsNegative ( ) { for ( Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( int i = 0 ; i < phs . length ; i + + ) { 
public void estPhonemeComparedToSelfIsZero ( ) { for ( Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( Rule . Phoneme ph : phs ) { 
public void estSubSequenceWorks ( ) { AppendableCharSequence is private to Rule. We can only make it through a Phoneme. Rule.Phoneme a = new Rule.Phoneme("a", null); Rule.Phoneme b = new Rule.Phoneme("b", null); Rule.Phoneme cd = new Rule.Phoneme("cd", null); Rule.Phoneme ef = new Rule.Phoneme("ef", null); Rule.Phoneme ghi = new Rule.Phoneme("ghi", null); Rule.Phoneme jkl = new Rule.Phoneme("jkl", null); assertEquals('a', a.getPhonemeText().charAt(0)); assertEquals('b', b.getPhonemeText().charAt(0)); assertEquals('c', cd.getPhonemeText().charAt(0)); assertEquals('d', cd.getPhonemeText().charAt(1)); assertEquals('e', ef.getPhonemeText().charAt(0)); assertEquals('f', ef.getPhonemeText().charAt(1)); assertEquals('g', ghi.getPhonemeText().charAt(0)); assertEquals('h', ghi.getPhonemeText().charAt(1)); assertEquals('i', ghi.getPhonemeText().charAt(2)); assertEquals('j', jkl.getPhonemeText().charAt(0)); assertEquals('k', jkl.getPhonemeText().charAt(1)); assertEquals('l', jkl.getPhonemeText().charAt(2)); Rule.Phoneme a_b = a.append(b.getPhonemeText()); assertEquals('a', a_b.getPhonemeText().charAt(0)); assertEquals('b', a_b.getPhonemeText().charAt(1)); assertEquals("ab", a_b.getPhonemeText().subSequence(0, 2).toString()); assertEquals("a", a_b.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b.getPhonemeText().subSequence(1, 2).toString()); Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText()); assertEquals('c', cd_ef.getPhonemeText().charAt(0)); assertEquals('d', cd_ef.getPhonemeText().charAt(1)); assertEquals('e', cd_ef.getPhonemeText().charAt(2)); assertEquals('f', cd_ef.getPhonemeText().charAt(3)); assertEquals("c", cd_ef.getPhonemeText().subSequence(0, 1).toString()); assertEquals("d", cd_ef.getPhonemeText().subSequence(1, 2).toString()); assertEquals("e", cd_ef.getPhonemeText().subSequence(2, 3).toString()); assertEquals("f", cd_ef.getPhonemeText().subSequence(3, 4).toString()); assertEquals("cd", cd_ef.getPhonemeText().subSequence(0, 2).toString()); assertEquals("de", cd_ef.getPhonemeText().subSequence(1, 3).toString()); assertEquals("ef", cd_ef.getPhonemeText().subSequence(2, 4).toString()); assertEquals("cde", cd_ef.getPhonemeText().subSequence(0, 3).toString()); assertEquals("def", cd_ef.getPhonemeText().subSequence(1, 4).toString()); assertEquals("cdef", cd_ef.getPhonemeText().subSequence(0, 4).toString()); Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText()); assertEquals('a', a_b_cd.getPhonemeText().charAt(0)); assertEquals('b', a_b_cd.getPhonemeText().charAt(1)); assertEquals('c', a_b_cd.getPhonemeText().charAt(2)); assertEquals('d', a_b_cd.getPhonemeText().charAt(3)); assertEquals("a", a_b_cd.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b_cd.getPhonemeText().subSequence(1, 2).toString()); assertEquals("c", a_b_cd.getPhonemeText().subSequence(2, 3).toString()); assertEquals("d", a_b_cd.getPhonemeText().subSequence(3, 4).toString()); assertEquals("ab", a_b_cd.getPhonemeText().subSequence(0, 2).toString()); assertEquals("bc", a_b_cd.getPhonemeText().subSequence(1, 3).toString()); assertEquals("cd", a_b_cd.getPhonemeText().subSequence(2, 4).toString()); assertEquals("abc", a_b_cd.getPhonemeText().subSequence(0, 3).toString()); assertEquals("bcd", a_b_cd.getPhonemeText().subSequence(1, 4).toString()); assertEquals("abcd", a_b_cd.getPhonemeText().subSequence(0, 4).toString()); } 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; Base64 b64 = new Base64 ( Base64 . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); bogus characters to decode (to skip actually) {e-acute*6} byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertTrue("decode hello world", decodeString.equals("Hello World")); } 
public Object encode ( Object object ) hrows EncoderException { if ( ! ( object instanceof String ) ) { hrow new EncoderException ( " This method's parameter was expected to be of the type " + String . class . getName ( ) + " . But actually it was of the type " + object . getClass ( ) . getName ( ) + " . " ) ; } return encode ( ( String ) object ) ; } 
public void estUsMappingEWithAcute ( ) { Assert . assertEquals ( " E000 " , his . getSoundexEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( '\u00e9' ) ) { e-acute try { 
public void estUsMappingOWithDiaeresis ( ) { Assert . assertEquals ( " O000 " , his . getSoundexEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( '\u00f6' ) ) { o-umlaut try { 
public void estEdgeCases ( ) hrows EncoderException { String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , a-umlaut {"\u00F6", "0"}, o-umlaut {"\u00FC", "0"}, u-umlaut {"aa", "0"}, {"ha", "0"}, {"h", ""}, {"aha", "0"}, {"b", "1"}, {"p", "1"}, {"ph", "3"}, {"f", "3"}, {"v", "3"}, {"w", "3"}, {"g", "4"}, {"k", "4"}, {"q", "4"}, {"x", "48"}, {"ax", "048"}, {"cx", "48"}, {"l", "5"}, {"cl", "45"}, {"acl", "085"}, {"mn", "6"}, {"r", "7"}}; this.checkEncodings(data); } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } String msg = failures.toString(); matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00e7", "S"); c-cedilla } @Test public void testNTilde() { this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00f1", "N"); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estCCedilla ( ) { his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " u00e7 " , " S " ) ; c-cedilla } 
public void estNTilde ( ) { his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " u00f1 " , " N " ) ; n-tilde } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } String msg = failures.toString(); matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (msg.length() > 0) { Turn on to see which pairs do NOT match. fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estCCedilla ( ) { assertTrue ( his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " u00e7 " , " S " ) ) ; c-cedilla } 
public void estNTilde ( ) { assertTrue ( his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " u00f1 " , " N " ) ) ; n-tilde } 
public void estSetConcat ( ) { BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setConcat ( false ) ; assertFalse ( " Should be able to set concat to false " , bmpm . isConcat ( ) ) ; } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { System.err.println("Warining: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Rule " ) ; sb . append ( " {line= " ) . append ( myLine ) ; sb . append ( " , loc=' " ) . append ( loc ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . oString ( ) ; } 
public static Lang loadFromResource ( String languageRulesResourceName , Languages languages ) { List < LangRule > rules = new ArrayList < LangRule > ( ) ; InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; } else { discard doc comment line } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { System.err.println("index of comment: " + cmtI); line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up String[] parts = line.split("\\s+"); System.err.println("part count: " + parts.length); if (parts.length != 3) { fixme: we really need to log this somewhere System.err.println("Warning: malformed line '" + rawLine + "'"); continue; } Pattern pattern = Pattern.compile(parts[0]); String[] langs = parts[1].split("\\+"); boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
public CharSequence subSequence ( int start , int end ) { if ( start = = end ) { return " " ; } CharSequence res = cache [ start ] [ end - 1 ] ; if ( res = = null ) { res = cached . subSequence ( start , end ) ; cache [ start ] [ end - 1 ] = res ; } return res ; } 
public void estBase32EmptyInputStreamMimeChuckSize ( ) hrows Exception { estBase32EmptyInputStream ( BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estBase32EmptyInputStreamPemChuckSize ( ) hrows Exception { estBase32EmptyInputStream ( BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32EmptyOutputStreamMimeChunkSize ( ) hrows Exception { estBase32EmptyOutputStream ( BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estBase32EmptyOutputStreamPemChunkSize ( ) hrows Exception { estBase32EmptyOutputStream ( BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase64EmptyInputStreamMimeChuckSize ( ) hrows Exception { estBase64EmptyInputStream ( BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estBase64EmptyInputStreamPemChuckSize ( ) hrows Exception { estBase64EmptyInputStream ( BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64EmptyOutputStreamMimeChunkSize ( ) hrows Exception { estBase64EmptyOutputStream ( BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estBase64EmptyOutputStreamPemChunkSize ( ) hrows Exception { estBase64EmptyOutputStream ( BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertTrue ( " encoding hello world " , encodedContent . equals ( " SGVsbG8gV29ybGQ= " ) ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertTrue("encoding hello world", encodedContent.equals("SGVsbG8gV29ybGQ=")); bogus characters to decode (to skip actually) {e-acute*6} byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertTrue("decode hello world", decodeString.equals("Hello World")); } 
public void estRfc2045Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 76 , BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estRfc1421Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 64 , BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estCodec98NPE ( ) hrows Exception { byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; ByteArrayInputStream data = new ByteArrayInputStream ( codec98 ) ; Base64InputStream stream = new Base64InputStream ( data ) ; This line causes an NPE in commons-codec-1.4.jar: byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]); String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("codec-98 NPE Base64InputStream", Base64TestData.CODEC_98_NPE_DECODED, decoded); } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { byte[][] randomData = Base64TestData.randomData(i, false); 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estSkipNone ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b64stream . skip ( 0 ) ) ; b64stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 0 , 0 , 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 } ) ; End of stream reached assertEquals(-1, b64stream.read()); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 8 , b64stream . skip ( 10 ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 8 , b64stream . skip ( 8 ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base32InputStream.markSupported() is false", in.markSupported()); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base32InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); 
public void estSkipNone ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b32stream . skip ( 0 ) ) ; b32stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 102 , 111 , 111 , 0 , 0 , 0 } ) ; End of stream reached assertEquals(-1, b32stream.read()); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 8 , b32stream . skip ( 10 ) ) ; End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); } 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 8 , b32stream . skip ( 8 ) ) ; End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } fixme: this is a readability/speed trade-off - these 3 expressions should be inlined for speed to avoid evaluating latter ones if earlier ones have already failed, but that would make the code a lot harder to read boolean patternMatches = input.subSequence(i, ipl).equals(this.pattern); boolean rContextMatches = this.rContext.isMatch(input.subSequence(ipl, input.length())); boolean lContextMatches = this.lContext.isMatch(input.subSequence(0, i)); return patternMatches && rContextMatches && lContextMatches; } 
public void estEncode ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat ) ; String phoneticActual = engine . encode ( his . name ) ; System.err.println("expecting: " + this.phoneticExpected); System.err.println("actual: " + phoneticActual); assertEquals("phoneme incorrect", this.phoneticExpected, phoneticActual); } 
public void estHugeLineSeparator ( ) { final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192 ; final int Base64_BYTES_PER_ENCODED_BLOCK = 4 ; byte [ ] baLineSeparator = new byte [ BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3 ] ; Base64 b64 = new Base64 ( Base64_BYTES_PER_ENCODED_BLOCK , baLineSeparator ) ; String strOriginal = " Hello World " ; String strDecoded = new String ( b64 . decode ( b64 . encode ( StringUtils . getBytesUtf8 ( strOriginal ) ) ) ) ; assertTrue ( " estDEFAULT_BUFFER_SIZE " , strOriginal . equals ( strDecoded ) ) ; } 
private static final int encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } 
private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; 
private static boolean isWhitespace ( final int b ) { return b = = SPACE | | b = = TAB ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } return buffer.toByteArray(); } 
public static final byte [ ] decodeQuotedPrintable ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final int b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { if the next octet is a CR we have found a soft line break if (bytes[++i] == CR) { continue; } int u = Utils.digit16(bytes[i]); int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else if (b != CR && b != LF) { every other octet is appended except for CR & LF buffer.write(b); } } return buffer.toByteArray(); } 
public void estSoftLineBreakDecode ( ) hrows Exception { String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics " + " is the most beautiful branch of philosophy. " ; String expected = " If you believe that truth=beauty, then surely mathematics " + " is the most beautiful branch of philosophy. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public void estSoftLineBreakEncode ( ) hrows Exception { String qpdata = " If you believe that truth=3Dbeauty, then surely mathematics is the most " + " b= r neautiful branch of philosophy. " ; String expected = " If you believe that truth=beauty, then surely mathematics is the most " + " beautiful branch of philosophy. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( qpdata , qpcodec . encode ( expected ) ) ; String decoded = qpcodec . decode ( qpdata ) ; assertEquals ( qpdata , qpcodec . encode ( decoded ) ) ; } 
public void estSkipNotEncodedCRLF ( ) hrows Exception { String qpdata = " CRLF in an n encoded text should be=20= r rskipped in the r decoding. " ; String expected = " CRLF in an encoded text should be skipped in the decoding. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public void estTrailingSpecial ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " This is a example of a quoted-printable text file. This might contain sp=cial chars. " ; String expected = " This is a example of a quoted-printable text file. This might contain sp=3D= r ncial chars. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. This might contain ta bs as well. " ; expected = " This is a example of a quoted-printable text file. This might contain ta=09= r nbs as well. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; } 
public void estUltimateSoftBreak ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " This is a example of a quoted-printable text file. There is no end to it " ; String expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=09 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. There is no end to it " ; expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=20 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; whitespace before soft break plain ="This is a example of a quoted-printable text file. There is no end to "; expected = "This is a example of a quoted-printable text file. There is no end to=20=\r =20"; assertEquals(expected, qpcodec.encode(plain)); non-printable character before soft break plain ="This is a example of a quoted-printable text file. There is no end to= "; expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r =20"; assertEquals(expected, qpcodec.encode(plain)); } 
public void estFinalBytes ( ) hrows Exception { whitespace, but does not need to be encoded String plain ="This is a example of a quoted=printable text file. There is no tt"; String expected = "This is a example of a quoted=3Dprintable text file. There is no tt"; assertEquals(expected, new QuotedPrintableCodec().encode(plain)); } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 0 ; RULES : for ( Rule rule : his . finalRules ) { String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; log("trying pattern: " + pattern); if (!rule.patternAndContextMatches(this.input, this.i)) { log("no match"); continue RULES; } this.phonemeBuilder = this.phonemeBuilder.apply(rule.getPhoneme(), maxPhonemes); this.found = true; break RULES; } if (!this.found) { patternLength = 1; } this.i += patternLength; return this; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); System.err.println("Languages: " + languageSet); System.err.println("Rules: " + rules); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); System.err.println(input + " " + i + ": " + phonemeBuilder.makeString()); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public void estAllChars ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = Character . MIN_VALUE ; c < Character . MAX_VALUE ; c + + ) { bmpm . encode ( Character . oString ( c ) ) ; 
public void estAsciiEncodeNotEmpty1Letter ( ) hrows EncoderException { BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = 'a' ; c < = 'z' ; c + + ) { final String value = Character . oString ( c ) ; 
public void estOOM ( ) hrows EncoderException { String phrase = " 200697900'-->&#1913348150;</ bceaeef >aadaabcf \" aedfbff<!-- '-->?>cae " + " cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo< cc = \" abff \" /></ afe > " + " <script><!-- f(';< cf aefbeef = \" bfabadcf \" ebbfeedd = fccabeb > " ; BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . EXACT ) ; encoder . setMaxPhonemes ( 10 ) ; String phonemes = encoder . encode ( phrase ) ; assertTrue ( phonemes . length ( ) > 0 ) ; String [ ] phonemeArr = phonemes . split ( " \\ | " ) ; assertTrue ( phonemeArr . length < = 10 ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " Renault " , " rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult " , NameType . GENERIC , RuleType . APPROX , rue , 10 } , 
public void estEncode ( ) { PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat , his . maxPhonemes ) ; String phoneticActual = engine . encode ( his . name ) ; System.err.println("expecting: " + this.phoneticExpected); System.err.println("actual: " + phoneticActual); assertEquals("phoneme incorrect", this.phoneticExpected, phoneticActual); if (this.concat) { String[] split = phoneticActual.split("\\|"); 
private static boolean isVowel ( final char c ) { return c = = 'A' | | c = = 'E' | | c = = 'I' | | c = = 'O' | | c = = 'U' ; } 
private static char [ ] ranscodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { 1. EV -> AF if (curr == 'E' && next == 'V') { return CHARS_AF; } A, E, I, O, U -> A if (isVowel(curr)) { return CHARS_A; } 2. Q -> G, Z -> S, M -> N if (curr == 'Q') { return CHARS_G; } else if (curr == 'Z') { return CHARS_S; } else if (curr == 'M') { return CHARS_N; } 3. KN -> NN else K -> C if (curr == 'K') { if (next == 'N') { return CHARS_NN; } else { return CHARS_C; } } 4. SCH -> SSS if (curr == 'S' && next == 'C' && aNext == 'H') { return CHARS_SSS; } PH -> FF if (curr == 'P' && next == 'H') { return CHARS_FF; } 5. H -> If previous or next is a non vowel, previous. if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) { return new char[] { prev }; } 6. W -> If previous is vowel, previous. if (curr == 'W' && isVowel(prev)) { return new char[] { prev }; } return new char[] { curr }; } 
public Object encode ( Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Nysiis encode is not of type java.lang.String " ) ; } return his . nysiis ( ( String ) pObject ) ; } 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = str.replaceFirst("^MAC", "MCC"); str = str.replaceFirst("^KN", "NN"); str = str.replaceFirst("^K", "C"); str = str.replaceFirst("^(PH|PF)", "FF"); str = str.replaceFirst("^SCH", "SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = str.replaceFirst("(EE|IE)$", "Y"); str = str.replaceFirst("(DT|RT|RD|NT|ND)$", "D"); First character of key = first character of name. StringBuffer key = new StringBuffer(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isTrueLength() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
protected StringEncoder createStringEncoder ( boolean rueLength ) { return new Nysiis ( rueLength ) ; } 
private void encodeAll ( String [ ] strings , String expectedEncoding ) hrows EncoderException { for ( int i = 0 ; i < strings . length ; i + + ) { Assert . assertEquals ( " Problem with " + strings [ i ] , expectedEncoding , getStringEncoder ( ) . encode ( strings [ i ] ) ) ; 
public void estDropBy ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " MACINTOSH " , " MCANT " } , new String [ ] { " KNUTH " , " NAT " } , new String [ ] { " KOEHN " , " CAN " } , new String [ ] { " PHILLIPSON " , " FALAPSAN " } , new String [ ] { " PFEISTER " , " FASTAR " } , new String [ ] { " MCKEE " , " MCY " } , new String [ ] { " MACKIE " , " MCY " } , new String [ ] { " HEITSCHMIDT " , " HATSNAD " } , new String [ ] { " BART " , " BAD " } , new String [ ] { " HURD " , " HAD " } , new String [ ] { " HUNT " , " HAD " } , new String [ ] { " WESTERLUND " , " WASTARLAD " } , new String [ ] { " CASSTEVENS " , " CASTAFAN " } , new String [ ] { " VASQUEZ " , " VASG " } , new String [ ] { " FRAZIER " , " FRASAR " } , new String [ ] { " BOWMAN " , " BANAN " } , new String [ ] { " RICKERT " , " RACAD " } , new String [ ] { " DEUTSCH " , " DAT " } , new String [ ] { " WESTPHAL " , " WASTFAL " } , new String [ ] { " SHRIVER " , " SRAVAR " } , new String [ ] { " KUHL " , " CAL " } , new String [ ] { " RAWSON " , " RASAN " } , new String [ ] { " JILES " , " JAL " } , new String [ ] { " CARRAWAY " , " CARY " } , new String [ ] { " YAMADA " , " YANAD " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , createStringEncoder ( false ) . encode ( arr [ 0 ] ) ) ; 
public void estOthers ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( http:www.dropby.com/indexLF.html?content=/NYSIIS.html 1. Transcode first characters of name new String[] { "MACINTOSH", "MCANT" }, new String[] { "KNUTH", "NNATH" }, Original: NNAT; modified: NATH new String[] { "KOEHN", "C" }, new String[] { "PHILLIPSON", "FFALAP" }, new String[] { "PFEISTER", "FFASTA" }, new String[] { "SCHOENHOEFT", "SSANAF" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 2.Transcode last characters of name: new String[] { "MCKEE", "MCY" }, new String[] { "MACKIE", "MCY" }, new String[] { "HEITSCHMIDT", "HATSNAD" }, new String[] { "BART", "BAD" }, new String[] { "HURD", "HAD" }, new String[] { "HUNT", "HAD" }, new String[] { "WESTERLUND", "WASTARLAD" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 4. Transcode remaining characters by following these rules, incrementing by one character each time: new String[] { "CASSTEVENS", "CASTAFAN" }, new String[] { "VASQUEZ", "VASG" }, new String[] { "FRAZIER", "FRASAR" }, new String[] { "BOWMAN", "BANAN" }, new String[] { "MCKNIGHT", "MCNAGT" }, new String[] { "RICKERT", "RACAD" }, new String[] { "DEUTSCH", "DATS" }, new String[] { "WESTPHAL", "WASTFAL" }, new String[] { "SHRIVER", "SHRAVA" }, new String[] { "KUHL", "C" }, new String[] { "RAWSON", "RASAN" }, If last character is S, remove it new String[] { "JILES", "JAL" }, new String[] { "CARRAWAY", "CARAY" }, new String[] { "YAMADA", "YANAD" }, Others new String[] { "O'Daniel", "ODANAL" }, new String[] { "O'Donnel", "ODANAL" }, new String[] { "Cory", "CARY" }, new String[] { "Corey", "CARY" }, new String[] { "Kory", "CARY" }, new String[] { "FUZZY", "FASY" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], createStringEncoder(false).encode(arr[0])); 
public void estBran ( ) hrows EncoderException { encodeAll ( new String [ ] { " Brian " , " Brown " , " Brun " } , " BRAN " ) ; } 
public void estCap ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Capp " , " Cope " , " Copp " , " Kipp " } , " CAP " ) ; } 
public void estDan ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Dane " , " Dean " , " Dionne " } , " DAN " ) ; } 
public void estDad ( ) hrows EncoderException { Data Quality and Record Linkage Techniques P.121 claims this is DAN, but it should be DAD, verified also with dropby.com this.encodeAll(new String[] { "Dent" }, "DAD"); } 
public void estSnat ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Smith " , " Schmit " } , " SNAT " ) ; } 
public void estSnad ( ) hrows EncoderException { Data Quality and Record Linkage Techniques P.121 claims this is SNAT, but it should be SNAD this.encodeAll(new String[] { "Schmidt" }, "SNAD"); } 
public void estFal ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Phil " } , " FAL " ) ; } 
public void estTranan ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Trueman " , " Truman " } , " TRANAN " ) ; } 
public void estDropBy2 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( http:www.dropby.com/indexLF.html?content=/NYSIIS.html 1. Transcode first characters of name new String[] { "MACINTOSH", "MCANT" }, new String[] { "KNUTH", "NNATH" }, Original: NNAT; modified: NATH new String[] { "KOEHN", "C" }, new String[] { "PHILLIPSON", "FFALAP" }, new String[] { "PFEISTER", "FFASTA" }, new String[] { "SCHOENHOEFT", "SSANAF" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 2.Transcode last characters of name: new String[] { "MCKEE", "MCY" }, new String[] { "MACKIE", "MCY" }, new String[] { "HEITSCHMIDT", "HATSNAD" }, new String[] { "BART", "BAD" }, new String[] { "HURD", "HAD" }, new String[] { "HUNT", "HAD" }, new String[] { "WESTERLUND", "WASTARLAD" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 4. Transcode remaining characters by following these rules, incrementing by one character each time: new String[] { "CASSTEVENS", "CASTAFAN" }, new String[] { "VASQUEZ", "VASG" }, new String[] { "FRAZIER", "FRASAR" }, new String[] { "BOWMAN", "BANAN" }, new String[] { "MCKNIGHT", "MCNAGT" }, new String[] { "RICKERT", "RACAD" }, new String[] { "DEUTSCH", "DATS" }, new String[] { "WESTPHAL", "WASTFAL" }, new String[] { "SHRIVER", "SHRAVA" }, new String[] { "KUHL", "C" }, new String[] { "RAWSON", "RASAN" }, If last character is S, remove it new String[] { "JILES", "JAL" }, new String[] { "CARRAWAY", "CARAY" }, new String[] { "YAMADA", "YANAD" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], createStringEncoder(false).encode(arr[0])); 
public void estOthers ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " O'Daniel " , " ODANAL " } , new String [ ] { " O'Donnel " , " ODANAL " } , new String [ ] { " Cory " , " CARY " } , new String [ ] { " Corey " , " CARY " } , new String [ ] { " Kory " , " CARY " } , new String[] { "FUZZY", "FASY" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], createStringEncoder(false).encode(arr[0])); 
public void estTrueVariant ( ) { Nysiis encoder = new Nysiis ( rue ) ; String encoded = encoder . encode ( " WESTERLUND " ) ; Assert . assertTrue ( encoded . length ( ) < = 6 ) ; Assert . assertEquals ( " WASTAR " , encoded ) ; } 
public void estSpecialBranches ( ) hrows EncoderException { his . encodeAll ( new String [ ] { " Kobwick " } , " CABWAC " ) ; his . encodeAll ( new String [ ] { " Kocher " } , " CACAR " ) ; his . encodeAll ( new String [ ] { " Fesca " } , " FASC " ) ; his . encodeAll ( new String [ ] { " Shom " } , " SAN " ) ; his . encodeAll ( new String [ ] { " Ohlo " } , " OL " ) ; his . encodeAll ( new String [ ] { " Uhu " } , " UH " ) ; his . encodeAll ( new String [ ] { " Um " } , " UN " ) ; } 
public void estDropBy2 ( ) hrows EncoderException { Explanation of differences between this implementation and the one at dropby.com. Algorithm (taken from www.dropby.com/NYSIIS.html): 1. Transcode first characters of name: MAC > MCC KN > NN K > C PH > FF PF > FF SCH > SSS 2. Transcode last characters of name: EE, IE > Y DT,RT,RD,NT,ND > D 3. First character of key = first character of name. 4. Transcode remaining characters by following these rules, incrementing by one character each time: 4a. EV > AF else A,E,I,O,U > A 4b. Q > G 4c. Z > S 4d. M > N 4e. KN > N else K > C 4f. SCH > SSS 4g. PH > FF 4h. H > If previous or next is nonvowel, previous 4i. W > If previous is vowel, previous 4j. Add current to key if current != last key character 5. If last character is S, remove it 6. If last characters are AY, replace with Y 7. If last character is A, remove it 8. Collapse all strings of repeated characters 9. Add original first character of name as first character of key List<String[]> testValues = Arrays.asList( http:www.dropby.com/indexLF.html?content=/NYSIIS.html 1. Transcode first characters of name new String[] { "MACINTOSH", "MCANT" }, violates 4j: the second N should not be added, as the first key char is already a N new String[] { "KNUTH", "NAT" }, Original: NNAT; modified: NATH O and E are transcoded to A because of rule 4a H also to A because of rule 4h the N gets mysteriously lost, maybe because of a wrongly implemented rule 4h that skips the next char in such a case? the remaining A is removed because of rule 7 new String[] { "KOEHN", "CAN" }, Original: C violates 4j: see also KNUTH new String[] { "PHILLIPSON", "FALAPSAN" }, Original: FFALAP[SAN] violates 4j: see also KNUTH new String[] { "PFEISTER", "FASTAR" }, Original: FFASTA[R] violates 4j: see also KNUTH new String[] { "SCHOENHOEFT", "SANAFT" }, Original: SSANAF[T] http:www.dropby.com/indexLF.html?content=/NYSIIS.html 2.Transcode last characters of name: new String[] { "MCKEE", "MCY" }, new String[] { "MACKIE", "MCY" }, new String[] { "HEITSCHMIDT", "HATSNAD" }, new String[] { "BART", "BAD" }, new String[] { "HURD", "HAD" }, new String[] { "HUNT", "HAD" }, new String[] { "WESTERLUND", "WASTARLAD" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 4. Transcode remaining characters by following these rules, incrementing by one character each time: new String[] { "CASSTEVENS", "CASTAFAN" }, new String[] { "VASQUEZ", "VASG" }, new String[] { "FRAZIER", "FRASAR" }, new String[] { "BOWMAN", "BANAN" }, new String[] { "MCKNIGHT", "MCNAGT" }, new String[] { "RICKERT", "RACAD" }, violates 5: the last S is not removed when comparing to DEUTS, which is phonetically similar the result it also DAT, which is correct for DEUTSCH too imo new String[] { "DEUTSCH", "DAT" }, Original: DATS new String[] { "WESTPHAL", "WASTFAL" }, violates 4h: the H should be transcoded to S and thus ignored as the first key character is also S new String[] { "SHRIVER", "SRAVAR" }, Original: SHRAVA[R] same as KOEHN, the L gets mysteriously lost new String[] { "KUHL", "CAL" }, Original: C new String[] { "RAWSON", "RASAN" }, If last character is S, remove it new String[] { "JILES", "JAL" }, violates 6: if the last two characters are AY, remove A new String[] { "CARRAWAY", "CARY" }, Original: CARAY new String[] { "YAMADA", "YANAD" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], createStringEncoder(false).encode(arr[0])); 
public void estDropBy ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " MACINTOSH " , " MCANT " } , new String [ ] { " KNUTH " , " NAT " } , new String [ ] { " KOEHN " , " CAN " } , new String [ ] { " PHILLIPSON " , " FALAPSAN " } , new String [ ] { " PFEISTER " , " FASTAR " } , new String [ ] { " MCKEE " , " MCY " } , new String [ ] { " MACKIE " , " MCY " } , new String [ ] { " HEITSCHMIDT " , " HATSNAD " } , new String [ ] { " BART " , " BAD " } , new String [ ] { " HURD " , " HAD " } , new String [ ] { " HUNT " , " HAD " } , new String [ ] { " WESTERLUND " , " WASTARLAD " } , new String [ ] { " CASSTEVENS " , " CASTAFAN " } , new String [ ] { " VASQUEZ " , " VASG " } , new String [ ] { " FRAZIER " , " FRASAR " } , new String [ ] { " BOWMAN " , " BANAN " } , new String [ ] { " RICKERT " , " RACAD " } , new String [ ] { " DEUTSCH " , " DAT " } , new String [ ] { " WESTPHAL " , " WASTFAL " } , new String [ ] { " SHRIVER " , " SRAVAR " } , new String [ ] { " KUHL " , " CAL " } , new String [ ] { " RAWSON " , " RASAN " } , new String [ ] { " JILES " , " JAL " } , new String [ ] { " CARRAWAY " , " CARY " } , new String [ ] { " YAMADA " , " YANAD " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estDropBy2 ( ) hrows EncoderException { Explanation of differences between this implementation and the one at dropby.com. Algorithm (taken from www.dropby.com/NYSIIS.html): 1. Transcode first characters of name: MAC > MCC KN > NN K > C PH > FF PF > FF SCH > SSS 2. Transcode last characters of name: EE, IE > Y DT,RT,RD,NT,ND > D 3. First character of key = first character of name. 4. Transcode remaining characters by following these rules, incrementing by one character each time: 4a. EV > AF else A,E,I,O,U > A 4b. Q > G 4c. Z > S 4d. M > N 4e. KN > N else K > C 4f. SCH > SSS 4g. PH > FF 4h. H > If previous or next is nonvowel, previous 4i. W > If previous is vowel, previous 4j. Add current to key if current != last key character 5. If last character is S, remove it 6. If last characters are AY, replace with Y 7. If last character is A, remove it 8. Collapse all strings of repeated characters 9. Add original first character of name as first character of key List<String[]> testValues = Arrays.asList( http:www.dropby.com/indexLF.html?content=/NYSIIS.html 1. Transcode first characters of name new String[] { "MACINTOSH", "MCANT" }, violates 4j: the second N should not be added, as the first key char is already a N new String[] { "KNUTH", "NAT" }, Original: NNAT; modified: NATH O and E are transcoded to A because of rule 4a H also to A because of rule 4h the N gets mysteriously lost, maybe because of a wrongly implemented rule 4h that skips the next char in such a case? the remaining A is removed because of rule 7 new String[] { "KOEHN", "CAN" }, Original: C violates 4j: see also KNUTH new String[] { "PHILLIPSON", "FALAPSAN" }, Original: FFALAP[SAN] violates 4j: see also KNUTH new String[] { "PFEISTER", "FASTAR" }, Original: FFASTA[R] violates 4j: see also KNUTH new String[] { "SCHOENHOEFT", "SANAFT" }, Original: SSANAF[T] http:www.dropby.com/indexLF.html?content=/NYSIIS.html 2.Transcode last characters of name: new String[] { "MCKEE", "MCY" }, new String[] { "MACKIE", "MCY" }, new String[] { "HEITSCHMIDT", "HATSNAD" }, new String[] { "BART", "BAD" }, new String[] { "HURD", "HAD" }, new String[] { "HUNT", "HAD" }, new String[] { "WESTERLUND", "WASTARLAD" }, http:www.dropby.com/indexLF.html?content=/NYSIIS.html 4. Transcode remaining characters by following these rules, incrementing by one character each time: new String[] { "CASSTEVENS", "CASTAFAN" }, new String[] { "VASQUEZ", "VASG" }, new String[] { "FRAZIER", "FRASAR" }, new String[] { "BOWMAN", "BANAN" }, new String[] { "MCKNIGHT", "MCNAGT" }, new String[] { "RICKERT", "RACAD" }, violates 5: the last S is not removed when comparing to DEUTS, which is phonetically similar the result it also DAT, which is correct for DEUTSCH too imo new String[] { "DEUTSCH", "DAT" }, Original: DATS new String[] { "WESTPHAL", "WASTFAL" }, violates 4h: the H should be transcoded to S and thus ignored as the first key character is also S new String[] { "SHRIVER", "SRAVAR" }, Original: SHRAVA[R] same as KOEHN, the L gets mysteriously lost new String[] { "KUHL", "CAL" }, Original: C new String[] { "RAWSON", "RASAN" }, If last character is S, remove it new String[] { "JILES", "JAL" }, violates 6: if the last two characters are AY, remove A new String[] { "CARRAWAY", "CARY" }, Original: CARAY new String[] { "YAMADA", "YANAD" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], this.fullNysiis.encode(arr[0])); 
public void estOthers ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " O'Daniel " , " ODANAL " } , new String [ ] { " O'Donnel " , " ODANAL " } , new String [ ] { " Cory " , " CARY " } , new String [ ] { " Corey " , " CARY " } , new String [ ] { " Kory " , " CARY " } , new String[] { "FUZZY", "FASY" }); for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], this.fullNysiis.encode(arr[0])); 
public void estRule1 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " MACX " , " MCX " } , new String [ ] { " KNX " , " NX " } , new String [ ] { " KX " , " CX " } , new String [ ] { " PHX " , " FX " } , new String [ ] { " PFX " , " FX " } , new String [ ] { " SCHX " , " SX " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estRule2 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XEE " , " XY " } , new String [ ] { " XIE " , " XY " } , new String [ ] { " XDT " , " XD " } , new String [ ] { " XRT " , " XD " } , new String [ ] { " XRD " , " XD " } , new String [ ] { " XNT " , " XD " } , new String [ ] { " XND " , " XD " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estRule4Dot1 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XEV " , " XAF " } , new String [ ] { " XAX " , " XAX " } , new String [ ] { " XEX " , " XAX " } , new String [ ] { " XIX " , " XAX " } , new String [ ] { " XOX " , " XAX " } , new String [ ] { " XUX " , " XAX " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estRule5 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XS " , " X " } , new String [ ] { " XSS " , " X " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estRule6 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XAY " , " XY " } , new String [ ] { " XAYS " , " XY " } ) ; Rules 5, 6 for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], this.fullNysiis.encode(arr[0])); 
public void estRule7 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XA " , " X " } , new String [ ] { " XAS " , " X " } ) ; Rules 5, 7 for (String[] arr : testValues) { Assert.assertEquals("Problem with " + arr[0], arr[1], this.fullNysiis.encode(arr[0])); 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. StringBuffer key = new StringBuffer(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isTrueLength() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public void estRule4Dot2 ( ) hrows EncoderException { List < String [ ] > estValues = Arrays . asList ( new String [ ] { " XQ " , " XG " } , new String [ ] { " XZ " , " X " } , new String [ ] { " XM " , " XN " } ) ; for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
private void assertEncodings ( String [ ] . . . estValues ) hrows EncoderException { for ( String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
public void estOthers ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " O'Daniel " , " ODANAL " } , 
public void estRule1 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " MACX " , " MCX " } , 
public void estRule2 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XEE " , " XY " } , 
public void estRule4Dot1 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XEV " , " XAF " } , 
public void estRule4Dot2 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XQ " , " XG " } , 
public void estRule5 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XS " , " X " } , 
public void estRule6 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XAY " , " XY " } , 
public void estRule7 ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " XA " , " X " } , 
public void estDropBy ( ) hrows EncoderException { his . assertEncodings ( new String [ ] { " MACINTOSH " , " MCANT " } , 
public void estDropBy2 ( ) hrows EncoderException { Explanation of differences between this implementation and the one at dropby.com. Algorithm (taken from www.dropby.com/NYSIIS.html): 1. Transcode first characters of name: MAC > MCC KN > NN K > C PH > FF PF > FF SCH > SSS 2. Transcode last characters of name: EE, IE > Y DT,RT,RD,NT,ND > D 3. First character of key = first character of name. 4. Transcode remaining characters by following these rules, incrementing by one character each time: 4a. EV > AF else A,E,I,O,U > A 4b. Q > G 4c. Z > S 4d. M > N 4e. KN > N else K > C 4f. SCH > SSS 4g. PH > FF 4h. H > If previous or next is nonvowel, previous 4i. W > If previous is vowel, previous 4j. Add current to key if current != last key character 5. If last character is S, remove it 6. If last characters are AY, replace with Y 7. If last character is A, remove it 8. Collapse all strings of repeated characters 9. Add original first character of name as first character of key this.assertEncodings( http:www.dropby.com/indexLF.html?content=/NYSIIS.html 
public void estDropBy ( ) hrows EncoderException { Explanation of differences between this implementation and the one at dropby.com is prepended to the test string. The referenced rules refer to the outlined steps the class description for Nysiis. this.assertEncodings( 1. Transcode first characters of name 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. StringBuffer key = new StringBuffer(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public int read ( ) hrows IOException { int r = read ( singleByte , 0 , 1 ) ; while ( r = = 0 ) { r = read ( singleByte , 0 , 1 ) ; } if ( r > 0 ) { final byte b = singleByte [ 0 ] ; return b < 0 ? 256 + b : b ; } return - 1 ; } 
int readResults ( byte [ ] b , int bPos , int bAvail ) { package protected for access from I/O streams if (buffer != null) { int len = Math.min(available(), bAvail); System.arraycopy(buffer, readPos, b, bPos, len); readPos += len; if (readPos >= pos) { buffer = null; so hasData() will return false, and this method can return -1 } return len; } return eof ? EOF : 0; } 
public byte [ ] decode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } decode ( pArray , 0 , pArray . length ) ; decode ( pArray , 0 , EOF ) ; Notify decoder of EOF. byte[] result = new byte[pos]; readResults(result, 0, result.length); return result; } 
public byte [ ] encode ( byte [ ] pArray ) { reset ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } encode ( pArray , 0 , pArray . length ) ; encode ( pArray , 0 , EOF ) ; Notify encoder of EOF. byte[] buf = new byte[pos - readPos]; readResults(buf, 0, buf.length); return buf; } 
public int read ( ) hrows IOException { int r = read ( singleByte , 0 , 1 ) ; while ( r = = 0 ) { r = read ( singleByte , 0 , 1 ) ; } if ( r > 0 ) { final byte b = singleByte [ 0 ] ; return b < 0 ? 256 + b : b ; } return EOF ; } 
public void close ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { baseNCodec.encode(singleByte, 0, EOF); } else { baseNCodec.decode(singleByte, 0, EOF); } flush(); out.close(); } 
public void estCodec130 ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Base64OutputStream base64os = new Base64OutputStream ( bos ) ; base64os . write ( " Hello World! " . getBytes ( ) ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); StringBuffer sb = new StringBuffer(); int len = 0; byte[] bytes = new byte[10]; while ((len = ins.read(bytes)) != -1) { String s = new String(bytes, 0, len, "iso-8859-1"); sb.append(s); } String str = sb.toString(); assertEquals("ello World!", str); } 
public void estCodec130 ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Base64OutputStream base64os = new Base64OutputStream ( bos ) ; base64os . write ( STRING_FIXTURE . getBytes ( ) ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); StringBuffer sb = new StringBuffer(); int len = 0; byte[] bytes = new byte[10]; while ((len = ins.read(bytes)) != -1) { String s = new String(bytes, 0, len, "iso-8859-1"); sb.append(s); } String str = sb.toString(); assertEquals(STRING_FIXTURE.substring(1), str); } 
public PhonemeBuilder append ( CharSequence str ) { Set < Rule . Phoneme > newPhonemes = new LinkedHashSet < Rule . Phoneme > ( ) ; for ( Rule . Phoneme ph : his . phonemes ) { newPhonemes . add ( ph . append ( str ) ) ; } return new PhonemeBuilder ( newPhonemes ) ; } 
public void estCodec130 ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Base32OutputStream base32os = new Base32OutputStream ( bos ) ; base32os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; base32os . close ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; Base32InputStream ins = new Base32InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); byte[] decodedBytes = Base32TestData.streamToBytes(ins, new byte[64]); String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec130 ( ) hrows IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; Base64OutputStream base64os = new Base64OutputStream ( bos ) ; base64os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; base64os . close ( ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); byte[] decodedBytes = Base64TestData.streamToBytes(ins, new byte[64]); String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public long skip ( long ) hrows IOException { if ( < 0 ) { hrow new IllegalArgumentException ( " Negative skip length " ) ; } skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } 
public int available ( ) hrows IOException { Note: the logic is similar to the InflaterInputStream: as long as we have not reached EOF, indicate that there is more data available. As we do not know for sure how much data is left, just return 1 as a safe guess. use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; 
public void estAvailable ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 1 , b32stream . available ( ) ) ; assertEquals ( 3 , b32stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b32stream.available()); assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); assertEquals(0, b32stream.available()); } 
public void estSkipBig ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 3 , b32stream . skip ( 1024 ) ) ; End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(10)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); } 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(3)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); } 
public void estSkipWrongArgument ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; b32stream . skip ( - 10 ) ; } 
public void estAvailable ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 1 , b64stream . available ( ) ) ; assertEquals ( 6 , b64stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b64stream.available()); assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); assertEquals(0, b64stream.available()); } 
public void estSkipBig ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 6 , b64stream . skip ( 1024 ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(10)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(6)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public void estSkipWrongArgument ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; b64stream . skip ( - 10 ) ; } 
public int available ( ) hrows IOException { Note: the logic is similar to the InflaterInputStream: as long as we have not reached EOF, indicate that there is more data available. As we do not know for sure how much data is left, just return 1 as a safe guess. use the EOF flag of the underlying codec instance return baseNCodec.eof ? 0 : 1; } 
public long skip ( long ) hrows IOException { if ( < 0 ) { hrow new IllegalArgumentException ( " Negative skip length: " + ) ; } skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } 
public void estSkipBig ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 6 , b64stream . skip ( Integer . MAX_VALUE ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); } 
public long skip ( long ) hrows IOException { if ( < 0 ) { hrow new IllegalArgumentException ( " Negative skip length: " + ) ; } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] { " Renault " , " rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult " , NameType . GENERIC , RuleType . APPROX , Boolean . TRUE , TEN } , 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); bogus characters to decode (to skip actually) {e-acute*6} byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertEquals("decode hello world", "Hello World", decodeString); } 
public void estDecodePadOnly ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("==".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("=".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("".getBytes("UTF-8")).length); } 
public void estDecodePadOnlyChunked ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( " UTF-8 " ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("==".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("=".getBytes("UTF-8")).length); assertEquals(0, Base64.decodeBase64("".getBytes("UTF-8")).length); } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( " UTF-8 " ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( " UTF-8 " ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object o = Base64 . encodeBase64 ( original . getBytes ( " UTF-8 " ) ) ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object origObj = original . getBytes ( " UTF-8 " ) ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estHugeLineSeparator ( ) { final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192 ; final int Base64_BYTES_PER_ENCODED_BLOCK = 4 ; byte [ ] baLineSeparator = new byte [ BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3 ] ; Base64 b64 = new Base64 ( Base64_BYTES_PER_ENCODED_BLOCK , baLineSeparator ) ; String strOriginal = " Hello World " ; String strDecoded = new String ( b64 . decode ( b64 . encode ( StringUtils . getBytesUtf8 ( strOriginal ) ) ) ) ; assertEquals ( " estDEFAULT_BUFFER_SIZE " , strOriginal , strDecoded ) ; } 
public void estHelloWorldLowerCaseHex ( ) { byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertEquals ( expected , new String ( actual ) ) ; } 
public void estHelloWorldLowerCaseHex ( ) { byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertEquals ( expected . oUpperCase ( ) , new String ( actual ) ) ; } 
public void estHelloWorldLowerCaseHex ( ) { byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
private static String newString ( byte [ ] bytes , Charset charset ) { return bytes = = null ? null : new String ( bytes , charset ) ; } 
public static String newStringIso8859_1 ( byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( byte [ ] bytes ) { return new String ( bytes , Charsets . US_ASCII ) ; } 
public static String newStringUtf16 ( byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16 ) ; } 
public static String newStringUtf16Be ( byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16BE ) ; } 
public static String newStringUtf16Le ( byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16LE ) ; } 
public static String newStringUtf8 ( byte [ ] bytes ) { return newString ( bytes , Charsets . UTF_8 ) ; } 
public void estIso8859_1 ( ) { Assert . assertEquals ( " ISO-8859-1 " , Charsets . ISO_8859_1 . name ( ) ) ; } 
public void estUsAscii ( ) { Assert . assertEquals ( " US-ASCII " , Charsets . US_ASCII . name ( ) ) ; } 
public void estUtf16 ( ) { Assert . assertEquals ( " UTF-16 " , Charsets . UTF_16 . name ( ) ) ; } 
public void estUtf16Be ( ) { Assert . assertEquals ( " UTF-16BE " , Charsets . UTF_16BE . name ( ) ) ; } 
public void estUtf16Le ( ) { Assert . assertEquals ( " UTF-16LE " , Charsets . UTF_16LE . name ( ) ) ; } 
public void estUtf8 ( ) { Assert . assertEquals ( " UTF-8 " , Charsets . UTF_8 . name ( ) ) ; } 
public byte [ ] decode ( byte [ ] array ) hrows DecoderException { return decodeHex ( new String ( array , getCharset ( ) ) . oCharArray ( ) ) ; } 
public byte [ ] encode ( byte [ ] array ) { return encodeHexString ( array ) . getBytes ( his . getCharset ( ) ) ; } 
public Object encode ( Object object ) hrows EncoderException { ry { byte [ ] byteArray = object instanceof String ? ( ( String ) object ) . getBytes ( his . getCharset ( ) ) : ( byte [ ] ) object ; 
public String oString ( ) { return super . oString ( ) + " [charsetName= " + his . charset + " ] " ; } 
private void estCustomCharset ( String name , String parent ) hrows UnsupportedEncodingException , DecoderException { if ( charsetSanityCheck ( name ) = = false ) { return ; } log ( parent + " = " + name ) ; Hex customCodec = new Hex ( name ) ; source data String sourceString = "Hello World"; byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
public void estCustomCharsetBadName ( ) hrows UnsupportedEncodingException { new Hex ( BAD_ENCODING_NAME ) ; } 
public String encode ( final String value , final Charset charset ) hrows EncoderException { if ( value = = null ) { return null ; } return encodeText ( value , charset ) ; } 
public String encode ( final String value , final String charset ) hrows EncoderException { if ( value = = null ) { return null ; } ry { return his . encodeText ( value , charset ) ; 
public String encode ( String value ) hrows EncoderException { if ( value = = null ) { return null ; } return encode ( value , his . getCharset ( ) ) ; } 
public String decode ( String value ) hrows DecoderException { if ( value = = null ) { return null ; } ry { return his . decodeText ( value ) ; 
public String encode ( final String pString , final Charset charset ) hrows EncoderException { if ( pString = = null ) { return null ; } return encodeText ( pString , charset ) ; } 
public String encode ( String pString ) hrows EncoderException { if ( pString = = null ) { return null ; } return encode ( pString , getCharset ( ) ) ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; byte [ ] rawData = his . doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } return his . encodeText ( ext , Charset . forName ( charsetName ) ) ; } 
public String encode ( String pString ) hrows EncoderException { return his . encode ( pString , getCharset ( ) ) ; } 
public String decode ( String pString , Charset charset ) hrows DecoderException { if ( pString = = null ) { return null ; } return new String ( his . decode ( StringUtils . getBytesUsAscii ( pString ) ) , charset ) ; } 
public String decode ( String pString ) hrows DecoderException { return his . decode ( pString , his . getCharset ( ) ) ; } 
public String encode ( String pString , Charset charset ) { if ( pString = = null ) { return null ; } return StringUtils . newStringUsAscii ( his . encode ( pString . getBytes ( charset ) ) ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base-N encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) obj ) ; } 
public Object decode ( Object obj ) hrows DecoderException { if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return his . caverphone ( ( String ) obj ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } return metaphone ( ( String ) obj ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Nysiis encode is not of type java.lang.String " ) ; } return his . nysiis ( ( String ) obj ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) obj ) ; } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) obj ) ; } 
public String encode ( final String str , final Charset charset ) hrows EncoderException { if ( str = = null ) { return null ; } return encodeText ( str , charset ) ; } 
public String encode ( final String str , final String charset ) hrows EncoderException { if ( str = = null ) { return null ; } ry { return encodeText ( str , charset ) ; 
public String encode ( String str ) hrows EncoderException { if ( str = = null ) { return null ; } return encode ( str , getCharset ( ) ) ; } 
public String decode ( String str ) hrows DecoderException { if ( str = = null ) { return null ; } ry { return decodeText ( str ) ; 
public Object encode ( Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; 
public Object decode ( Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; 
public String encode ( String str ) hrows EncoderException { return his . encode ( str , getCharset ( ) ) ; } 
public String decode ( String str , Charset charset ) hrows DecoderException { if ( str = = null ) { return null ; } return new String ( his . decode ( StringUtils . getBytesUsAscii ( str ) ) , charset ) ; } 
public String decode ( String str , String charset ) hrows DecoderException , UnsupportedEncodingException { if ( str = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( str ) ) , charset ) ; } 
public String decode ( String str ) hrows DecoderException { return his . decode ( str , his . getCharset ( ) ) ; } 
public String encode ( String str , Charset charset ) { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( his . encode ( str . getBytes ( charset ) ) ) ; } 
public String encode ( String str , String charset ) hrows UnsupportedEncodingException { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( str . getBytes ( charset ) ) ) ; } 
public String encode ( String str ) hrows EncoderException { if ( str = = null ) { return null ; } ry { return encode ( str , getDefaultCharset ( ) ) ; 
public String decode ( String str ) hrows DecoderException { if ( str = = null ) { return null ; } ry { return decode ( str , getDefaultCharset ( ) ) ; 
private boolean regionMatch ( StringBuffer string , int index , String est ) { boolean matches = false ; if ( index > = 0 & & index + est . length ( ) - 1 < string . length ( ) ) { String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; getMappingCode() throws IllegalArgumentException last = getMappingCode(str, 0); while (incount < str.length() && count < out.length) { mapped = getMappingCode(str, incount++); if (mapped != 0) { if (mapped != '0' && mapped != last) { out[count++] = mapped; } last = mapped; } } return new String(out); } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { public boolean isMatch(CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { public boolean isMatch(CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { public boolean isMatch(CharSequence input) { return endsWith(input, content); } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public boolean isMatch ( CharSequence input ) { return input . length ( ) = = 1 & & contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ; } 
public boolean isMatch ( CharSequence input ) { return input . length ( ) > 0 & & contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ; } 
public boolean isMatch ( CharSequence input ) { return input . length ( ) > 0 & & contains ( bContent , input . charAt ( input . length ( ) - 1 ) ) = = shouldMatch ; } 
public void estIsStringBase64 ( ) { String nullString = null ; String emptyString = " " ; String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; String invalidString = validString + ( char ) 0 ; append null character try { Base64.isBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public void estB650 ( ) hrows EncoderException { his . checkEncodingVariations ( " B650 " , new String [ ] { " BARHAM " , 
public void estEncodeIgnoreApostrophes ( ) hrows EncoderException { his . checkEncodingVariations ( " O165 " , new String [ ] { " OBrien " , 
public void estEncodeIgnoreHyphens ( ) hrows EncoderException { his . checkEncodingVariations ( " K525 " , new String [ ] { " KINGSMITH " , 
public void estHWRuleEx3 ( ) hrows EncoderException { Assert . assertEquals ( " S460 " , his . getSoundexEncoder ( ) . encode ( " Sgler " ) ) ; Assert . assertEquals ( " S460 " , his . getSoundexEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: this.checkEncodingVariations("S460", new String[]{ "SAILOR", 
public void estMsSqlServer2 ( ) hrows EncoderException { his . checkEncodingVariations ( " E625 " , new String [ ] { " Erickson " , " Erickson " , " Erikson " , " Ericson " , " Ericksen " , " Ericsen " } ) ; } 
public boolean matches ( Object item ) { return ( Integer ) item < 0 ; } 
private void encodeAll ( String [ ] strings , String expectedEncoding ) hrows EncoderException { for ( String string : strings ) { Assert . assertEquals ( " Problem with " + string , expectedEncoding , getStringEncoder ( ) . encode ( string ) ) ; 
private static CharSequence cacheSubSequence ( final CharSequence cached ) { return cached; final CharSequence[][] cache = new CharSequence[cached.length()][cached.length()]; return new CharSequence() { @Override 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return endsWith(input, content); } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } System.out.println("Couldn't optimize regex: " + regex); return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public static Charset oCharset ( Charset charset ) { return charset = = null ? Charset . defaultCharset ( ) : charset ; } 
public static Charset oCharset ( String charset ) { return charset = = null ? Charset . defaultCharset ( ) : Charset . forName ( charset ) ; } 
public void estToCharset ( ) { Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( String ) null ) ) ; Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( Charset ) null ) ) ; Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( Charset . defaultCharset ( ) ) ) ; Assert . assertEquals ( Charset . forName ( " UTF-8 " ) , Charsets . oCharset ( Charset . forName ( " UTF-8 " ) ) ) ; } 
public void estBase32Samples ( ) hrows Exception { Base32 codec = new Base32 ( ) ; for ( String [ ] element : BASE32_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { Base32 codec = new Base32 ( rue ) ; for ( String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
public void estBase32Chunked ( ) hrows Exception { Base32 codec = new Base32 ( 20 ) ; for ( String [ ] element : BASE32_TEST_CASES_CHUNKED ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
private static byte [ ] utf8 ( String s ) { We would use commons-codec-1.4.jar own utility method for this, but we need this class to be able to run against commons-codec-1.3.jar, hence the duplication here. return s != null ? s.getBytes(Charsets.UTF_8) : null; } 
public void estCodeInteger1 ( ) hrows UnsupportedEncodingException { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger2 ( ) hrows UnsupportedEncodingException { String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger3 ( ) hrows UnsupportedEncodingException { String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger4 ( ) hrows UnsupportedEncodingException { String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estDecodePadMarkerIndex2 ( ) hrows UnsupportedEncodingException { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) hrows UnsupportedEncodingException { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estDecodePadOnly ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(Charsets.UTF_8)).length); } 
public void estDecodePadOnlyChunked ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(Charsets.UTF_8)).length); } 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( Charsets . UTF_8 ) ) ; StringBuffer intermediate = new StringBuffer ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; 
public void estKnownDecodings ( ) hrows UnsupportedEncodingException { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estKnownEncodings ( ) hrows UnsupportedEncodingException { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object o = Base64 . encodeBase64 ( original . getBytes ( Charsets . UTF_8 ) ) ; Base64 b64 = new Base64 ( ) ; Object oDecoded = b64 . decode ( o ) ; byte [ ] baDecoded = ( byte [ ] ) oDecoded ; String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { String original = " Hello World! " ; Object origObj = original . getBytes ( Charsets . UTF_8 ) ; Base64 b64 = new Base64 ( ) ; Object oEncoded = b64 . encode ( origObj ) ; byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) hrows Exception { Base64 b64 = new Base64 ( ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , new String ( b64 . encode ( " Hello World " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException , UnsupportedEncodingException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( Charsets . UTF_8 ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodeByteArray ( ) hrows UnsupportedEncodingException { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); } 
public void estFromAsciiByteArray ( ) hrows UnsupportedEncodingException { assertEquals ( 0 , BinaryCodec . fromAscii ( ( byte [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new byte [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; collect decoded bytes if (context.modulus == 0) { we can output the 5 bytes context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize, context); 
void encode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
void encode ( byte [ ] in , int inPos , int inAvail , Context context ) { if ( context . eof ) { return ; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { ensureBufferSize ( decodeSize , context ) ; byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. context.eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { ensureBufferSize(decodeSize, context); 
boolean hasData ( Context context ) { package protected for access from I/O streams return context.buffer != null; } 
int available ( Context context ) { package protected for access from I/O streams return context.buffer != null ? context.pos - context.readPos : 0; } 
private void resizeBuffer ( Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ getDefaultBufferSize ( ) ] ; 
protected void ensureBufferSize ( int size , Context context ) { if ( ( context . buffer = = null ) | | ( context . buffer . length < context . pos + size ) ) { resizeBuffer ( context ) ; 
int readResults ( byte [ ] b , int bPos , int bAvail , Context context ) { package protected for access from I/O streams if (context.buffer != null) { int len = Math.min(available(context), bAvail); System.arraycopy(context.buffer, context.readPos, b, bPos, len); context.readPos += len; if (context.readPos >= context.pos) { context.buffer = null; so hasData() will return false, and this method can return -1 } return len; } return context.eof ? EOF : 0; } 
public byte [ ] decode ( byte [ ] pArray ) { Context context = new Context ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; Notify decoder of EOF. byte[] result = new byte[context.pos]; readResults(result, 0, result.length, context); return result; } 
public byte [ ] encode ( byte [ ] pArray ) { Context context = new Context ( ) ; if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } encode ( pArray , 0 , pArray . length , context ) ; encode ( pArray , 0 , EOF , context ) ; Notify encoder of EOF. byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
public int available ( ) hrows IOException { Note: the logic is similar to the InflaterInputStream: as long as we have not reached EOF, indicate that there is more data available. As we do not know for sure how much data is left, just return 1 as a safe guess. return context.eof ? 0 : 1; } 
private void flush ( boolean propogate ) hrows IOException { int avail = baseNCodec . available ( context ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; int c = baseNCodec . readResults ( buf , 0 , avail , context ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public void close ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { baseNCodec.encode(singleByte, 0, EOF, context); } else { baseNCodec.decode(singleByte, 0, EOF, context); } flush(); out.close(); } 
void encode ( byte [ ] pArray , int i , int length , Context context ) { } @Override void decode ( byte [ ] pArray , int i , int length , Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( byte [ ] pArray , int i , int length , Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public synchronized void reset ( ) hrows IOException { hrow new IOException ( " mark/reset not supported " ) ; } 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public void estCodeInteger1 ( ) { String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger2 ( ) { String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger3 ( ) { String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger4 ( ) { String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estDecodePadMarkerIndex2 ( ) { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estDecodePadOnly ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(Charsets.UTF_8)).length); } 
public void estDecodePadOnlyChunked ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(Charsets.UTF_8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(Charsets.UTF_8)).length); } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( Charsets . UTF_8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
void assertDecodeObject ( byte [ ] bits , String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( Charsets . UTF_8 ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodeByteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); } 
public void estFromAsciiByteArray ( ) { assertEquals ( 0 , BinaryCodec . fromAscii ( ( byte [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new byte [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes(Charsets.UTF_8)); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
static void b64from24bit ( byte b2 , byte b1 , byte b0 , int outLen , StringBuilder buffer ) { The bit masking is necessary because the JVM byte type is signed! int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff); It's effectively a "for" loop but kept to resemble the original C code. int n = outLen; while (n-- > 0) { buffer.append(B64T.charAt(w & 0x3f)); 
public static String crypt ( byte [ ] keyBytes ) hrows Exception { return crypt ( keyBytes , null ) ; } 
public static String crypt ( byte [ ] keyBytes , String salt ) hrows Exception { if ( salt = = null ) { return Sha2Crypt . sha512Crypt ( keyBytes ) ; 
public static String crypt ( String key ) hrows Exception { return crypt ( key , null ) ; } 
public static String crypt ( String key , String salt ) hrows Exception { return crypt ( key . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes ) hrows Exception { return apr1Crypt ( keyBytes , APR1_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes , String salt ) hrows Exception { to make the md5Crypt regex happy if (salt != null && !salt.startsWith(APR1_PREFIX)) { salt = APR1_PREFIX + salt; } return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX); } 
public static String apr1Crypt ( String keyBytes ) hrows Exception { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String apr1Crypt ( String keyBytes , String salt ) hrows Exception { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes ) hrows Exception { return md5Crypt ( keyBytes , MD5_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String md5Crypt ( byte [ ] keyBytes , String salt ) hrows Exception { return md5Crypt ( keyBytes , salt , MD5_PREFIX ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) hrows Exception { int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); Matcher m = p.matcher(salt); if (m == null || !m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); MessageDigest ctx = MessageDigest.getInstance(MD5_ALGORITHM); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String sha256Crypt ( byte [ ] keyBytes ) hrows Exception { return sha256Crypt ( keyBytes , null ) ; } 
public static String sha256Crypt ( byte [ ] keyBytes , String salt ) hrows Exception { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , SHA256_ALGORITHM ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes ) hrows Exception { return sha512Crypt ( keyBytes , null ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes , String salt ) hrows Exception { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , SHA512_ALGORITHM ) ; } 
private static int [ ] body ( int schedule [ ] , int eSwap0 , int eSwap1 ) { int left = 0 ; int right = 0 ; int = 0 ; for ( int j = 0 ; j < 25 ; j + + ) { for ( int i = 0 ; i < 32 ; i + = 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } = left ; left = right ; right = ; } = right ; right = left > > > 1 | left < < 31 ; left = > > > 1 | < < 31 ; left & = 0xffffffff ; right & = 0xffffffff ; int results [ ] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; int out [ ] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; } 
private static int byteToUnsigned ( byte b ) { int value = b ; return value < 0 ? value + 256 : value ; } 
private static int dEncrypt ( int el , int r , int s , int e0 , int e1 , int sArr [ ] ) { int v = r ^ r > > > 16 ; int u = v & e0 ; v & = e1 ; u = u ^ u < < 16 ^ r ^ sArr [ s ] ; int = v ^ v < < 16 ^ r ^ sArr [ s + 1 ] ; = > > > 4 | < < 28 ; el ^ = SPTRANS [ 1 ] [ & 0x3f ] | SPTRANS [ 3 ] [ > > > 8 & 0x3f ] | SPTRANS [ 5 ] [ > > > 16 & 0x3f ] | SPTRANS [ 7 ] [ > > > 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u > > > 8 & 0x3f ] | SPTRANS [ 4 ] [ u > > > 16 & 0x3f ] | SPTRANS [ 6 ] [ u > > > 24 & 0x3f ] ; return el ; } 
private static int [ ] desSetKey ( byte key [ ] ) { int schedule [ ] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; int results [ ] = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) & 0xffffffff ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s & 0xffffffff ; } return schedule ; } 
private static int fourBytesToInt ( byte b [ ] , int offset ) { int value = byteToUnsigned ( b [ offset + + ] ) ; value | = byteToUnsigned ( b [ offset + + ] ) < < 8 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 16 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 24 ; return value ; } 
private static int hPermOp ( int a , int , int m ) { int = ( a < < 16 - ^ a ) & m ; a = a ^ ^ > > > 16 - ; return a ; } 
private static void intToFourBytes ( int iValue , byte b [ ] , int offset ) { b [ offset + + ] = ( byte ) ( iValue & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 8 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 16 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 24 & 0xff ) ; } 
private static void permOp ( int a , int b , int , int m , int results [ ] ) { int = ( a > > > ^ b ) & m ; a ^ = < < ; b ^ = ; results [ 0 ] = a ; results [ 1 ] = b ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } for ( ; salt . length ( ) < 2 ; salt = salt + " A " ) ; StringBuilder buffer = new StringBuilder ( " " ) ; char charZero = salt . charAt ( 0 ) ; char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; int eSwap0 = CON_SALT [ charZero ] ; int eSwap1 = CON_SALT [ charOne ] < < 4 ; byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } int schedule [ ] = desSetKey ( key ) ; int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public static String crypt ( String original ) hrows Exception { return crypt ( original . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String crypt ( String original , String salt ) hrows Exception { return crypt ( original . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public void estApr1CryptStrings ( ) hrows Exception { A random example using htpasswd assertEquals("$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.", Md5Crypt.apr1Crypt("secret", "$apr1$TqI9WECO")); empty data assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt("", "$apr1$foo")); salt gets cut at dollar sign assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567$890")); salt gets cut at maximum length assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$1234567890123456")); assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$123456789012345678")); } 
public void estApr1CryptBytes ( ) hrows Exception { An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes("ISO-8859-1"), "$apr1$./$")); } 
public void estApr1CryptExplicitCall ( ) hrows Exception { When explicitly called the prefix is optional assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "1234")); When explicitly called without salt, a random one will be used. assertTrue(Md5Crypt.apr1Crypt("secret".getBytes()).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); assertTrue(Md5Crypt.apr1Crypt("secret".getBytes(), null).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); } 
public void estApr1CryptNullData ( ) hrows Exception { Md5Crypt . apr1Crypt ( ( byte [ ] ) null ) ; } 
public void estApr1CryptWithEmptySalt ( ) hrows Exception { Md5Crypt . apr1Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estB64from24bit ( ) { StringBuilder buffer = new StringBuilder ( " " ) ; B64 . b64from24bit ( ( byte ) 8 , ( byte ) 16 , ( byte ) 64 , 2 , buffer ) ; B64 . b64from24bit ( ( byte ) 7 , ( byte ) 77 , ( byte ) 120 , 4 , buffer ) ; assertEquals ( " ./spo/ " , buffer . oString ( ) ) ; } 
public void estDefaultCryptVariant ( ) hrows Exception { If salt is null or completely omitted, a random "$6$" is used. assertTrue(Crypt.crypt("secret").startsWith("$6$")); assertTrue(Crypt.crypt("secret", null).startsWith("$6$")); } 
public void estCryptWithEmptySalt ( ) hrows Exception { Crypt . crypt ( " secret " , " " ) ; } 
public void estMd5CryptStrings ( ) hrows Exception { empty data assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt("", "$1$foo")); salt gets cut at dollar sign assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567$890")); salt gets cut at maximum length assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$1234567890123456")); assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$123456789012345678")); } 
public void estMd5CryptBytes ( ) hrows Exception { An empty Bytearray equals an empty String assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt(new byte[0], "$1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1", Crypt.crypt("t\u00e4st", "$1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p", Crypt.crypt("t\u00e4st".getBytes("ISO-8859-1"), "$1$./$")); } 
public void estMd5CryptExplicitCall ( ) hrows Exception { assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estMd5CryptNullData ( ) hrows Exception { Md5Crypt . md5Crypt ( ( byte [ ] ) null ) ; } 
public void estMd5CryptWithEmptySalt ( ) hrows Exception { Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha256CryptStrings ( ) hrows Exception { empty data assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt("", "$5$foo")); salt gets cut at dollar sign assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012$456")); salt gets cut at maximum length assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456")); assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456789")); } 
public void estSha256CryptBytes ( ) hrows Exception { An empty Bytearray equals an empty String assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt(new byte[0], "$5$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8", Crypt.crypt("t\u00e4st", "$5$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14", Crypt.crypt("t\u00e4st".getBytes("ISO-8859-1"), "$5$./$")); } 
public void estSha256CryptExplicitCall ( ) hrows Exception { assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha256CryptNullData ( ) hrows Exception { Sha2Crypt . sha256Crypt ( ( byte [ ] ) null ) ; } 
public void estSha256CryptWithEmptySalt ( ) hrows Exception { Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha512CryptStrings ( ) hrows Exception { empty data assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt("", "$6$foo")); salt gets cut at dollar sign assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012$456")); salt gets cut at maximum length assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456")); assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456789")); } 
public void estSha512CryptBytes ( ) hrows Exception { An empty Bytearray equals an empty String assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt(new byte[0], "$6$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1", Crypt.crypt("t\u00e4st", "$6$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.", Crypt.crypt("t\u00e4st".getBytes("ISO-8859-1"), "$6$./$")); } 
public void estSha512CryptExplicitCall ( ) hrows Exception { assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha512CryptNullData ( ) hrows Exception { Sha2Crypt . sha512Crypt ( ( byte [ ] ) null ) ; } 
public void estSha512CryptWithEmptySalt ( ) hrows Exception { Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estUnixCryptStrings ( ) hrows Exception { trivial test assertEquals("xxWAum7tHdIUw", Crypt.crypt("secret", "xx")); empty data assertEquals("12UFlHxel6uMM", Crypt.crypt("", "12")); salt gets cut at maximum length assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12")); assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12345678")); } 
public void estUnixCryptBytes ( ) hrows Exception { An empty Bytearray equals an empty String assertEquals("12UFlHxel6uMM", Crypt.crypt(new byte[0], "12")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("./287bds2PjVw", Crypt.crypt("t\u00e4st", "./")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("./bLIFNqo9XKQ", Crypt.crypt("t\u00e4st".getBytes("ISO-8859-1"), "./")); assertEquals("./bLIFNqo9XKQ", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, "./")); } 
public void estUnixCryptExplicitCall ( ) { A call to crypt() with an empty salt would result in a "$6$" hash. Using unixCrypt() explicitly results in a random salt. assertTrue(UnixCrypt.crypt("secret".getBytes()).matches("^[a-zA-Z0-9./]{13}$")); assertTrue(UnixCrypt.crypt("secret".getBytes(), null).matches("^[a-zA-Z0-9./]{13}$")); } 
public void estUnicCryptInvalidSalt ( ) hrows Exception { UnixCrypt . crypt ( " secret " , " $a " ) ; } 
public void estUnixCryptWithEmptySalt ( ) hrows Exception { UnixCrypt . crypt ( " secret " , " " ) ; } 
public static MessageDigest updateDigest ( final MessageDigest messageDigest , final String valueToDigest ) { messageDigest . update ( getBytesUtf8 ( valueToDigest ) ) ; return messageDigest ; } 
public static MessageDigest updateDigest ( final MessageDigest messageDigest , byte [ ] valueToDigest ) { messageDigest . update ( valueToDigest ) ; return messageDigest ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } for ( ; salt . length ( ) < 2 ; salt = salt + " A " ) { NOOP } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuffer failures = new StringBuffer(); StringBuffer matches = new StringBuffer(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. String msg = failures.toString(); fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; StringBuffer failures = new StringBuffer ( ) ; StringBuffer matches = new StringBuffer ( ) ; String cr = System . getProperty ( " line.separator " ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { String name0 = FIXTURE [ i ] [ 0 ] ; String name1 = FIXTURE [ i ] [ 1 ] ; boolean match1 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; boolean match2 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public void estDecodeWithWhitespace ( ) hrows Exception { String orig = " I am a late night coder. " ; byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( Charsets . UTF_8 ) ) ; StringBuilder intermediate = new StringBuilder ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
private String oString ( byte [ ] data ) { StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { buf . append ( data [ i ] ) ; if ( i ! = data . length - 1 ) { buf . append ( " , " ) ; } } return buf . oString ( ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuilder failures = new StringBuilder(); StringBuilder matches = new StringBuilder(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. String msg = failures.toString(); fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; StringBuilder failures = new StringBuilder ( ) ; StringBuilder matches = new StringBuilder ( ) ; String cr = System . getProperty ( " line.separator " ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { String name0 = FIXTURE [ i ] [ 0 ] ; String name1 = FIXTURE [ i ] [ 1 ] ; boolean match1 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; boolean match2 = his . getDoubleMetaphone ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public void estSpeedCheck ( ) hrows EncoderException { BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; StringBuilder stringBuffer = new StringBuilder ( ) ; stringBuffer . append ( TEST_CHARS [ 0 ] ) ; for ( int i = 0 , j = 1 ; i < 40 ; i + + , j + + ) { if ( j = = TEST_CHARS . length ) { 
private String constructString ( int [ ] unicodeChars ) { StringBuilder buffer = new StringBuilder ( ) ; if ( unicodeChars ! = null ) { for ( int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
private String constructString ( int [ ] unicodeChars ) { StringBuilder buffer = new StringBuilder ( ) ; if ( unicodeChars ! = null ) { for ( int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
private boolean isVowel ( StringBuilder string , int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) > = 0 ; } 
private boolean isPreviousChar ( StringBuilder string , int index , char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
private boolean isNextChar ( StringBuilder string , int index , char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
private boolean regionMatch ( StringBuilder string , int index , String est ) { boolean matches = false ; if ( index > = 0 & & index + est . length ( ) - 1 < string . length ( ) ) { String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. StringBuilder key = new StringBuilder(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } StringBuilder sBuf = new StringBuilder ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; byte [ ] rawData = his . doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; collect decoded bytes if (context.modulus == 0) { we can output the 5 bytes context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize, context); 
public static String encodeBase64URLSafeString ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false , rue ) ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe , int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
public Object decode ( Object obj ) hrows DecoderException { if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public String doubleMetaphone ( String value , boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; DoubleMetaphoneResult result = new DoubleMetaphoneResult ( his . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " DoubleMetaphone encode parameter is not of type String " ) ; } return doubleMetaphone ( ( String ) obj ) ; } 
public boolean isDoubleMetaphoneEqual ( String value1 , String value2 , boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; 
private int handleAEIOUY ( DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'A' ) ; } return index + 1 ; } 
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { very confusing, moved out result.append('K'); index += 2; } else if (index == 0 && contains(value, index, 6, "CAESAR")) { result.append('S'); index += 2; } else if (contains(value, index, 2, "CH")) { index = handleCH(value, result, index); } else if (contains(value, index, 2, "CZ") && !contains(value, index - 2, 4, "WICZ")) { -- "Czerny" -- result.append('S', 'X'); index += 2; } else if (contains(value, index + 1, 3, "CIA")) { -- "focaccia" -- result.append('X'); index += 3; } else if (contains(value, index, 2, "CC") && !(index == 1 && charAt(value, 0) == 'M')) { -- double "cc" but not "McClelland" -- return handleCC(value, result, index); } else if (contains(value, index, 2, "CK", "CG", "CQ")) { result.append('K'); index += 2; } else if (contains(value, index, 2, "CI", "CE", "CY")) { -- Italian vs. English -- if (contains(value, index, 3, "CIO", "CIE", "CIA")) { result.append('S', 'X'); } else { result.append('S'); } index += 2; } else { result.append('K'); if (contains(value, index + 1, 2, " C", " Q", " G")) { -- Mac Caffrey, Mac Gregor -- index += 3; } else if (contains(value, index + 1, 1, "C", "K", "Q") && !contains(value, index + 1, 2, "CE", "CI")) { index += 2; } else { index++; } } return index; } 
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if ((index == 1 && charAt(value, index - 1) == 'A') || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleCH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); 
private int handleD ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " DG " ) ) { -- "Edge" -- if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('J'); index += 3; -- "Edgar" -- } else { result.append("TK"); index += 2; } } else if (contains(value, index, 2, "DT", "DD")) { result.append('T'); index += 2; } else { result.append('T'); index++; } return index; } 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleH ( String value , DoubleMetaphoneResult result , int index ) { -- only keep if first & before vowel or between 2 vowels -- if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) { result.append('H'); index += 2; -- also takes car of "HH" -- } else { index++; } return index; } 
private int handleJ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleL ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index + = 2 ; } else { index + + ; result . append ( 'L' ) ; } return index ; } 
private int handleP ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleR ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")){ -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private boolean conditionCH1 ( String value , int index ) { return ( ( contains ( value , 0 , 4 , " VAN " , " VON " ) | | contains ( value , 0 , 3 , " SCH " ) ) | | 
private boolean conditionL0 ( String value , int index ) { if ( index = = value . length ( ) - 3 & & contains ( value , index - 1 , 4 , " ILLO " , " ILLA " , " ALLE " ) ) { 
private boolean isSlavoGermanic ( String value ) { return value . indexOf ( 'W' ) > - 1 | | value . indexOf ( 'K' ) > - 1 | | value . indexOf ( " CZ " ) > - 1 | | value . indexOf ( " WITZ " ) > - 1 ; 
protected char charAt ( String value , int index ) { if ( index < 0 | | index > = value . length ( ) ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; } 
private static boolean contains ( String value , int start , int length , String criteria ) { return contains ( value , start , length , new String [ ] { criteria } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 } ) ; 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 , String criteria5 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 , String criteria5 , String criteria6 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , 
protected static boolean contains ( String value , int start , int length , String [ ] criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { String arget = value . substring ( start , start + length ) ; for ( String element : criteria ) { if ( arget . equals ( element ) ) { result = rue ; break ; } } } return result ; } 
public boolean isComplete ( ) { return his . primary . length ( ) > = his . maxLength & & his . alternate . length ( ) > = his . maxLength ; 
public Object encode ( Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } return metaphone ( ( String ) obj ) ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( byte b : bytes ) { if ( b = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { byte [ ] mp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { byte b = bytes [ i ] ; if ( b ! = UNDERSCORE ) { mp [ i ] = b ; } else { mp [ i ] = BLANK ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( mp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; byte [ ] rawData = his . doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } return his . encodeText ( ext , Charset . forName ( charsetName ) ) ; } 
protected abstract String getEncoding ( ) ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
protected abstract byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
public void estComparatorWithSoundex ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertTrue ( " O'Brien and O'Brian didn't come out with " + " he same Soundex, something must be wrong here " , 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; int compare = sCompare . compare ( new Double ( 3.0 ) , Long . valueOf ( 3 ) ) ; assertEquals ( " Trying to compare objects that make no sense to the underlying encoder should return a zero compare code " , 0 , compare ) ; 
private static byte [ ] utf8 ( String s ) { We would use commons-codec-1.4.jar own utility method for this, but we need this class to be able to run against commons-codec-1.3.jar, hence the duplication here. return s != null ? s.getBytes(Charsets.UTF_8) : null; } 
public void estIsStringBase64 ( ) { String nullString = null ; String emptyString = " " ; String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; String invalidString = validString + ( char ) 0 ; append null character try { Base64.isBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public void estBase64 ( ) { String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); bogus characters to decode (to skip actually) {e-acute*6} byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); String decodeString = StringUtils.newStringUtf8(decode); assertEquals("decode hello world", "Hello World", decodeString); } 
void encode ( byte [ ] pArray , int i , int length , Context context ) { } @Override void decode ( byte [ ] pArray , int i , int length , Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( byte [ ] pArray , int i , int length , Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public void estCustomCharset ( ) hrows UnsupportedEncodingException , DecoderException { for ( String name : Charset . availableCharsets ( ) . keySet ( ) ) { estCustomCharset ( name , " estCustomCharset " ) ; 
public void estSha256 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc")); assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex(getBytesUtf8("abc"))); assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1", DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); 
public void estSha384 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc")); assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex(getBytesUtf8("abc"))); assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039", DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); 
public void estSha512 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(new ByteArrayInputStream(testData))); 
public void estSetMaxCodeLength ( ) { String value = " jumped " ; DoubleMetaphone doubleMetaphone = new DoubleMetaphone ( ) ; Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuilder failures = new StringBuilder(); StringBuilder matches = new StringBuilder(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. String msg = failures.toString(); fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getDoubleMetaphone().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getDoubleMetaphone().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estWhy ( ) { PHP returns "H". The original metaphone returns an empty string. assertEquals("", this.getMetaphone().metaphone("WHY")); } 
private String constructString ( int [ ] unicodeChars ) { StringBuilder buffer = new StringBuilder ( ) ; if ( unicodeChars ! = null ) { for ( int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QCodec qcodec = new QCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " = Hello there = r " ; String encoded = qcodec . encode ( plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?=3D Hello there =3D=0D=0A?= " , encoded ) ; assertEquals ( " Basic Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " ?_= r " ; String encoded = qcodec . encode ( plain ) ; assertEquals ( " Unsafe chars Q encoding test " , " =?UTF-8?Q?=3F=5F=3D=0D=0A?= " , encoded ) ; assertEquals ( " Unsafe chars Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; assertNull ( " Null string Q encoding test " , qcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string Q decoding test " , qcodec . decode ( ( String ) null ) ) ; 
public void estEncodeObjects ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; Object result = qcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { QCodec qcodec = new QCodec ( ) ; String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; Object result = qcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " = Hello there = r " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " =3D Hello there =3D=0D=0A " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estSafeCharEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " abc123_-.*~!@#$%^&()+{} \" \\ ;:`,/[] " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Safe chars quoted-printable encoding test " , plain , encoded ) ; assertEquals ( " Safe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " = r " ; String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Unsafe chars quoted-printable encoding test " , " =3D=0D=0A " , encoded ) ; assertEquals ( " Unsafe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertNull ( " Null string quoted-printable encoding test " , qpcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string quoted-printable decoding test " , qpcodec . decode ( ( String ) null ) ) ; 
public void estEncodeNull ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; byte [ ] plain = null ; byte [ ] encoded = qpcodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; 
public void estUTF8RoundTrip ( ) hrows Exception { String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; his . validateState ( urlCodec ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " abc123_-.* " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Safe chars URL encoding test " , plain , encoded ) ; assertEquals ( " Safe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Unsafe chars URL encoding test " , " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded ) ; assertEquals ( " Unsafe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; assertNull ( " Null string URL encoding test " , urlCodec . encode ( ( String ) null ) ) ; assertNull ( " Null string URL decoding test " , urlCodec . decode ( ( String ) null ) ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeInvalid ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; ry { urlCodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( DecoderException e ) { Expected. Move on } try { urlCodec.decode("%A"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { Bad 1st char after % urlCodec.decode("%WW"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } try { Bad 2nd char after % urlCodec.decode("%0W"); fail("DecoderException should have been thrown"); } catch (DecoderException e) { Expected. Move on } this.validateState(urlCodec); } 
public void estDecodeInvalidContent ( ) hrows UnsupportedEncodingException , DecoderException { String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; URLCodec urlCodec = new URLCodec ( ) ; byte [ ] input = ch_msg . getBytes ( " ISO-8859-1 " ) ; byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } his . validateState ( urlCodec ) ; } 
public void estEncodeNull ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; byte [ ] plain = null ; byte [ ] encoded = urlCodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { URLCodec urlCodec = new URLCodec ( ) ; String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
private static int dEncrypt ( int el , int r , int s , int e0 , int e1 , int sArr [ ] ) { int v = r ^ r > > > 16 ; int u = v & e0 ; v & = e1 ; u = u ^ u < < 16 ^ r ^ sArr [ s ] ; int = v ^ v < < 16 ^ r ^ sArr [ s + 1 ] ; = > > > 4 | < < 28 ; el ^ = SPTRANS [ 1 ] [ & 0x3f ] | SPTRANS [ 3 ] [ > > > 8 & 0x3f ] | SPTRANS [ 5 ] [ > > > 16 & 0x3f ] | SPTRANS [ 7 ] [ > > > 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u > > > 8 & 0x3f ] | SPTRANS [ 4 ] [ u > > > 16 & 0x3f ] | SPTRANS [ 6 ] [ u > > > 24 & 0x3f ] ; return el ; } 
public static String crypt ( byte [ ] keyBytes ) hrows NoSuchAlgorithmException { return crypt ( keyBytes , null ) ; } 
public static String crypt ( byte [ ] keyBytes , String salt ) hrows NoSuchAlgorithmException { if ( salt = = null ) { return Sha2Crypt . sha512Crypt ( keyBytes ) ; 
public static String crypt ( String key ) hrows NoSuchAlgorithmException { return crypt ( key , null ) ; } 
public static String crypt ( String key , String salt ) hrows NoSuchAlgorithmException { return crypt ( key . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes ) hrows NoSuchAlgorithmException { return apr1Crypt ( keyBytes , APR1_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes , String salt ) hrows NoSuchAlgorithmException { to make the md5Crypt regex happy if (salt != null && !salt.startsWith(APR1_PREFIX)) { salt = APR1_PREFIX + salt; } return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX); } 
public static String apr1Crypt ( String keyBytes ) hrows NoSuchAlgorithmException { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String apr1Crypt ( String keyBytes , String salt ) hrows NoSuchAlgorithmException { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes ) hrows NoSuchAlgorithmException { return md5Crypt ( keyBytes , MD5_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String md5Crypt ( byte [ ] keyBytes , String salt ) hrows NoSuchAlgorithmException { return md5Crypt ( keyBytes , salt , MD5_PREFIX ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) hrows NoSuchAlgorithmException { int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (m == null || !m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); MessageDigest ctx = MessageDigest.getInstance(MD5_ALGORITHM); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String sha256Crypt ( byte [ ] keyBytes ) hrows NoSuchAlgorithmException { return sha256Crypt ( keyBytes , null ) ; } 
public static String sha256Crypt ( byte [ ] keyBytes , String salt ) hrows NoSuchAlgorithmException { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , SHA256_ALGORITHM ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes ) hrows NoSuchAlgorithmException { return sha512Crypt ( keyBytes , null ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes , String salt ) hrows NoSuchAlgorithmException { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , SHA512_ALGORITHM ) ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] + SALT_CHARS [ Math . abs ( randomGenerator . nextInt ( ) ) % numSaltChars ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } for ( ; salt . length ( ) < 2 ; salt = salt + " A " ) { NOOP } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
public static String crypt ( String original ) { return crypt ( original . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String crypt ( String original , String salt ) { return crypt ( original . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public void estApr1CryptStrings ( ) hrows NoSuchAlgorithmException { A random example using htpasswd assertEquals("$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.", Md5Crypt.apr1Crypt("secret", "$apr1$TqI9WECO")); empty data assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt("", "$apr1$foo")); salt gets cut at dollar sign assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567$890")); salt gets cut at maximum length assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$1234567890123456")); assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$123456789012345678")); } 
public void estApr1CryptBytes ( ) hrows NoSuchAlgorithmException { An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptExplicitCall ( ) hrows NoSuchAlgorithmException { When explicitly called the prefix is optional assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "1234")); When explicitly called without salt, a random one will be used. assertTrue(Md5Crypt.apr1Crypt("secret".getBytes()).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); assertTrue(Md5Crypt.apr1Crypt("secret".getBytes(), null).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); } 
public void estApr1CryptNullData ( ) hrows NoSuchAlgorithmException { Md5Crypt . apr1Crypt ( ( byte [ ] ) null ) ; } 
public void estApr1CryptWithEmptySalt ( ) hrows NoSuchAlgorithmException { Md5Crypt . apr1Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estDefaultCryptVariant ( ) hrows NoSuchAlgorithmException { If salt is null or completely omitted, a random "$6$" is used. assertTrue(Crypt.crypt("secret").startsWith("$6$")); assertTrue(Crypt.crypt("secret", null).startsWith("$6$")); } 
public void estCryptWithEmptySalt ( ) hrows NoSuchAlgorithmException { Crypt . crypt ( " secret " , " " ) ; } 
public void estMd5CryptStrings ( ) hrows NoSuchAlgorithmException { empty data assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt("", "$1$foo")); salt gets cut at dollar sign assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567$890")); salt gets cut at maximum length assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$1234567890123456")); assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$123456789012345678")); } 
public void estMd5CryptBytes ( ) hrows NoSuchAlgorithmException { An empty Bytearray equals an empty String assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt(new byte[0], "$1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1", Crypt.crypt("t\u00e4st", "$1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$1$./$")); } 
public void estMd5CryptExplicitCall ( ) hrows NoSuchAlgorithmException { assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estMd5CryptNullData ( ) hrows NoSuchAlgorithmException { Md5Crypt . md5Crypt ( ( byte [ ] ) null ) ; } 
public void estMd5CryptWithEmptySalt ( ) hrows NoSuchAlgorithmException { Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha256CryptStrings ( ) hrows NoSuchAlgorithmException { empty data assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt("", "$5$foo")); salt gets cut at dollar sign assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012$456")); salt gets cut at maximum length assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456")); assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456789")); } 
public void estSha256CryptBytes ( ) hrows NoSuchAlgorithmException { An empty Bytearray equals an empty String assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt(new byte[0], "$5$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8", Crypt.crypt("t\u00e4st", "$5$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$5$./$")); } 
public void estSha256CryptExplicitCall ( ) hrows NoSuchAlgorithmException { assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha256CryptNullData ( ) hrows NoSuchAlgorithmException { Sha2Crypt . sha256Crypt ( ( byte [ ] ) null ) ; } 
public void estSha256CryptWithEmptySalt ( ) hrows NoSuchAlgorithmException { Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha512CryptStrings ( ) hrows NoSuchAlgorithmException { empty data assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt("", "$6$foo")); salt gets cut at dollar sign assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012$456")); salt gets cut at maximum length assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456")); assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456789")); } 
public void estSha512CryptBytes ( ) hrows NoSuchAlgorithmException { An empty Bytearray equals an empty String assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt(new byte[0], "$6$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1", Crypt.crypt("t\u00e4st", "$6$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$6$./$")); } 
public void estSha512CryptExplicitCall ( ) hrows NoSuchAlgorithmException { assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha512CryptNullData ( ) hrows NoSuchAlgorithmException { Sha2Crypt . sha512Crypt ( ( byte [ ] ) null ) ; } 
public void estSha512CryptWithEmptySalt ( ) hrows NoSuchAlgorithmException { Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estUnixCryptStrings ( ) hrows NoSuchAlgorithmException { trivial test assertEquals("xxWAum7tHdIUw", Crypt.crypt("secret", "xx")); empty data assertEquals("12UFlHxel6uMM", Crypt.crypt("", "12")); salt gets cut at maximum length assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12")); assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12345678")); } 
public void estUnixCryptBytes ( ) hrows NoSuchAlgorithmException { An empty Bytearray equals an empty String assertEquals("12UFlHxel6uMM", Crypt.crypt(new byte[0], "12")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("./287bds2PjVw", Crypt.crypt("t\u00e4st", "./")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("./bLIFNqo9XKQ", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "./")); assertEquals("./bLIFNqo9XKQ", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, "./")); } 
public boolean patternAndContextMatches ( CharSequence input , int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } int patternLength = his . pattern . length ( ) ; int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } evaluate the pattern, left context and right context fail early if any of the evaluations is not successful if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); } 
public static Lang loadFromResource ( String languageRulesResourceName , Languages languages ) { List < LangRule > rules = new ArrayList < LangRule > ( ) ; InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; } else { discard doc comment line } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up String[] parts = line.split("\\s+"); if (parts.length != 3) { FIXME: consider throwing an IllegalStateException like in Rule System.err.println("Warning: malformed line '" + rawLine + "'"); continue; } Pattern pattern = Pattern.compile(parts[0]); String[] langs = parts[1].split("\\+"); boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
public Languages . LanguageSet guessLanguages ( String input ) { String ext = input . oLowerCase ( Locale . ENGLISH ) ; Set < String > langs = new HashSet < String > ( his . languages . getLanguages ( ) ) ; for ( LangRule rule : his . rules ) { if ( rule . matches ( ext ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } } Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 0 ; for ( Rule rule : his . finalRules ) { String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( ! rule . patternAndContextMatches ( his . input , his . i ) ) { continue ; } his . phonemeBuilder = his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' String remainder = input.substring(2); String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list String remainder = input.substring(l.length() + 1); input without the prefix String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (String aWord : words) { String[] parts = aWord.split("'"); String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) StringBuilder result = new StringBuilder(); for (String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr System.err.println("Warning: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return endsWith(input, content); } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public void estSolrGENERIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); assertEquals(encode(args, true, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<String, String>(); assertEquals(encode(args, false, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<String, String>(); assertEquals(encode(args, true, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, true, "D'Angelo"), "(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<String, String>(); assertEquals(encode(args, false, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, false, "D'Angelo"), "(agilo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongilo|oniilo|onilo|onxilo|onzilo)-(dagilo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrASHKENAZI ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); assertEquals(encode(args, true, "D'Angelo"), "dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "AnSelO|AngElO|AngzelO|AnkselO"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "AnElO|AnSelO|AngElO|AngzelO|AnkselO|AnzelO"); assertEquals(encode(args, false, "D'Angelo"), "dAnElO|dAnSelO|dAngElO|dAngzelO|dAnkselO|dAnzelO"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "AnSelO|AngElO|AngzelO|AnkselO"); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrSEPHARDIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "anZelo|andZelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "anZelo|andZelo|anxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "andZelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "anZelo|andZelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "danZelo|dandZelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "andZelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, true, "D'Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, false, "D'Angelo"), "danhila|danhilu|danzila|danzilu|nhila|nhilu|nzila|nzilu"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, false, "1234"), ""); } 
private static String encode ( Map < String , String > args , boolean concat , String input ) { Languages . LanguageSet languageSet ; PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true String nameTypeArg = args.get("nameType"); NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg); String ruleTypeArg = args.get("ruleType"); RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); 
public String makeString ( ) { final StringBuilder sb = new StringBuilder ( ) ; for ( Rule . Phoneme ph : his . phonemes ) { if ( sb . length ( ) > 0 ) { sb . append ( " | " ) ; } sb . append ( ph . getPhonemeText ( ) ) ; } return sb . oString ( ) ; } 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do ensureBufferSize(decodeSize, context); 
public boolean isDoubleMetaphoneEqual ( String value1 , String value2 , boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; } 
private int handleAEIOUY ( DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'A' ) ; } return index + 1 ; } 
private int handleC ( String value , DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { very confusing, moved out result.append('K'); index += 2; } else if (index == 0 && contains(value, index, 6, "CAESAR")) { result.append('S'); index += 2; } else if (contains(value, index, 2, "CH")) { index = handleCH(value, result, index); } else if (contains(value, index, 2, "CZ") && !contains(value, index - 2, 4, "WICZ")) { -- "Czerny" -- result.append('S', 'X'); index += 2; } else if (contains(value, index + 1, 3, "CIA")) { -- "focaccia" -- result.append('X'); index += 3; } else if (contains(value, index, 2, "CC") && !(index == 1 && charAt(value, 0) == 'M')) { -- double "cc" but not "McClelland" -- return handleCC(value, result, index); } else if (contains(value, index, 2, "CK", "CG", "CQ")) { result.append('K'); index += 2; } else if (contains(value, index, 2, "CI", "CE", "CY")) { -- Italian vs. English -- if (contains(value, index, 3, "CIO", "CIE", "CIA")) { result.append('S', 'X'); } else { result.append('S'); } index += 2; } else { result.append('K'); if (contains(value, index + 1, 2, " C", " Q", " G")) { -- Mac Caffrey, Mac Gregor -- index += 3; } else if (contains(value, index + 1, 1, "C", "K", "Q") && !contains(value, index + 1, 2, "CE", "CI")) { index += 2; } else { index++; } } return index; } 
private int handleCC ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if ((index == 1 && charAt(value, index - 1) == 'A') || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleCH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); 
private int handleG ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( String value , DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleH ( String value , DoubleMetaphoneResult result , int index ) { -- only keep if first & before vowel or between 2 vowels -- if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) { result.append('H'); index += 2; -- also takes car of "HH" -- } else { index++; } return index; } 
private int handleJ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleL ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index + = 2 ; } else { index + + ; result . append ( 'L' ) ; } return index ; } 
private int handleP ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleR ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( String value , DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( String value , DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( String value , DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( String value , DoubleMetaphoneResult result , int index , boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private boolean conditionCH1 ( String value , int index ) { return ( ( contains ( value , 0 , 4 , " VAN " , " VON " ) | | contains ( value , 0 , 3 , " SCH " ) ) | | contains ( value , index - 2 , 6 , " ORCHES " , " ARCHIT " , " ORCHID " ) | | 
private boolean conditionM0 ( String value , int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( ( index + 1 ) = = value . length ( ) - 1 | | contains ( value , index + 2 , 2 , " ER " ) ) ; 
private static boolean contains ( String value , int start , int length , String criteria ) { return contains ( value , start , length , new String [ ] { criteria } ) ; } 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 } ) ; } 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 } ) ; } 
private static boolean contains ( String value , int start , int length , String criteria1 , String criteria2 , String criteria3 , String criteria4 ) { return contains ( value , start , length , new String [ ] { criteria1 , criteria2 , criteria3 , criteria4 } ) ; 
public boolean isComplete ( ) { return his . primary . length ( ) > = his . maxLength & & his . alternate . length ( ) > = his . maxLength ; 
public synchronized void mark ( int readLimit ) { } @Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public Object encode ( Object object ) hrows EncoderException { ry { byte [ ] byteArray = object instanceof String ? 
public Phoneme join ( Phoneme right ) { return new Phoneme ( his . phonemeText . oString ( ) + right . phonemeText . oString ( ) , his . languages . restrictTo ( right . languages ) ) ; 
private static String createResourceName ( NameType nameType , RuleType rt , String lang ) { return String . format ( " org/apache/commons/codec/language/bm/%s_%s_%s.txt " , nameType . getName ( ) , rt . getName ( ) , lang ) ; 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr System.err.println("Warning: malformed import statement: " + rawLine); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { FIXME: consider throwing an IllegalStateException like in parsePhonemeExpr System.err.println("Warning: malformed rule statement split into " + parts.length + " parts: " + rawLine); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line " + currentLine, e); } } } } } } return lines; } 
private static RPattern pattern ( final String regex ) { boolean startsWith = regex . startsWith ( " ^ " ) ; boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(CharSequence input) { return endsWith(input, content); } }; } } else { boolean startsWithBox = content.startsWith("["); boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public boolean isMatch ( CharSequence input ) { return input . length ( ) > 0 & & contains ( bContent , input . charAt ( input . length ( ) - 1 ) ) = = shouldMatch ; 
public String encode ( String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("l", "2"); 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
int readResults ( byte [ ] b , int bPos , int bAvail , Context context ) { if ( context . buffer ! = null ) { int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( context . readPos > = context . pos ) { context . buffer = null ; so hasData() will return false, and this method can return -1 } return len; } return context.eof ? EOF : 0; } 
private byte [ ] resizeBuffer ( Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ getDefaultBufferSize ( ) ] ; context . pos = 0 ; context . readPos = 0 ; } else { byte [ ] b = new byte [ context . buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; } return context . buffer ; } 
protected byte [ ] ensureBufferSize ( int size , Context context ) { if ( ( context . buffer = = null ) | | ( context . buffer . length < context . pos + size ) ) { return resizeBuffer ( context ) ; } return context . buffer ; } 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, modulus=%s, pos=%s, readPos=%s] " , 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. context.eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. context.eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( byte [ ] in , int inPos , int inAvail , Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
public void estWriteOutOfBounds ( ) hrows Exception { byte [ ] buf = new byte [ 1024 ] ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); fail("Expected Base32OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } out.close(); } 
public void estWriteToNullCoverage ( ) hrows Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( null , 0 , 0 ) ; fail ( " Expcted Base32OutputStream.write(null) to throw a NullPointerException " ) ; } catch ( NullPointerException e ) { Expected } out.close(); } 
public void estWriteOutOfBounds ( ) hrows Exception { byte [ ] buf = new byte [ 1024 ] ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); fail("Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException ioobe) { Expected } out.close(); } 
public void estAvailable ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 1 , b32stream . available ( ) ) ; assertEquals ( 3 , b32stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b32stream.available()); assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); assertEquals(0, b32stream.available()); b32stream.close(); } 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base32InputStream.markSupported() is false", in.markSupported()); in.close(); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base32InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; in . close ( ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; fail ( " Base32InputStream.read(null, 0, 0) to throw a NullPointerException " ) ; } catch ( NullPointerException e ) { Expected } in.close(); } 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); fail("Base32InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } in.close(); } 
public void estSkipNone ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b32stream . skip ( 0 ) ) ; b32stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 102 , 111 , 111 , 0 , 0 , 0 } ) ; End of stream reached assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipBig ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 3 , b32stream . skip ( 1024 ) ) ; End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(10)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close();} 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(3)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipWrongArgument ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; Base32InputStream b32stream = new Base32InputStream ( ins ) ; b32stream . skip ( - 10 ) ; b32stream . close ( ) ; } 
public void estCodec101 ( ) hrows Exception { byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; Base64InputStream in = new Base64InputStream ( bais ) ; byte [ ] result = new byte [ 8192 ] ; int c = in . read ( result ) ; assertTrue ( " Codec101: First read successful [c= " + c + " ] " , c > 0 ) ; c = in . read ( result ) ; assertTrue ( " Codec101: Second read should report end-of-stream [c= " + c + " ] " , c < 0 ) ; in . close ( ) ; } 
public void estInputStreamReader ( ) hrows Exception { byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; Base64InputStream in = new Base64InputStream ( bais ) ; InputStreamReader isr = new InputStreamReader ( in ) ; BufferedReader br = new BufferedReader ( isr ) ; String line = br . readLine ( ) ; assertNotNull ( " Codec101: InputStreamReader works! " , line ) ; br . close ( ) ; } 
public void estAvailable ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 1 , b64stream . available ( ) ) ; assertEquals ( 6 , b64stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b64stream.available()); assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); assertEquals(0, b64stream.available()); b64stream.close(); } 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
public void estMarkSupported ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); in.close(); } 
public void estRead0 ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; in . close ( ) ; } 
public void estReadNull ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; fail ( " Base64InputStream.read(null, 0, 0) to throw a NullPointerException " ) ; } catch ( NullPointerException e ) { Expected } in.close(); } 
public void estReadOutOfBounds ( ) hrows Exception { byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; byte [ ] buf = new byte [ 1024 ] ; ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); fail("Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException"); } catch (IndexOutOfBoundsException e) { Expected } in.close(); } 
public void estSkipBig ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 6 , b64stream . skip ( Integer . MAX_VALUE ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipNone ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b64stream . skip ( 0 ) ) ; b64stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 0 , 0 , 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 } ) ; End of stream reached assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipPastEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(10)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipToEnd ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(6)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipWrongArgument ( ) hrows Throwable { InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; Base64InputStream b64stream = new Base64InputStream ( ins ) ; b64stream . skip ( - 10 ) ; b64stream . close ( ) ; } 
public static Lang loadFromResource ( String languageRulesResourceName , Languages languages ) { List < LangRule > rules = new ArrayList < LangRule > ( ) ; InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inExtendedComment = false ; } else { discard doc comment line } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } Pattern pattern = Pattern.compile(parts[0]); String[] langs = parts[1].split("\\+"); boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } else { skip } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inMultilineComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; byte [ ] rawData = his . doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException , UnsupportedEncodingException { if ( ext = = null ) { return null ; } return his . encodeText ( ext , Charset . forName ( charsetName ) ) ; } 
protected abstract String getEncoding ( ) ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
protected abstract byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException ; protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; Types casts fix two FindBugs report of RV_ABSOLUTE_VALUE_OF_RANDOM_INT. salt = "" + SALT_CHARS[(int)Math.abs((long)randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[(int)Math.abs((long)randomGenerator.nextInt()) % numSaltChars]; } else if (!salt.matches("^[" + B64.B64T + "]{2,}$")) { throw new IllegalArgumentException("Invalid salt value: " + salt); } for (; salt.length() < 2; salt = salt + "A") { NOOP } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " + " modulus=%s, pos=%s, readPos=%s] " , his . getClass ( ) . getSimpleName ( ) , buffer , currentLinePos , eof , 
public static String crypt ( byte [ ] keyBytes , String salt ) { if ( salt = = null ) { return Sha2Crypt . sha512Crypt ( keyBytes ) ; 
public static String crypt ( String key , String salt ) { return crypt ( key . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes ) { return apr1Crypt ( keyBytes , APR1_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String apr1Crypt ( byte [ ] keyBytes , String salt ) { to make the md5Crypt regex happy if (salt != null && !salt.startsWith(APR1_PREFIX)) { salt = APR1_PREFIX + salt; } return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX); } 
public static String apr1Crypt ( String keyBytes ) { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String apr1Crypt ( String keyBytes , String salt ) { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes ) { return md5Crypt ( keyBytes , MD5_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String md5Crypt ( byte [ ] keyBytes , String salt ) { return md5Crypt ( keyBytes , salt , MD5_PREFIX ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) { int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (m == null || !m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String sha256Crypt ( byte [ ] keyBytes ) { return sha256Crypt ( keyBytes , null ) ; } 
public static String sha256Crypt ( byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithms . SHA_256 ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes ) { return sha512Crypt ( keyBytes , null ) ; } 
public static String sha512Crypt ( byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , MessageDigestAlgorithms . SHA_512 ) ; } 
public void estApr1CryptStrings ( ) { A random example using htpasswd assertEquals("$apr1$TqI9WECO$LHZB2DqRlk9nObiB6vJG9.", Md5Crypt.apr1Crypt("secret", "$apr1$TqI9WECO")); empty data assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt("", "$apr1$foo")); salt gets cut at dollar sign assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567")); assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "$apr1$1234$567$890")); salt gets cut at maximum length assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$1234567890123456")); assertEquals("$apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0", Md5Crypt.apr1Crypt("secret", "$apr1$123456789012345678")); } 
public void estApr1CryptBytes ( ) { random salt byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; String hash = Md5Crypt.apr1Crypt(keyBytes); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptExplicitCall ( ) { When explicitly called the prefix is optional assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "1234")); When explicitly called without salt, a random one will be used. assertTrue(Md5Crypt.apr1Crypt("secret".getBytes()).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); assertTrue(Md5Crypt.apr1Crypt("secret".getBytes(), null).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); } 
public void estApr1LongSalt ( ) { assertEquals ( " $apr1$12345678$0lqb/6VUFP8JY/s/jTrIk0 " , Md5Crypt . apr1Crypt ( " secret " , " 12345678901234567890 " ) ) ; } 
public void estApr1CryptWithEmptySalt ( ) { Md5Crypt . apr1Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estApr1CryptWithoutSalt ( ) { Without salt, a random is generated String hash = Md5Crypt.apr1Crypt("secret"); assertTrue(hash.matches("^\\$apr1\\$[a-zA-Z0-9\\./]{8}\\$[a-zA-Z0-9\\./]{22}$")); String hash2 = Md5Crypt.apr1Crypt("secret"); assertNotSame(hash, hash2); } 
public void estApr1CryptWithInvalidSalt ( ) { Md5Crypt . apr1Crypt ( new byte [ 0 ] , " ! " ) ; } 
public void estB64T ( ) { assertNotNull ( new B64 ( ) ) ; for the 100% code coverage :) assertEquals(64, B64.B64T.length()); } 
public void estCrypt ( ) { assertNotNull ( new Crypt ( ) ) ; just for Test Coverage } 
public void estDefaultCryptVariant ( ) { If salt is null or completely omitted, a random "$6$" is used. assertTrue(Crypt.crypt("secret").startsWith("$6$")); assertTrue(Crypt.crypt("secret", null).startsWith("$6$")); } 
public void estCryptWithBytes ( ) { byte [ ] keyBytes = new byte [ ] { 'b' , 'y' , 't' , 'e' } ; String hash = Crypt . crypt ( keyBytes ) ; assertEquals ( hash , Crypt . crypt ( " byte " , hash ) ) ; } 
public void estCtor ( ) { assertNotNull ( new Md5Crypt ( ) ) ; for code-coverage } 
public void estMd5CryptStrings ( ) { empty data assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt("", "$1$foo")); salt gets cut at dollar sign assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567")); assertEquals("$1$1234$ImZYBLmYC.rbBKg9ERxX70", Crypt.crypt("secret", "$1$1234$567$890")); salt gets cut at maximum length assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$1234567890123456")); assertEquals("$1$12345678$hj0uLpdidjPhbMMZeno8X/", Crypt.crypt("secret", "$1$123456789012345678")); } 
public void estMd5CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt(new byte[0], "$1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1", Crypt.crypt("t\u00e4st", "$1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$1$./$")); } 
public void estMd5CryptExplicitCall ( ) { assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estMd5CryptLongInput ( ) { assertEquals ( " $1$1234$MoxekaNNUgfPRVqoeYjCD/ " , Crypt . crypt ( " 12345678901234567890 " , " $1$1234 " ) ) ; } 
public void estMd5CryptWithEmptySalt ( ) { Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha256CryptStrings ( ) { empty data assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt("", "$5$foo")); salt gets cut at dollar sign assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012")); assertEquals("$5$45678$LulJuUIJIn.1uU.KPV9x92umMYFopzVDD.o2ZqA1i2/", Crypt.crypt("secret", "$5$45678$012$456")); salt gets cut at maximum length assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456")); assertEquals("$5$1234567890123456$GUiFKBSTUAGvcK772ulTDPltkTOLtFvPOmp9o.9FNPB", Crypt.crypt("secret", "$5$1234567890123456789")); } 
public void estSha256CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt(new byte[0], "$5$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8", Crypt.crypt("t\u00e4st", "$5$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$5$./$")); } 
public void estSha2CryptRounds ( ) { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd")); } 
public void estSha256CryptExplicitCall ( ) { assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $5 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha256CryptNullData ( ) { Sha2Crypt . sha256Crypt ( ( byte [ ] ) null ) ; } 
public void estSha256CryptWithEmptySalt ( ) { Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha256LargetThanBlocksize ( ) { byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8 " , Sha2Crypt . sha256Crypt ( buffer , " $5$abc " ) ) ; } 
public void estSha512CryptStrings ( ) { empty data assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt("", "$6$foo")); salt gets cut at dollar sign assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012$456")); salt gets cut at maximum length assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456")); assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456789")); } 
public void estSha512CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt(new byte[0], "$6$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1", Crypt.crypt("t\u00e4st", "$6$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$6$./$")); } 
public void estSha512CryptExplicitCall ( ) { assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , null ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
public void estSha512CryptNullData ( ) { Sha2Crypt . sha512Crypt ( ( byte [ ] ) null ) ; } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd")); } @Test(expected = IllegalArgumentException.class) public void testSha2CryptWrongSalt() { Sha2Crypt.sha512Crypt("secret".getBytes(Charsets.UTF_8), "xx"); } @Test(expected = IllegalArgumentException.class) public void testSha512CryptWithEmptySalt() { Sha2Crypt.sha512Crypt("secret".getBytes(), ""); } @Test public void testSha256LargetThanBlocksize() { byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); }} 
public void estSha2CryptWrongSalt ( ) { Sha2Crypt . sha512Crypt ( " secret " . getBytes ( Charsets . UTF_8 ) , " xx " ) ; } 
public void estSha512CryptWithEmptySalt ( ) { Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , " " ) ; } 
public void estSha256LargetThanBlocksize ( ) { byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1 " , Sha2Crypt . sha512Crypt ( buffer , " $6$abc " ) ) ; } 
public void estUnixCryptStrings ( ) { trivial test assertEquals("xxWAum7tHdIUw", Crypt.crypt("secret", "xx")); empty data assertEquals("12UFlHxel6uMM", Crypt.crypt("", "12")); salt gets cut at maximum length assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12")); assertEquals("12FJgqDtVOg7Q", Crypt.crypt("secret", "12345678")); } 
public void estUnixCryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("12UFlHxel6uMM", Crypt.crypt(new byte[0], "12")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("./287bds2PjVw", Crypt.crypt("t\u00e4st", "./")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("./bLIFNqo9XKQ", Crypt.crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "./")); assertEquals("./bLIFNqo9XKQ", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, "./")); } 
public void estUnixCryptWithoutSalt ( ) { String hash = UnixCrypt . crypt ( " foo " ) ; assertTrue ( hash . matches ( " ^[a-zA-Z0-9./]{13}$ " ) ) ; String hash2 = UnixCrypt . crypt ( " foo " ) ; assertNotSame ( hash , hash2 ) ; } 
private static int [ ] body ( int schedule [ ] , int eSwap0 , int eSwap1 ) { int left = 0 ; int right = 0 ; int = 0 ; for ( int j = 0 ; j < 25 ; j + + ) { for ( int i = 0 ; i < 32 ; i + = 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } = left ; left = right ; right = ; } = right ; right = left > > > 1 | left < < 31 ; left = > > > 1 | < < 31 ; int results [ ] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; int out [ ] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; } 
private static int [ ] desSetKey ( byte key [ ] ) { int schedule [ ] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; int results [ ] = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; Types casts fix two FindBugs report of RV_ABSOLUTE_VALUE_OF_RANDOM_INT. salt = "" + SALT_CHARS[(int)Math.abs((long)randomGenerator.nextInt()) % numSaltChars] + SALT_CHARS[(int)Math.abs((long)randomGenerator.nextInt()) % numSaltChars]; } else if (!salt.matches("^[" + B64.B64T + "]{2,}$")) { throw new IllegalArgumentException("Invalid salt value: " + salt); } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; Types casts fix two FindBugs report of RV_ABSOLUTE_VALUE_OF_RANDOM_INT. salt = "" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] + SALT_CHARS[randomGenerator.nextInt(numSaltChars)]; } else if (!salt.matches("^[" + B64.B64T + "]{2,}$")) { throw new IllegalArgumentException("Invalid salt value: " + salt); } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) { int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (m == null || !m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; Types casts fix two FindBugs report of RV_ABSOLUTE_VALUE_OF_RANDOM_INT. salt = "" + SALT_CHARS[randomGenerator.nextInt(numSaltChars)] + SALT_CHARS[randomGenerator.nextInt(numSaltChars)]; } else if (!salt.matches("^[" + B64.B64T + "]{2,}$")) { throw new IllegalArgumentException("Invalid salt value: " + salt); } StringBuilder buffer = new StringBuilder(" "); char charZero = salt.charAt(0); char charOne = salt.charAt(1); buffer.setCharAt(0, charZero); buffer.setCharAt(1, charOne); int eSwap0 = CON_SALT[charZero]; int eSwap1 = CON_SALT[charOne] << 4; byte key[] = new byte[8]; for (int i = 0; i < key.length; i++) { key[i] = 0; } for (int i = 0; i < key.length && i < original.length; i++) { int iChar = original[i]; key[i] = (byte) (iChar << 1); } int schedule[] = desSetKey(key); int out[] = body(schedule, eSwap0, eSwap1); byte b[] = new byte[9]; intToFourBytes(out[0], b, 0); intToFourBytes(out[1], b, 4); b[8] = 0; int i = 2; int y = 0; int u = 128; for (; i < 13; i++) { int j = 0; int c = 0; for (; j < 6; j++) { c <<= 1; if ((b[y] & u) != 0) { c |= 0x1; } u >>>= 1; if (u == 0) { y++; u = 128; } buffer.setCharAt(i, (char) COV2CHAR[c]); } } return buffer.toString(); } 
private static int [ ] desSetKey ( byte key [ ] ) { int schedule [ ] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; int results [ ] = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " + " modulus=%s, pos=%s, readPos=%s] " , his . getClass ( ) . getSimpleName ( ) , buffer , currentLinePos , eof , 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } StringBuilder buffer = new StringBuilder ( " " ) ; char charZero = salt . charAt ( 0 ) ; char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; int eSwap0 = CON_SALT [ charZero ] ; int eSwap1 = CON_SALT [ charOne ] < < 4 ; byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } int schedule [ ] = desSetKey ( key ) ; int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public static String crypt ( byte [ ] original , String salt ) { if ( salt = = null ) { Random randomGenerator = new Random ( ) ; int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } StringBuilder buffer = new StringBuilder ( " " ) ; char charZero = salt . charAt ( 0 ) ; char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; int eSwap0 = CON_SALT [ charZero ] ; int eSwap1 = CON_SALT [ charOne ] < < 4 ; byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } int schedule [ ] = desSetKey ( key ) ; int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
private static int dEncrypt ( int el , int r , int s , int e0 , int e1 , int sArr [ ] ) { int v = r ^ r > > > 16 ; int u = v & e0 ; v & = e1 ; u = u ^ u < < 16 ^ r ^ sArr [ s ] ; int = v ^ v < < 16 ^ r ^ sArr [ s + 1 ] ; = > > > 4 | < < 28 ; el ^ = SPTRANS [ 1 ] [ & 0x3f ] | SPTRANS [ 3 ] [ > > > 8 & 0x3f ] | SPTRANS [ 5 ] [ > > > 16 & 0x3f ] | SPTRANS [ 7 ] [ > > > 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u > > > 8 & 0x3f ] | SPTRANS [ 4 ] [ u > > > 16 & 0x3f ] | SPTRANS [ 6 ] [ u > > > 24 & 0x3f ] ; return el ; } 
private static int [ ] desSetKey ( byte key [ ] ) { int schedule [ ] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; int results [ ] = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
public static byte [ ] sha1 ( byte [ ] data ) { return getSha1Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha1 ( InputStream data ) hrows IOException { return digest ( getSha1Digest ( ) , data ) ; } 
public static byte [ ] md2 ( InputStream data ) hrows IOException { return digest ( getMd2Digest ( ) , data ) ; } 
public static String md2Hex ( byte [ ] data ) { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static String md2Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static String md2Hex ( String data ) { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public void estMd2Hex ( ) hrows IOException { Examples from RFC 1319 assertEquals("8350e5a3e24c153df2275c9f80692773", DigestUtils.md2Hex("")); assertEquals("32ec01ec4a6dac72c0ab96fb34c0b5d1", DigestUtils.md2Hex("a")); assertEquals("da853b0d3f88d99b30283a69e6ded6bb", DigestUtils.md2Hex("abc")); assertEquals("ab4f496bfb2a530b219ff33031fe06b0", DigestUtils.md2Hex("message digest")); assertEquals("4e8ddff3650292ab5a4108c3aa47940b", DigestUtils.md2Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "da33def2a42df13975352846c30338cd", DigestUtils.md2Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "d5976f79d83d3a0dc9806c3c66f3efd8", DigestUtils.md2Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md2Hex(testData), DigestUtils.md2Hex(new ByteArrayInputStream(testData))); 
public void estMd2HexLength ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md2Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md2Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMd2Length ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md2 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md2 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; } 
public static String sha1Hex ( byte [ ] data ) { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static String sha1Hex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static String sha1Hex ( String data ) { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public void estSha1Hex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex(getBytesUtf8("abc"))); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.shaHex(testData), DigestUtils.shaHex(new ByteArrayInputStream(testData))); 
public void estMd5HexLength ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMd5Length ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estInternalNoSuchAlgorithmException ( ) { DigestUtils . getDigest ( " Bogus Bogus " ) ; } 
public void estSha1Hex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex(getBytesUtf8("abc"))); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.shaHex(testData), DigestUtils.sha1Hex(new ByteArrayInputStream(testData))); 
public void estSha1Hex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex(getBytesUtf8("abc"))); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.sha1Hex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha1Hex(testData), DigestUtils.sha1Hex(new ByteArrayInputStream(testData))); 
public static Lang loadFromResource ( String languageRulesResourceName , Languages languages ) { List < LangRule > rules = new ArrayList < LangRule > ( ) ; InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } Pattern pattern = Pattern.compile(parts[0]); String[] langs = parts[1].split("\\+"); boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } else { try { String pat = stripQuotes(parts[0]); String lCon = stripQuotes(parts[1]); String rCon = stripQuotes(parts[2]); PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " + " modulus=%s, pos=%s, readPos=%s] " , his . getClass ( ) . getSimpleName ( ) , buffer , currentLinePos , eof , 
public static byte [ ] sha ( InputStream data ) hrows IOException { return sha1 ( data ) ; } 
public static String shaHex ( InputStream data ) hrows IOException { return sha1Hex ( data ) ; } 
public boolean matches ( Object item ) { return ( ( Integer ) item ) . intValue ( ) < 0 ; } 
public byte [ ] decode ( byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } Context context = new Context ( ) ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; Notify decoder of EOF. byte[] result = new byte[context.pos]; readResults(result, 0, result.length, context); return result; } 
public byte [ ] encode ( byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } Context context = new Context ( ) ; encode ( pArray , 0 , pArray . length , context ) ; encode ( pArray , 0 , EOF , context ) ; Notify encoder of EOF. byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
public void estRfc4648Section10DecodeEncode ( ) { estDecodeEncode ( " " ) ; estDecodeEncode ( " Zg== " ) ; estDecodeEncode ( " Zm8= " ) ; estDecodeEncode ( " Zm9v " ) ; estDecodeEncode ( " Zm9vYg== " ) ; estDecodeEncode ( " Zm9vYmE= " ) ; estDecodeEncode ( " Zm9vYmFy " ) ; } 
public void estGetBytesUncheckedNullInput ( ) { Assert . assertNull ( StringUtils . getBytesUnchecked ( null , " UNKNOWN " ) ) ; } 
public void estNewStringNullInput ( ) { Assert . assertNull ( StringUtils . newString ( null , " UNKNOWN " ) ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16BE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE_16BE , charsetName ) ; String actual = StringUtils . newStringUtf16Be ( BYTES_FIXTURE_16BE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { String charsetName = " UTF-16LE " ; estNewString ( charsetName ) ; String expected = new String ( BYTES_FIXTURE_16LE , charsetName ) ; String actual = StringUtils . newStringUtf16Le ( BYTES_FIXTURE_16LE ) ; Assert . assertEquals ( expected , actual ) ; } 
public static byte [ ] md2 ( String data ) { return md2 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] md5 ( String data ) { return md5 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha1 ( String data ) { return sha1 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha256 ( String data ) { return sha256 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha384 ( String data ) { return sha384 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha512 ( String data ) { return sha512 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static MessageDigest updateDigest ( final MessageDigest messageDigest , final String valueToDigest ) { messageDigest . update ( StringUtils . getBytesUtf8 ( valueToDigest ) ) ; return messageDigest ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; CologneOutputBuffer output = new CologneOutputBuffer ( ext . length ( ) * 2 ) ; CologneInputBuffer input = new CologneInputBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = input . length ( ) ; while ( rightLength > 0 ) { chr = input . removeNext ( ) ; if ( ( rightLength = input . length ( ) ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( AEIJOUY , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( SCZ , nextChar ) ) { code = '2' ; } else if ( arrayContains ( WFPV , chr ) ) { code = '3' ; } else if ( arrayContains ( GKQ , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( CKQ , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( AHKLOQRUX , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( SZ , lastChar ) | | ! arrayContains ( AHOUKQX , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( TDX , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
protected static boolean contains ( String value , int start , int length , String . . . criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { String arget = value . substring ( start , start + length ) ; for ( String element : criteria ) { if ( arget . equals ( element ) ) { result = rue ; break ; } } } return result ; } 
String cleanName ( final String name ) { String upperName = name . oUpperCase ( Locale . ENGLISH ) ; String [ ] charsToTrim = { " \\ - " , " [&] " , " \\ ' " , " \\ . " , " [ \\ ,] " } ; for ( String str : charsToTrim ) { upperName = upperName . replaceAll ( str , EMPTY ) ; } upperName = removeAccents ( upperName ) ; upperName = upperName . replaceAll ( " \\ s+ " , EMPTY ) ; return upperName ; } 
public final Object encode ( final Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Match Rating Approach encoder is not of type java.lang.String " ) ; } return encode ( ( String ) pObject ) ; } 
public final String encode ( String name ) { Bulletproof for trivial input - NINO if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) { return EMPTY; } Preprocessing name = cleanName(name); BEGIN: Actual encoding part of the algorithm... 1. Delete all vowels unless the vowel begins the word name = removeVowels(name); 2. Remove second consonant from any double consonant name = removeDoubleConsonants(name); 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters name = getFirst3Last3(name); return name; } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } else if (name1.length() == 1 || name2.length() == 1) { return false; } else if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= THREE) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. int sumLength = Math.abs(name1.length() + name2.length()); int minRating = 0; minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
boolean isVowel ( String letter ) { return letter . equalsIgnoreCase ( " E " ) | | letter . equalsIgnoreCase ( " A " ) | | letter . equalsIgnoreCase ( " O " ) | | letter . equalsIgnoreCase ( " I " ) | | letter . equalsIgnoreCase ( " U " ) ; 
int leftToRightThenRightToLeftProcessing ( String name1 , String name2 ) { char [ ] name1Char = name1 . oCharArray ( ) ; char [ ] name2Char = name2 . oCharArray ( ) ; int name1Size = name1 . length ( ) - 1 ; int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , ( name1Size - i ) + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , ( name2Size - i ) + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space String strA = new String(name1Char).replaceAll("\\s+", EMPTY); String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(SIX - strA.length()); 
String removeAccents ( final String accentedWord ) { if ( accentedWord = = null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; int = accentedWord . length ( ) ; for ( int i = 0 ; i < ; i + + ) { char c = accentedWord . charAt ( i ) ; int pos = UNICODE . indexOf ( c ) ; if ( pos > - 1 ) { sb . append ( PLAIN_ASCII . charAt ( pos ) ) ; } else { sb . append ( c ) ; } } return sb . oString ( ) ; } 
String removeDoubleConsonants ( String name ) { String [ ] dblCnstArray = new String [ ] { " BB " , " CC " , " DD " , " FF " , " GG " , " HH " , " JJ " , " KK " , " LL " , " MM " , " NN " , " PP " , " QQ " , " RR " , " SS " , " TT " , " VV " , " WW " , " XX " , " YY " , " ZZ " } ; String replacedName = name . oUpperCase ( ) ; for ( String dc : dblCnstArray ) { if ( replacedName . contains ( dc ) ) { String singleLetter = dc . substring ( 0 , 1 ) ; replacedName = replacedName . replace ( dc , singleLetter ) ; } } return replacedName ; } 
String removeVowels ( String name ) { Extract first letter String firstLetter = name.substring(0, 1); name = name.replaceAll("A", EMPTY); name = name.replaceAll("E", EMPTY); name = name.replaceAll("I", EMPTY); name = name.replaceAll("O", EMPTY); name = name.replaceAll("U", EMPTY); name = name.replaceAll("\\s{2,}\\b", SPACE); return isVowel(firstLetter) ? (firstLetter + name) : name; if (isVowel(firstLetter)) { return (firstLetter + name); 
public final void estAccentRemovalNormalString_NoChange ( ) { assertEquals ( " Colorless green ideas sleep furiously " , getMatchRatingApproachEncoder ( ) . removeAccents ( " Colorless green ideas sleep furiously " ) ) ; } 
public final void estAccentRemoval_NINO_NoChange ( ) { assertEquals ( " " , getMatchRatingApproachEncoder ( ) . removeAccents ( " " ) ) ; } 
public final void estRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully ( ) { assertEquals ( " BUBLE " , getMatchRatingApproachEncoder ( ) . removeDoubleConsonants ( " BUBBLE " ) ) ; } 
public final void estRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully ( ) { assertEquals ( " MISISIPI " , getMatchRatingApproachEncoder ( ) . removeDoubleConsonants ( " MISSISSIPPI " ) ) ; } 
public final void estRemoveDoubleDoubleVowel_BEETLE_NotRemoved ( ) { assertEquals ( " BEETLE " , getMatchRatingApproachEncoder ( ) . removeDoubleConsonants ( " BEETLE " ) ) ; } 
public final void estIsVowel_CapitalA_ReturnsTrue ( ) { assertEquals ( rue , getMatchRatingApproachEncoder ( ) . isVowel ( " A " ) ) ; } 
public final void estIsVowel_SmallD_ReturnsFalse ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isVowel ( " d " ) ) ; } 
public final void estRemoveVowel_ALESSANDRA_Returns_ALSSNDR ( ) { assertEquals ( " ALSSNDR " , getMatchRatingApproachEncoder ( ) . removeVowels ( " ALESSANDRA " ) ) ; } 
public final void estRemoveVowel__AIDAN_Returns_ADN ( ) { assertEquals ( " ADN " , getMatchRatingApproachEncoder ( ) . removeVowels ( " AIDAN " ) ) ; } 
public final void estRemoveVowel__DECLAN_Returns_DCLN ( ) { assertEquals ( " DCLN " , getMatchRatingApproachEncoder ( ) . removeVowels ( " DECLAN " ) ) ; } 
public final void estGetFirstLast3__ALEXANDER_Returns_Aleder ( ) { assertEquals ( " Aleder " , getMatchRatingApproachEncoder ( ) . getFirst3Last3 ( " Alexzander " ) ) ; } 
public final void estGetFirstLast3_PETE_Returns_PETE ( ) { assertEquals ( " PETE " , getMatchRatingApproachEncoder ( ) . getFirst3Last3 ( " PETE " ) ) ; } 
public final void estleftTorightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4 ( ) { assertEquals ( 4 , getMatchRatingApproachEncoder ( ) . leftToRightThenRightToLeftProcessing ( " ALEXANDER " , " ALEXANDRA " ) ) ; } 
public final void estleftTorightThenRightToLeft_EINSTEIN_MICHAELA_Returns0 ( ) { assertEquals ( 0 , getMatchRatingApproachEncoder ( ) . leftToRightThenRightToLeftProcessing ( " EINSTEIN " , " MICHAELA " ) ) ; } 
public final void estGetMinRating_7_Return4_Successfully ( ) { assertEquals ( 4 , getMatchRatingApproachEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estGetMinRating_2_Returns5_Successfully ( ) { assertEquals ( 5 , getMatchRatingApproachEncoder ( ) . getMinRating ( 2 ) ) ; } 
public final void estGetMinRating_2_Return1_Successfully ( ) { assertEquals ( 1 , getMatchRatingApproachEncoder ( ) . getMinRating ( 13 ) ) ; } 
public final void estGetEncoding_HARPER_HRPR ( ) { assertEquals ( " HRPR " , getMatchRatingApproachEncoder ( ) . encode ( " HARPER " ) ) ; } 
public final void estGetEncoding_SMITH_to_SMTH ( ) { assertEquals ( " SMTH " , getMatchRatingApproachEncoder ( ) . encode ( " Smith " ) ) ; } 
public final void estGetEncoding_SMYTH_to_SMYTH ( ) { assertEquals ( " SMYTH " , getMatchRatingApproachEncoder ( ) . encode ( " Smyth " ) ) ; } 
public final void estGetEncoding_Space_to_Nothing ( ) { assertEquals ( " " , getMatchRatingApproachEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetEncoding_NoSpace_to_Nothing ( ) { assertEquals ( " " , getMatchRatingApproachEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetEncoding_Null_to_Nothing ( ) { assertEquals ( " " , getMatchRatingApproachEncoder ( ) . encode ( null ) ) ; } 
public final void estGetEncoding_One_Letter_to_Nothing ( ) { assertEquals ( " " , getMatchRatingApproachEncoder ( ) . encode ( " E " ) ) ; } 
public final void estCompare_SMITH_SMYTH_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " smith " , " smyth " ) ) ; } 
public final void estCompare_BURNS_BOURNE_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Burns " , " Bourne " ) ) ; } 
public final void estCompare_ShortNames_AL_ED_WorksButNoMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Al " , " Ed " ) ) ; } 
public final void estCompare_CATHERINE_KATHRYN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Catherine " , " Kathryn " ) ) ; } 
public final void estCompare_BRIAN_BRYAN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Brian " , " Bryan " ) ) ; } 
public final void estCompare_STEPHEN_STEVEN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Stephen " , " Steven " ) ) ; } 
public final void estCompare_STEVEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Steven " , " Stefan " ) ) ; } 
public final void estCompare_STEPHEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Stephen " , " Stefan " ) ) ; } 
public final void estCompare_SAM_SAMUEL_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Sam " , " Samuel " ) ) ; } 
public final void estCompare_MICKY_MICHAEL_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Micky " , " Michael " ) ) ; } 
public final void estCompare_OONA_OONAGH_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Oona " , " Oonagh " ) ) ; } 
public final void estCompare_SOPHIE_SOFIA_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Sophie " , " Sofia " ) ) ; } 
public final void estCompare_FRANCISZEK_FRANCES_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Franciszek " , " Frances " ) ) ; } 
public final void estCompare_TOMASZ_TOM_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Tomasz " , " om " ) ) ; } 
public final void estCompare_SmallInput_CARK_Kl_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Kl " , " Karl " ) ) ; } 
public final void estCompareNameToSingleLetter_KARL_C_DoesNotMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Karl " , " C " ) ) ; } 
public final void estCompare_ZACH_ZAKARIA_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Zach " , " Zacharia " ) ) ; } 
public final void estCompare_KARL_ALESSANDRO_DoesNotMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Karl " , " Alessandro " ) ) ; } 
public final void estCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Moriarty " , " OMuircheartaigh " ) ) ; } 
public final void estCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Cooper-Flynn " , " Super-Lyn " ) ) ; } 
public final void estCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Hailey " , " Halley " ) ) ; } 
public final void estCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Auerbach " , " Uhrbach " ) ) ; } 
public final void estCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Moskowitz " , " Moskovitz " ) ) ; } 
public final void estCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " LIPSHITZ " , " LIPPSZYC " ) ) ; } 
public final void estCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " LEWINSKY " , " LEVINSKI " ) ) ; } 
public final void estCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " SZLAMAWICZ " , " SHLAMOVITZ " ) ) ; } 
public final void estCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " R o s o ch o w a c ie c " , " R o s o k ho v a ts e ts " ) ) ; } 
public final void estCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " P rz e m y s l " , " P sh e m e sh i l " ) ) ; } 
public final void estCompare_PETERSON_PETERS_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Peterson " , " Peters " ) ) ; } 
public final void estCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " McGowan " , " Mc Geoghegan " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_Space_NoMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_SurnameCornerCase_Nulls_NoMatch ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( null , null ) ) ; } 
public final void estCompare_Surnames_MURPHY_LYNCH_NoMatchExpected ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Murphy " , " Lynch " ) ) ; } 
public final void estCompare_Forenames_SEAN_JOHN_MatchExpected ( ) { assertTrue ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Sean " , " John " ) ) ; } 
public final void estCompare_Forenames_SEAN_PETE_NoMatchExpected ( ) { assertFalse ( getMatchRatingApproachEncoder ( ) . isEncodeEquals ( " Sean " , " Pete " ) ) ; } 
protected StringEncoder createStringEncoder ( ) { return new MatchRatingApproachEncoder ( ) ; } 
protected ColognePhonetic createStringEncoder ( ) { return new ColognePhonetic ( ) ; } 
protected DoubleMetaphone createStringEncoder ( ) { return new DoubleMetaphone ( ) ; } 
private void assertDoubleMetaphone ( String expected , String source ) { assertEquals ( expected , his . getStringEncoder ( ) . encode ( source ) ) ; ry { assertEquals ( expected , his . getStringEncoder ( ) . encode ( ( Object ) source ) ) ; } catch ( EncoderException e ) { fail ( " Unexpected expection: " + e ) ; } assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source ) ) ; assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source , false ) ) ; } 
public void assertDoubleMetaphoneAlt ( String expected , String source ) { assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source , rue ) ) ; } 
public void doubleMetaphoneNotEqualTest ( boolean alternate ) { assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " , alternate ) ) ; assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Band " , " Brain " , alternate ) ) ; if ( ! alternate ) { assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " ) ) ; 
public void estEmpty ( ) { assertEquals ( null , his . getStringEncoder ( ) . doubleMetaphone ( null ) ) ; assertEquals ( null , his . getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertEquals ( null , his . getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertEquals ( null , his . getStringEncoder ( ) . doubleMetaphone ( " r " ) ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); StringBuilder failures = new StringBuilder(); StringBuilder matches = new StringBuilder(); String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { String name0 = FIXTURE[i][0]; String name1 = FIXTURE[i][1]; boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. String msg = failures.toString(); fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { String name0 = MATCHES[i][0]; String name1 = MATCHES[i][1]; boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false); boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; StringBuilder failures = new StringBuilder ( ) ; StringBuilder matches = new StringBuilder ( ) ; String cr = System . getProperty ( " line.separator " ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { String name0 = FIXTURE [ i ] [ 0 ] ; String name1 = FIXTURE [ i ] [ 1 ] ; boolean match1 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; boolean match2 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public void estCCedilla ( ) { assertTrue ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " u00e7 " , " S " ) ) ; c-cedilla } 
public void estNTilde ( ) { assertTrue ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " u00f1 " , " N " ) ) ; n-tilde } 
public final void estAccentRemovalNormalString_NoChange ( ) { assertEquals ( " Colorless green ideas sleep furiously " , his . getStringEncoder ( ) . removeAccents ( " Colorless green ideas sleep furiously " ) ) ; } 
public final void estAccentRemoval_NINO_NoChange ( ) { assertEquals ( " " , his . getStringEncoder ( ) . removeAccents ( " " ) ) ; } 
public final void estRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully ( ) { assertEquals ( " BUBLE " , his . getStringEncoder ( ) . removeDoubleConsonants ( " BUBBLE " ) ) ; } 
public final void estRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully ( ) { assertEquals ( " MISISIPI " , his . getStringEncoder ( ) . removeDoubleConsonants ( " MISSISSIPPI " ) ) ; } 
public final void estRemoveDoubleDoubleVowel_BEETLE_NotRemoved ( ) { assertEquals ( " BEETLE " , his . getStringEncoder ( ) . removeDoubleConsonants ( " BEETLE " ) ) ; } 
public final void estIsVowel_CapitalA_ReturnsTrue ( ) { assertEquals ( rue , his . getStringEncoder ( ) . isVowel ( " A " ) ) ; } 
public final void estIsVowel_SmallD_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isVowel ( " d " ) ) ; } 
public final void estRemoveVowel_ALESSANDRA_Returns_ALSSNDR ( ) { assertEquals ( " ALSSNDR " , his . getStringEncoder ( ) . removeVowels ( " ALESSANDRA " ) ) ; } 
public final void estRemoveVowel__AIDAN_Returns_ADN ( ) { assertEquals ( " ADN " , his . getStringEncoder ( ) . removeVowels ( " AIDAN " ) ) ; } 
public final void estRemoveVowel__DECLAN_Returns_DCLN ( ) { assertEquals ( " DCLN " , his . getStringEncoder ( ) . removeVowels ( " DECLAN " ) ) ; } 
public final void estGetFirstLast3__ALEXANDER_Returns_Aleder ( ) { assertEquals ( " Aleder " , his . getStringEncoder ( ) . getFirst3Last3 ( " Alexzander " ) ) ; } 
public final void estGetFirstLast3_PETE_Returns_PETE ( ) { assertEquals ( " PETE " , his . getStringEncoder ( ) . getFirst3Last3 ( " PETE " ) ) ; } 
public final void estleftTorightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " ALEXANDER " , " ALEXANDRA " ) ) ; } 
public final void estleftTorightThenRightToLeft_EINSTEIN_MICHAELA_Returns0 ( ) { assertEquals ( 0 , his . getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " EINSTEIN " , " MICHAELA " ) ) ; } 
public final void estGetMinRating_7_Return4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estGetMinRating_2_Returns5_Successfully ( ) { assertEquals ( 5 , his . getStringEncoder ( ) . getMinRating ( 2 ) ) ; } 
public final void estGetMinRating_2_Return1_Successfully ( ) { assertEquals ( 1 , his . getStringEncoder ( ) . getMinRating ( 13 ) ) ; } 
public final void estGetEncoding_HARPER_HRPR ( ) { assertEquals ( " HRPR " , his . getStringEncoder ( ) . encode ( " HARPER " ) ) ; } 
public final void estGetEncoding_SMITH_to_SMTH ( ) { assertEquals ( " SMTH " , his . getStringEncoder ( ) . encode ( " Smith " ) ) ; } 
public final void estGetEncoding_SMYTH_to_SMYTH ( ) { assertEquals ( " SMYTH " , his . getStringEncoder ( ) . encode ( " Smyth " ) ) ; } 
public final void estGetEncoding_Space_to_Nothing ( ) { assertEquals ( " " , his . getStringEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetEncoding_NoSpace_to_Nothing ( ) { assertEquals ( " " , his . getStringEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetEncoding_Null_to_Nothing ( ) { assertEquals ( " " , his . getStringEncoder ( ) . encode ( null ) ) ; } 
public final void estGetEncoding_One_Letter_to_Nothing ( ) { assertEquals ( " " , his . getStringEncoder ( ) . encode ( " E " ) ) ; } 
public final void estCompare_SMITH_SMYTH_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " smith " , " smyth " ) ) ; } 
public final void estCompare_BURNS_BOURNE_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Burns " , " Bourne " ) ) ; } 
public final void estCompare_ShortNames_AL_ED_WorksButNoMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Al " , " Ed " ) ) ; } 
public final void estCompare_CATHERINE_KATHRYN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Catherine " , " Kathryn " ) ) ; } 
public final void estCompare_BRIAN_BRYAN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Brian " , " Bryan " ) ) ; } 
public final void estCompare_STEPHEN_STEVEN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Stephen " , " Steven " ) ) ; } 
public final void estCompare_STEVEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Steven " , " Stefan " ) ) ; } 
public final void estCompare_STEPHEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Stephen " , " Stefan " ) ) ; } 
public final void estCompare_SAM_SAMUEL_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Sam " , " Samuel " ) ) ; } 
public final void estCompare_MICKY_MICHAEL_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Micky " , " Michael " ) ) ; } 
public final void estCompare_OONA_OONAGH_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Oona " , " Oonagh " ) ) ; } 
public final void estCompare_SOPHIE_SOFIA_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Sophie " , " Sofia " ) ) ; } 
public final void estCompare_FRANCISZEK_FRANCES_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Franciszek " , " Frances " ) ) ; } 
public final void estCompare_TOMASZ_TOM_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Tomasz " , " om " ) ) ; } 
public final void estCompare_SmallInput_CARK_Kl_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Kl " , " Karl " ) ) ; } 
public final void estCompareNameToSingleLetter_KARL_C_DoesNotMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Karl " , " C " ) ) ; } 
public final void estCompare_ZACH_ZAKARIA_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Zach " , " Zacharia " ) ) ; } 
public final void estCompare_KARL_ALESSANDRO_DoesNotMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Karl " , " Alessandro " ) ) ; } 
public final void estCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Moriarty " , " OMuircheartaigh " ) ) ; } 
public final void estCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Cooper-Flynn " , " Super-Lyn " ) ) ; } 
public final void estCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Hailey " , " Halley " ) ) ; } 
public final void estCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Auerbach " , " Uhrbach " ) ) ; } 
public final void estCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Moskowitz " , " Moskovitz " ) ) ; } 
public final void estCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " LIPSHITZ " , " LIPPSZYC " ) ) ; } 
public final void estCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " LEWINSKY " , " LEVINSKI " ) ) ; } 
public final void estCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " SZLAMAWICZ " , " SHLAMOVITZ " ) ) ; } 
public final void estCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " R o s o ch o w a c ie c " , " R o s o k ho v a ts e ts " ) ) ; } 
public final void estCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " P rz e m y s l " , " P sh e m e sh i l " ) ) ; } 
public final void estCompare_PETERSON_PETERS_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Peterson " , " Peters " ) ) ; } 
public final void estCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " McGowan " , " Mc Geoghegan " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_Space_NoMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_SurnameCornerCase_Nulls_NoMatch ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( null , null ) ) ; } 
public final void estCompare_Surnames_MURPHY_LYNCH_NoMatchExpected ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " Lynch " ) ) ; } 
public final void estCompare_Forenames_SEAN_JOHN_MatchExpected ( ) { assertTrue ( his . getStringEncoder ( ) . isEncodeEquals ( " Sean " , " John " ) ) ; } 
public final void estCompare_Forenames_SEAN_PETE_NoMatchExpected ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " Sean " , " Pete " ) ) ; } 
protected MatchRatingApproachEncoder createStringEncoder ( ) { return new MatchRatingApproachEncoder ( ) ; } 
public void assertIsMetaphoneEqual ( String source , String [ ] matches ) { match source to all matches for (String matche : matches) { assertTrue("Source: " + source + ", should have same Metaphone as: " + matche, this.getStringEncoder().isMetaphoneEqual(source, matche)); } match to each other for (String matche : matches) { for (String matche2 : matches) { 
public void estMetaphone ( ) { assertEquals ( " HL " , his . getStringEncoder ( ) . metaphone ( " howl " ) ) ; assertEquals ( " TSTN " , his . getStringEncoder ( ) . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , his . getStringEncoder ( ) . metaphone ( " The " ) ) ; assertEquals ( " KK " , his . getStringEncoder ( ) . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , his . getStringEncoder ( ) . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , his . getStringEncoder ( ) . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , his . getStringEncoder ( ) . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , his . getStringEncoder ( ) . metaphone ( " over " ) ) ; assertEquals ( " 0 " , his . getStringEncoder ( ) . metaphone ( " he " ) ) ; assertEquals ( " LS " , his . getStringEncoder ( ) . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , his . getStringEncoder ( ) . metaphone ( " dogs " ) ) ; } 
public void estWordEndingInMB ( ) { assertEquals ( " KM " , his . getStringEncoder ( ) . metaphone ( " COMB " ) ) ; assertEquals ( " TM " , his . getStringEncoder ( ) . metaphone ( " TOMB " ) ) ; assertEquals ( " WM " , his . getStringEncoder ( ) . metaphone ( " WOMB " ) ) ; } 
public void estDiscardOfSCEOrSCIOrSCY ( ) { assertEquals ( " SNS " , his . getStringEncoder ( ) . metaphone ( " SCIENCE " ) ) ; assertEquals ( " SN " , his . getStringEncoder ( ) . metaphone ( " SCENE " ) ) ; assertEquals ( " S " , his . getStringEncoder ( ) . metaphone ( " SCY " ) ) ; } 
public void estWhy ( ) { PHP returns "H". The original metaphone returns an empty string. assertEquals("", this.getStringEncoder().metaphone("WHY")); } 
public void estWordsWithCIA ( ) { assertEquals ( " XP " , his . getStringEncoder ( ) . metaphone ( " CIAPO " ) ) ; } 
public void estTranslateOfSCHAndCH ( ) { assertEquals ( " SKTL " , his . getStringEncoder ( ) . metaphone ( " SCHEDULE " ) ) ; assertEquals ( " SKMT " , his . getStringEncoder ( ) . metaphone ( " SCHEMATIC " ) ) ; assertEquals ( " KRKT " , his . getStringEncoder ( ) . metaphone ( " CHARACTER " ) ) ; assertEquals ( " TX " , his . getStringEncoder ( ) . metaphone ( " TEACH " ) ) ; } 
public void estTranslateToJOfDGEOrDGIOrDGY ( ) { assertEquals ( " TJ " , his . getStringEncoder ( ) . metaphone ( " DODGY " ) ) ; assertEquals ( " TJ " , his . getStringEncoder ( ) . metaphone ( " DODGE " ) ) ; assertEquals ( " AJMT " , his . getStringEncoder ( ) . metaphone ( " ADGIEMTI " ) ) ; } 
public void estDiscardOfSilentHAfterG ( ) { assertEquals ( " KNT " , his . getStringEncoder ( ) . metaphone ( " GHENT " ) ) ; assertEquals ( " B " , his . getStringEncoder ( ) . metaphone ( " BAUGH " ) ) ; } 
public void estDiscardOfSilentGN ( ) { NOTE: This does not test for silent GN, but for starting with GN assertEquals( "N", this.getStringEncoder().metaphone("GNU") ); NOTE: Trying to test for GNED, but expected code does not appear to execute assertEquals( "SNT", this.getStringEncoder().metaphone("SIGNED") ); } 
public void estPHTOF ( ) { assertEquals ( " FX " , his . getStringEncoder ( ) . metaphone ( " PHISH " ) ) ; } 
public void estSHAndSIOAndSIAToX ( ) { assertEquals ( " XT " , his . getStringEncoder ( ) . metaphone ( " SHOT " ) ) ; assertEquals ( " OTXN " , his . getStringEncoder ( ) . metaphone ( " ODSIAN " ) ) ; assertEquals ( " PLXN " , his . getStringEncoder ( ) . metaphone ( " PULSION " ) ) ; } 
public void estTIOAndTIAToX ( ) { assertEquals ( " OX " , his . getStringEncoder ( ) . metaphone ( " OTIA " ) ) ; assertEquals ( " PRXN " , his . getStringEncoder ( ) . metaphone ( " PORTION " ) ) ; } 
public void estTCH ( ) { assertEquals ( " RX " , his . getStringEncoder ( ) . metaphone ( " RETCH " ) ) ; assertEquals ( " WX " , his . getStringEncoder ( ) . metaphone ( " WATCH " ) ) ; } 
public void estExceedLength ( ) { should be AKSKS, but istruncated by Max Code Length assertEquals( "AKSK", this.getStringEncoder().metaphone("AXEAXE") ); } 
public void estSetMaxLengthWithTruncation ( ) { should be AKSKS, but istruncated by Max Code Length this.getStringEncoder().setMaxCodeLen( 6 ); assertEquals( "AKSKSK", this.getStringEncoder().metaphone("AXEAXEAXE") ); } 
protected RefinedSoundex createStringEncoder ( ) { return new RefinedSoundex ( ) ; } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getStringEncoder().difference(null, null)); assertEquals(0, this.getStringEncoder().difference("", "")); assertEquals(0, this.getStringEncoder().difference(" ", " ")); Normal cases assertEquals(6, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(3, this.getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Margaret", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(5, this.getStringEncoder().difference("Green", "Greene")); assertEquals(1, this.getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(8, this.getStringEncoder().difference("Smithers", "Smythers")); assertEquals(5, this.getStringEncoder().difference("Anothers", "Brothers")); } 
public void estEncode ( ) { assertEquals ( " T6036084 " , his . getStringEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , his . getStringEncoder ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , his . getStringEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , his . getStringEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , his . getStringEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , his . getStringEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , his . getStringEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , his . getStringEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , his . getStringEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , his . getStringEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , his . getStringEncoder ( ) . encode ( " dogs " ) ) ; Testing CODEC-56 assertEquals("D6043", RefinedSoundex.US_ENGLISH.encode("dogs")); } 
public void estGetMappingCodeNonLetter ( ) { char code = his . getStringEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , code ) ; } 
public void estBadCharacters ( ) { Assert . assertEquals ( " H452 " , his . getStringEncoder ( ) . encode ( " HOL>MES " ) ) ; 
public void estDifference ( ) hrows EncoderException { Edge cases Assert.assertEquals(0, this.getStringEncoder().difference(null, null)); Assert.assertEquals(0, this.getStringEncoder().difference("", "")); Assert.assertEquals(0, this.getStringEncoder().difference(" ", " ")); Normal cases Assert.assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); Assert.assertEquals(2, this.getStringEncoder().difference("Ann", "Andrew")); Assert.assertEquals(1, this.getStringEncoder().difference("Margaret", "Andrew")); Assert.assertEquals(0, this.getStringEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp Assert.assertEquals(4, this.getStringEncoder().difference("Green", "Greene")); Assert.assertEquals(0, this.getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp Assert.assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); Assert.assertEquals(4, this.getStringEncoder().difference("Smithers", "Smythers")); Assert.assertEquals(2, this.getStringEncoder().difference("Anothers", "Brothers")); } 
public void estEncodeBasic ( ) { Assert . assertEquals ( " T235 " , his . getStringEncoder ( ) . encode ( " esting " ) ) ; Assert . assertEquals ( " T000 " , his . getStringEncoder ( ) . encode ( " The " ) ) ; Assert . assertEquals ( " Q200 " , his . getStringEncoder ( ) . encode ( " quick " ) ) ; Assert . assertEquals ( " B650 " , his . getStringEncoder ( ) . encode ( " brown " ) ) ; Assert . assertEquals ( " F200 " , his . getStringEncoder ( ) . encode ( " fox " ) ) ; Assert . assertEquals ( " J513 " , his . getStringEncoder ( ) . encode ( " jumped " ) ) ; Assert . assertEquals ( " O160 " , his . getStringEncoder ( ) . encode ( " over " ) ) ; Assert . assertEquals ( " T000 " , his . getStringEncoder ( ) . encode ( " he " ) ) ; Assert . assertEquals ( " L200 " , his . getStringEncoder ( ) . encode ( " lazy " ) ) ; Assert . assertEquals ( " D200 " , his . getStringEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncodeBatch2 ( ) { Assert . assertEquals ( " A462 " , his . getStringEncoder ( ) . encode ( " Allricht " ) ) ; Assert . assertEquals ( " E166 " , his . getStringEncoder ( ) . encode ( " Eberhard " ) ) ; Assert . assertEquals ( " E521 " , his . getStringEncoder ( ) . encode ( " Engebrethson " ) ) ; Assert . assertEquals ( " H512 " , his . getStringEncoder ( ) . encode ( " Heimbach " ) ) ; Assert . assertEquals ( " H524 " , his . getStringEncoder ( ) . encode ( " Hanselmann " ) ) ; Assert . assertEquals ( " H431 " , his . getStringEncoder ( ) . encode ( " Hildebrand " ) ) ; Assert . assertEquals ( " K152 " , his . getStringEncoder ( ) . encode ( " Kavanagh " ) ) ; Assert . assertEquals ( " L530 " , his . getStringEncoder ( ) . encode ( " Lind " ) ) ; Assert . assertEquals ( " L222 " , his . getStringEncoder ( ) . encode ( " Lukaschowsky " ) ) ; Assert . assertEquals ( " M235 " , his . getStringEncoder ( ) . encode ( " McDonnell " ) ) ; Assert . assertEquals ( " M200 " , his . getStringEncoder ( ) . encode ( " McGee " ) ) ; Assert . assertEquals ( " O155 " , his . getStringEncoder ( ) . encode ( " Opnian " ) ) ; Assert . assertEquals ( " O155 " , his . getStringEncoder ( ) . encode ( " Oppenheimer " ) ) ; Assert . assertEquals ( " R355 " , his . getStringEncoder ( ) . encode ( " Riedemanas " ) ) ; Assert . assertEquals ( " Z300 " , his . getStringEncoder ( ) . encode ( " Zita " ) ) ; Assert . assertEquals ( " Z325 " , his . getStringEncoder ( ) . encode ( " Zitzmeinn " ) ) ; } 
public void estEncodeBatch3 ( ) { Assert . assertEquals ( " W252 " , his . getStringEncoder ( ) . encode ( " Washington " ) ) ; Assert . assertEquals ( " L000 " , his . getStringEncoder ( ) . encode ( " Lee " ) ) ; Assert . assertEquals ( " G362 " , his . getStringEncoder ( ) . encode ( " Gutierrez " ) ) ; Assert . assertEquals ( " P236 " , his . getStringEncoder ( ) . encode ( " Pfister " ) ) ; Assert . assertEquals ( " J250 " , his . getStringEncoder ( ) . encode ( " Jackson " ) ) ; Assert . assertEquals ( " T522 " , his . getStringEncoder ( ) . encode ( " Tymczak " ) ) ; For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also possible. Assert.assertEquals("V532", this.getStringEncoder().encode("VanDeusen")); } 
public void estEncodeBatch4 ( ) { Assert . assertEquals ( " H452 " , his . getStringEncoder ( ) . encode ( " HOLMES " ) ) ; Assert . assertEquals ( " A355 " , his . getStringEncoder ( ) . encode ( " ADOMOMI " ) ) ; Assert . assertEquals ( " V536 " , his . getStringEncoder ( ) . encode ( " VONDERLEHR " ) ) ; Assert . assertEquals ( " B400 " , his . getStringEncoder ( ) . encode ( " BALL " ) ) ; Assert . assertEquals ( " S000 " , his . getStringEncoder ( ) . encode ( " SHAW " ) ) ; Assert . assertEquals ( " J250 " , his . getStringEncoder ( ) . encode ( " JACKSON " ) ) ; Assert . assertEquals ( " S545 " , his . getStringEncoder ( ) . encode ( " SCANLON " ) ) ; Assert . assertEquals ( " S532 " , his . getStringEncoder ( ) . encode ( " SAINTJOHN " ) ) ; 
public void estEncodeIgnoreTrimmable ( ) { Assert . assertEquals ( " W252 " , his . getStringEncoder ( ) . encode ( " r Washington r " ) ) ; } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft")); } 
public void estHWRuleEx2 ( ) { Assert . assertEquals ( " B312 " , his . getStringEncoder ( ) . encode ( " BOOTHDAVIS " ) ) ; Assert . assertEquals ( " B312 " , his . getStringEncoder ( ) . encode ( " BOOTH-DAVIS " ) ) ; } 
public void estHWRuleEx3 ( ) hrows EncoderException { Assert . assertEquals ( " S460 " , his . getStringEncoder ( ) . encode ( " Sgler " ) ) ; Assert . assertEquals ( " S460 " , his . getStringEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: this.checkEncodingVariations("S460", new String[]{ "SAILOR", 
public void estMsSqlServer1 ( ) { Assert . assertEquals ( " S530 " , his . getStringEncoder ( ) . encode ( " Smith " ) ) ; Assert . assertEquals ( " S530 " , his . getStringEncoder ( ) . encode ( " Smythe " ) ) ; } 
public void estMsSqlServer3 ( ) { Assert . assertEquals ( " A500 " , his . getStringEncoder ( ) . encode ( " Ann " ) ) ; Assert . assertEquals ( " A536 " , his . getStringEncoder ( ) . encode ( " Andrew " ) ) ; Assert . assertEquals ( " J530 " , his . getStringEncoder ( ) . encode ( " Janet " ) ) ; Assert . assertEquals ( " M626 " , his . getStringEncoder ( ) . encode ( " Margaret " ) ) ; Assert . assertEquals ( " S315 " , his . getStringEncoder ( ) . encode ( " Steven " ) ) ; Assert . assertEquals ( " M240 " , his . getStringEncoder ( ) . encode ( " Michael " ) ) ; Assert . assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Robert " ) ) ; Assert . assertEquals ( " L600 " , his . getStringEncoder ( ) . encode ( " Laura " ) ) ; Assert . assertEquals ( " A500 " , his . getStringEncoder ( ) . encode ( " Anne " ) ) ; } 
public void estUsMappingEWithAcute ( ) { Assert . assertEquals ( " E000 " , his . getStringEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( '\u00e9' ) ) { e-acute try { 
public void estUsMappingOWithDiaeresis ( ) { Assert . assertEquals ( " O000 " , his . getStringEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( '\u00f6' ) ) { o-umlaut try { 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByChunk ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( byte [ ] encoded , byte [ ] decoded , int chunkSize , byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
public final void estAccentRemoval_NullValue_ReturnNullSuccessfully ( ) { assertEquals ( null , his . getStringEncoder ( ) . removeAccents ( null ) ) ; } 
public final void estCompareNameNullSpace_ReturnsFalseSuccessfully ( ) { assertEquals ( false , getStringEncoder ( ) . isEncodeEquals ( null , " " ) ) ; } 
public final void estCompareNameSameNames_ReturnsFalseSuccessfully ( ) { assertEquals ( rue , getStringEncoder ( ) . isEncodeEquals ( " John " , " John " ) ) ; } 
public static Charset oCharset ( final Charset charset ) { return charset = = null ? Charset . defaultCharset ( ) : charset ; } 
public static Charset oCharset ( final String charset ) { return charset = = null ? Charset . defaultCharset ( ) : Charset . forName ( charset ) ; } 
public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; ry { final Comparable s1 = ( Comparable ) his . stringEncoder . encode ( o1 ) ; final Comparable s2 = ( Comparable ) his . stringEncoder . encode ( o2 ) ; compareCode = s1 . compareTo ( s2 ) ; } catch ( final EncoderException ee ) { compareCode = 0 ; } return compareCode ; } 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void encode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
public boolean isInAlphabet ( final byte octet ) { return octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ; } 
void encode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos + + ] ; if ( b = = PAD ) { We're done. context.eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
public static boolean isArrayByteBase64 ( final byte [ ] arrayOctet ) { return isBase64 ( arrayOctet ) ; } 
public static boolean isBase64 ( final byte octet ) { return octet = = PAD_DEFAULT | | ( octet > = 0 & & octet < DECODE_TABLE . length & & DECODE_TABLE [ octet ] ! = - 1 ) ; } 
public static boolean isBase64 ( final String base64 ) { return isBase64 ( StringUtils . getBytesUtf8 ( base64 ) ) ; } 
public static boolean isBase64 ( final byte [ ] arrayOctet ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isBase64 ( arrayOctet [ i ] ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) { return false ; } } return rue ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData ) { return encodeBase64 ( binaryData , false ) ; } 
public static String encodeBase64String ( final byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } 
public static byte [ ] encodeBase64URLSafe ( final byte [ ] binaryData ) { return encodeBase64 ( binaryData , false , rue ) ; } 
public static String encodeBase64URLSafeString ( final byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false , rue ) ) ; } 
public static byte [ ] encodeBase64Chunked ( final byte [ ] binaryData ) { return encodeBase64 ( binaryData , rue ) ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked ) { return encodeBase64 ( binaryData , isChunked , false ) ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe ) { return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); final long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
public static byte [ ] decodeBase64 ( final String base64String ) { return new Base64 ( ) . decode ( base64String ) ; } 
public static byte [ ] decodeBase64 ( final byte [ ] base64Data ) { return new Base64 ( ) . decode ( base64Data ) ; } 
public static BigInteger decodeInteger ( final byte [ ] pArray ) { return new BigInteger ( 1 , decodeBase64 ( pArray ) ) ; } 
public static byte [ ] encodeInteger ( final BigInteger bigInt ) { if ( bigInt = = null ) { hrow new NullPointerException ( " encodeInteger called with null parameter " ) ; } return encodeBase64 ( oIntegerBytes ( bigInt ) , false ) ; } 
static byte [ ] oIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = ((bitlen + 7) >> 3) << 3; final byte[] bigBytes = bigInt.toByteArray(); if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if ((bigInt.bitLength() % 8) == 0) { startSrc = 1; len--; } final int startDst = bitlen / 8 - len; to pad w/ nulls as per spec final byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
protected boolean isInAlphabet ( final byte octet ) { return octet > = 0 & & octet < decodeTable . length & & decodeTable [ octet ] ! = - 1 ; } 
boolean hasData ( final Context context ) { package protected for access from I/O streams return context.buffer != null; } 
int available ( final Context context ) { package protected for access from I/O streams return context.buffer != null ? context.pos - context.readPos : 0; } 
private byte [ ] resizeBuffer ( final Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ getDefaultBufferSize ( ) ] ; context . pos = 0 ; context . readPos = 0 ; } else { final byte [ ] b = new byte [ context . buffer . length * DEFAULT_BUFFER_RESIZE_FACTOR ] ; System . arraycopy ( context . buffer , 0 , b , 0 , context . buffer . length ) ; context . buffer = b ; } return context . buffer ; } 
protected byte [ ] ensureBufferSize ( final int size , final Context context ) { if ( ( context . buffer = = null ) | | ( context . buffer . length < context . pos + size ) ) { return resizeBuffer ( context ) ; } return context . buffer ; } 
int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer ! = null ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( context . readPos > = context . pos ) { context . buffer = null ; so hasData() will return false, and this method can return -1 } return len; } return context.eof ? EOF : 0; } 
protected static boolean isWhiteSpace ( final byte byteToCheck ) { switch ( byteToCheck ) { case ' ' : 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof byte [ ] ) ) { hrow new EncoderException ( " Parameter supplied to Base-N encode is not a byte[] " ) ; } return encode ( ( byte [ ] ) obj ) ; } 
public String encodeToString ( final byte [ ] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } 
public String encodeAsString ( final byte [ ] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; 
public byte [ ] decode ( final String pArray ) { return decode ( StringUtils . getBytesUtf8 ( pArray ) ) ; } 
public byte [ ] decode ( final byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } final Context context = new Context ( ) ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; Notify decoder of EOF. final byte[] result = new byte[context.pos]; readResults(result, 0, result.length, context); return result; } 
public byte [ ] encode ( final byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } final Context context = new Context ( ) ; encode ( pArray , 0 , pArray . length , context ) ; encode ( pArray , 0 , EOF , context ) ; Notify encoder of EOF. final byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isInAlphabet ( arrayOctet [ i ] ) & & ( ! allowWSPad | | ( arrayOctet [ i ] ! = PAD ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) ) { return false ; } } return rue ; } 
public boolean isInAlphabet ( final String basen ) { return isInAlphabet ( StringUtils . getBytesUtf8 ( basen ) , rue ) ; } 
protected boolean containsAlphabetOrPad ( final byte [ ] arrayOctet ) { if ( arrayOctet = = null ) { return false ; } for ( final byte element : arrayOctet ) { if ( PAD = = element | | isInAlphabet ( element ) ) { return rue ; } } return false ; } 
public synchronized void mark ( final int readLimit ) { } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte b [ ] , final int offset , final int len ) hrows IOException { if ( b = = null ) { hrow new NullPointerException ( ) ; 
public long skip ( final long ) hrows IOException { if ( < 0 ) { hrow new IllegalArgumentException ( " Negative skip length: " + ) ; } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; } 
public void write ( final int i ) hrows IOException { singleByte [ 0 ] = ( byte ) i ; write ( singleByte , 0 , 1 ) ; } 
public void write ( final byte b [ ] , final int offset , final int len ) hrows IOException { if ( b = = null ) { hrow new NullPointerException ( ) ; 
private void flush ( final boolean propogate ) hrows IOException { final int avail = baseNCodec . available ( context ) ; if ( avail > 0 ) { final byte [ ] buf = new byte [ avail ] ; final int c = baseNCodec . readResults ( buf , 0 , avail , context ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propogate ) { out . flush ( ) ; 
public Object encode ( final Object raw ) hrows EncoderException { if ( ! ( raw instanceof byte [ ] ) ) { hrow new EncoderException ( " argument not a byte array " ) ; } return oAsciiChars ( ( byte [ ] ) raw ) ; } 
public Object decode ( final Object ascii ) hrows DecoderException { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } if ( ascii instanceof byte [ ] ) { return fromAscii ( ( byte [ ] ) ascii ) ; } if ( ascii instanceof char [ ] ) { return fromAscii ( ( char [ ] ) ascii ) ; } if ( ascii instanceof String ) { return fromAscii ( ( ( String ) ascii ) . oCharArray ( ) ) ; } hrow new DecoderException ( " argument not a byte array " ) ; } 
public byte [ ] oByteArray ( final String ascii ) { if ( ascii = = null ) { return EMPTY_BYTE_ARRAY ; } return fromAscii ( ascii . oCharArray ( ) ) ; } 
public static byte [ ] fromAscii ( final char [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length final byte[] l_raw = new byte[ascii.length >> 3]; for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
public static byte [ ] fromAscii ( final byte [ ] ascii ) { if ( isEmpty ( ascii ) ) { return EMPTY_BYTE_ARRAY ; } get length/8 times bytes with 3 bit shifts to the right of the length final byte[] l_raw = new byte[ascii.length >> 3]; for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
private static boolean isEmpty ( final byte [ ] array ) { return array = = null | | array . length = = 0 ; } 
public static byte [ ] oAsciiBytes ( final byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_BYTE_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length final byte[] l_ascii = new byte[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static char [ ] oAsciiChars ( final byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_CHAR_ARRAY ; } get 8 times the bytes with 3 bit shifts to the left of the length final char[] l_ascii = new char[raw.length << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static String oAsciiString ( final byte [ ] raw ) { return new String ( oAsciiChars ( raw ) ) ; } 
public static byte [ ] decodeHex ( final char [ ] data ) hrows DecoderException { final int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } final byte [ ] out = new byte [ len > > 1 ] ; two characters form the hex value. for (int i = 0, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f = f | toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return out; } 
public static char [ ] encodeHex ( final byte [ ] data ) { return encodeHex ( data , rue ) ; } 
public static char [ ] encodeHex ( final byte [ ] data , final boolean oLowerCase ) { return encodeHex ( data , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; } 
protected static char [ ] encodeHex ( final byte [ ] data , final char [ ] oDigits ) { final int l = data . length ; final char [ ] out = new char [ l < < 1 ] ; two characters form the hex value. for (int i = 0, j = 0; i < l; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; out[j++] = toDigits[0x0F & data[i]]; } return out; } 
public static String encodeHexString ( final byte [ ] data ) { return new String ( encodeHex ( data ) ) ; } 
protected static int oDigit ( final char ch , final int index ) hrows DecoderException { final int digit = Character . digit ( ch , 16 ) ; if ( digit = = - 1 ) { hrow new DecoderException ( " Illegal hexadecimal character " + ch + " at index " + index ) ; } return digit ; } 
public byte [ ] decode ( final byte [ ] array ) hrows DecoderException { return decodeHex ( new String ( array , getCharset ( ) ) . oCharArray ( ) ) ; } 
public Object decode ( final Object object ) hrows DecoderException { ry { final char [ ] charArray = object instanceof String ? ( ( String ) object ) . oCharArray ( ) : ( char [ ] ) object ; 
public byte [ ] encode ( final byte [ ] array ) { return encodeHexString ( array ) . getBytes ( his . getCharset ( ) ) ; } 
public Object encode ( final Object object ) hrows EncoderException { ry { final byte [ ] byteArray = object instanceof String ? 
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + " : " + e ) ; } 
private static String newString ( final byte [ ] bytes , final Charset charset ) { return bytes = = null ? null : new String ( bytes , charset ) ; } 
public static String newString ( final byte [ ] bytes , final String charsetName ) { if ( bytes = = null ) { return null ; } ry { return new String ( bytes , charsetName ) ; 
public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( final byte [ ] bytes ) { return new String ( bytes , Charsets . US_ASCII ) ; } 
public static String newStringUtf16 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16 ) ; } 
public static String newStringUtf16Be ( final byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16BE ) ; } 
public static String newStringUtf16Le ( final byte [ ] bytes ) { return new String ( bytes , Charsets . UTF_16LE ) ; } 
public static String newStringUtf8 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . UTF_8 ) ; } 
static void b64from24bit ( final byte b2 , final byte b1 , final byte b0 , final int outLen , final StringBuilder buffer ) { The bit masking is necessary because the JVM byte type is signed! int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff); It's effectively a "for" loop but kept to resemble the original C code. int n = outLen; while (n-- > 0) { buffer.append(B64T.charAt(w & 0x3f)); 
public static String crypt ( final byte [ ] keyBytes ) { return crypt ( keyBytes , null ) ; } 
public static String crypt ( final byte [ ] keyBytes , final String salt ) { if ( salt = = null ) { return Sha2Crypt . sha512Crypt ( keyBytes ) ; 
public static String crypt ( final String key , final String salt ) { return crypt ( key . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
private static byte [ ] digest ( final MessageDigest digest , final InputStream data ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest . digest ( ) ; } 
public static byte [ ] md2 ( final byte [ ] data ) { return getMd2Digest ( ) . digest ( data ) ; } 
public static byte [ ] md2 ( final InputStream data ) hrows IOException { return digest ( getMd2Digest ( ) , data ) ; } 
public static byte [ ] md2 ( final String data ) { return md2 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String md2Hex ( final byte [ ] data ) { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static String md2Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static String md2Hex ( final String data ) { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static byte [ ] md5 ( final byte [ ] data ) { return getMd5Digest ( ) . digest ( data ) ; } 
public static byte [ ] md5 ( final InputStream data ) hrows IOException { return digest ( getMd5Digest ( ) , data ) ; } 
public static byte [ ] md5 ( final String data ) { return md5 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String md5Hex ( final byte [ ] data ) { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String md5Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String md5Hex ( final String data ) { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static byte [ ] sha ( final InputStream data ) hrows IOException { return sha1 ( data ) ; } 
public static byte [ ] sha1 ( final byte [ ] data ) { return getSha1Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha1 ( final InputStream data ) hrows IOException { return digest ( getSha1Digest ( ) , data ) ; } 
public static byte [ ] sha1 ( final String data ) { return sha1 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha1Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static String sha1Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static String sha1Hex ( final String data ) { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static byte [ ] sha256 ( final byte [ ] data ) { return getSha256Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha256 ( final InputStream data ) hrows IOException { return digest ( getSha256Digest ( ) , data ) ; } 
public static byte [ ] sha256 ( final String data ) { return sha256 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha256Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha256Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha256Hex ( final String data ) { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static byte [ ] sha384 ( final byte [ ] data ) { return getSha384Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha384 ( final InputStream data ) hrows IOException { return digest ( getSha384Digest ( ) , data ) ; } 
public static byte [ ] sha384 ( final String data ) { return sha384 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha384Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha384Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha384Hex ( final String data ) { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static byte [ ] sha512 ( final byte [ ] data ) { return getSha512Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha512 ( final InputStream data ) hrows IOException { return digest ( getSha512Digest ( ) , data ) ; } 
public static byte [ ] sha512 ( final String data ) { return sha512 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha512Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String sha512Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String sha512Hex ( final String data ) { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static String shaHex ( final InputStream data ) hrows IOException { return sha1Hex ( data ) ; } 
public static MessageDigest updateDigest ( final MessageDigest messageDigest , final byte [ ] valueToDigest ) { messageDigest . update ( valueToDigest ) ; return messageDigest ; } 
public static String apr1Crypt ( final byte [ ] keyBytes ) { return apr1Crypt ( keyBytes , APR1_PREFIX + B64 . getRandomSalt ( 8 ) ) ; } 
public static String apr1Crypt ( final byte [ ] keyBytes , String salt ) { to make the md5Crypt regex happy if (salt != null && !salt.startsWith(APR1_PREFIX)) { salt = APR1_PREFIX + salt; } return Md5Crypt.md5Crypt(keyBytes, salt, APR1_PREFIX); } 
public static String apr1Crypt ( final String keyBytes ) { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String apr1Crypt ( final String keyBytes , final String salt ) { return apr1Crypt ( keyBytes . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt ) { return md5Crypt ( keyBytes , salt , MD5_PREFIX ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (m == null || !m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String sha256Crypt ( final byte [ ] keyBytes ) { return sha256Crypt ( keyBytes , null ) ; } 
public static String sha256Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithms . SHA_256 ) ; } 
public static String sha512Crypt ( final byte [ ] keyBytes ) { return sha512Crypt ( keyBytes , null ) ; } 
public static String sha512Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , MessageDigestAlgorithms . SHA_512 ) ; } 
public static String crypt ( final byte [ ] original ) { return crypt ( original , null ) ; } 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final Random randomGenerator = new Random ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int schedule [ ] = desSetKey ( key ) ; final int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public static String crypt ( final String original ) { return crypt ( original . getBytes ( Charsets . UTF_8 ) ) ; } 
public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( Charsets . UTF_8 ) , salt ) ; } 
private static int [ ] body ( final int schedule [ ] , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int = 0 ; for ( int j = 0 ; j < 25 ; j + + ) { for ( int i = 0 ; i < 32 ; i + = 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } = left ; left = right ; right = ; } = right ; right = left > > > 1 | left < < 31 ; left = > > > 1 | < < 31 ; final int results [ ] = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; final int out [ ] = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; } 
private static int byteToUnsigned ( final byte b ) { final int value = b ; return value < 0 ? value + 256 : value ; } 
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int sArr [ ] ) { int v = r ^ r > > > 16 ; int u = v & e0 ; v & = e1 ; u = u ^ u < < 16 ^ r ^ sArr [ s ] ; int = v ^ v < < 16 ^ r ^ sArr [ s + 1 ] ; = > > > 4 | < < 28 ; el ^ = SPTRANS [ 1 ] [ & 0x3f ] | SPTRANS [ 3 ] [ > > > 8 & 0x3f ] | SPTRANS [ 5 ] [ > > > 16 & 0x3f ] | SPTRANS [ 7 ] [ > > > 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u > > > 8 & 0x3f ] | SPTRANS [ 4 ] [ u > > > 16 & 0x3f ] | SPTRANS [ 6 ] [ u > > > 24 & 0x3f ] ; return el ; } 
private static int [ ] desSetKey ( final byte key [ ] ) { final int schedule [ ] = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int results [ ] = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; final int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
private static int fourBytesToInt ( final byte b [ ] , int offset ) { int value = byteToUnsigned ( b [ offset + + ] ) ; value | = byteToUnsigned ( b [ offset + + ] ) < < 8 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 16 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 24 ; return value ; } 
private static int hPermOp ( int a , final int , final int m ) { final int = ( a < < 16 - ^ a ) & m ; a = a ^ ^ > > > 16 - ; return a ; } 
private static void intToFourBytes ( final int iValue , final byte b [ ] , int offset ) { b [ offset + + ] = ( byte ) ( iValue & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 8 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 16 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 24 & 0xff ) ; } 
private static void permOp ( int a , int b , final int , final int m , final int results [ ] ) { final int = ( a > > > ^ b ) & m ; a ^ = < < ; b ^ = ; results [ 0 ] = a ; results [ 1 ] = b ; } 
public Object encode ( final Object source ) hrows EncoderException { if ( ! ( source instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return his . encode ( ( String ) source ) ; } 
public boolean isEncodeEqual ( final String str1 , final String str2 ) hrows EncoderException { return his . encode ( str1 ) . equals ( his . encode ( str2 ) ) ; } 
public String caverphone ( final String source ) { return his . encoder . encode ( source ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return his . caverphone ( ( String ) obj ) ; } 
public boolean isCaverphoneEqual ( final String str1 , final String str2 ) { return his . caverphone ( str1 ) . equals ( his . caverphone ( str2 ) ) ; } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("l", "2"); 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
public void addRight ( final char chr ) { data [ length ] = chr ; length + + ; } 
protected char [ ] copyData ( final int start , final int length ) { final char [ ] newData = new char [ length ] ; System . arraycopy ( data , start , newData , 0 , length ) ; return newData ; } 
public void addLeft ( final char ch ) { length + + ; data [ getNextPos ( ) ] = ch ; } 
protected char [ ] copyData ( final int start , final int length ) { final char [ ] newData = new char [ length ] ; System . arraycopy ( data , data . length - his . length + start , newData , 0 , length ) ; return newData ; } 
public char removeNext ( ) { final char ch = getNextChar ( ) ; length - - ; return ch ; } 
private static boolean arrayContains ( final char [ ] arr , final char key ) { for ( final char element : arr ) { if ( element = = key ) { return rue ; } } return false ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } ext = preprocess ( ext ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( ext . length ( ) * 2 ) ; final CologneInputBuffer input = new CologneInputBuffer ( ext . oCharArray ( ) ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = input . length ( ) ; while ( rightLength > 0 ) { chr = input . removeNext ( ) ; if ( ( rightLength = input . length ( ) ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( AEIJOUY , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( SCZ , nextChar ) ) { code = '2' ; } else if ( arrayContains ( WFPV , chr ) ) { code = '3' ; } else if ( arrayContains ( GKQ , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( CKQ , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( AHKLOQRUX , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( SZ , lastChar ) | | ! arrayContains ( AHOUKQX , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( TDX , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
public Object encode ( final Object object ) hrows EncoderException { if ( ! ( object instanceof String ) ) { hrow new EncoderException ( " This method's parameter was expected to be of the type " + String . class . getName ( ) + " . But actually it was of the type " + object . getClass ( ) . getName ( ) + " . " ) ; } return encode ( ( String ) object ) ; } 
public boolean isEncodeEqual ( final String ext1 , final String ext2 ) { return colognePhonetic ( ext1 ) . equals ( colognePhonetic ( ext2 ) ) ; } 
private String preprocess ( String ext ) { ext = ext . oUpperCase ( Locale . GERMAN ) ; final char [ ] chrs = ext . oCharArray ( ) ; for ( int index = 0 ; index < chrs . length ; index + + ) { if ( chrs [ index ] > 'Z' ) { for ( final char [ ] element : PREPROCESS_MAP ) { if ( chrs [ index ] = = element [ 0 ] ) { chrs [ index ] = element [ 1 ] ; break ; } } } } return new String ( chrs ) ; } 
public String doubleMetaphone ( final String value ) { return doubleMetaphone ( value , false ) ; } 
public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( his . getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " DoubleMetaphone encode parameter is not of type String " ) ; } return doubleMetaphone ( ( String ) obj ) ; } 
public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 ) { return isDoubleMetaphoneEqual ( value1 , value2 , false ) ; } 
public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; } 
private int handleAEIOUY ( final DoubleMetaphoneResult result , final int index ) { if ( index = = 0 ) { result . append ( 'A' ) ; } return index + 1 ; } 
private int handleC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( conditionC0 ( value , index ) ) { very confusing, moved out result.append('K'); index += 2; } else if (index == 0 && contains(value, index, 6, "CAESAR")) { result.append('S'); index += 2; } else if (contains(value, index, 2, "CH")) { index = handleCH(value, result, index); } else if (contains(value, index, 2, "CZ") && !contains(value, index - 2, 4, "WICZ")) { -- "Czerny" -- result.append('S', 'X'); index += 2; } else if (contains(value, index + 1, 3, "CIA")) { -- "focaccia" -- result.append('X'); index += 3; } else if (contains(value, index, 2, "CC") && !(index == 1 && charAt(value, 0) == 'M')) { -- double "cc" but not "McClelland" -- return handleCC(value, result, index); } else if (contains(value, index, 2, "CK", "CG", "CQ")) { result.append('K'); index += 2; } else if (contains(value, index, 2, "CI", "CE", "CY")) { -- Italian vs. English -- if (contains(value, index, 3, "CIO", "CIE", "CIA")) { result.append('S', 'X'); } else { result.append('S'); } index += 2; } else { result.append('K'); if (contains(value, index + 1, 2, " C", " Q", " G")) { -- Mac Caffrey, Mac Gregor -- index += 3; } else if (contains(value, index + 1, 1, "C", "K", "Q") && !contains(value, index + 1, 2, "CE", "CI")) { index += 2; } else { index++; } } return index; } 
private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if ((index == 1 && charAt(value, index - 1) == 'A') || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); 
private int handleD ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " DG " ) ) { -- "Edge" -- if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('J'); index += 3; -- "Edgar" -- } else { result.append("TK"); index += 2; } } else if (contains(value, index, 2, "DT", "DD")) { result.append('T'); index += 2; } else { result.append('T'); index++; } return index; } 
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) ) | | ( index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) ) | | ( index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleH ( final String value , final DoubleMetaphoneResult result , int index ) { -- only keep if first & before vowel or between 2 vowels -- if ((index == 0 || isVowel(charAt(value, index - 1))) && isVowel(charAt(value, index + 1))) { result.append('H'); index += 2; -- also takes car of "HH" -- } else { index++; } return index; } 
private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleL ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'L' ) { if ( conditionL0 ( value , index ) ) { result . appendPrimary ( 'L' ) ; } else { result . append ( 'L' ) ; } index + = 2 ; } else { index + + ; result . append ( 'L' ) ; } return index ; } 
private int handleP ( final String value , final DoubleMetaphoneResult result , int index ) { if ( charAt ( value , index + 1 ) = = 'H' ) { result . append ( 'F' ) ; index + = 2 ; } else { result . append ( 'P' ) ; index = contains ( value , index + 1 , 1 , " P " , " B " ) ? index + 2 : index + 1 ; } return index ; } 
private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else { if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } } return index; } 
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( ( index = = value . length ( ) - 1 ) & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private boolean conditionC0 ( final String value , final int index ) { if ( contains ( value , index , 4 , " CHIA " ) ) { return rue ; 
private boolean conditionCH0 ( final String value , final int index ) { if ( index ! = 0 ) { return false ; 
private boolean conditionCH1 ( final String value , final int index ) { return ( ( contains ( value , 0 , 4 , " VAN " , " VON " ) | | contains ( value , 0 , 3 , " SCH " ) ) | | contains ( value , index - 2 , 6 , " ORCHES " , " ARCHIT " , " ORCHID " ) | | 
private boolean conditionL0 ( final String value , final int index ) { if ( index = = value . length ( ) - 3 & & contains ( value , index - 1 , 4 , " ILLO " , " ILLA " , " ALLE " ) ) { 
private boolean conditionM0 ( final String value , final int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( ( index + 1 ) = = value . length ( ) - 1 | | contains ( value , index + 2 , 2 , " ER " ) ) ; 
private boolean isSlavoGermanic ( final String value ) { return value . indexOf ( 'W' ) > - 1 | | value . indexOf ( 'K' ) > - 1 | | value . indexOf ( " CZ " ) > - 1 | | value . indexOf ( " WITZ " ) > - 1 ; 
private boolean isSilentStart ( final String value ) { boolean result = false ; for ( final String element : SILENT_START ) { if ( value . startsWith ( element ) ) { result = rue ; break ; } } return result ; } 
protected char charAt ( final String value , final int index ) { if ( index < 0 | | index > = value . length ( ) ) { return Character . MIN_VALUE ; } return value . charAt ( index ) ; } 
protected static boolean contains ( final String value , final int start , final int length , final String . . . criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { final String arget = value . substring ( start , start + length ) ; for ( final String element : criteria ) { if ( arget . equals ( element ) ) { result = rue ; break ; } } } return result ; } 
public void append ( final char value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } 
public void append ( final char primary , final char alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } 
public void appendPrimary ( final char value ) { if ( his . primary . length ( ) < his . maxLength ) { his . primary . append ( value ) ; 
public void appendAlternate ( final char value ) { if ( his . alternate . length ( ) < his . maxLength ) { his . alternate . append ( value ) ; 
public void append ( final String value ) { appendPrimary ( value ) ; appendAlternate ( value ) ; } 
public void append ( final String primary , final String alternate ) { appendPrimary ( primary ) ; appendAlternate ( alternate ) ; } 
public void appendPrimary ( final String value ) { final int addChars = his . maxLength - his . primary . length ( ) ; if ( value . length ( ) < = addChars ) { his . primary . append ( value ) ; 
public void appendAlternate ( final String value ) { final int addChars = his . maxLength - his . alternate . length ( ) ; if ( value . length ( ) < = addChars ) { his . alternate . append ( value ) ; 
String cleanName ( final String name ) { String upperName = name . oUpperCase ( Locale . ENGLISH ) ; final String [ ] charsToTrim = { " \\ - " , " [&] " , " \\ ' " , " \\ . " , " [ \\ ,] " } ; for ( final String str : charsToTrim ) { upperName = upperName . replaceAll ( str , EMPTY ) ; } upperName = removeAccents ( upperName ) ; upperName = upperName . replaceAll ( " \\ s+ " , EMPTY ) ; return upperName ; } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } else if (name1.length() == 1 || name2.length() == 1) { return false; } else if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= THREE) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); int minRating = 0; minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
boolean isVowel ( final String letter ) { return letter . equalsIgnoreCase ( " E " ) | | letter . equalsIgnoreCase ( " A " ) | | letter . equalsIgnoreCase ( " O " ) | | letter . equalsIgnoreCase ( " I " ) | | letter . equalsIgnoreCase ( " U " ) ; 
int leftToRightThenRightToLeftProcessing ( final String name1 , final String name2 ) { final char [ ] name1Char = name1 . oCharArray ( ) ; final char [ ] name2Char = name2 . oCharArray ( ) ; final int name1Size = name1 . length ( ) - 1 ; final int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , ( name1Size - i ) + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , ( name2Size - i ) + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space final String strA = new String(name1Char).replaceAll("\\s+", EMPTY); final String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(SIX - strA.length()); 
String removeAccents ( final String accentedWord ) { if ( accentedWord = = null ) { return null ; } final StringBuilder sb = new StringBuilder ( ) ; final int = accentedWord . length ( ) ; for ( int i = 0 ; i < ; i + + ) { final char c = accentedWord . charAt ( i ) ; final int pos = UNICODE . indexOf ( c ) ; if ( pos > - 1 ) { sb . append ( PLAIN_ASCII . charAt ( pos ) ) ; } else { sb . append ( c ) ; } } return sb . oString ( ) ; } 
String removeDoubleConsonants ( final String name ) { final String [ ] dblCnstArray = new String [ ] { " BB " , " CC " , " DD " , " FF " , " GG " , " HH " , " JJ " , " KK " , " LL " , " MM " , " NN " , " PP " , " QQ " , " RR " , " SS " , " TT " , " VV " , " WW " , " XX " , " YY " , " ZZ " } ; String replacedName = name . oUpperCase ( ) ; for ( final String dc : dblCnstArray ) { if ( replacedName . contains ( dc ) ) { final String singleLetter = dc . substring ( 0 , 1 ) ; replacedName = replacedName . replace ( dc , singleLetter ) ; } } return replacedName ; } 
String removeVowels ( String name ) { Extract first letter final String firstLetter = name.substring(0, 1); name = name.replaceAll("A", EMPTY); name = name.replaceAll("E", EMPTY); name = name.replaceAll("I", EMPTY); name = name.replaceAll("O", EMPTY); name = name.replaceAll("U", EMPTY); name = name.replaceAll("\\s{2,}\\b", SPACE); return isVowel(firstLetter) ? (firstLetter + name) : name; if (isVowel(firstLetter)) { return (firstLetter + name); 
private boolean isVowel ( final StringBuilder string , final int index ) { return VOWELS . indexOf ( string . charAt ( index ) ) > = 0 ; } 
private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
private boolean regionMatch ( final StringBuilder string , final int index , final String est ) { boolean matches = false ; if ( index > = 0 & & index + est . length ( ) - 1 < string . length ( ) ) { final String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
private boolean isLastChar ( final int wdsz , final int ) { return + 1 = = wdsz ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Metaphone encode is not of type java.lang.String " ) ; } return metaphone ( ( String ) obj ) ; } 
public boolean isMetaphoneEqual ( final String str1 , final String str2 ) { return metaphone ( str1 ) . equals ( metaphone ( str2 ) ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Nysiis encode is not of type java.lang.String " ) ; } return his . nysiis ( ( String ) obj ) ; } 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. final StringBuilder key = new StringBuilder(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public int difference ( final String s1 , final String s2 ) hrows EncoderException { return SoundexUtils . difference ( his , s1 , s2 ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to RefinedSoundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) obj ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final StringBuilder sBuf = new StringBuilder ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Soundex encode is not of type java.lang.String " ) ; } return soundex ( ( String ) obj ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; getMappingCode() throws IllegalArgumentException last = getMappingCode(str, 0); while (incount < str.length() && count < out.length) { mapped = getMappingCode(str, incount++); if (mapped != 0) { if (mapped != '0' && mapped != last) { out[count++] = mapped; } last = mapped; } } return new String(out); } 
static String clean ( final String str ) { if ( str = = null | | str . length ( ) = = 0 ) { return str ; } final int len = str . length ( ) ; final char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
static int difference ( final StringEncoder encoder , final String s1 , final String s2 ) hrows EncoderException { return differenceEncoded ( encoder . encode ( s1 ) , encoder . encode ( s2 ) ) ; } 
static int differenceEncoded ( final String es1 , final String es2 ) { if ( es1 = = null | | es2 = = null ) { return 0 ; } final int lengthToMatch = Math . min ( es1 . length ( ) , es2 . length ( ) ) ; int diff = 0 ; for ( int i = 0 ; i < lengthToMatch ; i + + ) { if ( es1 . charAt ( i ) = = es2 . charAt ( i ) ) { diff + + ; } } return diff ; } 
public Object encode ( final Object source ) hrows EncoderException { if ( ! ( source instanceof String ) ) { hrow new EncoderException ( " BeiderMorseEncoder encode parameter is not of type String " ) ; } return encode ( ( String ) source ) ; } 
public String encode ( final String source ) hrows EncoderException { if ( source = = null ) { return null ; } return his . engine . encode ( source ) ; } 
public boolean matches ( final String xt ) { return his . pattern . matcher ( xt ) . find ( ) ; } 
public static Lang instance ( final NameType nameType ) { return Langs . get ( nameType ) ; } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < LangRule > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
public String guessLanguage ( final String ext ) { final Languages . LanguageSet ls = guessLanguages ( ext ) ; return ls . isSingleton ( ) ? ls . getAny ( ) : Languages . ANY ; } 
public Languages . LanguageSet guessLanguages ( final String input ) { final String ext = input . oLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet < String > ( his . languages . getLanguages ( ) ) ; for ( final LangRule rule : his . rules ) { if ( rule . matches ( ext ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } } final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; } 
public static LanguageSet from ( final Set < String > langs ) { return langs . isEmpty ( ) ? NO_LANGUAGES : new SomeLanguages ( langs ) ; } 
public boolean contains ( final String language ) { return his . languages . contains ( language ) ; } 
public LanguageSet restrictTo ( final LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return other ; 
private static String langResourceName ( final NameType nameType ) { return String . format ( " org/apache/commons/codec/language/bm/%s_languages.txt " , nameType . getName ( ) ) ; } 
public LanguageSet restrictTo ( final LanguageSet other ) { return his ; } 
public LanguageSet restrictTo ( final LanguageSet other ) { return other ; } 
public static PhonemeBuilder empty ( final Languages . LanguageSet languages ) { return new PhonemeBuilder ( Collections . singleton ( new Rule . Phoneme ( " " , languages ) ) ) ; } 
public PhonemeBuilder append ( final CharSequence str ) { final Set < Rule . Phoneme > newPhonemes = new LinkedHashSet < Rule . Phoneme > ( ) ; for ( final Rule . Phoneme ph : his . phonemes ) { newPhonemes . add ( ph . append ( str ) ) ; } return new PhonemeBuilder ( newPhonemes ) ; } 
public String makeString ( ) { final StringBuilder sb = new StringBuilder ( ) ; for ( final Rule . Phoneme ph : his . phonemes ) { if ( sb . length ( ) > 0 ) { sb . append ( " | " ) ; } sb . append ( ph . getPhonemeText ( ) ) ; } return sb . oString ( ) ; } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 0 ; for ( final Rule rule : his . finalRules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( ! rule . patternAndContextMatches ( his . input , his . i ) ) { continue ; } his . phonemeBuilder = his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
public char charAt ( final int index ) { return cached . charAt ( index ) ; } 
public CharSequence subSequence ( final int start , final int end ) { if ( start = = end ) { return " " ; } CharSequence res = cache [ start ] [ end - 1 ] ; if ( res = = null ) { res = cached . subSequence ( start , end ) ; cache [ start ] [ end - 1 ] = res ; } return res ; } 
private static String join ( final Iterable < String > strings , final String sep ) { final StringBuilder sb = new StringBuilder ( ) ; final Iterator < String > si = strings . iterator ( ) ; if ( si . hasNext ( ) ) { sb . append ( si . next ( ) ) ; } while ( si . hasNext ( ) ) { sb . append ( sep ) . append ( si . next ( ) ) ; } return sb . oString ( ) ; } 
public String encode ( final String input ) { final Languages . LanguageSet languageSet = his . lang . guessLanguages ( input ) ; return encode ( input , languageSet ) ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final List < Rule > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final List<Rule> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final List<Rule> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually final CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public int compare ( final Phoneme o1 , final Phoneme o2 ) { for ( int i = 0 ; i < o1 . phonemeText . length ( ) ; i + + ) { if ( i > = o2 . phonemeText . length ( ) ) { return + 1 ; } final int c = o1 . phonemeText . charAt ( i ) - o2 . phonemeText . charAt ( i ) ; if ( c ! = 0 ) { return c ; } } if ( o1 . phonemeText . length ( ) < o2 . phonemeText . length ( ) ) { return - 1 ; } return 0 ; } 
public Phoneme append ( final CharSequence str ) { return new Phoneme ( his . phonemeText . oString ( ) + str . oString ( ) , his . languages ) ; } 
public Phoneme join ( final Phoneme right ) { return new Phoneme ( his . phonemeText . oString ( ) + right . phonemeText . oString ( ) , his . languages . restrictTo ( right . languages ) ) ; 
private static boolean contains ( final CharSequence chars , final char input ) { for ( int i = 0 ; i < chars . length ( ) ; i + + ) { if ( chars . charAt ( i ) = = input ) { return rue ; } } return false ; } 
private static String createResourceName ( final NameType nameType , final RuleType rt , final String lang ) { return String . format ( " org/apache/commons/codec/language/bm/%s_%s_%s.txt " , nameType . getName ( ) , rt . getName ( ) , lang ) ; 
private static Scanner createScanner ( final NameType nameType , final RuleType rt , final String lang ) { final String resName = createResourceName ( nameType , rt , lang ) ; final InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( " org/apache/commons/codec/language/bm/%s.txt " , lang ) ; final InputStream rulesIS = Languages . class . getClassLoader ( ) . getResourceAsStream ( resName ) ; if ( rulesIS = = null ) { hrow new IllegalArgumentException ( " Unable to load resource: " + resName ) ; } return new Scanner ( rulesIS , ResourceConstants . ENCODING ) ; } 
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { if ( suffix . length ( ) > input . length ( ) ) { return false ; } for ( int i = input . length ( ) - 1 , j = suffix . length ( ) - 1 ; j > = 0 ; i - - , j - - ) { if ( input . charAt ( i ) ! = suffix . charAt ( j ) ) { return false ; } } return rue ; } 
private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( " [ " ) ; if ( open > = 0 ) { if ( ! ph . endsWith ( " ] " ) ) { 
private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( " ( " ) ) { we have a bracketed list of options if (!ph.endsWith(")")) { 
private static List < Rule > parseRules ( final Scanner scanner , final String location ) { final List < Rule > lines = new ArrayList < Rule > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } else { lines.addAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; lines.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } else { return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public boolean isMatch ( final CharSequence input ) { return input . length ( ) = = 0 ; } 
public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } 
public boolean isMatch ( final CharSequence input ) { return startsWith ( input , content ) ; } 
public boolean isMatch ( final CharSequence input ) { return endsWith ( input , content ) ; } 
public boolean isMatch ( final CharSequence input ) { return input . length ( ) = = 1 & & contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ; } 
public boolean isMatch ( final CharSequence input ) { return input . length ( ) > 0 & & contains ( bContent , input . charAt ( 0 ) ) = = shouldMatch ; } 
public boolean isMatch ( final CharSequence input ) { return input . length ( ) > 0 & & contains ( bContent , input . charAt ( input . length ( ) - 1 ) ) = = shouldMatch ; 
public boolean isMatch ( final CharSequence input ) { final Matcher matcher = pattern . matcher ( input ) ; return matcher . find ( ) ; } 
private static boolean startsWith ( final CharSequence input , final CharSequence prefix ) { if ( prefix . length ( ) > input . length ( ) ) { return false ; } for ( int i = 0 ; i < prefix . length ( ) ; i + + ) { if ( input . charAt ( i ) ! = prefix . charAt ( i ) ) { return false ; } } return rue ; } 
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } final int patternLength = his . pattern . length ( ) ; final int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } evaluate the pattern, left context and right context fail early if any of the evaluations is not successful if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); } 
protected byte [ ] doEncoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } return Base64 . encodeBase64 ( bytes ) ; } 
protected byte [ ] doDecoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } return Base64 . decodeBase64 ( bytes ) ; } 
public String encode ( final String value ) hrows EncoderException { if ( value = = null ) { return null ; } return encode ( value , his . getCharset ( ) ) ; } 
public String decode ( final String value ) hrows DecoderException { if ( value = = null ) { return null ; } ry { return his . decodeText ( value ) ; 
public Object encode ( final Object value ) hrows EncoderException { if ( value = = null ) { return null ; 
public Object decode ( final Object value ) hrows DecoderException { if ( value = = null ) { return null ; 
protected byte [ ] doEncoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } final byte [ ] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; if ( his . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i + + ) { if ( data [ i ] = = BLANK ) { data [ i ] = UNDERSCORE ; } } } return data ; } 
protected byte [ ] doDecoding ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { final byte [ ] mp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { final byte b = bytes [ i ] ; if ( b ! = UNDERSCORE ) { mp [ i ] = b ; } else { mp [ i ] = BLANK ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( mp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; } 
public String encode ( final String str ) hrows EncoderException { if ( str = = null ) { return null ; } return encode ( str , getCharset ( ) ) ; } 
public String decode ( final String str ) hrows DecoderException { if ( str = = null ) { return null ; } ry { return decodeText ( str ) ; 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; 
private static final void encodeQuotedPrintable ( final int b , final ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; final char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( final byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { encodeQuotedPrintable ( b , buffer ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeQuotedPrintable ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final int b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { final int u = Utils . digit16 ( bytes [ + + i ] ) ; final int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid quoted-printable encoding " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( final byte [ ] bytes ) { return encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; } 
public byte [ ] decode ( final byte [ ] bytes ) hrows DecoderException { return decodeQuotedPrintable ( bytes ) ; } 
public String encode ( final String str ) hrows EncoderException { return his . encode ( str , getCharset ( ) ) ; } 
public String decode ( final String str , final Charset charset ) hrows DecoderException { if ( str = = null ) { return null ; } return new String ( his . decode ( StringUtils . getBytesUsAscii ( str ) ) , charset ) ; } 
public String decode ( final String str , final String charset ) hrows DecoderException , UnsupportedEncodingException { if ( str = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( str ) ) , charset ) ; } 
public String decode ( final String str ) hrows DecoderException { return his . decode ( str , his . getCharset ( ) ) ; } 
public String encode ( final String str , final Charset charset ) { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( his . encode ( str . getBytes ( charset ) ) ) ; } 
public String encode ( final String str , final String charset ) hrows UnsupportedEncodingException { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( str . getBytes ( charset ) ) ) ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; final byte [ ] rawData = his . doEncoding ( ext . getBytes ( charset ) ) ; buffer . append ( StringUtils . newStringUsAscii ( rawData ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( final byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; final char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public static final byte [ ] decodeUrl ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final int b = bytes [ i ] ; if ( b = = '+' ) { buffer . write ( ' ' ) ; } else if ( b = = ESCAPE_CHAR ) { ry { final int u = Utils . digit16 ( bytes [ + + i ] ) ; final int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid URL encoding: " , e ) ; } } else { buffer . write ( b ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( final byte [ ] bytes ) { return encodeUrl ( WWW_FORM_URL , bytes ) ; } 
public byte [ ] decode ( final byte [ ] bytes ) hrows DecoderException { return decodeUrl ( bytes ) ; } 
public String encode ( final String str ) hrows EncoderException { if ( str = = null ) { return null ; } ry { return encode ( str , getDefaultCharset ( ) ) ; 
public String decode ( final String str ) hrows DecoderException { if ( str = = null ) { return null ; } ry { return decode ( str , getDefaultCharset ( ) ) ; 
static int digit16 ( final byte b ) hrows DecoderException { final int i = Character . digit ( ( char ) b , 16 ) ; if ( i = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding: not a valid digit (radix " + URLCodec . RADIX + " ): " + b ) ; } return i ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; @Test public void estEncodeEmpty ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } @Test public void estEncodeNull ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; } catch ( final EncoderException ee ) { An exception should be thrown } }} 
public void estEncodeEmpty ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } 
public void estEncodeNull ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; 
public void estConstructor0 ( ) { final DecoderException e = new DecoderException ( ) ; assertNull ( e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorString ( ) { final DecoderException e = new DecoderException ( MSG ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorStringThrowable ( ) { final DecoderException e = new DecoderException ( MSG , ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructorThrowable ( ) { final DecoderException e = new DecoderException ( ) ; assertEquals ( . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructor0 ( ) { final EncoderException e = new EncoderException ( ) ; assertNull ( e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorString ( ) { final EncoderException e = new EncoderException ( MSG ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertNull ( e . getCause ( ) ) ; } 
public void estConstructorStringThrowable ( ) { final EncoderException e = new EncoderException ( MSG , ) ; assertEquals ( MSG , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void estConstructorThrowable ( ) { final EncoderException e = new EncoderException ( ) ; assertEquals ( . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; assertEquals ( , e . getCause ( ) ) ; } 
public void checkEncoding ( final String expected , final String source ) hrows EncoderException { Assert . assertEquals ( " Source: " + source , expected , his . getStringEncoder ( ) . encode ( source ) ) ; } 
protected void checkEncodings ( final String [ ] [ ] data ) hrows EncoderException { for ( final String [ ] element : data ) { his . checkEncoding ( element [ 1 ] , element [ 0 ] ) ; 
protected void checkEncodingVariations ( final String expected , final String data [ ] ) hrows EncoderException { for ( final String element : data ) { his . checkEncoding ( expected , element ) ; 
public void estEncodeEmpty ( ) hrows Exception { final Encoder encoder = his . getStringEncoder ( ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; encoder . encode ( " " ) ; } 
public void estEncodeNull ( ) hrows Exception { final StringEncoder encoder = his . getStringEncoder ( ) ; ry { encoder . encode ( null ) ; 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { final StringEncoder encoder = his . getStringEncoder ( ) ; encoder . encode ( new Float ( 3.4 ) ) ; } catch ( final Exception e ) { exceptionThrown = rue ; } Assert . assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; } 
public void estLocaleIndependence ( ) hrows Exception { final StringEncoder encoder = his . getStringEncoder ( ) ; final String [ ] data = { " I " , " i " , } ; final Locale orig = Locale . getDefault ( ) ; final Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( final String element : data ) { 
public void estComparatorWithSoundex ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertTrue ( " O'Brien and O'Brian didn't come out with " + " he same Soundex, something must be wrong here " , 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; Collections . sort ( estList , sCompare ) ; final String [ ] resultArray = estList . oArray ( new String [ 0 ] ) ; for ( int i = 0 ; i < resultArray . length ; i + + ) { assertEquals ( " Result Array not Equal to Control Array at index: " + i , controlArray [ i ] , resultArray [ i ] ) ; 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final int compare = sCompare . compare ( new Double ( 3.0 ) , Long . valueOf ( 3 ) ) ; assertEquals ( " Trying to compare objects that make no sense to the underlying encoder should return a zero compare code " , 0 , compare ) ; 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final Base32OutputStream base32os = new Base32OutputStream ( bos ) ; base32os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; base32os . close ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base32InputStream ins = new Base32InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = Base32TestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec105 ( ) hrows IOException { final Base32InputStream in = new Base32InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; ry { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 1 , b32stream . available ( ) ) ; assertEquals ( 3 , b32stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b32stream.available()); assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); assertEquals(0, b32stream.available()); b32stream.close(); } 
private void estBase32EmptyInputStream ( final int chuckSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, seperator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base32InputStream.markSupported() is false", in.markSupported()); in.close(); } 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base32InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; in . close ( ) ; } 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; fail ( " Base32InputStream.read(null, 0, 0) to throw a NullPointerException " ) ; } catch ( final NullPointerException e ) { Expected } in.close(); } 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( final IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); fail("Base32InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } in.close(); } 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; final byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b32stream . skip ( 0 ) ) ; b32stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 102 , 111 , 111 , 0 , 0 , 0 } ) ; End of stream reached assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; assertEquals ( 3 , b32stream . skip ( 1024 ) ) ; End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(10)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close();} 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(3, b32stream.skip(3)); End of stream reached assertEquals(-1, b32stream.read()); assertEquals(-1, b32stream.read()); b32stream.close(); } 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; final Base32InputStream b32stream = new Base32InputStream ( ins ) ; b32stream . skip ( - 10 ) ; b32stream . close ( ) ; } 
private void estBase32EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, seperator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; final Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( final IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); fail("Expected Base32OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } out.close(); } 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; final Base32OutputStream out = new Base32OutputStream ( bout ) ; ry { out . write ( null , 0 , 0 ) ; fail ( " Expcted Base32OutputStream.write(null) to throw a NullPointerException " ) ; } catch ( final NullPointerException e ) { Expected } out.close(); } 
public void estBase32Samples ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { final Base32 codec = new Base32 ( rue ) ; for ( final String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
public void estBase32Chunked ( ) hrows Exception { final Base32 codec = new Base32 ( 20 ) ; for ( final String [ ] element : BASE32_TEST_CASES_CHUNKED ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( Charsets . UTF_8 ) ) ) ; 
public void estRandomBytes ( ) { for ( int i = 0 ; i < 20 ; i + + ) { final Base32 codec = new Base32 ( ) ; 
public void estRandomBytesChunked ( ) { for ( int i = 0 ; i < 20 ; i + + ) { final Base32 codec = new Base32 ( 10 ) ; 
public void estRandomBytesHex ( ) { for ( int i = 0 ; i < 20 ; i + + ) { final Base32 codec = new Base32 ( rue ) ; 
static byte [ ] streamToBytes ( final InputStream in , byte [ ] buf ) hrows IOException { ry { int [ ] status = fill ( buf , 0 , in ) ; int size = status [ SIZE_KEY ] ; int lastRead = status [ LAST_READ_KEY ] ; while ( lastRead ! = - 1 ) { buf = resizeArray ( buf ) ; status = fill ( buf , size , in ) ; size = status [ SIZE_KEY ] ; lastRead = status [ LAST_READ_KEY ] ; } if ( buf . length ! = size ) { final byte [ ] smallerBuf = new byte [ size ] ; System . arraycopy ( buf , 0 , smallerBuf , 0 , size ) ; buf = smallerBuf ; } } finally { in . close ( ) ; } return buf ; } 
private static byte [ ] resizeArray ( final byte [ ] bytes ) { final byte [ ] biggerBytes = new byte [ bytes . length * 2 ] ; System . arraycopy ( bytes , 0 , biggerBytes , 0 , bytes . length ) ; return biggerBytes ; } 
static byte [ ] [ ] randomData ( final BaseNCodec codec , final int size ) { final Random r = new Random ( ) ; final byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; final byte [ ] encoded = codec . encode ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
static boolean bytesContain ( final byte [ ] bytes , final byte c ) { for ( final byte b : bytes ) { if ( b = = c ) { return rue ; } } return false ; } 
public void estEncoder ( ) hrows EncoderException { final Encoder enc = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estDecoder ( ) hrows DecoderException { final Decoder dec = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estBinaryEncoder ( ) hrows EncoderException { final BinaryEncoder enc = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estBinaryDecoder ( ) hrows DecoderException { final BinaryDecoder dec = new Base64 ( ) ; for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
private static byte [ ] utf8 ( final String s ) { We would use commons-codec-1.4.jar own utility method for this, but we need this class to be able to run against commons-codec-1.3.jar, hence the duplication here. return s != null ? s.getBytes(Charsets.UTF_8) : null; } 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final Base64OutputStream base64os = new Base64OutputStream ( bos ) ; base64os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; base64os . close ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = Base64TestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec105 ( ) hrows IOException { final Base64InputStream in = new Base64InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ; ry { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estCodec101 ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; final Base64InputStream in = new Base64InputStream ( bais ) ; final byte [ ] result = new byte [ 8192 ] ; int c = in . read ( result ) ; assertTrue ( " Codec101: First read successful [c= " + c + " ] " , c > 0 ) ; c = in . read ( result ) ; assertTrue ( " Codec101: Second read should report end-of-stream [c= " + c + " ] " , c < 0 ) ; in . close ( ) ; } 
public void estInputStreamReader ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; final Base64InputStream in = new Base64InputStream ( bais ) ; final InputStreamReader isr = new InputStreamReader ( in ) ; final BufferedReader br = new BufferedReader ( isr ) ; final String line = br . readLine ( ) ; assertNotNull ( " Codec101: InputStreamReader works! " , line ) ; br . close ( ) ; } 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final ByteArrayInputStream data = new ByteArrayInputStream ( codec98 ) ; final Base64InputStream stream = new Base64InputStream ( data ) ; This line causes an NPE in commons-codec-1.4.jar: final byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("codec-98 NPE Base64InputStream", Base64TestData.CODEC_98_NPE_DECODED, decoded); } 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 1 , b64stream . available ( ) ) ; assertEquals ( 6 , b64stream . skip ( 10 ) ) ; End of stream reached assertEquals(0, b64stream.available()); assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); assertEquals(0, b64stream.available()); b64stream.close(); } 
private void estBase64EmptyInputStream ( final int chuckSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, seperator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, seperator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; Always returns false for now. assertFalse("Base64InputStream.markSupported() is false", in.markSupported()); in.close(); } 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; bytesRead = in . read ( buf , 0 , 0 ) ; assertEquals ( " Base64InputStream.read(buf, 0, 0) returns 0 " , 0 , bytesRead ) ; in . close ( ) ; } 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( null , 0 , 0 ) ; fail ( " Base64InputStream.read(null, 0, 0) to throw a NullPointerException " ) ; } catch ( final NullPointerException e ) { Expected } in.close(); } 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ; ry { in . read ( buf , - 1 , 0 ) ; fail ( " Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException " ) ; } catch ( final IndexOutOfBoundsException e ) { Expected } try { in.read(buf, 0, -1); fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length + 1, 0); fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } try { in.read(buf, buf.length - 1, 2); fail("Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException e) { Expected } in.close(); } 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; assertEquals ( 6 , b64stream . skip ( Integer . MAX_VALUE ) ) ; End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; final byte [ ] actualBytes = new byte [ 6 ] ; assertEquals ( 0 , b64stream . skip ( 0 ) ) ; b64stream . read ( actualBytes , 0 , actualBytes . length ) ; assertArrayEquals ( actualBytes , new byte [ ] { 0 , 0 , 0 , ( byte ) 255 , ( byte ) 255 , ( byte ) 255 } ) ; End of stream reached assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(10)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; due to CODEC-130, skip now skips correctly decoded characters rather than encoded assertEquals(6, b64stream.skip(6)); End of stream reached assertEquals(-1, b64stream.read()); assertEquals(-1, b64stream.read()); b64stream.close(); } 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; final Base64InputStream b64stream = new Base64InputStream ( ins ) ; b64stream . skip ( - 10 ) ; b64stream . close ( ) ; } 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final byte [ ] codec98_1024 = new byte [ 1024 ] ; System . arraycopy ( codec98 , 0 , codec98_1024 , 0 , codec98 . length ) ; final ByteArrayOutputStream data = new ByteArrayOutputStream ( 1024 ) ; final Base64OutputStream stream = new Base64OutputStream ( data , false ) ; stream . write ( codec98_1024 , 0 , 1024 ) ; stream . close ( ) ; final byte [ ] decodedBytes = data . oByteArray ( ) ; final String decoded = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( " codec-98 NPE Base64OutputStream " , Base64TestData . CODEC_98_NPE_DECODED , decoded 
private void estBase64EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CRLF ) ; } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] seperator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, seperator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; final Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( buf , - 1 , 1 ) ; fail ( " Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException " ) ; } catch ( final IndexOutOfBoundsException ioobe ) { Expected } try { out.write(buf, 1, -1); fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length + 1, 0); fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } try { out.write(buf, buf.length - 1, 2); fail("Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException"); } catch (final IndexOutOfBoundsException ioobe) { Expected } out.close(); } 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; final Base64OutputStream out = new Base64OutputStream ( bout ) ; ry { out . write ( null , 0 , 0 ) ; 
public void estIsStringBase64 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; final String invalidString = validString + ( char ) 0 ; append null character try { Base64.isBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (final NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public void estBase64 ( ) { final String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); bogus characters to decode (to skip actually) {e-acute*6} final byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); final String decodeString = StringUtils.newStringUtf8(decode); assertEquals("decode hello world", "Hello World", decodeString); } 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estCodec68 ( ) { final byte [ ] x = new byte [ ] { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public void estCodeInteger1 ( ) { final String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; final BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger2 ( ) { final String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; final BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger3 ( ) { final String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; final BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estCodeInteger4 ( ) { final String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; final BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( Charsets . UTF_8 ) ) ) ; } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; '}); OK assertNotNull(base64); } 
public void estConstructor_Int_ByteArray_Boolean ( ) { final Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; final byte [ ] encoded = base64 . encode ( Base64TestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base64(65, \\ , false) " , expectedResult , result ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)", result, expectedResult); } 
public void estDecodeWithWhitespace ( ) hrows Exception { final String orig = " I am a late night coder. " ; final byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( Charsets . UTF_8 ) ) ; final StringBuilder intermediate = new StringBuilder ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; final byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( Charsets . UTF_8 ) ; final byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; final String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { final byte [ ] data = new byte [ his . getRandom ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estEncodeDecodeSmall ( ) { for ( int i = 0 ; i < 12 ; i + + ) { final byte [ ] data = new byte [ i ] ; 
public void estCodec112 ( ) { size calculation assumes always chunked final byte[] in = new byte[] {0}; final byte[] out=Base64.encodeBase64(in); Base64.encodeBase64(in, false, false, out.length); } 
private void estEncodeOverMaxSize ( final int maxSize ) hrows Exception { ry { Base64 . encodeBase64 ( Base64TestData . DECODED , rue , false , maxSize ) ; 
public void estIsUrlSafe ( ) { final Base64 base64Standard = new Base64 ( false ) ; final Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; final byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isBase64(whiteSpace)=true " , Base64 . isBase64 ( whiteSpace ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { final byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isBase64 ( bArray ) ) ; ry { final Base64 b64 = new Base64 ( ) ; 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; ry { b64 . decode ( Integer . valueOf ( 5 ) ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = Base64 . encodeBase64 ( original . getBytes ( Charsets . UTF_8 ) ) ; final Base64 b64 = new Base64 ( ) ; final Object oDecoded = b64 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; ry { b64 . encode ( " Yadayadayada " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( Charsets . UTF_8 ) ; final Base64 b64 = new Base64 ( ) ; final Object oEncoded = b64 . encode ( origObj ) ; final byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , new String ( b64 . encode ( " Hello World " . getBytes ( Charsets . UTF_8 ) ) ) ) ; } 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estRfc4648Section10DecodeWithCrLf ( ) { final String CRLF = StringUtils . newStringUsAscii ( Base64 . CHUNK_SEPARATOR ) ; assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " + CRLF ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " + CRLF ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " + CRLF ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " + CRLF ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " + CRLF ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " + CRLF ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " + CRLF ) ) ) ; } 
private void estDecodeEncode ( final String encodedText ) { final String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; final String encodedText2 = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( decodedText ) ) ; assertEquals ( encodedText , encodedText2 ) ; } 
private void estEncodeDecode ( final String plainText ) { final String encodedText = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( plainText ) ) ; final String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; assertEquals ( plainText , decodedText ) ; } 
public void estUrlSafe ( ) { test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, true); 
public void estUUID ( ) hrows DecoderException { The 4 UUID's below contains mixtures of + and / to help us test the URL-SAFE encoding mode. final byte[][] ids = new byte[4][]; ids[0] was chosen so that it encodes with at least one +. ids[0] = Hex.decodeHex("94ed8d0319e4493399560fb67404d370".toCharArray()); ids[1] was chosen so that it encodes with both / and +. ids[1] = Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090".toCharArray()); ids[2] was chosen so that it encodes with at least one /. ids[2] = Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca".toCharArray()); ids[3] was chosen so that it encodes with both / and +, with / right at the beginning. ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray()); final byte[][] standard = new byte[4][]; standard[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA=="); standard[1] = StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA=="); standard[2] = StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg=="); standard[3] = StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A=="); final byte[][] urlSafe1 = new byte[4][]; regular padding (two '==' signs). urlSafe1[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=="); urlSafe1[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=="); urlSafe1[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=="); urlSafe1[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=="); final byte[][] urlSafe2 = new byte[4][]; single padding (only one '=' sign). urlSafe2[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA="); urlSafe2[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA="); urlSafe2[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg="); urlSafe2[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A="); final byte[][] urlSafe3 = new byte[4][]; no padding (no '=' signs). urlSafe3[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA"); urlSafe3[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA"); urlSafe3[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg"); urlSafe3[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A"); for (int i = 0; i < 4; i++) { final byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertEquals("byteToString null", null, base64.encodeToString(b3)); assertEquals("byteToString static null", null, Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; for url-safe tests assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8(base64.decode(s1))); assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8((byte[])base64.decode((Object)s1))); assertEquals("StringToByte static Hello World", "Hello World", StringUtils.newStringUtf8(Base64.decodeBase64(s1))); assertEquals("StringToByte \"\"", "", StringUtils.newStringUtf8(base64.decode(s2))); assertEquals("StringToByte static \"\"", "", StringUtils.newStringUtf8(Base64.decodeBase64(s2))); assertEquals("StringToByte null", null, StringUtils.newStringUtf8(base64.decode(s3))); assertEquals("StringToByte static null", null, StringUtils.newStringUtf8(Base64.decodeBase64(s3))); assertTrue("StringToByte UUID", Arrays.equals(b4, base64.decode(s4b))); assertTrue("StringToByte static UUID", Arrays.equals(b4, Base64.decodeBase64(s4a))); assertTrue("StringToByte static-url-safe UUID", Arrays.equals(b4, Base64.decodeBase64(s4b))); } 
private String oString ( final byte [ ] data ) { final StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { buf . append ( data [ i ] ) ; if ( i ! = data . length - 1 ) { buf . append ( " , " ) ; } } return buf . oString ( ) ; } 
public void estHugeLineSeparator ( ) { final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192 ; final int Base64_BYTES_PER_ENCODED_BLOCK = 4 ; final byte [ ] baLineSeparator = new byte [ BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3 ] ; final Base64 b64 = new Base64 ( Base64_BYTES_PER_ENCODED_BLOCK , baLineSeparator ) ; final String strOriginal = " Hello World " ; final String strDecoded = new String ( b64 . decode ( b64 . encode ( StringUtils . getBytesUtf8 ( strOriginal ) ) ) ) ; assertEquals ( " estDEFAULT_BUFFER_SIZE " , strOriginal , strDecoded ) ; } 
static byte [ ] [ ] randomData ( final int size , final boolean urlSafe ) { final Random r = new Random ( ) ; final byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; final byte [ ] encoded = urlSafe ? Base64 . encodeBase64URLSafe ( decoded ) : Base64 . encodeBase64 ( decoded ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
protected boolean isInAlphabet ( final byte b ) { return b = = 'O' | | b = = 'K' ; allow OK } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.PAD})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); }} 
public void estDecodeObjectException ( ) { ry { his . instance . decode ( new Object ( ) ) ; } catch ( final DecoderException e ) { all is well. return; } fail("Expected DecoderException"); } 
void assertDecodeObject ( final byte [ ] bits , final String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( Charsets . UTF_8 ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estEncodeObjectNull ( ) hrows Exception { final Object obj = new byte [ 0 ] ; assertEquals ( 0 , ( ( char [ ] ) instance . encode ( obj ) ) . length ) ; } 
public void estEncodeObjectException ( ) { ry { instance . encode ( " " ) ; } catch ( final EncoderException e ) { all is well. return; } fail("Expected EncoderException"); } 
public int read ( final byte b [ ] , final int pos , final int len ) hrows IOException { if ( his . countdown - - > 0 ) { b [ pos ] = '' ; 
private boolean charsetSanityCheck ( final String name ) { final String source = " he quick brown dog jumped over the lazy fox " ; ry { final byte [ ] bytes = source . getBytes ( name ) ; 
private void checkDecodeHexOddCharacters ( final char [ ] data ) { ry { Hex . decodeHex ( data ) ; 
private void log ( final Throwable ) { if ( LOG ) { . printStackTrace ( System . out ) ; 
public void estCustomCharset ( ) hrows UnsupportedEncodingException , DecoderException { for ( final String name : Charset . availableCharsets ( ) . keySet ( ) ) { estCustomCharset ( name , " estCustomCharset " ) ; 
private void estCustomCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( charsetSanityCheck ( name ) = = false ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
public void estEncodeDecodeRandom ( ) hrows DecoderException , EncoderException { final Random random = new Random ( ) ; final Hex hex = new Hex ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ random . nextInt ( 10000 ) + 1 ] ; 
public void estEncodeZeroes ( ) { final char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estHelloWorldLowerCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estHelloWorldUpperCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = " ISO-8859-1 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
private void estGetBytesUnchecked ( final String charsetName ) hrows UnsupportedEncodingException { final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUnchecked ( STRING_FIXTURE , charsetName ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = " US-ASCII " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16BE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16LE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-8 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; Assert . assertTrue ( Arrays . equals ( expected , actual ) ) ; } 
private void estNewString ( final String charsetName ) hrows UnsupportedEncodingException { final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newString ( BYTES_FIXTURE , charsetName ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = " ISO-8859-1 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringIso8859_1 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = " US-ASCII " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUsAscii ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf16 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16BE " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16BE , charsetName ) ; final String actual = StringUtils . newStringUtf16Be ( BYTES_FIXTURE_16BE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16LE " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16LE , charsetName ) ; final String actual = StringUtils . newStringUtf16Le ( BYTES_FIXTURE_16LE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estNewStringUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-8 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf8 ( BYTES_FIXTURE ) ; Assert . assertEquals ( expected , actual ) ; } 
public void estApr1CryptBytes ( ) { random salt final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; final String hash = Md5Crypt.apr1Crypt(keyBytes); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptWithoutSalt ( ) { Without salt, a random is generated final String hash = Md5Crypt.apr1Crypt("secret"); assertTrue(hash.matches("^\\$apr1\\$[a-zA-Z0-9\\./]{8}\\$[a-zA-Z0-9\\./]{22}$")); final String hash2 = Md5Crypt.apr1Crypt("secret"); assertNotSame(hash, hash2); } 
public void estB64from24bit ( ) { final StringBuilder buffer = new StringBuilder ( " " ) ; B64 . b64from24bit ( ( byte ) 8 , ( byte ) 16 , ( byte ) 64 , 2 , buffer ) ; B64 . b64from24bit ( ( byte ) 7 , ( byte ) 77 , ( byte ) 120 , 4 , buffer ) ; assertEquals ( " ./spo/ " , buffer . oString ( ) ) ; } 
public void estCryptWithBytes ( ) { final byte [ ] keyBytes = new byte [ ] { 'b' , 'y' , 't' , 'e' } ; final String hash = Crypt . crypt ( keyBytes ) ; assertEquals ( hash , Crypt . crypt ( " byte " , hash ) ) ; } 
public void estSha256LargetThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8 " , Sha2Crypt . sha256Crypt ( buffer , " $5$abc " ) ) ; } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd")); } @Test(expected = IllegalArgumentException.class) public void testSha2CryptWrongSalt() { Sha2Crypt.sha512Crypt("secret".getBytes(Charsets.UTF_8), "xx"); } @Test(expected = IllegalArgumentException.class) public void testSha512CryptWithEmptySalt() { Sha2Crypt.sha512Crypt("secret".getBytes(), ""); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); }} 
public void estSha256LargetThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1 " , Sha2Crypt . sha512Crypt ( buffer , " $6$abc " ) ) ; } 
public void estUnixCryptWithoutSalt ( ) { final String hash = UnixCrypt . crypt ( " foo " ) ; assertTrue ( hash . matches ( " ^[a-zA-Z0-9./]{13}$ " ) ) ; final String hash2 = UnixCrypt . crypt ( " foo " ) ; assertNotSame ( hash , hash2 ) ; } 
public void estEndMb ( ) hrows EncoderException { final String [ ] [ ] data = { { " mb " , " M11111 " } , { " mbmb " , " MPM111 " } } ; his . checkEncodings ( data ) ; } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { final Caverphone1 caverphone = new Caverphone1 ( ) ; Assert . assertFalse ( " Caverphone encodings should not be equal " , caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) ) ; Assert . assertTrue ( " Caverphone encodings should be equal " , caverphone . isEncodeEqual ( " Peter " , " Peady " ) ) ; } 
public void estSpecificationV1Examples ( ) hrows EncoderException { final String [ ] [ ] data = { { " David " , " TFT111 " } , { " Whittle " , " WTL111 " } } ; his . checkEncodings ( data ) ; } 
public void estWikipediaExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Lee " , " L11111 " } , { " Thompson " , " TMPSN1 " } } ; his . checkEncodings ( data ) ; } 
public void estCaverphoneRevisitedExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } } ; his . checkEncodings ( data ) ; } 
public void estEndMb ( ) hrows EncoderException { final String [ ] [ ] data = { { " mb " , " M111111111 " } , { " mbmb " , " MPM1111111 " } } ; his . checkEncodings ( data ) ; } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { final Caverphone2 caverphone = new Caverphone2 ( ) ; Assert . assertFalse ( " Caverphone encodings should not be equal " , caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) ) ; Assert . assertTrue ( " Caverphone encodings should be equal " , caverphone . isEncodeEqual ( " Peter " , " Peady " ) ) ; } 
public void estSpecificationExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } } ; his . checkEncodings ( data ) ; } 
public void estEdgeCases ( ) hrows EncoderException { final String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , a-umlaut {"\u00F6", "0"}, o-umlaut {"\u00FC", "0"}, u-umlaut {"aa", "0"}, {"ha", "0"}, {"h", ""}, {"aha", "0"}, {"b", "1"}, {"p", "1"}, {"ph", "3"}, {"f", "3"}, {"v", "3"}, {"w", "3"}, {"g", "4"}, {"k", "4"}, {"q", "4"}, {"x", "48"}, {"ax", "048"}, {"cx", "48"}, {"l", "5"}, {"cl", "45"}, {"acl", "085"}, {"mn", "6"}, {"r", "7"}}; this.checkEncodings(data); } 
public void estVariationsMella ( ) hrows EncoderException { final String data [ ] = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; his . checkEncodingVariations ( " 65 " , data ) ; } 
public void estVariationsMeyer ( ) hrows EncoderException { final String data [ ] = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
private void checkDoubleMetaphone ( final int ypeIndex , final boolean alternate ) { for ( int i = 0 ; i < TEST_DATA . length ; i + + ) { final String value = TEST_DATA [ i ] [ 0 ] ; 
private void assertDoubleMetaphone ( final String expected , final String source ) { assertEquals ( expected , his . getStringEncoder ( ) . encode ( source ) ) ; ry { assertEquals ( expected , his . getStringEncoder ( ) . encode ( ( Object ) source ) ) ; } catch ( final EncoderException e ) { fail ( " Unexpected expection: " + e ) ; } assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source ) ) ; assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source , false ) ) ; } 
public void assertDoubleMetaphoneAlt ( final String expected , final String source ) { assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source , rue ) ) ; } 
public void doubleMetaphoneEqualTest ( final String [ ] [ ] pairs , final boolean useAlternate ) { his . validateFixture ( pairs ) ; for ( final String [ ] pair : pairs ) { final String name0 = pair [ 0 ] ; 
public void doubleMetaphoneNotEqualTest ( final boolean alternate ) { assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " , alternate ) ) ; assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Band " , " Brain " , alternate ) ) ; if ( ! alternate ) { assertFalse ( his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " ) ) ; 
public void estSetMaxCodeLength ( ) { final String value = " jumped " ; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone ( ) ; Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } 
public void estIsDoubleMetaphoneEqualBasic ( ) { final String [ ] [ ] estFixture = new String [ ] [ ] { { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " cookie " , " quick " } , { " quick " , " cookie " } , { " Brian " , " Bryan " } , { " Auto " , " Otto " } , { " Steven " , " Stefan " } , { " Philipowitz " , " Filipowicz " } } ; doubleMetaphoneEqualTest ( estFixture , false ) ; doubleMetaphoneEqualTest ( estFixture , rue ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended3() { this.validateFixture(FIXTURE); final StringBuilder failures = new StringBuilder(); final StringBuilder matches = new StringBuilder(); final String cr = System.getProperty("line.separator"); matches.append("private static final String[][] MATCHES = {" + cr); int failCount = 0; for (int i = 0; i < FIXTURE.length; i++) { final String name0 = FIXTURE[i][0]; final String name1 = FIXTURE[i][1]; final boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false); final boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { final String failMsg = "[" + i + "] " + name0 + " and " + name1 + cr; failures.append(failMsg); failCount++; } else { matches.append("{\"" + name0 + "\", \"" + name1 + "\"}," + cr); } } matches.append("};"); Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. String msg = failures.toString(); fail(failCount + " failures out of " + FIXTURE.length + ". The following could be made to match: " + cr + msg); } } @Test public void testIsDoubleMetaphoneEqualWithMATCHES() { this.validateFixture(MATCHES); for (int i = 0; i < MATCHES.length; i++) { final String name0 = MATCHES[i][0]; final String name1 = MATCHES[i][1]; final boolean match1 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, false); final boolean match2 = this.getStringEncoder().isDoubleMetaphoneEqual(name0, name1, true); if (match1 == false && match2 == false) { fail("Expected match [" + i + "] " + name0 + " and " + name1); } } } @Test public void testIsDoubleMetaphoneNotEqual() { doubleMetaphoneNotEqualTest(false); doubleMetaphoneNotEqualTest(true); } @Test public void testCCedilla() { assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00e7", "S")); c-cedilla } @Test public void testNTilde() { assertTrue(this.getStringEncoder().isDoubleMetaphoneEqual("\u00f1", "N")); n-tilde } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended2 ( ) { final String [ ] [ ] estFixture = new String [ ] [ ] { { " Jablonski " , " Yablonsky " } } ; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; final StringBuilder failures = new StringBuilder ( ) ; final StringBuilder matches = new StringBuilder ( ) ; final String cr = System . getProperty ( " line.separator " ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { final String name0 = FIXTURE [ i ] [ 0 ] ; final String name1 = FIXTURE [ i ] [ 1 ] ; final boolean match1 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; final boolean match2 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { final String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public void estIsDoubleMetaphoneEqualWithMATCHES ( ) { his . validateFixture ( MATCHES ) ; for ( int i = 0 ; i < MATCHES . length ; i + + ) { final String name0 = MATCHES [ i ] [ 0 ] ; 
public void validateFixture ( final String [ ] [ ] pairs ) { if ( pairs . length = = 0 ) { fail ( " Test fixture is empty " ) ; } for ( int i = 0 ; i < pairs . length ; i + + ) { if ( pairs [ i ] . length ! = 2 ) { 
public void assertIsMetaphoneEqual ( final String source , final String [ ] matches ) { match source to all matches for (final String matche : matches) { assertTrue("Source: " + source + ", should have same Metaphone as: " + matche, this.getStringEncoder().isMetaphoneEqual(source, matche)); } match to each other for (final String matche : matches) { for (final String matche2 : matches) { 
public void assertMetaphoneEqual ( final String [ ] [ ] pairs ) { his . validateFixture ( pairs ) ; for ( final String [ ] pair : pairs ) { final String name0 = pair [ 0 ] ; 
private void assertEncodings ( final String [ ] . . . estValues ) hrows EncoderException { for ( final String [ ] arr : estValues ) { Assert . assertEquals ( " Problem with " + arr [ 0 ] , arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) ) ; 
private void encodeAll ( final String [ ] strings , final String expectedEncoding ) hrows EncoderException { for ( final String string : strings ) { Assert . assertEquals ( " Problem with " + string , expectedEncoding , getStringEncoder ( ) . encode ( string ) ) ; 
public void estTrueVariant ( ) { final Nysiis encoder = new Nysiis ( rue ) ; final String encoded = encoder . encode ( " WESTERLUND " ) ; Assert . assertTrue ( encoded . length ( ) < = 6 ) ; Assert . assertEquals ( " WASTAR " , encoded ) ; } 
public void estGetMappingCodeNonLetter ( ) { final char code = his . getStringEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( " Code does not equals zero " , 0 , code ) ; } 
private void assertNotEmpty ( final BeiderMorseEncoder bmpm , final String value ) hrows EncoderException { Assert . assertFalse ( value , bmpm . encode ( value ) . equals ( " " ) ) ; } 
private BeiderMorseEncoder createGenericApproxEncoder ( ) { final BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . APPROX ) ; return encoder ; } 
public void estAllChars ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = Character . MIN_VALUE ; c < Character . MAX_VALUE ; c + + ) { bmpm . encode ( Character . oString ( c ) ) ; 
public void estAsciiEncodeNotEmpty1Letter ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c = 'a' ; c < = 'z' ; c + + ) { final String value = Character . oString ( c ) ; 
public void estAsciiEncodeNotEmpty2Letters ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; for ( char c1 = 'a' ; c1 < = 'z' ; c1 + + ) { for ( char c2 = 'a' ; c2 < = 'z' ; c2 + + ) { 
public void estEncodeGna ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; bmpm . encode ( " gna " ) ; } 
public void estLongestEnglishSurname ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; bmpm . encode ( " MacGhilleseatheanaich " ) ; } 
public void estNegativeIndexForRuleMatchIndexOutOfBoundsException ( ) { final Rule r = new Rule ( " a " , " " , " " , new Rule . Phoneme ( " " , Languages . ANY_LANGUAGE ) ) ; r . patternAndContextMatches ( " bob " , - 1 ) ; } 
public void estOOM ( ) hrows EncoderException { final String phrase = " 200697900'-->&#1913348150;</ bceaeef >aadaabcf \" aedfbff<!-- '-->?>cae " + " cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo< cc = \" abff \" /></ afe > " + " <script><!-- f(';< cf aefbeef = \" bfabadcf \" ebbfeedd = fccabeb > " ; final BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . EXACT ) ; encoder . setMaxPhonemes ( 10 ) ; final String phonemes = encoder . encode ( phrase ) ; assertTrue ( phonemes . length ( ) > 0 ) ; final String [ ] phonemeArr = phonemes . split ( " \\ | " ) ; assertTrue ( phonemeArr . length < = 10 ) ; } 
public void estSetConcat ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setConcat ( false ) ; assertFalse ( " Should be able to set concat to false " , bmpm . isConcat ( ) ) ; } 
public void estSetNameTypeAsh ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . ASHKENAZI ) ; assertEquals ( " Name type should have been set to ash " , NameType . ASHKENAZI , bmpm . getNameType ( ) ) ; } 
public void estSetRuleTypeExact ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setRuleType ( RuleType . EXACT ) ; assertEquals ( " Rule type should have been set to exact " , RuleType . EXACT , bmpm . getRuleType ( ) ) ; } 
public void estSetRuleTypeToRulesIllegalArgumentException ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setRuleType ( RuleType . RULES ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; final StringBuilder stringBuffer = new StringBuilder ( ) ; stringBuffer . append ( TEST_CHARS [ 0 ] ) ; for ( int i = 0 , j = 1 ; i < 40 ; i + + , j + + ) { if ( j = = TEST_CHARS . length ) { 
public void estSpeedCheck2 ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; final String phrase = " ItstheendoftheworldasweknowitandIfeelfine " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void estSpeedCheck3 ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = his . createGenericApproxEncoder ( ) ; final String phrase = " abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void estLanguageGuessing ( ) { final Languages . LanguageSet guesses = his . lang . guessLanguages ( his . name ) ; assertTrue ( " language predicted for name ' " + his . name + " ' is wrong: " + guesses + " should contain ' " + his . language + " ' " , guesses . contains ( his . language ) ) ; 
private static String encode ( final Map < String , String > args , final boolean concat , final String input ) { Languages . LanguageSet languageSet ; PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true final String nameTypeArg = args.get("nameType"); final NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg); final String ruleTypeArg = args.get("ruleType"); final RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. final String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); 
public void estEncode ( ) { final PhoneticEngine engine = new PhoneticEngine ( his . nameType , his . ruleType , his . concat , his . maxPhonemes ) ; final String phoneticActual = engine . encode ( his . name ) ; System.err.println("expecting: " + this.phoneticExpected); System.err.println("actual: " + phoneticActual); assertEquals("phoneme incorrect", this.phoneticExpected, phoneticActual); if (this.concat) { final String[] split = phoneticActual.split("\\|"); 
public void describeTo ( final Description description ) { description . appendText ( " value should be negative " ) ; } 
public boolean matches ( final Object item ) { return ( ( Integer ) item ) . intValue ( ) < 0 ; } 
private Rule . Phoneme [ ] [ ] makePhonemes ( ) { final String [ ] [ ] words = { { " rinD " , " rinDlt " , " rina " , " rinalt " , " rino " , " rinolt " , " rinu " , " rinult " } , { " dortlaj " , " dortlej " , " ortlaj " , " ortlej " , " ortlej-dortlaj " } } ; final Rule . Phoneme [ ] [ ] phonemes = new Rule . Phoneme [ words . length ] [ ] ; for ( int i = 0 ; i < words . length ; i + + ) { final String [ ] words_i = words [ i ] ; final Rule . Phoneme [ ] phonemes_i = phonemes [ i ] = new Rule . Phoneme [ words_i . length ] ; for ( int j = 0 ; j < words_i . length ; j + + ) { phonemes_i [ j ] = new Rule . Phoneme ( words_i [ j ] , Languages . NO_LANGUAGES ) ; } } return phonemes ; } 
public void estPhonemeComparedToLaterIsNegative ( ) { for ( final Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( int i = 0 ; i < phs . length ; i + + ) { 
public void estPhonemeComparedToSelfIsZero ( ) { for ( final Rule . Phoneme [ ] phs : makePhonemes ( ) ) { for ( final Rule . Phoneme ph : phs ) { 
public void estSubSequenceWorks ( ) { AppendableCharSequence is private to Rule. We can only make it through a Phoneme. final Rule.Phoneme a = new Rule.Phoneme("a", null); final Rule.Phoneme b = new Rule.Phoneme("b", null); final Rule.Phoneme cd = new Rule.Phoneme("cd", null); final Rule.Phoneme ef = new Rule.Phoneme("ef", null); final Rule.Phoneme ghi = new Rule.Phoneme("ghi", null); final Rule.Phoneme jkl = new Rule.Phoneme("jkl", null); assertEquals('a', a.getPhonemeText().charAt(0)); assertEquals('b', b.getPhonemeText().charAt(0)); assertEquals('c', cd.getPhonemeText().charAt(0)); assertEquals('d', cd.getPhonemeText().charAt(1)); assertEquals('e', ef.getPhonemeText().charAt(0)); assertEquals('f', ef.getPhonemeText().charAt(1)); assertEquals('g', ghi.getPhonemeText().charAt(0)); assertEquals('h', ghi.getPhonemeText().charAt(1)); assertEquals('i', ghi.getPhonemeText().charAt(2)); assertEquals('j', jkl.getPhonemeText().charAt(0)); assertEquals('k', jkl.getPhonemeText().charAt(1)); assertEquals('l', jkl.getPhonemeText().charAt(2)); final Rule.Phoneme a_b = a.append(b.getPhonemeText()); assertEquals('a', a_b.getPhonemeText().charAt(0)); assertEquals('b', a_b.getPhonemeText().charAt(1)); assertEquals("ab", a_b.getPhonemeText().subSequence(0, 2).toString()); assertEquals("a", a_b.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b.getPhonemeText().subSequence(1, 2).toString()); final Rule.Phoneme cd_ef = cd.append(ef.getPhonemeText()); assertEquals('c', cd_ef.getPhonemeText().charAt(0)); assertEquals('d', cd_ef.getPhonemeText().charAt(1)); assertEquals('e', cd_ef.getPhonemeText().charAt(2)); assertEquals('f', cd_ef.getPhonemeText().charAt(3)); assertEquals("c", cd_ef.getPhonemeText().subSequence(0, 1).toString()); assertEquals("d", cd_ef.getPhonemeText().subSequence(1, 2).toString()); assertEquals("e", cd_ef.getPhonemeText().subSequence(2, 3).toString()); assertEquals("f", cd_ef.getPhonemeText().subSequence(3, 4).toString()); assertEquals("cd", cd_ef.getPhonemeText().subSequence(0, 2).toString()); assertEquals("de", cd_ef.getPhonemeText().subSequence(1, 3).toString()); assertEquals("ef", cd_ef.getPhonemeText().subSequence(2, 4).toString()); assertEquals("cde", cd_ef.getPhonemeText().subSequence(0, 3).toString()); assertEquals("def", cd_ef.getPhonemeText().subSequence(1, 4).toString()); assertEquals("cdef", cd_ef.getPhonemeText().subSequence(0, 4).toString()); final Rule.Phoneme a_b_cd = a.append(b.getPhonemeText()).append(cd.getPhonemeText()); assertEquals('a', a_b_cd.getPhonemeText().charAt(0)); assertEquals('b', a_b_cd.getPhonemeText().charAt(1)); assertEquals('c', a_b_cd.getPhonemeText().charAt(2)); assertEquals('d', a_b_cd.getPhonemeText().charAt(3)); assertEquals("a", a_b_cd.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b_cd.getPhonemeText().subSequence(1, 2).toString()); assertEquals("c", a_b_cd.getPhonemeText().subSequence(2, 3).toString()); assertEquals("d", a_b_cd.getPhonemeText().subSequence(3, 4).toString()); assertEquals("ab", a_b_cd.getPhonemeText().subSequence(0, 2).toString()); assertEquals("bc", a_b_cd.getPhonemeText().subSequence(1, 3).toString()); assertEquals("cd", a_b_cd.getPhonemeText().subSequence(2, 4).toString()); assertEquals("abc", a_b_cd.getPhonemeText().subSequence(0, 3).toString()); assertEquals("bcd", a_b_cd.getPhonemeText().subSequence(1, 4).toString()); assertEquals("abcd", a_b_cd.getPhonemeText().subSequence(0, 4).toString()); } 
private String constructString ( final int [ ] unicodeChars ) { final StringBuilder buffer = new StringBuilder ( ) ; if ( unicodeChars ! = null ) { for ( final int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
public void estNullInput ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; assertNull ( bcodec . doDecoding ( null ) ) ; assertNull ( bcodec . doEncoding ( null ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final BCodec bcodec = new BCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?B?0JLRgdC10Lxf0L/RgNC40LLQtdGC?= " , bcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?B?R3LDvGV6aV96w6Rtw6Q=?= " , bcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , bcodec . decode ( bcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , bcodec . decode ( bcodec . encode ( ch_msg ) ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " Hello there " ; final String encoded = bcodec . encode ( plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?SGVsbG8gdGhlcmU=?= " , encoded ) ; assertEquals ( " Basic B decoding test " , plain , bcodec . decode ( encoded ) ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; assertNull ( " Null string B encoding test " , bcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string B decoding test " , bcodec . decode ( ( String ) null ) ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . decode ( est ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " what not " ; final String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded ) ; final Object result = bcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; final String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic B decoding test " , " what not " , plain ) ; final Object result = bcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
private String constructString ( final int [ ] unicodeChars ) { final StringBuilder buffer = new StringBuilder ( ) ; if ( unicodeChars ! = null ) { for ( final int unicodeChar : unicodeChars ) { buffer . append ( ( char ) unicodeChar ) ; } } return buffer . oString ( ) ; } 
public void estNullInput ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; assertNull ( qcodec . doDecoding ( null ) ) ; assertNull ( qcodec . doEncoding ( null ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final QCodec qcodec = new QCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " = Hello there = r " ; final String encoded = qcodec . encode ( plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?=3D Hello there =3D=0D=0A?= " , encoded ) ; assertEquals ( " Basic Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " ?_= r " ; final String encoded = qcodec . encode ( plain ) ; assertEquals ( " Unsafe chars Q encoding test " , " =?UTF-8?Q?=3F=5F=3D=0D=0A?= " , encoded ) ; assertEquals ( " Unsafe chars Q decoding test " , plain , qcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; assertNull ( " Null string Q encoding test " , qcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string Q decoding test " , qcodec . decode ( ( String ) null ) ) ; 
public void estEncodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . decode ( est ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
public void estEncodeDecodeBlanks ( ) hrows Exception { final String plain = " Mind those pesky blanks " ; final String encoded1 = " =?UTF-8?Q?Mind those pesky blanks?= " ; final String encoded2 = " =?UTF-8?Q?Mind_those_pesky_blanks?= " ; final QCodec qcodec = new QCodec ( ) ; qcodec . setEncodeBlanks ( false ) ; String s = qcodec . encode ( plain ) ; assertEquals ( " Blanks encoding with the Q codec test " , encoded1 , s ) ; qcodec . setEncodeBlanks ( rue ) ; s = qcodec . encode ( plain ) ; assertEquals ( " Blanks encoding with the Q codec test " , encoded2 , s ) ; s = qcodec . decode ( encoded1 ) ; assertEquals ( " Blanks decoding with the Q codec test " , plain , s ) ; s = qcodec . decode ( encoded2 ) ; assertEquals ( " Blanks decoding with the Q codec test " , plain , s ) ; } 
public void estLetUsMakeCloverHappy ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; qcodec . setEncodeBlanks ( rue ) ; assertTrue ( qcodec . isEncodeBlanks ( ) ) ; qcodec . setEncodeBlanks ( false ) ; assertFalse ( qcodec . isEncodeBlanks ( ) ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " = Hello there = r " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " =3D Hello there =3D=0D=0A " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estSafeCharEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " abc123_-.*~!@#$%^&()+{} \" \\ ;:`,/[] " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Safe chars quoted-printable encoding test " , plain , encoded ) ; assertEquals ( " Safe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estUnsafeEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " = r " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( " Unsafe chars quoted-printable encoding test " , " =3D=0D=0A " , encoded ) ; assertEquals ( " Unsafe chars quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeDecodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertNull ( " Null string quoted-printable encoding test " , qpcodec . encode ( ( String ) null ) ) ; assertNull ( " Null string quoted-printable decoding test " , qpcodec . decode ( ( String ) null ) ) ; 
public void estDecodeInvalid ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; ry { qpcodec . decode ( " = " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( final DecoderException e ) { Expected. Move on } try { qpcodec.decode("=A"); fail("DecoderException should have been thrown"); } catch (final DecoderException e) { Expected. Move on } try { qpcodec.decode("=WW"); 
public void estEncodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = qpcodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = QuotedPrintableCodec . decodeQuotedPrintable ( plain ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . decode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; 
public void estDefaultEncoding ( ) hrows Exception { final String plain = " Hello there! " ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( " UnicodeBig " ) ; qpcodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 final String encoded1 = qpcodec.encode(plain, "UnicodeBig"); final String encoded2 = qpcodec.encode(plain); assertEquals(encoded1, encoded2); } 
public void estSoftLineBreakDecode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; assertEquals ( expected , new QuotedPrintableCodec ( ) . decode ( qpdata ) ) ; } 
public void estSoftLineBreakEncode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; assertEquals ( qpdata , new QuotedPrintableCodec ( ) . encode ( expected ) ) ; } 
public void estNullInput ( ) hrows Exception { final RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; assertNull ( estcodec . decodeText ( null ) ) ; assertNull ( estcodec . encodeText ( null , CharEncoding . UTF_8 ) ) ; } 
private void assertExpectedDecoderException ( final String s ) hrows Exception { final RFC1522TestCodec estcodec = new RFC1522TestCodec ( ) ; ry { estcodec . decodeText ( s ) ; 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; his . validateState ( urlCodec ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " abc123_-.* " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Safe chars URL encoding test " , plain , encoded ) ; assertEquals ( " Safe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Unsafe chars URL encoding test " , " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded ) ; assertEquals ( " Unsafe chars URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertNull ( " Null string URL encoding test " , urlCodec . encode ( ( String ) null ) ) ; assertNull ( " Null string URL decoding test " , urlCodec . decode ( ( String ) null ) ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeInvalid ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; ry { urlCodec . decode ( " % " ) ; fail ( " DecoderException should have been thrown " ) ; } catch ( final DecoderException e ) { Expected. Move on } try { urlCodec.decode("%A"); fail("DecoderException should have been thrown"); } catch (final DecoderException e) { Expected. Move on } try { Bad 1st char after % urlCodec.decode("%WW"); fail("DecoderException should have been thrown"); } catch (final DecoderException e) { Expected. Move on } try { Bad 2nd char after % urlCodec.decode("%0W"); fail("DecoderException should have been thrown"); } catch (final DecoderException e) { Expected. Move on } this.validateState(urlCodec); } 
public void estDecodeInvalidContent ( ) hrows UnsupportedEncodingException , DecoderException { final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] input = ch_msg . getBytes ( " ISO-8859-1 " ) ; final byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } his . validateState ( urlCodec ) ; } 
public void estEncodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = urlCodec . encode ( plain ) ; assertEquals ( " Encoding a null string should return null " , null , encoded ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( Charsets . UTF_8 ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = URLCodec . decodeUrl ( plain ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . encode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . decode ( est , " charset " ) ; assertEquals ( " Result should be null " , null , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estInvalidEncoding ( ) { final URLCodec urlCodec = new URLCodec ( " NONSENSE " ) ; final String plain = " Hello there! " ; ry { urlCodec . encode ( plain ) ; fail ( " We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked. " ) ; } catch ( final EncoderException ee ) { Exception expected, test segment passes. } try { urlCodec.decode(plain); fail("We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked."); } catch (final DecoderException ee) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = new Double ( 3.0 ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDefaultEncoding ( ) hrows Exception { final String plain = " Hello there! " ; final URLCodec urlCodec = new URLCodec ( " UnicodeBig " ) ; urlCodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 final String encoded1 = urlCodec.encode(plain, "UnicodeBig"); final String encoded2 = urlCodec.encode(plain); assertEquals(encoded1, encoded2); this.validateState(urlCodec); } 
String removeDoubleConsonants ( final String name ) { String replacedName = name . oUpperCase ( ) ; for ( final String dc : DOUBLE_CONSONANT ) { if ( replacedName . contains ( dc ) ) { final String singleLetter = dc . substring ( 0 , 1 ) ; replacedName = replacedName . replace ( dc , singleLetter ) ; } } return replacedName ; } 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = in[inPos++]; if (b == PAD) { We're done. context.eof = true; break; } else { final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void encode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); final long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
private static IllegalStateException newIllegalStateException ( final String charsetName , final UnsupportedEncodingException e ) { return new IllegalStateException ( charsetName + " : " + e ) ; } 
static void b64from24bit ( final byte b2 , final byte b1 , final byte b0 , final int outLen , final StringBuilder buffer ) { The bit masking is necessary because the JVM byte type is signed! int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff); It's effectively a "for" loop but kept to resemble the original C code. int n = outLen; while (n-- > 0) { buffer.append(B64T.charAt(w & 0x3f)); 
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } 
private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if ((index == 0 && (charAt(value, index + 4) == ' ') || value.length() == 4) || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleR ( final String value , final DoubleMetaphoneResult result , final int index , final boolean slavoGermanic ) { if ( index = = value . length ( ) - 1 & & ! slavoGermanic & & contains ( value , index - 2 , 2 , " IE " ) & & ! contains ( value , index - 4 , 2 , " ME " , " MA " ) ) { result . appendAlternate ( 'R' ) ; } else { result . append ( 'R' ) ; } return charAt ( value , index + 1 ) = = 'R' ? index + 2 : index + 1 ; } 
private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language altho in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
public final Object encode ( final Object pObject ) hrows EncoderException { if ( ! ( pObject instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Match Rating Approach encoder is not of type java.lang.String " ) ; } return encode ( ( String ) pObject ) ; } 
boolean isVowel ( final String letter ) { return letter . equalsIgnoreCase ( " E " ) | | letter . equalsIgnoreCase ( " A " ) | | letter . equalsIgnoreCase ( " O " ) | | letter . equalsIgnoreCase ( " I " ) | | letter . equalsIgnoreCase ( " U " ) ; 
public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { return langs . isSingleton ( ) ? getInstance ( nameType , rt , langs . getAny ( ) ) : getInstance ( nameType , rt , Languages . ANY ) ; 
public final void estGetMinRating_1_Returns5_Successfully ( ) { assertEquals ( 5 , his . getStringEncoder ( ) . getMinRating ( 1 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully2 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_6_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 6 ) ) ; } 
public final void estgetMinRating_7_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_8_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 8 ) ) ; } 
public final void estgetMinRating_10_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 10 ) ) ; } 
public final void estgetMinRating_11_Returns_3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 11 ) ) ; } 
public final void estGetMinRating_13_Returns_1_Successfully ( ) { assertEquals ( 1 , his . getStringEncoder ( ) . getMinRating ( 13 ) ) ; } 
public final void estisVowel_SingleVowel_ReturnsTrue ( ) { assertTrue ( his . getStringEncoder ( ) . isVowel ( ( " I " ) ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , null ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( null , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEqualsSecondNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
int leftToRightThenRightToLeftProcessing ( final String name1 , final String name2 ) { final char [ ] name1Char = name1 . oCharArray ( ) ; final char [ ] name2Char = name2 . oCharArray ( ) ; final int name1Size = name1 . length ( ) - 1 ; final int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , name1Size - i + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , name2Size - i + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space final String strA = new String(name1Char).replaceAll("\\s+", EMPTY); final String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(SIX - strA.length()); 
String removeVowels ( String name ) { Extract first letter final String firstLetter = name.substring(0, 1); name = name.replaceAll("A", EMPTY); name = name.replaceAll("E", EMPTY); name = name.replaceAll("I", EMPTY); name = name.replaceAll("O", EMPTY); name = name.replaceAll("U", EMPTY); name = name.replaceAll("\\s{2,}\\b", SPACE); return isVowel(firstLetter) ? (firstLetter + name) : name; if (isVowel(firstLetter)) { return firstLetter + name; 
private void encodeAll ( final String [ ] strings , final String expectedEncoding ) { for ( final String string : strings ) { Assert . assertEquals ( " Problem with " + string , expectedEncoding , getStringEncoder ( ) . encode ( string ) ) ; 
public void estBran ( ) { encodeAll ( new String [ ] { " Brian " , " Brown " , " Brun " } , " BRAN " ) ; } 
public void estCap ( ) { his . encodeAll ( new String [ ] { " Capp " , " Cope " , " Copp " , " Kipp " } , " CAP " ) ; } 
public void estDad ( ) { Data Quality and Record Linkage Techniques P.121 claims this is DAN, but it should be DAD, verified also with dropby.com this.encodeAll(new String[] { "Dent" }, "DAD"); } 
public void estDan ( ) { his . encodeAll ( new String [ ] { " Dane " , " Dean " , " Dionne " } , " DAN " ) ; } 
public void estSnad ( ) { Data Quality and Record Linkage Techniques P.121 claims this is SNAT, but it should be SNAD this.encodeAll(new String[] { "Schmidt" }, "SNAD"); } 
public void estSnat ( ) { his . encodeAll ( new String [ ] { " Smith " , " Schmit " } , " SNAT " ) ; } 
public void estSpecialBranches ( ) { his . encodeAll ( new String [ ] { " Kobwick " } , " CABWAC " ) ; his . encodeAll ( new String [ ] { " Kocher " } , " CACAR " ) ; his . encodeAll ( new String [ ] { " Fesca " } , " FASC " ) ; his . encodeAll ( new String [ ] { " Shom " } , " SAN " ) ; his . encodeAll ( new String [ ] { " Ohlo " } , " OL " ) ; his . encodeAll ( new String [ ] { " Uhu " } , " UH " ) ; his . encodeAll ( new String [ ] { " Um " } , " UN " ) ; } 
public void estTranan ( ) { his . encodeAll ( new String [ ] { " Trueman " , " Truman " } , " TRANAN " ) ; } 
public final void estIsVowel_CapitalA_ReturnsTrue ( ) { assertTrue ( his . getStringEncoder ( ) . isVowel ( " A " ) ) ; } 
public final void estCompareNameNullSpace_ReturnsFalseSuccessfully ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( null , " " ) ) ; } 
public final void estCompareNameSameNames_ReturnsFalseSuccessfully ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " John " , " John " ) ) ; } 
public void estDecodeWithInnerPad ( ) { final String content = " SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ= " ; byte [ ] result = Base64 . decodeBase64 ( content ) ; byte [ ] shouldBe = StringUtils . getBytesUtf8 ( " Hello World " ) ; assertTrue ( " decode should halt at pad (=) " , Arrays . equals ( result , shouldBe ) ) ; } 
static byte [ ] decode ( final char [ ] sArr ) { final int sLen = sArr ! = null ? sArr . length : 0 ; if ( sLen = = 0 ) { return new byte [ 0 ] ; } Find earliest pad character so that we can decode things like "AA==AA==" consistently. int padPos = sLen; int padCount = 0; for (int i = sLen - 1; i >= 0; i--) { if (sArr[i] == '=') { padPos = i; padCount = 1; if (i + 1 < sLen && sArr[i + 1] == '=') { padCount = 2; } } } Count illegal characters (including '\r', '') to know what size the returned array will be, so we don't have to reallocate & copy it later. int sepCnt = 0; Number of separator characters. (Actually illegal characters, but that's a bonus...) for (int i = 0; i < padPos; i++) { if (IA[sArr[i]] < 0) { sepCnt++; } } final int len = ((padPos + padCount - sepCnt) * 6 >> 3) - padCount; if (len <= 0) { return new byte[0]; } final byte[] dArr = new byte[len]; Preallocate byte[] of exact length int d = 0; int i = 0; try { for (int s = 0; d < len; ) { Assemble three bytes into an int from four "valid" characters. i = 0; for (int j = 0; j < 4; j++) { j only increased if a valid char was found. int c = IA[sArr[s++]]; if (c >= 0) { i |= c << (18 - j * 6); } else { j--; } } Add the bytes dArr[d++] = (byte) (i >> 16); if (d < len) { dArr[d++] = (byte) (i >> 8); if (d < len) { dArr[d++] = (byte) i; } } } } catch (ArrayIndexOutOfBoundsException aioobe) { Handle url-safe input (with no padding). dArr[d++] = (byte) (i >> 16); if (d < len) { dArr[d++] = (byte) (i >> 8); if (d < len) { dArr[d] = (byte) i; } } } return dArr; } 
static byte [ ] decode ( final byte [ ] sArr ) { final int sLen = sArr ! = null ? sArr . length : 0 ; if ( sLen = = 0 ) { return new byte [ 0 ] ; } Find earliest pad character so that we can decode things like "AA==AA==" consistently. int padPos = sLen; int padCount = 0; for (int i = sLen - 1; i >= 0; i--) { if (sArr[i] == '=') { padPos = i; padCount = 1; if (i + 1 < sLen && sArr[i + 1] == '=') { padCount = 2; } } } Count illegal characters (including '\r', '') to know what size the returned array will be, so we don't have to reallocate & copy it later. int sepCnt = 0; Number of separator characters. (Actually illegal characters, but that's a bonus...) for (int i = 0; i < padPos; i++) { if (IA[sArr[i] & 0xff] < 0) { sepCnt++; } } final int len = ((padPos + padCount - sepCnt) * 6 >> 3) - padCount; if (len <= 0) { return new byte[0]; } final byte[] dArr = new byte[len]; Preallocate byte[] of exact length int d = 0; int i = 0; try { for (int s = 0; d < len; ) { Assemble three bytes into an int from four "valid" characters. i = 0; for (int j = 0; j < 4; j++) { j only increased if a valid char was found. int c = IA[sArr[s++] & 0xff]; if (c >= 0) { i |= c << (18 - j * 6); } else { j--; } } Add the bytes dArr[d++] = (byte) (i >> 16); if (d < len) { dArr[d++] = (byte) (i >> 8); if (d < len) { dArr[d++] = (byte) i; } } } } catch (ArrayIndexOutOfBoundsException aioobe) { Handle url-safe input (with no padding). dArr[d++] = (byte) (i >> 16); if (d < len) { dArr[d++] = (byte) (i >> 8); if (d < len) { dArr[d] = (byte) i; } } } return dArr; } 
static byte [ ] encodeToByte ( byte [ ] sArr , final boolean lineSep , boolean urlSafe , int maxResultSize ) { return encodeToByte ( sArr , lineSep , urlSafe , maxResultSize , CRLF , 76 ) ; } 
static byte [ ] encodeToByte ( final byte [ ] sArr , final boolean lineSep , final boolean urlSafe , final int maxResultSize , final byte [ ] lineSeparator , final int lineLen ) { if ( sArr = = null | | sArr . length = = 0 ) { return sArr ; } final int sLen = sArr . length ; final int eLen = ( sLen / 3 ) * 3 ; Length of even 24-bits. final int left = sLen - eLen; A value between 0 and 2. final int cCnt = ((sLen - 1) / 3 + 1) << 2; Returned character count int dLen = cCnt + (lineSep ? (cCnt - 1) / lineLen * lineSeparator.length : 0); Length of returned array org.apache.commons.binary.codec.Base64 always ends with CRLF in chunking mode. if (lineSep) { dLen += lineSeparator.length; } final char[] ENCODE_ARRAY = urlSafe ? ApacheModifiedMiGBase64.CA_URL_SAFE : ApacheModifiedMiGBase64.CA; if (urlSafe && left > 0) { dLen--; if (left != 2) { dLen--; } } checkLen(dLen, maxResultSize); final byte[] dArr = new byte[dLen]; Encode even 24-bits int charCount = 0; for (int s = 0, d = 0; s < eLen; ) { Copy next three bytes into lower 24 bits of int, paying attension to sign. int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff); Encode the int into four chars dArr[d++] = (byte) ENCODE_ARRAY[(i >>> 18) & 0x3f]; dArr[d++] = (byte) ENCODE_ARRAY[(i >>> 12) & 0x3f]; dArr[d++] = (byte) ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[d++] = (byte) ENCODE_ARRAY[i & 0x3f]; charCount += 4; Add optional line separator if (lineSep && charCount % lineLen <= 3 && d < dLen - lineSeparator.length) { System.arraycopy(lineSeparator, 0, dArr, d, lineSeparator.length); d += lineSeparator.length; } } Make space for our final CRLF. if (lineSep) { dLen -= lineSeparator.length; } Pad and encode last bits if source isn't an even 24 bits. if (left > 0) { Prepare the int int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0); Set last four chars (url-safe omits the '=' padding). if (urlSafe && left == 2) { dArr[dLen - 3] = (byte) ENCODE_ARRAY[i >> 12]; dArr[dLen - 2] = (byte) ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[dLen - 1] = (byte) ENCODE_ARRAY[i & 0x3f]; } else if (urlSafe) { dArr[dLen - 2] = (byte) ENCODE_ARRAY[i >> 12]; dArr[dLen - 1] = (byte) ENCODE_ARRAY[(i >>> 6) & 0x3f]; } else { dArr[dLen - 4] = (byte) ENCODE_ARRAY[i >> 12]; dArr[dLen - 3] = (byte) ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[dLen - 2] = (byte) (left == 2 ? ENCODE_ARRAY[i & 0x3f] : '='); dArr[dLen - 1] = '='; } } And now we append our final CRLF if necessary. if (lineSep) { dLen += lineSeparator.length; System.arraycopy(lineSeparator, 0, dArr, dLen - lineSeparator.length, lineSeparator.length); } return dArr; } 
static char [ ] encodeToChar ( final byte [ ] sArr , final boolean lineSep , final boolean urlSafe , final int maxResultSize ) { if ( sArr = = null ) { return null ; } if ( sArr . length = = 0 ) { return new char [ 0 ] ; } final int sLen = sArr . length ; final int eLen = ( sLen / 3 ) * 3 ; Length of even 24-bits. final int left = sLen - eLen; A value between 0 and 2. final int cCnt = ((sLen - 1) / 3 + 1) << 2; Returned character count int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); Length of returned array org.apache.commons.binary.codec.Base64 always ends with CRLF in chunking mode. if (lineSep) { dLen += 2; } final char[] ENCODE_ARRAY = urlSafe ? ApacheModifiedMiGBase64.CA_URL_SAFE : ApacheModifiedMiGBase64.CA; if (urlSafe && left > 0) { dLen--; if (left != 2) { dLen--; } } checkLen(dLen, maxResultSize); final char[] dArr = new char[dLen]; Encode even 24-bits for (int s = 0, d = 0, cc = 0; s < eLen; ) { Copy next three bytes into lower 24 bits of int, paying attension to sign. int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff); Encode the int into four chars dArr[d++] = ENCODE_ARRAY[(i >>> 18) & 0x3f]; dArr[d++] = ENCODE_ARRAY[(i >>> 12) & 0x3f]; dArr[d++] = ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[d++] = ENCODE_ARRAY[i & 0x3f]; Add optional line separator if (lineSep && ++cc == 19 && d < dLen - 2) { dArr[d++] = '\r'; dArr[d++] = ''; cc = 0; } } Make space for our final CRLF. if (lineSep) { dLen -= 2; } Pad and encode last bits if source isn't even 24 bits. if (left > 0) { Prepare the int int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0); Set last four chars (url-safe omits the '=' padding). if (urlSafe && left == 2) { dArr[dLen - 3] = ENCODE_ARRAY[i >> 12]; dArr[dLen - 2] = ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[dLen - 1] = ENCODE_ARRAY[i & 0x3f]; } else if (urlSafe) { dArr[dLen - 2] = ENCODE_ARRAY[i >> 12]; dArr[dLen - 1] = ENCODE_ARRAY[(i >>> 6) & 0x3f]; } else { dArr[dLen - 4] = ENCODE_ARRAY[i >> 12]; dArr[dLen - 3] = ENCODE_ARRAY[(i >>> 6) & 0x3f]; dArr[dLen - 2] = left == 2 ? ENCODE_ARRAY[i & 0x3f] : '='; dArr[dLen - 1] = '='; } } And now we append our final CRLF if necessary. if (lineSep) { dLen += 2; dArr[dLen - 2] = '\r'; dArr[dLen - 1] = ''; } return dArr; } 
static String encodeToString ( byte [ ] sArr , boolean lineSep , boolean urlSafe , int maxResultSize ) { if ( sArr = = null ) { return null ; } if ( sArr . length = = 0 ) { return " " ; } Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower. return new String(encodeToChar(sArr, lineSep, urlSafe, maxResultSize)); } 
private static void checkLen ( int dLen , int maxResultSize ) { if ( dLen > maxResultSize ) { hrow new IllegalArgumentException ( " Input array too big, the output array would be bigger ( " + 
public byte [ ] decode ( final byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } return ApacheModifiedMiGBase64 . decode ( pArray ) ; } 
public byte [ ] encode ( final byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } return ApacheModifiedMiGBase64 . encodeToByte ( pArray , lineSeparator ! = null , isUrlSafe ( ) , Integer . MAX_VALUE , lineSeparator , lineLength 
public static String encodeBase64String ( final byte [ ] binaryData ) { return ApacheModifiedMiGBase64 . encodeToString ( binaryData , false , false , Integer . MAX_VALUE 
public static String encodeBase64URLSafeString ( final byte [ ] binaryData ) { return ApacheModifiedMiGBase64 . encodeToString ( binaryData , false , rue , Integer . MAX_VALUE 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) { return ApacheModifiedMiGBase64 . encodeToByte ( binaryData , isChunked , urlSafe , maxResultSize 
public static byte [ ] decodeBase64 ( final String base64String ) { if ( base64String = = null ) { return null ; } if ( " " . equals ( base64String ) ) { return new byte [ 0 ] ; } return ApacheModifiedMiGBase64 . decode ( base64String . oCharArray ( ) ) ; } 
public static byte [ ] decodeBase64 ( final byte [ ] base64Data ) { if ( base64Data = = null | | base64Data . length = = 0 ) { return base64Data ; } return ApacheModifiedMiGBase64 . decode ( base64Data ) ; } 
static int digit16 ( final byte b ) hrows DecoderException { final int i = Character . digit ( ( char ) b , URLCodec . RADIX ) ; if ( i = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding: not a valid digit (radix " + URLCodec . RADIX + " ): " + b ) ; } return i ; } 
private static byte [ ] digest ( final MessageDigest digest , final InputStream data ) hrows IOException { return updateDigest ( digest , data ) . digest ( ) ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final InputStream data ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest ; } 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " + " modulus=%s, pos=%s, readPos=%s] " , his . getClass ( ) . getSimpleName ( ) , Arrays . oString ( buffer ) , 
public String oString ( ) { return String . format ( " %s[buffer=%s, currentLinePos=%s, eof=%s, ibitWorkArea=%s, lbitWorkArea=%s, " + " modulus=%s, pos=%s, readPos=%s] " , his . getClass ( ) . getSimpleName ( ) , Arrays . oString ( buffer ) , 
public int compare ( final Object o1 , final Object o2 ) { int compareCode = 0 ; ry { @SuppressWarnings ( " unchecked " ) May fail with CCE if encode returns something that is not Comparable However this was always the case. final Comparable<Comparable<?>> s1 = (Comparable<Comparable<?>>) this.stringEncoder.encode(o1); final Comparable<?> s2 = (Comparable<?>) this.stringEncoder.encode(o2); compareCode = s1.compareTo(s2); } catch (final EncoderException ee) { compareCode = 0; } return compareCode; } 
public void est ( ) { PhoneticEngine engine = new PhoneticEngine ( NameType . GENERIC , RuleType . APPROX , rue ) ; final String input = " Angelo " ; final long startMillis = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < LOOP ; i + + ) { engine . encode ( input ) ; } final long otalMillis = System . currentTimeMillis ( ) - startMillis ; System . out . println ( String . format ( " Time for encoding %,d times the input '%s': %,d millis. " , LOOP , input , otalMillis ) ) ; 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 1 ; List < Rule > rules = his . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( his . input , his . i ) ) { his . phonemeBuilder = his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } } } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually final CharSequence inputCache = cacheSubSequence(input); for (int i = 0; i < inputCache.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, inputCache, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static Map < String , List < Rule > > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { return langs . isSingleton ( ) ? getInstance ( nameType , rt , langs . getAny ( ) ) : getInstance ( nameType , rt , Languages . ANY ) ; 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
public static PhonemeBuilder empty ( final Languages . LanguageSet languages ) { return new PhonemeBuilder ( new Rule . Phoneme ( " " , languages ) ) ; } 
public void append ( final CharSequence str ) { for ( final Rule . Phoneme ph : his . phonemes ) { ph . append ( str ) ; 
public void append ( final CharSequence str ) { this . phonemeText . append ( str ) ; } 
public void estSubSequenceWorks ( ) { AppendableCharSequence is private to Rule. We can only make it through a Phoneme. final Rule.Phoneme a = new Rule.Phoneme("a", null); final Rule.Phoneme b = new Rule.Phoneme("b", null); final Rule.Phoneme cd = new Rule.Phoneme("cd", null); final Rule.Phoneme ef = new Rule.Phoneme("ef", null); final Rule.Phoneme ghi = new Rule.Phoneme("ghi", null); final Rule.Phoneme jkl = new Rule.Phoneme("jkl", null); assertEquals('a', a.getPhonemeText().charAt(0)); assertEquals('b', b.getPhonemeText().charAt(0)); assertEquals('c', cd.getPhonemeText().charAt(0)); assertEquals('d', cd.getPhonemeText().charAt(1)); assertEquals('e', ef.getPhonemeText().charAt(0)); assertEquals('f', ef.getPhonemeText().charAt(1)); assertEquals('g', ghi.getPhonemeText().charAt(0)); assertEquals('h', ghi.getPhonemeText().charAt(1)); assertEquals('i', ghi.getPhonemeText().charAt(2)); assertEquals('j', jkl.getPhonemeText().charAt(0)); assertEquals('k', jkl.getPhonemeText().charAt(1)); assertEquals('l', jkl.getPhonemeText().charAt(2)); final Rule.Phoneme a_b = new Rule.Phoneme(a, b); assertEquals('a', a_b.getPhonemeText().charAt(0)); assertEquals('b', a_b.getPhonemeText().charAt(1)); assertEquals("ab", a_b.getPhonemeText().subSequence(0, 2).toString()); assertEquals("a", a_b.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b.getPhonemeText().subSequence(1, 2).toString()); final Rule.Phoneme cd_ef = new Rule.Phoneme(cd, ef); assertEquals('c', cd_ef.getPhonemeText().charAt(0)); assertEquals('d', cd_ef.getPhonemeText().charAt(1)); assertEquals('e', cd_ef.getPhonemeText().charAt(2)); assertEquals('f', cd_ef.getPhonemeText().charAt(3)); assertEquals("c", cd_ef.getPhonemeText().subSequence(0, 1).toString()); assertEquals("d", cd_ef.getPhonemeText().subSequence(1, 2).toString()); assertEquals("e", cd_ef.getPhonemeText().subSequence(2, 3).toString()); assertEquals("f", cd_ef.getPhonemeText().subSequence(3, 4).toString()); assertEquals("cd", cd_ef.getPhonemeText().subSequence(0, 2).toString()); assertEquals("de", cd_ef.getPhonemeText().subSequence(1, 3).toString()); assertEquals("ef", cd_ef.getPhonemeText().subSequence(2, 4).toString()); assertEquals("cde", cd_ef.getPhonemeText().subSequence(0, 3).toString()); assertEquals("def", cd_ef.getPhonemeText().subSequence(1, 4).toString()); assertEquals("cdef", cd_ef.getPhonemeText().subSequence(0, 4).toString()); final Rule.Phoneme a_b_cd = new Rule.Phoneme(new Rule.Phoneme(a, b), cd); assertEquals('a', a_b_cd.getPhonemeText().charAt(0)); assertEquals('b', a_b_cd.getPhonemeText().charAt(1)); assertEquals('c', a_b_cd.getPhonemeText().charAt(2)); assertEquals('d', a_b_cd.getPhonemeText().charAt(3)); assertEquals("a", a_b_cd.getPhonemeText().subSequence(0, 1).toString()); assertEquals("b", a_b_cd.getPhonemeText().subSequence(1, 2).toString()); assertEquals("c", a_b_cd.getPhonemeText().subSequence(2, 3).toString()); assertEquals("d", a_b_cd.getPhonemeText().subSequence(3, 4).toString()); assertEquals("ab", a_b_cd.getPhonemeText().subSequence(0, 2).toString()); assertEquals("bc", a_b_cd.getPhonemeText().subSequence(1, 3).toString()); assertEquals("cd", a_b_cd.getPhonemeText().subSequence(2, 4).toString()); assertEquals("abc", a_b_cd.getPhonemeText().subSequence(0, 3).toString()); assertEquals("bcd", a_b_cd.getPhonemeText().subSequence(1, 4).toString()); assertEquals("abcd", a_b_cd.getPhonemeText().subSequence(0, 4).toString()); } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < LangRule > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < LangRule > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; ry { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } } finally { scanner.close(); } return new Lang(rules, languages); } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 1 ; final List < Rule > rules = his . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( final Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( his . input , his . i ) ) { his . phonemeBuilder = his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } } } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
public void estDecodeWithInnerPad ( ) { final String content = " SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ= " ; final byte [ ] result = Base64 . decodeBase64 ( content ) ; final byte [ ] shouldBe = StringUtils . getBytesUtf8 ( " Hello World " ) ; assertTrue ( " decode should halt at pad (=) " , Arrays . equals ( result , shouldBe ) ) ; } 
public void est ( ) { final PhoneticEngine engine = new PhoneticEngine ( NameType . GENERIC , RuleType . APPROX , rue ) ; final String input = " Angelo " ; final long startMillis = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < LOOP ; i + + ) { engine . encode ( input ) ; } final long otalMillis = System . currentTimeMillis ( ) - startMillis ; System . out . println ( String . format ( " Time for encoding %,d times the input '%s': %,d millis. " , LOOP , input , otalMillis ) ) ; 
public final void estAccentRemoval_NullValue_ReturnNullSuccessfully ( ) { assertEquals ( null , his . getStringEncoder ( ) . removeAccents ( null ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully2 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_6_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 6 ) ) ; } 
public final void estgetMinRating_7_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_8_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 8 ) ) ; } 
public final void estgetMinRating_10_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 10 ) ) ; } 
public final void estgetMinRating_11_Returns_3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 11 ) ) ; } 
public final void estisVowel_SingleVowel_ReturnsTrue ( ) { assertTrue ( his . getStringEncoder ( ) . isVowel ( ( " I " ) ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , null ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( null , " est " ) ) ; } 
public final void estisEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estisEncodeEqualsSecondNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estCompareNameNullSpace_ReturnsFalseSuccessfully ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( null , " " ) ) ; } 
public final void estCompareNameSameNames_ReturnsFalseSuccessfully ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " John " , " John " ) ) ; } 
public void append ( final CharSequence str ) { his . phonemeText . append ( str ) ; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } else { lines.putAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
public void append ( final CharSequence str ) { for ( final Rule . Phoneme ph : his . phonemes ) { ph . append ( str ) ; 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 1 ; final List < Rule > rules = his . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( final Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( his . input , his . i ) ) { his . phonemeBuilder = his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } } } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
public Phoneme append ( final CharSequence str ) { his . phonemeText . append ( str ) ; return his ; } 
public void est ( ) { final int imes = 10000000 ; System . out . print ( " Test with String : " ) ; est ( " Angelo " , imes ) ; System . out . print ( " Test with StringBuilder : " ) ; est ( new StringBuilder ( " Angelo " ) , imes ) ; System . out . print ( " Test with cached String : " ) ; est ( cacheSubSequence ( " Angelo " ) , imes ) ; System . out . print ( " Test with cached StringBuilder : " ) ; est ( cacheSubSequence ( new StringBuilder ( " Angelo " ) ) , imes ) ; } 
private void est ( final CharSequence input , final int imes ) { final long beginTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < imes ; i + + ) { est ( input ) ; } System . out . println ( System . currentTimeMillis ( ) - beginTime + " millis " ) ; } 
private void est ( final CharSequence input ) { for ( int i = 0 ; i < input . length ( ) ; i + + ) { for ( int j = i ; j < = input . length ( ) ; j + + ) { 
private CharSequence cacheSubSequence ( final CharSequence cached ) { final CharSequence [ ] [ ] cache = new CharSequence [ cached . length ( ) ] [ cached . length ( ) ] ; return new CharSequence ( ) { @Override 
public CharSequence subSequence ( final int start , final int end ) { if ( start = = end ) { return " " ; } CharSequence res = cache [ start ] [ end - 1 ] ; if ( res = = null ) { res = cached . subSequence ( start , end ) ; cache [ start ] [ end - 1 ] = res ; } return res ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstance ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstance(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstance(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < LangRule > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; ry { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<String>(Arrays.asList(langs)), accept)); } } } } finally { scanner.close(); } return new Lang(rules, languages); } 
public Phoneme append ( final CharSequence str ) { his . phonemeText . append ( str ) ; return his ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<String>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList < Rule > ( ) ; for ( final List < Rule > rules : ruleMap . values ( ) ) { allRules . addAll ( rules ) ; } return allRules ; } 
public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { return langs . isSingleton ( ) ? getInstanceMap ( nameType , rt , langs . getAny ( ) ) : getInstanceMap ( nameType , rt , Languages . ANY ) ; 
public static Map < String , List < Rule > > getInstanceMap ( final NameType nameType , final RuleType rt , final String lang ) { final Map < String , List < Rule > > rules = RULES . get ( nameType ) . get ( rt ) . get ( lang ) ; if ( rules = = null ) { hrow new IllegalArgumentException ( String . format ( " No rules found for %s, %s, %s. " , nameType . getName ( ) , rt . getName ( ) , lang ) ) ; } return rules ; } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 1 ; final List < Rule > rules = his . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( final Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( his . input , his . i ) ) { his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } } } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
private void flush ( final boolean propagate ) hrows IOException { final int avail = baseNCodec . available ( context ) ; if ( avail > 0 ) { final byte [ ] buf = new byte [ avail ] ; final int c = baseNCodec . readResults ( buf , 0 , avail , context ) ; if ( c > 0 ) { out . write ( buf , 0 , c ) ; } } if ( propagate ) { out . flush ( ) ; 
private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language although in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = Base32TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() Base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte Base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = Base64TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded)); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded)); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); } 
public final void estgetMinRating_5_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully2 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_6_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 6 ) ) ; } 
public final void estgetMinRating_7_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_10_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 10 ) ) ; } 
public final void estgetMinRating_11_Returns_3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 11 ) ) ; } 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = in[inPos++]; if (b == pad) { We're done. context.eof = true; break; } else { final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } else { if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( int i = 0 ; i < arrayOctet . length ; i + + ) { if ( ! isInAlphabet ( arrayOctet [ i ] ) & & ( ! allowWSPad | | ( arrayOctet [ i ] ! = pad ) & & ! isWhiteSpace ( arrayOctet [ i ] ) ) ) { return false ; } } return rue ; } 
protected boolean containsAlphabetOrPad ( final byte [ ] arrayOctet ) { if ( arrayOctet = = null ) { return false ; } for ( final byte element : arrayOctet ) { if ( pad = = element | | isInAlphabet ( element ) ) { return rue ; } } return false ; } 
public void estBase32SamplesNonDefaultPadding ( ) hrows Exception { final Base32 codec = new Base32 ( ( byte ) 0x25 ) ; '%' <=> 0x25 for (final String[] element : BASE32_PAD_TEST_CASES) { assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8))); 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estContainsAlphabetOrPad ( ) { assertFalse ( codec . containsAlphabetOrPad ( null ) ) ; assertFalse ( codec . containsAlphabetOrPad ( new byte [ ] { } ) ) ; assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( " OK " . getBytes ( ) ) ) ; assertFalse ( codec . containsAlphabetOrPad ( " ok " . getBytes ( ) ) ) ; assertTrue ( codec . containsAlphabetOrPad ( new byte [ ] { codec . pad } ) ) ; } 
public void estProvidePaddingByte ( ) { codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
static boolean regionMatches ( final CharSequence cs , final boolean ignoreCase , final int hisStart , final CharSequence substring , final int start , final int length ) { if ( cs instanceof String & & substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , hisStart , ( String ) substring , start , length ) ; } int index1 = hisStart ; int index2 = start ; int mpLen = length ; while ( mpLen - - > 0 ) { char c1 = cs . charAt ( index1 + + ) ; char c2 = substring . charAt ( index2 + + ) ; if ( c1 = = c2 ) { continue ; } if ( ! ignoreCase ) { return false ; } The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } 
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 = = cs2 ) { return rue ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; } 
public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } 
public void estCodec184 ( ) hrows Throwable { assertTrue ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " " , false ) ) ; assertTrue ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " " , rue ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " aa " , " " , false ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " aa " , " " , rue ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " aa " , false ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " aa " , rue ) ) ; } 
public void estIsDoubleMetaphoneEqualBasic ( ) { final String [ ] [ ] estFixture = new String [ ] [ ] { { " " , " " } , { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " cookie " , " quick " } , { " quick " , " cookie " } , { " Brian " , " Bryan " } , { " Auto " , " Otto " } , { " Steven " , " Stefan " } , { " Philipowitz " , " Filipowicz " } } ; doubleMetaphoneEqualTest ( estFixture , false ) ; doubleMetaphoneEqualTest ( estFixture , rue ) ; } 
public void estSolrGENERIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<String, String>(); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<String, String>(); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, true, "D'Angelo"), "(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<String, String>(); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, false, "D'Angelo"), "(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, false, "1234"), ""); } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom"); } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom"); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom"); } 
public void estSolrASHKENAZI ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); assertEquals(encode(args, true, "D'Angelo"), "dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angilo|anxilo|ongilo|onxilo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<String, String>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); assertEquals(encode(args, false, "D'Angelo"), "dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angilo|anxilo|ongilo|onxilo"); assertEquals(encode(args, false, "1234"), ""); } 
public LanguageSet merge ( final LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return his ; 
public LanguageSet merge ( final LanguageSet other ) { return other ; } 
public Phoneme mergeWithLanguage ( final LanguageSet lang ) { return new Phoneme ( his . phonemeText . oString ( ) , his . languages . merge ( lang ) ) ; } 
public String oString ( ) { return phonemeText . oString ( ) + " [ " + languages + " ] " ; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } else { lines.putAll(parseRules(createScanner(incl), location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } else { try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } } return lines; } 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Rule " ) ; sb . append ( " {line= " ) . append ( myLine ) ; sb . append ( " , loc=' " ) . append ( loc ) . append ( '\'' ) ; sb . append ( " , pat=' " ) . append ( pat ) . append ( '\'' ) ; sb . append ( " , lcon=' " ) . append ( lCon ) . append ( '\'' ) ; sb . append ( " , rcon=' " ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . oString ( ) ; } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom"); assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn"); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom"); assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn"); 
public static byte [ ] hmacMd5 ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmacMd5 ( key ) . doFinal ( valueToDigest ) ; 
public static byte [ ] hmacMd5 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return updateHmac ( getHmacMd5 ( key ) , valueToDigest ) . doFinal ( ) ; } 
public static byte [ ] hmacMd5 ( final String key , final String valueToDigest ) { return hmacMd5 ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmacMd5 ( key , valueToDigest ) ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmacMd5 ( key , valueToDigest ) ) ; } 
public static String hmacMd5Hex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmacMd5 ( key , valueToDigest ) ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmacSha1 ( key ) . doFinal ( valueToDigest ) ; 
public static byte [ ] hmacSha1 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return updateHmac ( getHmacSha1 ( key ) , valueToDigest ) . doFinal ( ) ; } 
public static byte [ ] hmacSha1 ( final String key , final String valueToDigest ) { return hmacSha1 ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmacSha1 ( key , valueToDigest ) ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmacSha1 ( key , valueToDigest ) ) ; } 
public static String hmacSha1Hex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmacSha1 ( key , valueToDigest ) ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmacSha256 ( key ) . doFinal ( valueToDigest ) ; 
public static byte [ ] hmacSha256 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return updateHmac ( getHmacSha256 ( key ) , valueToDigest ) . doFinal ( ) ; } 
public static byte [ ] hmacSha256 ( final String key , final String valueToDigest ) { return hmacSha256 ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmacSha256 ( key , valueToDigest ) ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmacSha256 ( key , valueToDigest ) ) ; } 
public static String hmacSha256Hex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmacSha256 ( key , valueToDigest ) ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmacSha384 ( key ) . doFinal ( valueToDigest ) ; 
public static byte [ ] hmacSha384 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return updateHmac ( getHmacSha384 ( key ) , valueToDigest ) . doFinal ( ) ; } 
public static byte [ ] hmacSha384 ( final String key , final String valueToDigest ) { return hmacSha384 ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmacSha384 ( key , valueToDigest ) ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmacSha384 ( key , valueToDigest ) ) ; } 
public static String hmacSha384Hex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmacSha384 ( key , valueToDigest ) ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmacSha512 ( key ) . doFinal ( valueToDigest ) ; 
public static byte [ ] hmacSha512 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return updateHmac ( getHmacSha512 ( key ) , valueToDigest ) . doFinal ( ) ; } 
public static byte [ ] hmacSha512 ( final String key , final String valueToDigest ) { return hmacSha512 ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmacSha512 ( key , valueToDigest ) ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmacSha512 ( key , valueToDigest ) ) ; } 
public static String hmacSha512Hex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmacSha512 ( key , valueToDigest ) ) ; } 
public static Mac updateHmac ( final Mac mac , final byte [ ] valueToDigest ) { mac . reset ( ) ; mac . update ( valueToDigest ) ; return mac ; } 
public static Mac updateHmac ( final Mac mac , final InputStream valueToDigest ) hrows IOException { mac . reset ( ) ; final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { mac . update ( buffer , 0 , read ) ; read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return mac ; } 
public static Mac updateHmac ( final Mac mac , final String valueToDigest ) { mac . reset ( ) ; mac . update ( StringUtils . getBytesUtf8 ( valueToDigest ) ) ; return mac ; } 
public void estGetHMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . getHmacMd5 ( STANDARD_KEY_BYTES ) . doFinal ( STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA1_RESULT_BYTES , HmacUtils . getHmacSha1 ( STANDARD_KEY_BYTES ) . doFinal ( STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA256_RESULT_BYTES , HmacUtils . getHmacSha256 ( STANDARD_KEY_BYTES ) . doFinal ( STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA384_RESULT_BYTES , HmacUtils . getHmacSha384 ( STANDARD_KEY_BYTES ) . doFinal ( STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA512_RESULT_BYTES , HmacUtils . getHmacSha512 ( STANDARD_KEY_BYTES ) . doFinal ( STANDARD_PHRASE_BYTES ) ) ; 
public void estHmacMd5Hex ( ) hrows IOException { assertEquals ( " 80070713463e7749b90c2dc24911e275 " , HmacUtils . hmacMd5Hex ( STANDARD_KEY_STRING , " The quick brown fox jumps over the lazy dog " ) ) ; assertEquals ( " 750c783e6ab0b503eaa86e310a5db738 " , HmacUtils . hmacMd5Hex ( " Jefe " , " what do ya want for nothing? " ) ) ; assertEquals ( " 750c783e6ab0b503eaa86e310a5db738 " , 
public void estHmacSha1Hex ( ) hrows IOException { assertEquals ( STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , HmacUtils . hmacSha1Hex ( STANDARD_KEY_STRING , " " ) ) ; assertEquals ( " effcdf6ae5eb2fa2d27416d5f184df9c259a7c79 " , HmacUtils . hmacSha1Hex ( " Jefe " , " what do ya want for nothing? " ) ) ; assertEquals ( " effcdf6ae5eb2fa2d27416d5f184df9c259a7c79 " , 
public void estHmacSha1UpdateWithByteArray ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , STANDARD_PHRASE_BYTES ) ; assertEquals ( STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " . getBytes ( ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estHmacSha1UpdateWithInpustream ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ; assertEquals ( STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( " " . getBytes ( ) ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estHmacSha1UpdateWithString ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , STANDARD_PHRASE_STRING ) ; assertEquals ( STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estInitializedMac ( ) hrows IOException { final Mac md5Mac = HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , STANDARD_KEY_BYTES ) ; final Mac md5Mac2 = HmacUtils . getInitializedMac ( " HmacMD5 " , STANDARD_KEY_BYTES ) ; Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac2 , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; 
public void estInitializedMacNullAlgo ( ) hrows IOException { HmacUtils . getInitializedMac ( ( String ) null , STANDARD_KEY_BYTES ) ; } 
public void estInitializedMacNullKey ( ) hrows IOException { HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , null ) ; } 
public void estInternalNoSuchAlgorithmException ( ) { HmacUtils . getInitializedMac ( " Bogus Bogus " , StringUtils . getBytesUtf8 ( " akey " ) ) ; } 
public void estMd5HMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; 
public void estMd5HMacFail ( ) hrows IOException { HmacUtils . hmacMd5 ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estSecretKeySpecAllowsEmtyKeys ( ) { new SecretKeySpec ( new byte [ ] { } , " HmacMD5 " ) ; } 
public void estSha1HMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; 
public void estSha1HMacFail ( ) hrows IOException { HmacUtils . hmacSha1 ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estSha256HMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; 
public void estSha256HMacFail ( ) hrows IOException { HmacUtils . hmacSha256 ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estSha384HMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; 
public void estSha384HMacFail ( ) hrows IOException { HmacUtils . hmacSha384 ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estSha512HMac ( ) hrows IOException { Assert . assertArrayEquals ( STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; 
public void estSha512HMacFail ( ) hrows IOException { HmacUtils . hmacSha512 ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
static boolean regionMatches ( final CharSequence cs , final boolean ignoreCase , final int hisStart , final CharSequence substring , final int start , final int length ) { if ( cs instanceof String & & substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , hisStart , ( String ) substring , start , length ) ; } int index1 = hisStart ; int index2 = start ; int mpLen = length ; while ( mpLen - - > 0 ) { char c1 = cs . charAt ( index1 + + ) ; char c2 = substring . charAt ( index2 + + ) ; if ( c1 = = c2 ) { continue ; } if ( ! ignoreCase ) { return false ; } The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } 
public void estBase32SamplesNonDefaultPadding ( ) hrows Exception { final Base32 codec = new Base32 ( ( byte ) 0x25 ) ; '%' <=> 0x25 for (final String[] element : BASE32_PAD_TEST_CASES) { assertEquals(element[1], codec.encodeAsString(element[0].getBytes(Charsets.UTF_8))); 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estProvidePaddingByte ( ) { codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estIsDoubleMetaphoneEqualBasic ( ) { final String [ ] [ ] estFixture = new String [ ] [ ] { { " " , " " } , { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " cookie " , " quick " } , { " quick " , " cookie " } , { " Brian " , " Bryan " } , { " Auto " , " Otto " } , { " Steven " , " Stefan " } , { " Philipowitz " , " Filipowicz " } } ; doubleMetaphoneEqualTest ( estFixture , false ) ; doubleMetaphoneEqualTest ( estFixture , rue ) ; } 
public Branch createBranch ( ) { final Branch branch = new Branch ( ) ; branch . builder . append ( oString ( ) ) ; branch . lastReplacement = his . lastReplacement ; return branch ; } 
public boolean equals ( final Object other ) { if ( his = = other ) { return rue ; } if ( ! ( other instanceof Branch ) ) { return false ; } return oString ( ) . equals ( ( ( Branch ) other ) . oString ( ) ) ; } 
public void finish ( ) { while ( builder . length ( ) < MAX_LENGTH ) { builder . append ( '0' ) ; 
public void processNextReplacement ( final String replacement , final boolean forceAppend ) { final boolean append = lastReplacement = = null | | ! lastReplacement . endsWith ( replacement ) | | forceAppend ; if ( append & & builder . length ( ) < MAX_LENGTH ) { builder . append ( replacement ) ; remove all characters after the maximum length if (builder.length() > MAX_LENGTH) { builder.delete(MAX_LENGTH, builder.length()); } cachedString = null; } lastReplacement = replacement; } 
public String oString ( ) { if ( cachedString = = null ) { cachedString = builder . oString ( ) ; } return cachedString ; } 
private boolean isVowel ( final char ch ) { return ch = = 'a' | | ch = = 'e' | | ch = = 'i' | | ch = = 'o' | | ch = = 'u' ; } 
public boolean matches ( final String context ) { return context . startsWith ( pattern ) ; } 
public String oString ( ) { return String . format ( " %s=(%s,%s,%s) " , pattern , Arrays . asList ( replacementAtStart ) , Arrays . asList ( replacementBeforeVowel ) , Arrays . asList ( replacementDefault ) ) ; 
public int compare ( final Rule rule1 , final Rule rule2 ) { return rule2 . getPatternLength ( ) - rule1 . getPatternLength ( ) ; } 
private static void parseRules ( final Scanner scanner , final String location , final Map < Character , List < Rule > > ruleMapping , final Map < Character , Character > asciiFoldings ) { int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; 
private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder ( ) ; for ( char ch : input . oCharArray ( ) ) { if ( Character . isWhitespace ( ch ) ) { continue ; } ch = Character . oLowerCase ( ch ) ; if ( folding & & FOLDINGS . containsKey ( ch ) ) { ch = FOLDINGS . get ( ch ) ; } sb . append ( ch ) ; } return sb . oString ( ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to DaitchMokotoffSoundex encode is not of type java.lang.String " ) ; } return encode ( ( String ) obj ) ; } 
public String encode ( final String source ) { if ( source = = null ) { return null ; } return soundex ( source , false ) [ 0 ] ; } 
public String soundex ( final String source ) { final String [ ] branches = soundex ( source , rue ) ; final StringBuilder sb = new StringBuilder ( ) ; int index = 0 ; for ( final String branch : branches ) { sb . append ( branch ) ; if ( + + index < branches . length ) { sb . append ( '|' ) ; } } return sb . oString ( ) ; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < Branch > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access @SuppressWarnings("unchecked") final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST; for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
protected DaitchMokotoffSoundex createStringEncoder ( ) { return new DaitchMokotoffSoundex ( ) ; } 
public void estAdjacentCodes ( ) { AKSSOL A-KS-S-O-L 0-54-4---8 -> wrong 0-54-----8 -> correct Assert.assertEquals("054800", this.getStringEncoder().soundex("AKSSOL")); GERSCHFELD G-E-RS-CH-F-E-L-D 5--4/94-5/4-7-8-3 -> wrong 5--4/94-5/--7-8-3 -> correct Assert.assertEquals("547830|545783|594783|594578", this.getStringEncoder().soundex("GERSCHFELD")); } 
public void estEncodeBasic ( ) { same as above, but without branching Assert.assertEquals("097400", this.getStringEncoder().encode("AUERBACH")); Assert.assertEquals("097400", this.getStringEncoder().encode("OHRBACH")); Assert.assertEquals("874400", this.getStringEncoder().encode("LIPSHITZ")); Assert.assertEquals("874400", this.getStringEncoder().encode("LIPPSZYC")); Assert.assertEquals("876450", this.getStringEncoder().encode("LEWINSKY")); Assert.assertEquals("876450", this.getStringEncoder().encode("LEVINSKI")); Assert.assertEquals("486740", this.getStringEncoder().encode("SZLAMAWICZ")); Assert.assertEquals("486740", this.getStringEncoder().encode("SHLAMOVITZ")); } 
public void estEncodeIgnoreApostrophes ( ) hrows EncoderException { his . checkEncodingVariations ( " 079600 " , new String [ ] { " OBrien " , " 'OBrien " , " O'Brien " , " OB'rien " , " OBr'ien " , " OBri'en " , " OBrie'n " , " OBrien' " } ) ; 
public void estEncodeIgnoreHyphens ( ) hrows EncoderException { his . checkEncodingVariations ( " 565463 " , new String [ ] { " KINGSMITH " , " -KINGSMITH " , " K-INGSMITH " , " KI-NGSMITH " , " KIN-GSMITH " , " KING-SMITH " , " KINGS-MITH " , " KINGSM-ITH " , " KINGSMI-TH " , " KINGSMIT-H " , " KINGSMITH- " } ) ; 
public void estEncodeIgnoreTrimmable ( ) { Assert . assertEquals ( " 746536 " , his . getStringEncoder ( ) . encode ( " r Washington r " ) ) ; Assert . assertEquals ( " 746536 " , his . getStringEncoder ( ) . encode ( " Washington " ) ) ; } 
public void estSoundexBasic ( ) { Assert . assertEquals ( " 583600 " , his . getStringEncoder ( ) . soundex ( " GOLDEN " ) ) ; Assert . assertEquals ( " 087930 " , his . getStringEncoder ( ) . soundex ( " Alpert " ) ) ; Assert . assertEquals ( " 791900 " , his . getStringEncoder ( ) . soundex ( " Breuer " ) ) ; Assert . assertEquals ( " 579000 " , his . getStringEncoder ( ) . soundex ( " Haber " ) ) ; Assert . assertEquals ( " 665600 " , his . getStringEncoder ( ) . soundex ( " Mannheim " ) ) ; Assert . assertEquals ( " 664000 " , his . getStringEncoder ( ) . soundex ( " Mintz " ) ) ; Assert . assertEquals ( " 370000 " , his . getStringEncoder ( ) . soundex ( " Topf " ) ) ; Assert . assertEquals ( " 586660 " , his . getStringEncoder ( ) . soundex ( " Kleinmann " ) ) ; Assert . assertEquals ( " 769600 " , his . getStringEncoder ( ) . soundex ( " Ben Aron " ) ) ; Assert . assertEquals ( " 097400|097500 " , his . getStringEncoder ( ) . soundex ( " AUERBACH " ) ) ; Assert . assertEquals ( " 097400|097500 " , his . getStringEncoder ( ) . soundex ( " OHRBACH " ) ) ; Assert . assertEquals ( " 874400 " , his . getStringEncoder ( ) . soundex ( " LIPSHITZ " ) ) ; Assert . assertEquals ( " 874400|874500 " , his . getStringEncoder ( ) . soundex ( " LIPPSZYC " ) ) ; Assert . assertEquals ( " 876450 " , his . getStringEncoder ( ) . soundex ( " LEWINSKY " ) ) ; Assert . assertEquals ( " 876450 " , his . getStringEncoder ( ) . soundex ( " LEVINSKI " ) ) ; Assert . assertEquals ( " 486740 " , his . getStringEncoder ( ) . soundex ( " SZLAMAWICZ " ) ) ; Assert . assertEquals ( " 486740 " , his . getStringEncoder ( ) . soundex ( " SHLAMOVITZ " ) ) ; } 
public void estSoundexBasic2 ( ) { Assert . assertEquals ( " 467000|567000 " , his . getStringEncoder ( ) . soundex ( " Ceniow " ) ) ; Assert . assertEquals ( " 467000 " , his . getStringEncoder ( ) . soundex ( " Tsenyuv " ) ) ; Assert . assertEquals ( " 587400|587500 " , his . getStringEncoder ( ) . soundex ( " Holubica " ) ) ; Assert . assertEquals ( " 587400 " , his . getStringEncoder ( ) . soundex ( " Golubitsa " ) ) ; Assert . assertEquals ( " 746480|794648 " , his . getStringEncoder ( ) . soundex ( " Przemysl " ) ) ; Assert . assertEquals ( " 746480 " , his . getStringEncoder ( ) . soundex ( " Pshemeshil " ) ) ; Assert . assertEquals ( " 944744|944745|944754|944755|945744|945745|945754|945755 " , his . getStringEncoder ( ) . soundex ( " Rosochowaciec " ) ) ; Assert . assertEquals ( " 945744 " , his . getStringEncoder ( ) . soundex ( " Rosokhovatsets " ) ) ; } 
public void estSoundexBasic3 ( ) { Assert . assertEquals ( " 734000|739400 " , his . getStringEncoder ( ) . soundex ( " Peters " ) ) ; Assert . assertEquals ( " 734600|739460 " , his . getStringEncoder ( ) . soundex ( " Peterson " ) ) ; Assert . assertEquals ( " 645740 " , his . getStringEncoder ( ) . soundex ( " Moskowitz " ) ) ; Assert . assertEquals ( " 645740 " , his . getStringEncoder ( ) . soundex ( " Moskovitz " ) ) ; Assert . assertEquals ( " 154600|145460|454600|445460 " , his . getStringEncoder ( ) . soundex ( " Jackson " ) ) ; Assert . assertEquals ( " 154654|154645|154644|145465|145464|454654|454645|454644|445465|445464 " , his . getStringEncoder ( ) . soundex ( " Jackson-Jackson " ) ) ; 
private String soundex ( String source ) { return getStringEncoder ( ) . soundex ( source ) ; } 
private String encode ( String source ) { return getStringEncoder ( ) . encode ( source ) ; } 
public void estAdjacentCodes ( ) { AKSSOL A-KS-S-O-L 0-54-4---8 -> wrong 0-54-----8 -> correct Assert.assertEquals("054800", soundex("AKSSOL")); GERSCHFELD G-E-RS-CH-F-E-L-D 5--4/94-5/4-7-8-3 -> wrong 5--4/94-5/--7-8-3 -> correct Assert.assertEquals("547830|545783|594783|594578", soundex("GERSCHFELD")); } 
public void estEncodeBasic ( ) { same as above, but without branching Assert.assertEquals("097400", encode("AUERBACH")); Assert.assertEquals("097400", encode("OHRBACH")); Assert.assertEquals("874400", encode("LIPSHITZ")); Assert.assertEquals("874400", encode("LIPPSZYC")); Assert.assertEquals("876450", encode("LEWINSKY")); Assert.assertEquals("876450", encode("LEVINSKI")); Assert.assertEquals("486740", encode("SZLAMAWICZ")); Assert.assertEquals("486740", encode("SHLAMOVITZ")); } 
public void estEncodeIgnoreTrimmable ( ) { Assert . assertEquals ( " 746536 " , encode ( " r Washington r " ) ) ; Assert . assertEquals ( " 746536 " , encode ( " Washington " ) ) ; } 
public void estSoundexBasic ( ) { Assert . assertEquals ( " 583600 " , soundex ( " GOLDEN " ) ) ; Assert . assertEquals ( " 087930 " , soundex ( " Alpert " ) ) ; Assert . assertEquals ( " 791900 " , soundex ( " Breuer " ) ) ; Assert . assertEquals ( " 579000 " , soundex ( " Haber " ) ) ; Assert . assertEquals ( " 665600 " , soundex ( " Mannheim " ) ) ; Assert . assertEquals ( " 664000 " , soundex ( " Mintz " ) ) ; Assert . assertEquals ( " 370000 " , soundex ( " Topf " ) ) ; Assert . assertEquals ( " 586660 " , soundex ( " Kleinmann " ) ) ; Assert . assertEquals ( " 769600 " , soundex ( " Ben Aron " ) ) ; Assert . assertEquals ( " 097400|097500 " , soundex ( " AUERBACH " ) ) ; Assert . assertEquals ( " 097400|097500 " , soundex ( " OHRBACH " ) ) ; Assert . assertEquals ( " 874400 " , soundex ( " LIPSHITZ " ) ) ; Assert . assertEquals ( " 874400|874500 " , soundex ( " LIPPSZYC " ) ) ; Assert . assertEquals ( " 876450 " , soundex ( " LEWINSKY " ) ) ; Assert . assertEquals ( " 876450 " , soundex ( " LEVINSKI " ) ) ; Assert . assertEquals ( " 486740 " , soundex ( " SZLAMAWICZ " ) ) ; Assert . assertEquals ( " 486740 " , soundex ( " SHLAMOVITZ " ) ) ; } 
public void estSoundexBasic2 ( ) { Assert . assertEquals ( " 467000|567000 " , soundex ( " Ceniow " ) ) ; Assert . assertEquals ( " 467000 " , soundex ( " Tsenyuv " ) ) ; Assert . assertEquals ( " 587400|587500 " , soundex ( " Holubica " ) ) ; Assert . assertEquals ( " 587400 " , soundex ( " Golubitsa " ) ) ; Assert . assertEquals ( " 746480|794648 " , soundex ( " Przemysl " ) ) ; Assert . assertEquals ( " 746480 " , soundex ( " Pshemeshil " ) ) ; Assert . assertEquals ( " 944744|944745|944754|944755|945744|945745|945754|945755 " , soundex ( " Rosochowaciec " ) ) ; Assert . assertEquals ( " 945744 " , soundex ( " Rosokhovatsets " ) ) ; } 
public void estSoundexBasic3 ( ) { Assert . assertEquals ( " 734000|739400 " , soundex ( " Peters " ) ) ; Assert . assertEquals ( " 734600|739460 " , soundex ( " Peterson " ) ) ; Assert . assertEquals ( " 645740 " , soundex ( " Moskowitz " ) ) ; Assert . assertEquals ( " 645740 " , soundex ( " Moskovitz " ) ) ; Assert . assertEquals ( " 154600|145460|454600|445460 " , soundex ( " Jackson " ) ) ; Assert . assertEquals ( " 154654|154645|154644|145465|145464|454654|454645|454644|445465|445464 " , soundex ( " Jackson-Jackson " ) ) ; 
private static final int encodeQuotedPrintable ( final int b , final ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; final char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes ) { return encodeQuotedPrintable ( printable , bytes , false ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; if ( strict ) { int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
public static final byte [ ] decodeQuotedPrintable ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final int b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { if the next octet is a CR we have found a soft line break if (bytes[++i] == CR) { continue; } final int u = Utils.digit16(bytes[i]); final int l = Utils.digit16(bytes[++i]); buffer.write((char) ((u << 4) + l)); } catch (final ArrayIndexOutOfBoundsException e) { throw new DecoderException("Invalid quoted-printable encoding", e); } } else if (b != CR && b != LF) { every other octet is appended except for CR & LF buffer.write(b); } } return buffer.toByteArray(); } 
public byte [ ] encode ( final byte [ ] bytes ) { return encodeQuotedPrintable ( PRINTABLE_CHARS , bytes , strict ) ; } 
public void estSoftLineBreakDecode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public void estSoftLineBreakEncode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely mathematics is the most b= r neautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertEquals ( qpdata , qpcodec . encode ( expected ) ) ; String decoded = qpcodec . decode ( qpdata ) ; assertEquals ( qpdata , qpcodec . encode ( decoded ) ) ; } 
public void estSkipNotEncodedCRLF ( ) hrows Exception { String qpdata = " CRLF in an n encoded text should be=20= r rskipped in the r decoding. " ; String expected = " CRLF in an encoded text should be skipped in the decoding. " ; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public void estTrailingSpecial ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; String plain = " This is a example of a quoted-printable text file. This might contain sp=cial chars. " ; String expected = " This is a example of a quoted-printable text file. This might contain sp=3D= r ncial chars. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. This might contain ta bs as well. " ; expected = " This is a example of a quoted-printable text file. This might contain ta=09= r nbs as well. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; } 
public void estUltimateSoftBreak ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; String plain = " This is a example of a quoted-printable text file. There is no end to it " ; String expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=09 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. There is no end to it " ; expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=20 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; whitespace before soft break plain ="This is a example of a quoted-printable text file. There is no end to "; expected = "This is a example of a quoted-printable text file. There is no end to=20=\r =20"; assertEquals(expected, qpcodec.encode(plain)); non-printable character before soft break plain ="This is a example of a quoted-printable text file. There is no end to= "; expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r =20"; assertEquals(expected, qpcodec.encode(plain)); } 
public void estFinalBytes ( ) hrows Exception { whitespace, but does not need to be encoded final String plain ="This is a example of a quoted=printable text file. There is no tt"; final String expected = "This is a example of a quoted=3Dprintable text file. There is no tt"; assertEquals(expected, new QuotedPrintableCodec(true).encode(plain)); } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; if ( strict ) { int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
public void estDecodeEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( " " ) ) ) ; } 
public void estEncodeHexBytesHelloWorldLowerCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estEncodeHexBytesHelloWorldUpperCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estEncodeHexBytesZeroes ( ) { final char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estEncodeHexBytesEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; } 
public void estEncodeStringEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( " " ) ) ) ; } 
private void checkDecodeHexCharArrayOddCharacters ( final char [ ] data ) { ry { Hex . decodeHex ( data ) ; 
public void estDecodeHexCharArrayOddCharacters1 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' } ) ; } 
public void estDecodeHexCharArrayOddCharacters3 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' , 'B' , 'C' } ) ; } 
public void estDecodeHexCharArrayOddCharacters5 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' } ) ; } 
public void estDecodeByteArrayEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ) ; } 
public void estDecodeStringEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( " " ) ) ) ; } 
public void estDecodeHexStringOddCharacters ( ) { ry { new Hex ( ) . decode ( " 6 " ) ; 
public void estDecodeByteArrayOddCharacters ( ) { ry { new Hex ( ) . decode ( new byte [ ] { 65 } ) ; 
public void estEncodeHexByteArrayEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; } 
public void estEncodeHexByteArrayZeroes ( ) { final char [ ] c = Hex . encodeHex ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estEncodeHexByteArrayHelloWorldLowerCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estEncodeHexByteArrayHelloWorldUpperCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estDecodeByteArrayEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ) ; } 
public void estDecodeCharArrayEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; } 
public static char [ ] encodeHex ( final ByteBuffer data ) { return encodeHex ( data , rue ) ; } 
public static char [ ] encodeHex ( final ByteBuffer data , final boolean oLowerCase ) { return encodeHex ( data , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER ) ; } 
protected static char [ ] encodeHex ( final ByteBuffer data , final char [ ] oDigits ) { return encodeHex ( data . array ( ) , oDigits ) ; } 
public static String encodeHexString ( final ByteBuffer data ) { return new String ( encodeHex ( data ) ) ; } 
public byte [ ] decode ( final ByteBuffer buffer ) hrows DecoderException { return decodeHex ( new String ( buffer . array ( ) , getCharset ( ) ) . oCharArray ( ) ) ; } 
public Object decode ( final Object object ) hrows DecoderException { if ( object instanceof String ) { return decode ( ( ( String ) object ) . oCharArray ( ) ) ; 
public byte [ ] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( his . getCharset ( ) ) ; } 
public Object encode ( final Object object ) hrows EncoderException { byte [ ] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( his . getCharset ( ) ) ; } else if ( object instanceof ByteBuffer ) { byteArray = ( ( ByteBuffer ) object ) . array ( ) ; } else { ry { byteArray = ( byte [ ] ) object ; } catch ( final ClassCastException e ) { hrow new EncoderException ( e . getMessage ( ) , e ) ; } } return encodeHex ( byteArray ) ; } 
private void estCustomCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( charsetSanityCheck ( name ) = = false ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
public void estDecodeByteBufferEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estDecodeByteArrayOddCharacters ( ) { ry { new Hex ( ) . decode ( new byte [ ] { 65 } ) ; 
public void estDecodeByteBufferOddCharacters ( ) { ByteBuffer buffer = ByteBuffer . allocate ( 1 ) ; buffer . put ( ( byte ) 65 ) ; ry { new Hex ( ) . decode ( buffer ) ; 
public void estDecodeHexCharArrayOddCharacters1 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' } ) ; } 
public void estDecodeHexCharArrayOddCharacters3 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' , 'B' , 'C' } ) ; } 
public void estDecodeHexCharArrayOddCharacters5 ( ) { checkDecodeHexCharArrayOddCharacters ( new char [ ] { 'A' , 'B' , 'C' , 'D' , 'E' } ) ; } 
public void estDecodeByteArrayObjectEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( ( Object ) new byte [ 0 ] ) ) ) ; } 
public void estDecodeByteBufferObjectEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( ( Object ) ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estEncodeHexByteBufferEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( ByteBuffer . allocate ( 0 ) ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estEncodeHexByteBufferHelloWorldLowerCaseHex ( ) { final ByteBuffer b = StringUtils . getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; } 
public void estEncodeHexByteBufferHelloWorldUpperCaseHex ( ) { final ByteBuffer b = StringUtils . getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertFalse ( expected . equals ( new String ( actual ) ) ) ; actual = Hex . encodeHex ( b , false ) ; assertTrue ( expected . equals ( new String ( actual ) ) ) ; } 
public void estEncodeHexByteBufferZeroes ( ) { final char [ ] c = Hex . encodeHex ( ByteBuffer . allocate ( 36 ) ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estGetCharset ( ) hrows UnsupportedEncodingException , DecoderException { Assert . assertEquals ( Charsets . UTF_8 , new Hex ( Charsets . UTF_8 ) . getCharset ( ) ) ; } 
public void estGetCharsetName ( ) hrows UnsupportedEncodingException , DecoderException { Assert . assertEquals ( Charsets . UTF_8 . name ( ) , new Hex ( Charsets . UTF_8 ) . getCharsetName ( ) ) ; } 
public void estEncodeByteArrayEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; } 
public void estEncodeByteArrayObjectEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( ( Object ) new byte [ 0 ] ) ) ) ; } 
public void estEncodeByteBufferEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estEncodeByteBufferObjectEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( ( Object ) ByteBuffer . allocate ( 0 ) ) ) ) ; } 
private static byte [ ] digest ( final MessageDigest messageDigest , final ByteBuffer data ) { messageDigest . update ( data ) ; return messageDigest . digest ( ) ; } 
public static String md2Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static byte [ ] md2 ( final ByteBuffer data ) { return digest ( getMd2Digest ( ) , data ) ; } 
public static byte [ ] sha1 ( final ByteBuffer data ) { return digest ( getSha1Digest ( ) , data ) ; } 
public static byte [ ] sha256 ( final ByteBuffer data ) { return digest ( getSha256Digest ( ) , data ) ; } 
public static byte [ ] sha384 ( final ByteBuffer data ) { return digest ( getSha384Digest ( ) , data ) ; } 
public static byte [ ] sha512 ( final ByteBuffer data ) { return digest ( getSha512Digest ( ) , data ) ; } 
public static byte [ ] md5 ( final ByteBuffer data ) { return digest ( getMd5Digest ( ) , data ) ; } 
public static String md5Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static String sha1Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static String sha256Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static String sha384Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static String sha512Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static MessageDigest updateDigest ( final MessageDigest messageDigest , final ByteBuffer valueToDigest ) { messageDigest . update ( valueToDigest ) ; return messageDigest ; } 
public void estMd2Hex ( ) hrows IOException { Examples from RFC 1319 assertEquals("8350e5a3e24c153df2275c9f80692773", DigestUtils.md2Hex("")); assertEquals("32ec01ec4a6dac72c0ab96fb34c0b5d1", DigestUtils.md2Hex("a")); assertEquals("da853b0d3f88d99b30283a69e6ded6bb", DigestUtils.md2Hex("abc")); assertEquals("ab4f496bfb2a530b219ff33031fe06b0", DigestUtils.md2Hex("message digest")); assertEquals("4e8ddff3650292ab5a4108c3aa47940b", DigestUtils.md2Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "da33def2a42df13975352846c30338cd", DigestUtils.md2Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "d5976f79d83d3a0dc9806c3c66f3efd8", DigestUtils.md2Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md2Hex(testData), DigestUtils.md2Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.md2Hex(testData), DigestUtils.md2Hex(ByteBuffer.wrap(testData))); 
public void estMd5Hex ( ) hrows IOException { Examples from RFC 1321 assertEquals("d41d8cd98f00b204e9800998ecf8427e", DigestUtils.md5Hex("")); assertEquals("0cc175b9c0f1b6a831c399e269772661", DigestUtils.md5Hex("a")); assertEquals("900150983cd24fb0d6963f7d28e17f72", DigestUtils.md5Hex("abc")); assertEquals("f96b697d7cb7938d525a2f31aaf161d0", DigestUtils.md5Hex("message digest")); assertEquals("c3fcd3d76192e4007dfb496cca67e13b", DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "d174ab98d277d9f5a5611c2c9f419d9f", DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "57edf4a22be3c955ac49da2e2107b67a", DigestUtils.md5Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md5Hex(testData), DigestUtils.md5Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.md5Hex(testData), DigestUtils.md5Hex(ByteBuffer.wrap(testData))); 
public void estMd5HexLengthForBytes ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMd5HexLengthForByteBuffer ( ) { String hashMe = " his is some string that is longer than 32 characters " ; String hash = DigestUtils . md5Hex ( getByteBufferUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; hashMe = " length < 32 " ; hash = DigestUtils . md5Hex ( getByteBufferUtf8 ( hashMe ) ) ; assertEquals ( 32 , hash . length ( ) ) ; } 
public void estMd5LengthForBytes ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( getBytesUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estMd5LengthForByteBuffer ( ) { String hashMe = " his is some string that is longer than 16 characters " ; byte [ ] hash = DigestUtils . md5 ( getByteBufferUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; hashMe = " length < 16 " ; hash = DigestUtils . md5 ( getByteBufferUtf8 ( hashMe ) ) ; assertEquals ( 16 , hash . length ) ; } 
public void estSha1Hex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex(getBytesUtf8("abc"))); assertEquals( "84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.sha1Hex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha1Hex(testData), DigestUtils.sha1Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.sha1Hex(testData), DigestUtils.sha1Hex(ByteBuffer.wrap(testData))); 
public void estSha256 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc")); assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex(getBytesUtf8("abc"))); assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1", DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(ByteBuffer.wrap(testData))); 
public void estSha384 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc")); assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex(getBytesUtf8("abc"))); assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039", DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(ByteBuffer.wrap(testData))); 
public void estSha512 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(new ByteArrayInputStream(testData))); assertEquals(DigestUtils.sha512Hex(testData), DigestUtils.sha512Hex(ByteBuffer.wrap(testData))); 
public static String md5Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static byte [ ] sha ( final InputStream data ) hrows IOException { return sha1 ( data ) ; } 
public static byte [ ] sha224 ( final byte [ ] data ) { return getSha224Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha224 ( final ByteBuffer data ) { return digest ( getSha224Digest ( ) , data ) ; } 
public static byte [ ] sha224 ( final InputStream data ) hrows IOException { return digest ( getSha224Digest ( ) , data ) ; } 
public static byte [ ] sha224 ( final String data ) { return sha224 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha224Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha224 ( data ) ) ; } 
public static String sha224Hex ( final ByteBuffer data ) { return Hex . encodeHexString ( sha224 ( data ) ) ; } 
public static String sha224Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha224 ( data ) ) ; } 
public static String sha224Hex ( final String data ) { return Hex . encodeHexString ( sha224 ( data ) ) ; } 
public void estSha224 ( ) hrows IOException { Assume . assumeTrue ( SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_8 ) ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , DigestUtils . sha224Hex ( " " ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , DigestUtils . sha224Hex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
public void close ( ) hrows IOException { eof ( ) ; flush ( ) ; out . close ( ) ; } 
public void eof ( ) hrows IOException { Notify encoder of EOF (-1). if (doEncode) { baseNCodec.encode(singleByte, 0, EOF, context); 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft")); Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft")); } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcraft")); Assert.assertEquals("A261", this.getStringEncoder().encode("Ashcroft")); Assert.assertEquals("Y330", this.getStringEncoder().encode("yehudit")); Assert.assertEquals("Y330", this.getStringEncoder().encode("yhwdyt")); } 
public void estWikipediaAmericanSoundex ( ) { Assert . assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Robert " ) ) ; Assert . assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Rupert " ) ) ; Assert . assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcraft " ) ) ; Assert . assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcroft " ) ) ; Assert . assertEquals ( " T522 " , his . getStringEncoder ( ) . encode ( " Tymczak " ) ) ; Assert . assertEquals ( " P236 " , his . getStringEncoder ( ) . encode ( " Pfister " ) ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; char last , mapped ; int incount = 1 , count = 1 ; out [ 0 ] = str . charAt ( 0 ) ; map() throws IllegalArgumentException last = this.map(str.charAt(0)); while (incount < str.length() && count < out.length) { mapped = this.map(str.charAt(incount++)); if (mapped == '0') { last = mapped; } else if (mapped != '#' && mapped != last) { out[count++] = mapped; last = mapped; } } return new String(out); } 
public void estCodec200 ( ) { final Base32 codec = new Base32 ( rue , ( byte ) 'W' ) ; should be allowed assertNotNull(codec); } 
public void estBase32Samples ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32HexSamples ( ) hrows Exception { final Base32 codec = new Base32 ( rue ) ; for ( final String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32Chunked ( ) hrows Exception { final Base32 codec = new Base32 ( 20 ) ; for ( final String [ ] element : BASE32_TEST_CASES_CHUNKED ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32SamplesNonDefaultPadding ( ) hrows Exception { final Base32 codec = new Base32 ( ( byte ) 0x25 ) ; '%' <=> 0x25 for (final String[] element : BASE32_PAD_TEST_CASES) { assertEquals(element[1], codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))); 
public void estCodeInteger1 ( ) { final String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; final BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger2 ( ) { final String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; final BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger3 ( ) { final String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; final BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger4 ( ) { final String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; final BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estDecodePadMarkerIndex2 ( ) { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodePadOnly ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(CHARSET_UTF8)).length); } 
public void estDecodePadOnlyChunked ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; Test truncated padding assertEquals(0, Base64.decodeBase64("===".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("==".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("=".getBytes(CHARSET_UTF8)).length); assertEquals(0, Base64.decodeBase64("".getBytes(CHARSET_UTF8)).length); } 
public void estDecodeWithWhitespace ( ) hrows Exception { final String orig = " I am a late night coder. " ; final byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( CHARSET_UTF8 ) ) ; final StringBuilder intermediate = new StringBuilder ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; final byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( CHARSET_UTF8 ) ; final byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; final String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIH@$#$@%F1aWN@#@#@@rIGJyb3duIGZve r %#%#%#%CBqd##$#$W1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = Base64 . encodeBase64 ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base64 b64 = new Base64 ( ) ; final Object oDecoded = b64 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Base64 b64 = new Base64 ( ) ; final Object oEncoded = b64 . encode ( origObj ) ; final byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , new String ( b64 . encode ( " Hello World " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
void assertDecodeObject ( final byte [ ] bits , final String encodeMe ) hrows DecoderException { byte [ ] decoded ; decoded = ( byte [ ] ) instance . decode ( encodeMe ) ; assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = instance . decode ( ( byte [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( ( Object ) encodeMe . getBytes ( CHARSET_UTF8 ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; if ( encodeMe = = null ) { decoded = ( byte [ ] ) instance . decode ( ( char [ ] ) null ) ; } else { decoded = ( byte [ ] ) instance . decode ( encodeMe . oCharArray ( ) ) ; } assertEquals ( new String ( bits ) , new String ( decoded ) ) ; } 
public void estDecodeByteArray ( ) { With a single raw binary byte[] bits = new byte[1]; byte[] decoded = instance.decode("00000000".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = instance.decode("00000001".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = instance.decode("00000011".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = instance.decode("00000111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = instance.decode("00001111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = instance.decode("00011111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = instance.decode("00111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = instance.decode("01111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("11111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000011111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000000111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000001111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000011111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0000111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0001111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0011111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("0111111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = instance.decode("1111111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); } 
public void estFromAsciiByteArray ( ) { assertEquals ( 0 , BinaryCodec . fromAscii ( ( byte [ ] ) null ) . length ) ; assertEquals ( 0 , BinaryCodec . fromAscii ( new byte [ 0 ] ) . length ) ; With a single raw binary byte[] bits = new byte[1]; byte[] decoded = BinaryCodec.fromAscii("00000000".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0; decoded = BinaryCodec.fromAscii("00000001".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1; decoded = BinaryCodec.fromAscii("00000011".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2; decoded = BinaryCodec.fromAscii("00000111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3; decoded = BinaryCodec.fromAscii("00001111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; decoded = BinaryCodec.fromAscii("00011111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; decoded = BinaryCodec.fromAscii("00111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; decoded = BinaryCodec.fromAscii("01111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[1]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("11111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); With a two raw binaries bits = new byte[2]; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000011111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000000111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000001111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000011111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0000111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0001111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0011111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6; bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("0111111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); bits = new byte[2]; bits[1] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); bits[0] = (byte) (BIT_0 | BIT_1 | BIT_2 | BIT_3 | BIT_4 | BIT_5 | BIT_6 | BIT_7); decoded = BinaryCodec.fromAscii("1111111111111111".getBytes(CHARSET_UTF8)); assertEquals(new String(bits), new String(decoded)); assertEquals(0, BinaryCodec.fromAscii((byte[]) null).length); } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test @SuppressWarnings("deprecation") TODO remove when Java 7 is minimum and Charsets constants can be replaced public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd")); } @Test(expected = IllegalArgumentException.class) @SuppressWarnings("deprecation") TODO remove when Java 7 is minimum and Charsets constants can be replaced public void testSha2CryptWrongSalt() { Sha2Crypt.sha512Crypt("secret".getBytes(Charsets.UTF_8), "xx"); } @Test(expected = IllegalArgumentException.class) public void testSha512CryptWithEmptySalt() { Sha2Crypt.sha512Crypt("secret".getBytes(), ""); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); }} 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final String encoded = new String(QuotedPrintableCodec. encodeQuotedPrintable(null, plain.getBytes(Charsets.UTF_8))); assertEquals("Basic quoted-printable encoding test", "1+1 =3D 2", encoded); assertEquals("Basic quoted-printable decoding test", plain, qpcodec.decode(encoded)); 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final byte[] plainBA = plain.getBytes(Charsets.UTF_8); final byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA); encoded = new String(encodedBA); assertEquals("Basic quoted-printable encoding test", "1+1 =3D 2", encoded); final Object result = qpcodec.encode((Object) null); assertEquals( "Encoding a null Object should return null", null, result); try { final Object dObj = new Double(3.0); 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final byte[] plainBA = plain.getBytes(Charsets.UTF_8); final byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA); decoded = new String(decodedBA); assertEquals("Basic quoted-printable decoding test", "1+1 = 2", decoded); final Object result = qpcodec.decode((Object) null); assertEquals( "Decoding a null Object should return null", null, result); try { final Object dObj = new Double(3.0); 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final String encoded = new String( URLCodec.encodeUrl(null, plain.getBytes(Charsets.UTF_8))); assertEquals("Basic URL encoding test", "Hello+there%21", encoded); assertEquals("Basic URL decoding test", plain, urlCodec.decode(encoded)); this.validateState(urlCodec); } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final byte[] plainBA = plain.getBytes(Charsets.UTF_8); final byte[] encodedBA = (byte[]) urlCodec.encode((Object) plainBA); encoded = new String(encodedBA); assertEquals("Basic URL encoding test", "Hello+there%21", encoded); final Object result = urlCodec.encode((Object) null); assertEquals( "Encoding a null Object should return null", null, result); try { final Object dObj = new Double(3.0); urlCodec.encode( dObj ); fail( "Trying to url encode a Double object should cause an exception."); } catch (final EncoderException ee) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; @SuppressWarnings ( " deprecation " ) TODO remove when Java 7 is minimum and Charsets constants can be replaced final byte[] plainBA = plain.getBytes(Charsets.UTF_8); final byte[] decodedBA = (byte[]) urlCodec.decode((Object) plainBA); decoded = new String(decodedBA); assertEquals("Basic URL decoding test", "Hello there!", decoded); final Object result = urlCodec.decode((Object) null); assertEquals( "Decoding a null Object should return null", null, result); try { final Object dObj = new Double(3.0); urlCodec.decode( dObj ); fail( "Trying to url encode a Double object should cause an exception."); } catch (final DecoderException ee) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
static boolean regionMatches ( final CharSequence cs , final boolean ignoreCase , final int hisStart , final CharSequence substring , final int start , final int length ) { if ( cs instanceof String & & substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , hisStart , ( String ) substring , start , length ) ; } int index1 = hisStart ; int index2 = start ; int mpLen = length ; while ( mpLen - - > 0 ) { final char c1 = cs . charAt ( index1 + + ) ; final char c2 = substring . charAt ( index2 + + ) ; if ( c1 = = c2 ) { continue ; } if ( ! ignoreCase ) { return false ; } The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } 
public static final byte [ ] encodeQuotedPrintable ( final BitSet printable , final byte [ ] bytes ) { return encodeQuotedPrintable ( printable , bytes , false ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , final boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; if ( strict ) { int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytes.length - 3; i++) { final int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytes.length - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytes.length - 2; i < bytes.length; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytes.length - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estProvidePaddingByte ( ) { codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estDecodeByteBufferOddCharacters ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( 1 ) ; buffer . put ( ( byte ) 65 ) ; ry { new Hex ( ) . decode ( buffer ) ; 
private String soundex ( final String source ) { return getStringEncoder ( ) . soundex ( source ) ; } 
private String encode ( final String source ) { return getStringEncoder ( ) . encode ( source ) ; } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html final Map<String, String> args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom"); assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn"); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom"); assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn"); 
public void estSoftLineBreakDecode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely=20= r nmathematics is the most beautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; final String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public void estSoftLineBreakEncode ( ) hrows Exception { final String qpdata = " If you believe that truth=3Dbeauty, then surely mathematics is the most b= r neautiful branch of philosophy. " ; final String expected = " If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy. " ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertEquals ( qpdata , qpcodec . encode ( expected ) ) ; final String decoded = qpcodec . decode ( qpdata ) ; assertEquals ( qpdata , qpcodec . encode ( decoded ) ) ; } 
public void estSkipNotEncodedCRLF ( ) hrows Exception { final String qpdata = " CRLF in an n encoded text should be=20= r rskipped in the r decoding. " ; final String expected = " CRLF in an encoded text should be skipped in the decoding. " ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertEquals ( expected , qpcodec . decode ( qpdata ) ) ; final String encoded = qpcodec . encode ( expected ) ; assertEquals ( expected , qpcodec . decode ( encoded ) ) ; } 
public byte [ ] encode ( final byte [ ] pArray ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } return encode ( pArray , 0 , pArray . length ) ; } 
public byte [ ] encode ( final byte [ ] pArray , int offset , int length ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } final Context context = new Context ( ) ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; Notify encoder of EOF. final byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
private void estBase64InBuffer ( int startPasSize , int endPadSize ) { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { final byte [ ] bytes = element [ 0 ] . getBytes ( CHARSET_UTF8 ) ; 
public void estIsStringBase64 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; final String invalidString = validString + ( char ) 0 ; } 
public void estBase64 ( ) { final String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; } 
private void estBase64InBuffer ( int startPasSize , int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; } 
public void estDecodeWithInnerPad ( ) { final String content = " SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ= " ; final byte [ ] result = Base64 . decodeBase64 ( content ) ; final byte [ ] shouldBe = StringUtils . getBytesUtf8 ( " Hello World " ) ; assertTrue ( " decode should halt at pad (=) " , Arrays . equals ( result , shouldBe ) ) ; } 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; } 
public void estCodec68 ( ) { final byte [ ] x = new byte [ ] { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public void estCodeInteger1 ( ) { final String encodedInt1 = " li7dzDacuo67Jg7mtqEm2TRuOMU= " ; final BigInteger bigInt1 = new BigInteger ( " 85739377120809420210425962799 " + " 0318636601332086981 " ) ; assertEquals ( encodedInt1 , new String ( Base64 . encodeInteger ( bigInt1 ) ) ) ; assertEquals ( bigInt1 , Base64 . decodeInteger ( encodedInt1 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger2 ( ) { final String encodedInt2 = " 9B5ypLY9pMOmtxCeTDHgwdNFeGs= " ; final BigInteger bigInt2 = new BigInteger ( " 13936727572861167254666467268 " + " 91466679477132949611 " ) ; assertEquals ( encodedInt2 , new String ( Base64 . encodeInteger ( bigInt2 ) ) ) ; assertEquals ( bigInt2 , Base64 . decodeInteger ( encodedInt2 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger3 ( ) { final String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; final BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger4 ( ) { final String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; final BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; try { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; } 
public void estConstructor_Int_ByteArray_Boolean ( ) { final Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; final byte [ ] encoded = base64 . encode ( Base64TestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base64(65, \\ , false) " , expectedResult , result ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { } 
public void estDecodePadMarkerIndex2 ( ) { assertEquals ( " A " , new String ( Base64 . decodeBase64 ( " QQ== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodePadMarkerIndex3 ( ) { assertEquals ( " AA " , new String ( Base64 . decodeBase64 ( " QUE= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AAA " , new String ( Base64 . decodeBase64 ( " QUFB " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodePadOnly ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodePadOnlyChunked ( ) { assertEquals ( 0 , Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) . length ) ; assertEquals ( " " , new String ( Base64 . decodeBase64 ( " ==== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estDecodeWithWhitespace ( ) hrows Exception { final String orig = " I am a late night coder. " ; final byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( CHARSET_UTF8 ) ) ; final StringBuilder intermediate = new StringBuilder ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; final byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( CHARSET_UTF8 ) ; final byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; final String dest = new String ( decodedWithWS ) ; assertEquals ( " Dest string doesn't equal the original " , orig , dest ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( ( byte [ ] ) null ) ) ; } 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { final byte [ ] data = new byte [ his . getRandom ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estEncodeDecodeSmall ( ) { for ( int i = 0 ; i < 12 ; i + + ) { final byte [ ] data = new byte [ i ] ; 
public void estEncodeOverMaxSize ( ) hrows Exception { testEncodeOverMaxSize ( - 1 ) ; testEncodeOverMaxSize ( 0 ) ; testEncodeOverMaxSize ( 1 ) ; testEncodeOverMaxSize ( 2 ) ; } 
public void estCodec112 ( ) { } 
private void estEncodeOverMaxSize ( final int maxSize ) hrows Exception { try { Base64 . encodeBase64 ( Base64TestData . DECODED , rue , false , maxSize ) ; 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estIsUrlSafe ( ) { final Base64 base64Standard = new Base64 ( false ) ; final Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; final byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isBase64(whiteSpace)=true " , Base64 . isBase64 ( whiteSpace ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { final byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isBase64 ( bArray ) ) ; try { final Base64 b64 = new Base64 ( ) ; 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; try { b64 . decode ( Integer . valueOf ( 5 ) ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = Base64 . encodeBase64 ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base64 b64 = new Base64 ( ) ; final Object oDecoded = b64 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; try { b64 . encode ( " Yadayadayada " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Base64 b64 = new Base64 ( ) ; final Object oEncoded = b64 . encode ( origObj ) ; final byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) hrows Exception { final Base64 b64 = new Base64 ( ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , new String ( b64 . encode ( " Hello World " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertTrue ( Arrays . equals ( new byte [ ] { 13 , 10 } , Base64 . CHUNK_SEPARATOR ) ) ; } 
public void estRfc2045Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 76 , BaseNCodec . MIME_CHUNK_SIZE ) ; } 
public void estRfc1421Section6Dot8ChunkSizeDefinition ( ) { assertEquals ( 64 , BaseNCodec . PEM_CHUNK_SIZE ) ; } 
public void estRfc4648Section10Decode ( ) { assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " ) ) ) ; } 
public void estRfc4648Section10DecodeWithCrLf ( ) { final String CRLF = StringUtils . newStringUsAscii ( Base64 . CHUNK_SEPARATOR ) ; assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " + CRLF ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " + CRLF ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " + CRLF ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " + CRLF ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " + CRLF ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " + CRLF ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " + CRLF ) ) ) ; } 
public void estRfc4648Section10Encode ( ) { assertEquals ( " " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " " ) ) ) ; assertEquals ( " Zg== " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " f " ) ) ) ; assertEquals ( " Zm8= " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " fo " ) ) ) ; assertEquals ( " Zm9v " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foo " ) ) ) ; assertEquals ( " Zm9vYg== " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foob " ) ) ) ; assertEquals ( " Zm9vYmE= " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " fooba " ) ) ) ; assertEquals ( " Zm9vYmFy " , Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( " foobar " ) ) ) ; } 
public void estRfc4648Section10DecodeEncode ( ) { testDecodeEncode ( " " ) ; testDecodeEncode ( " Zg== " ) ; testDecodeEncode ( " Zm8= " ) ; testDecodeEncode ( " Zm9v " ) ; testDecodeEncode ( " Zm9vYg== " ) ; testDecodeEncode ( " Zm9vYmE= " ) ; testDecodeEncode ( " Zm9vYmFy " ) ; } 
private void estDecodeEncode ( final String encodedText ) { final String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; final String encodedText2 = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( decodedText ) ) ; assertEquals ( encodedText , encodedText2 ) ; } 
public void estRfc4648Section10EncodeDecode ( ) { testEncodeDecode ( " " ) ; testEncodeDecode ( " f " ) ; testEncodeDecode ( " fo " ) ; testEncodeDecode ( " foo " ) ; testEncodeDecode ( " foob " ) ; testEncodeDecode ( " fooba " ) ; testEncodeDecode ( " foobar " ) ; } 
private void estEncodeDecode ( final String plainText ) { final String encodedText = Base64 . encodeBase64String ( StringUtils . getBytesUtf8 ( plainText ) ) ; final String decodedText = StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( encodedText ) ) ; assertEquals ( plainText , decodedText ) ; } 
public void estUrlSafe ( ) { final byte[][] randomData = Base64TestData.randomData(i, true); 
public void estUUID ( ) hrows DecoderException { final byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; Base64.encodeBase64URLSafeString(b4)); 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " . oCharArray ( ) ) ; } 
private String oString ( final byte [ ] data ) { final StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { buf . append ( data [ i ] ) ; if ( i ! = data . length - 1 ) { buf . append ( " , " ) ; } } return buf . oString ( ) ; } 
public void estHugeLineSeparator ( ) { final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192 ; final int Base64_BYTES_PER_ENCODED_BLOCK = 4 ; final byte [ ] baLineSeparator = new byte [ BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3 ] ; final Base64 b64 = new Base64 ( Base64_BYTES_PER_ENCODED_BLOCK , baLineSeparator ) ; final String strOriginal = " Hello World " ; final String strDecoded = new String ( b64 . decode ( b64 . encode ( StringUtils . getBytesUtf8 ( strOriginal ) ) ) ) ; assertEquals ( " estDEFAULT_BUFFER_SIZE " , strOriginal , strDecoded ) ; } 
public static byte [ ] decodeHex ( String data ) hrows DecoderException { return decodeHex ( data . oCharArray ( ) ) ; } 
public void estUUID ( ) hrows DecoderException { final byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
private void checkDecodeHexCharArrayOddCharacters ( String data ) { ry { Hex . decodeHex ( data ) ; 
public void estDecodeHexCharArrayEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ) ; } 
public void estDecodeHexStringEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , Hex . decodeHex ( " " ) ) ) ; } 
public void estDecodeHexStringOddCharacters1 ( ) { checkDecodeHexCharArrayOddCharacters ( " A " ) ; } 
public void estEncodeDecodeHexCharArrayRandom ( ) hrows DecoderException , EncoderException { final Random random = new Random ( ) ; final Hex hex = new Hex ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ random . nextInt ( 10000 ) + 1 ] ; 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; Base64.encodeBase64URLSafeString(b4)); 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; } 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = in[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( final byte [ ] in , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = in [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
int leftToRightThenRightToLeftProcessing ( final String name1 , final String name2 ) { final char [ ] name1Char = name1 . oCharArray ( ) ; final char [ ] name2Char = name2 . oCharArray ( ) ; final int name1Size = name1 . length ( ) - 1 ; final int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , name1Size - i + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , name2Size - i + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space final String strA = new String(name1Char).replaceAll("\\s+", EMPTY); final String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(SIX - strA.length()); } return Math.abs(SIX - strB.length()); } 
String removeVowels ( String name ) { Extract first letter final String firstLetter = name.substring(0, 1); name = name.replaceAll("A", EMPTY); name = name.replaceAll("E", EMPTY); name = name.replaceAll("I", EMPTY); name = name.replaceAll("O", EMPTY); name = name.replaceAll("U", EMPTY); name = name.replaceAll("\\s{2,}\\b", SPACE); return isVowel(firstLetter) ? (firstLetter + name) : name; if (isVowel(firstLetter)) { return firstLetter + name; } return name; } 
private static char [ ] ranscodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { 1. EV -> AF if (curr == 'E' && next == 'V') { return CHARS_AF; } A, E, I, O, U -> A if (isVowel(curr)) { return CHARS_A; } 2. Q -> G, Z -> S, M -> N if (curr == 'Q') { return CHARS_G; } else if (curr == 'Z') { return CHARS_S; } else if (curr == 'M') { return CHARS_N; } 3. KN -> NN else K -> C if (curr == 'K') { if (next == 'N') { return CHARS_NN; } return CHARS_C; } 4. SCH -> SSS if (curr == 'S' && next == 'C' && aNext == 'H') { return CHARS_SSS; } PH -> FF if (curr == 'P' && next == 'H') { return CHARS_FF; } 5. H -> If previous or next is a non vowel, previous. if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) { return new char[] { prev }; } 6. W -> If previous is vowel, previous. if (curr == 'W' && isVowel(prev)) { return new char[] { prev }; } return new char[] { curr }; } 
private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( " [ " ) ; if ( open > = 0 ) { if ( ! ph . endsWith ( " ] " ) ) { hrow new IllegalArgumentException ( " Phoneme expression contains a '[' but does not end in ']' " ) ; } final String before = ph . substring ( 0 , open ) ; final String in = ph . substring ( open + 1 , ph . length ( ) - 1 ) ; final Set < String > langs = new HashSet < String > ( Arrays . asList ( in . split ( " [+] " ) ) ) ; return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } 
private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( " ( " ) ) { we have a bracketed list of options if (!ph.endsWith(")")) { throw new IllegalArgumentException("Phoneme starts with '(' so must end with ')'"); } final List<Phoneme> phs = new ArrayList<Phoneme>(); final String body = ph.substring(1, ph.length() - 1); for (final String part : body.split("[|]")) { phs.add(parsePhoneme(part)); } if (body.startsWith("|") || body.endsWith("|")) { phs.add(new Phoneme("", Languages.ANY_LANGUAGE)); } return new PhonemeList(phs); } return parsePhoneme(ph); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } lines.putAll(parseRules(createScanner(incl), location + "->" + incl)); } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Rule " ) ; sb . append ( " {line= " ) . append ( myLine ) ; sb . append ( " , loc=' " ) . append ( loc ) . append ( '\'' ) ; sb . append ( " , pat=' " ) . append ( pat ) . append ( '\'' ) ; sb . append ( " , lcon=' " ) . append ( lCon ) . append ( '\'' ) ; sb . append ( " , rcon=' " ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . oString ( ) ; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.length() == 0) { empty return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } else if ((startsWith || endsWith) && content.length() == 0) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public boolean isMatch ( final CharSequence input ) { return input . equals ( content ) ; } 
private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; } buffer . write ( b ) ; return 1 ; } 
public int read ( ) hrows IOException { if ( his . countdown - - > 0 ) { return '' ; } return EOF ; } 
public int read ( final byte b [ ] , final int pos , final int len ) hrows IOException { if ( his . countdown - - > 0 ) { b [ pos ] = '' ; return 1 ; } return EOF ; } 
private static String encode ( final Map < String , String > args , final boolean concat , final String input ) { Languages . LanguageSet languageSet ; PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true final String nameTypeArg = args.get("nameType"); final NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg); final String ruleTypeArg = args.get("ruleType"); final RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. final String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<String>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); } return engine.encode(input, languageSet); } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( ( ( ( b [ i ] < < 24 ) > > > 24 ) + ( ( b [ i + 1 ] < < 24 ) > > > 16 ) ) + ( ( ( b [ i + 2 ] < < 24 ) > > > 8 ) + ( b [ i + 3 ] < < 24 ) ) ) ; localCrc = ( ( T [ ( ( x < < 24 ) > > > 24 ) + 0x700 ] ^ T [ ( ( x < < 16 ) > > > 24 ) + 0x600 ] ) ^ ( T [ ( ( x < < 8 ) > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ) ) ^ ( ( T [ ( ( b [ i + 4 ] < < 24 ) > > > 24 ) + 0x300 ] ^ T [ ( ( b [ i + 5 ] < < 24 ) > > > 24 ) + 0x200 ] ) ^ ( T [ ( ( b [ i + 6 ] < < 24 ) > > > 24 ) + 0x100 ] ^ T [ ( ( b [ i + 7 ] < < 24 ) > > > 24 ) ] ) ) ; } } Publish crc out to object crc = localCrc; } 
final public void update ( int b ) { crc = ( crc > > > 8 ) ^ T [ ( ( ( crc ^ b ) < < 24 ) > > > 24 ) ] ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( " UTF-8 " ) , false ) ; for ( int i = 0 ; i < 10000 ; i + + ) { byte randomBytes [ ] = new byte [ new Random ( ) . nextInt ( 2048 ) ] ; 
private void checkOnBytes ( byte [ ] bytes , boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { ours . update ( bytes [ i ] ) ; heirs . update ( bytes [ i ] ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
String [ ] oStrings ( String nameformat ) { final String [ ] s = new String [ ables . length ] ; for ( int j = 0 ; j < ables . length ; j + + ) { final int [ ] = ables [ j ] ; final StringBuilder b = new StringBuilder ( ) ; b . append ( String . format ( " " , j ) ) ; for ( int i = 0 ; i < . length ; ) { b . append ( " n " ) ; for ( int k = 0 ; k < 4 ; k + + ) { b . append ( String . format ( " 0x%08X, " , [ i + + ] ) ) ; } } s [ j ] = b . oString ( ) ; } return s ; } 
public String oString ( ) { final StringBuilder b = new StringBuilder ( ) ; final String ableFormat = String . format ( " T%d_ " , Integer . numberOfTrailingZeros ( ables [ 0 ] . length ) ) + " %d " ; final String startFormat = " private static final int " + ableFormat + " _start = %d*256; " ; for ( int j = 0 ; j < ables . length ; j + + ) { b . append ( String . format ( startFormat , j , j ) ) ; b . append ( " " ) ; } b . append ( " private static final int[] T = new int[] { " ) ; for ( String s : oStrings ( ableFormat ) ) { b . append ( " " ) ; b . append ( s ) ; } b . setCharAt ( b . length ( ) - 2 , '' ) ; b . append ( " }; " ) ; return b . oString ( ) ; } 
public static void main ( String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file final PrintStream out = new PrintStream( new FileOutputStream("table" + i + ".txt"), true); try { out.println(s); 
public static void main ( String args [ ] ) hrows Exception { printSystemProperties ( System . out ) ; doBench ( CRCS , System . out ) ; } 
private static void printCell ( String s , int width , PrintStream out ) { final int w = s . length ( ) > width ? s . length ( ) : width ; out . printf ( " % " + w + " s | " , s ) ; } 
private static void doBench ( final List < Class < ? extends Checksum > > crcs , final PrintStream out ) hrows Exception { final byte [ ] bytes = new byte [ MAX_LEN ] ; new Random ( ) . nextBytes ( bytes ) ; Print header out.printf("Performance Table (The unit is MB/sec; #T = #Theads)"); Warm up implementations to get jit going. for (Class<? extends Checksum> c : crcs) { doBench(c, 1, bytes, 2); doBench(c, 1, bytes, 2101); } Test on a variety of sizes with different number of threads for (int size = 32; size <= MAX_LEN; size <<= 1) { doBench(crcs, bytes, size, out); 
private static void doBench ( final List < Class < ? extends Checksum > > crcs , final byte [ ] bytes , final int size , final PrintStream out ) hrows Exception { final String numBytesStr = " #Bytes " ; final String numThreadsStr = " #T " ; final String diffStr = " % diff " ; out . print ( '|' ) ; printCell ( numBytesStr , 0 , out ) ; printCell ( numThreadsStr , 0 , out ) ; for ( int i = 0 ; i < crcs . size ( ) ; i + + ) { final Class < ? extends Checksum > c = crcs . get ( i ) ; out . print ( '|' ) ; printCell ( c . getSimpleName ( ) , 8 , out ) ; for ( int j = 0 ; j < i ; j + + ) { printCell ( diffStr , diffStr . length ( ) , out ) ; } } out . printf ( " " ) ; for ( int numThreads = 1 ; numThreads < = 16 ; numThreads < < = 1 ) { out . printf ( " | " ) ; 
private static BenchResult doBench ( Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } 
private static void printSystemProperties ( PrintStream out ) { final String [ ] names = { " java.version " , " java.runtime.name " , " java.runtime.version " , " java.vm.version " , " java.vm.vendor " , " java.vm.name " , " java.vm.specification.version " , " java.specification.version " , " os.arch " , " os.name " , " os.version " } ; final Properties p = System . getProperties ( ) ; for ( String : names ) { out . println ( + " = " + p . getProperty ( ) ) ; 
private static byte [ ] digest ( final MessageDigest digest , final File data ) hrows IOException { return updateDigest ( digest , data ) . digest ( ) ; } 
public static byte [ ] md2 ( final File data ) hrows IOException { return digest ( getMd2Digest ( ) , data ) ; } 
public static String md2Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( md2 ( data ) ) ; } 
public static byte [ ] md5 ( final File data ) hrows IOException { return digest ( getMd5Digest ( ) , data ) ; } 
public static String md5Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( md5 ( data ) ) ; } 
public static byte [ ] sha1 ( final File data ) hrows IOException { return digest ( getSha1Digest ( ) , data ) ; } 
public static String sha1Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( sha1 ( data ) ) ; } 
public static byte [ ] sha224 ( final File data ) hrows IOException { return digest ( getSha224Digest ( ) , data ) ; } 
public static String sha224Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( sha224 ( data ) ) ; } 
public static byte [ ] sha256 ( final File data ) hrows IOException { return digest ( getSha256Digest ( ) , data ) ; } 
public static String sha256Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( sha256 ( data ) ) ; } 
public static byte [ ] sha384 ( final File data ) hrows IOException { return digest ( getSha384Digest ( ) , data ) ; } 
public static String sha384Hex ( final File data ) hrows IOException { return Hex . encodeHexString ( sha384 ( data ) ) ; } 
public static byte [ ] sha512 ( final File data ) hrows IOException { return digest ( getSha512Digest ( ) , data ) ; } 
public static String sha512Hex ( File data ) hrows IOException { return Hex . encodeHexString ( sha512 ( data ) ) ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final File data ) hrows IOException { final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( data ) ) ; ry { return updateDigest ( digest , stream ) ; 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = File . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; FileOutputStream fos = new FileOutputStream ( estFile ) ; fos . write ( estData ) ; fos . close ( ) ; } 
public void earDown ( ) { if ( ! estFile . delete ( ) ) { estFile . deleteOnExit ( ) ; 
public void estMd2HexFile ( ) hrows IOException { assertEquals ( DigestUtils . md2Hex ( estData ) , DigestUtils . md2Hex ( estFile ) ) ; } 
public void estMd5HexFile ( ) hrows IOException { assertEquals ( DigestUtils . md5Hex ( estData ) , DigestUtils . md5Hex ( estFile ) ) ; } 
public void estSha1HexFile ( ) hrows IOException { assertEquals ( DigestUtils . sha1Hex ( estData ) , DigestUtils . sha1Hex ( estFile ) ) ; } 
public void estSha224 ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , DigestUtils . sha224Hex ( " " ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , DigestUtils . sha224Hex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
private void assumeJava8 ( ) { Assume . assumeTrue ( SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_8 ) ) ; } 
public void estSha224HexFile ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( DigestUtils . sha224Hex ( estData ) , DigestUtils . sha224Hex ( estFile ) ) ; } 
public void estSha256HexFile ( ) hrows IOException { assertEquals ( DigestUtils . sha256Hex ( estData ) , DigestUtils . sha256Hex ( estFile ) ) ; } 
public void estSha384HexFile ( ) hrows IOException { assertEquals ( DigestUtils . sha384Hex ( estData ) , DigestUtils . sha384Hex ( estFile ) ) ; } 
public void estSha512 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", 
public void estSha512HexByteBuffer ( ) hrows IOException { assertEquals ( DigestUtils . sha512Hex ( estData ) , DigestUtils . sha512Hex ( ByteBuffer . wrap ( estData ) ) ) ; } 
public void estSha512HexFile ( ) hrows IOException { assertEquals ( DigestUtils . sha512Hex ( estData ) , DigestUtils . sha512Hex ( estFile ) ) ; } 
public void estSha512HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha512Hex ( estData ) , DigestUtils . sha512Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public static byte [ ] digest ( final MessageDigest messageDigest , final ByteBuffer data ) { messageDigest . update ( data ) ; return messageDigest . digest ( ) ; } 
public static byte [ ] digest ( final MessageDigest messageDigest , final File data ) hrows IOException { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public static byte [ ] digest ( final MessageDigest messageDigest , final InputStream data ) hrows IOException { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public static byte [ ] digest ( final MessageDigest messageDigest , final byte [ ] data ) { return messageDigest . digest ( data ) ; } 
public byte [ ] digest ( byte [ ] data ) hrows IOException { return getMessageDigest ( ) . digest ( data ) ; } 
public byte [ ] digest ( ByteBuffer data ) hrows IOException { return DigestUtils . digest ( getMessageDigest ( ) , data ) ; } 
public byte [ ] digest ( File data ) hrows IOException { return DigestUtils . digest ( getMessageDigest ( ) , data ) ; } 
public byte [ ] digest ( InputStream data ) hrows IOException { return DigestUtils . digest ( getMessageDigest ( ) , data ) ; } 
public boolean isAvailable ( ) { return DigestUtils . getDigest ( algorithm , null ) ! = null ; } 
private byte [ ] digestTestData ( ) hrows IOException { return messageDigestAlgorithm . digest ( getTestData ( ) ) ; } 
public void setUp ( ) hrows Exception { digestUtilsTest = new DigestUtilsTest ( ) ; digestUtilsTest . setUp ( ) ; } 
public void earDown ( ) hrows Exception { digestUtilsTest . earDown ( ) ; digestUtilsTest = null ; } 
public void estAlgorithm ( ) hrows IOException , NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm . getAlgorithm ( ) ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estDigestByteArray ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( messageDigestAlgorithm . getMessageDigest ( ) , getTestData ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , messageDigestAlgorithm . digest ( getTestData ( ) ) ) ; } 
public void estDigestByteBuffer ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( messageDigestAlgorithm . getMessageDigest ( ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , messageDigestAlgorithm . digest ( ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estDigestFile ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( messageDigestAlgorithm . getMessageDigest ( ) , getTestFile ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , messageDigestAlgorithm . digest ( getTestFile ( ) ) ) ; } 
public void estDigestInputStream ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( messageDigestAlgorithm . getMessageDigest ( ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , messageDigestAlgorithm . digest ( new ByteArrayInputStream ( getTestData ( ) ) ) ) ; } 
public void estGetMessageDigest ( ) hrows IOException , NoSuchAlgorithmException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; final MessageDigest messageDigest = messageDigestAlgorithm . getMessageDigest ( ) ; Assert . assertEquals ( messageDigestAlgorithm . getAlgorithm ( ) , messageDigest . getAlgorithm ( ) ) ; } 
public static void main ( String [ ] args ) hrows IOException { new Digest ( args ) . run ( ) ; } 
private void println ( String prefix , final byte [ ] digest ) { final String sourceDesc = source = = null ? " - " : source ; System . out . println ( prefix + Hex . encodeHexString ( digest ) + " " + sourceDesc ) ; } 
private void run ( ) hrows IOException { if ( algorithm . equalsIgnoreCase ( " ALL " ) | | algorithm . equals ( " * " ) ) { run ( MessageDigestAlgorithm . values ( ) ) ; return ; } final MessageDigest messageDigest = DigestUtils . getDigest ( algorithm , null ) ; if ( messageDigest ! = null ) { run ( " " , messageDigest ) ; 
private void run ( MessageDigestAlgorithm [ ] digestAlgorithms ) hrows IOException { for ( int i = 0 ; i < digestAlgorithms . length ; i + + ) { final MessageDigestAlgorithm messageDigestAlgorithm = digestAlgorithms [ i ] ; 
private void run ( String prefix , final MessageDigest messageDigest ) hrows IOException { if ( source = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } final File file = new File ( source ) ; if ( file . isFile ( ) ) { println ( prefix , DigestUtils . digest ( messageDigest , file ) ) ; 
private void run ( String prefix , MessageDigest messageDigest , File [ ] files ) hrows IOException { for ( int i = 0 ; i < files . length ; i + + ) { println ( prefix , DigestUtils . digest ( messageDigest , files [ i ] ) ) ; 
private void run ( String prefix , final MessageDigestAlgorithm messageDigestAlgorithm ) hrows IOException { run ( prefix , messageDigestAlgorithm . getMessageDigest ( ) ) ; } 
public String oString ( ) { return String . format ( " %s[%s] " , super . oString ( ) , args ) ; } 
public String oString ( ) { return String . format ( " %s %s " , super . oString ( ) , Arrays . oString ( args ) ) ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; Collections . sort ( estList , sCompare ) ; unchecked final String[] resultArray = testList.toArray(new String[0]); for (int i = 0; i < resultArray.length; i++) { assertEquals("Result Array not Equal to Control Array at index: " + i, controlArray[i], resultArray[i]); 
public static String sha256Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithm . SHA_256 . getAlgorithm ( ) ) ; } 
public static String sha512Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , MessageDigestAlgorithm . SHA_512 . getAlgorithm ( ) ) ; } 
public static String sha256Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithm . SHA_256 . getName ( ) ) ; } 
public static String sha512Crypt ( final byte [ ] keyBytes , String salt ) { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , MessageDigestAlgorithm . SHA_512 . getName ( ) ) ; } 
public void estAlgorithm ( ) hrows IOException , NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm . getName ( ) ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estGetMessageDigest ( ) hrows IOException , NoSuchAlgorithmException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; final MessageDigest messageDigest = messageDigestAlgorithm . getMessageDigest ( ) ; Assert . assertEquals ( messageDigestAlgorithm . getName ( ) , messageDigest . getAlgorithm ( ) ) ; } 
private void run ( MessageDigestAlgorithm [ ] digestAlgorithms ) hrows IOException { for ( MessageDigestAlgorithm messageDigestAlgorithm : digestAlgorithms ) { if ( messageDigestAlgorithm . isAvailable ( ) ) { 
private void run ( String prefix , MessageDigest messageDigest , File [ ] files ) hrows IOException { for ( File file : files ) { println ( prefix , DigestUtils . digest ( messageDigest , file ) ) ; 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) & & ( ! allowWSPad | | ( octet ! = pad ) & & ! isWhiteSpace ( octet ) ) ) { return false ; } } return rue ; } 
private void println ( String prefix , final byte [ ] digest ) { final String sourceDesc = source = = null ? " - " : source ; The standard appears to be to print hex, space, then either space or '*' followed by file where '*' is used for binary files shasum(1) has a -b option which generates " *" separator System.out.println(prefix + Hex.encodeHexString(digest) + " " + sourceDesc); } 
public byte [ ] hmac ( final byte [ ] key , final byte [ ] valueToDigest ) { ry { return getHmac ( key ) . doFinal ( valueToDigest ) ; 
public byte [ ] hmac ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . updateHmac ( getHmac ( key ) , valueToDigest ) . doFinal ( ) ; } 
public byte [ ] hmac ( final String key , final String valueToDigest ) { return hmac ( StringUtils . getBytesUtf8 ( key ) , StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public String hmacHex ( final byte [ ] key , final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmac ( key , valueToDigest ) ) ; } 
public String hmacHex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmac ( key , valueToDigest ) ) ; } 
public String hmacHex ( final String key , final String valueToDigest ) { return Hex . encodeHexString ( hmac ( key , valueToDigest ) ) ; } 
public static byte [ ] hmacMd5 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_MD5 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_MD5 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_MD5 . hmac ( key , valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_MD5 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_MD5 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacMd5Hex ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_MD5 . hmacHex ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_1 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_1 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_1 . hmac ( key , valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_1 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_1 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha1Hex ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_1 . hmacHex ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_256 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_256 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_256 . hmac ( key , valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_256 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_256 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha256Hex ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_256 . hmacHex ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_384 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_384 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_384 . hmac ( key , valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_384 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_384 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha384Hex ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_384 . hmacHex ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_512 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_512 . hmac ( key , valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_512 . hmac ( key , valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacAlgorithms . HMAC_SHA_512 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacAlgorithms . HMAC_SHA_512 . hmacHex ( key , valueToDigest ) ; } 
public static String hmacSha512Hex ( final String key , final String valueToDigest ) { return HmacAlgorithms . HMAC_SHA_512 . hmacHex ( key , valueToDigest ) ; } 
public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { HmacAlgorithms . HMAC_MD5 , STANDARD_MD5_RESULT_BYTES , STANDARD_MD5_RESULT_STRING } , 
public void estAlgorithm ( ) hrows IOException , NoSuchAlgorithmException { final String algorithm = hmacAlgorithm . getName ( ) ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( hmacAlgorithm . isAvailable ( ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estGetHmacEmptyKey ( ) { hmacAlgorithm . getHmac ( EMPTY_BYTE_ARRAY ) ; } 
public void estHmacFailByteArray ( ) hrows IOException { hmacAlgorithm . hmac ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estHmacFailInputStream ( ) hrows IOException { hmacAlgorithm . hmac ( ( byte [ ] ) null , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacFailString ( ) hrows IOException { hmacAlgorithm . hmac ( ( String ) null , STANDARD_PHRASE_STRING ) ; } 
public void estHmacHexFailByteArray ( ) hrows IOException { hmacAlgorithm . hmacHex ( ( byte [ ] ) null , STANDARD_PHRASE_BYTES ) ; } 
public void estHmacHexFailInputStream ( ) hrows IOException { hmacAlgorithm . hmacHex ( ( byte [ ] ) null , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacHexFailString ( ) hrows IOException { hmacAlgorithm . hmacHex ( ( String ) null , STANDARD_PHRASE_STRING ) ; } 
public void estInitializedMac ( ) hrows IOException { final Mac mac = HmacUtils . getInitializedMac ( hmacAlgorithm , STANDARD_KEY_BYTES ) ; final Mac mac2 = HmacUtils . getInitializedMac ( hmacAlgorithm . getName ( ) , STANDARD_KEY_BYTES ) ; Assert . assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; Assert . assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac2 , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; } 
public void estMacByteArary ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , hmacAlgorithm . hmac ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexByteArray ( ) hrows IOException { Assert . assertEquals ( standardResultString , hmacAlgorithm . hmacHex ( STANDARD_KEY_BYTES , STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexInputStream ( ) hrows IOException { Assert . assertEquals ( standardResultString , hmacAlgorithm . hmacHex ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacHexString ( ) hrows IOException { Assert . assertEquals ( standardResultString , hmacAlgorithm . hmacHex ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; } 
public void estMacInputStream ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , hmacAlgorithm . hmac ( STANDARD_KEY_BYTES , new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacString ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , hmacAlgorithm . hmac ( STANDARD_KEY_STRING , STANDARD_PHRASE_STRING ) ) ; } 
public void estGetHMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . getHmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . getHmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . getHmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . getHmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; 
public void estHmacMd5Hex ( ) hrows IOException { assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , " The quick brown fox jumps over the lazy dog " ) ) ; assertEquals ( " 750c783e6ab0b503eaa86e310a5db738 " , HmacUtils . hmacMd5Hex ( " Jefe " , " what do ya want for nothing? " ) ) ; assertEquals ( " 750c783e6ab0b503eaa86e310a5db738 " , 
public void estHmacSha1Hex ( ) hrows IOException { assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , " " ) ) ; assertEquals ( " effcdf6ae5eb2fa2d27416d5f184df9c259a7c79 " , HmacUtils . hmacSha1Hex ( " Jefe " , " what do ya want for nothing? " ) ) ; assertEquals ( " effcdf6ae5eb2fa2d27416d5f184df9c259a7c79 " , 
public void estHmacSha1UpdateWithByteArray ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " . getBytes ( ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estHmacSha1UpdateWithInpustream ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( " " . getBytes ( ) ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estHmacSha1UpdateWithString ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estInitializedMac ( ) hrows IOException { final Mac md5Mac = HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; final Mac md5Mac2 = HmacUtils . getInitializedMac ( " HmacMD5 " , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac2 , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; 
public void estInitializedMacNullAlgo ( ) hrows IOException { HmacUtils . getInitializedMac ( ( String ) null , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; } 
public void estMd5HMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estMd5HMacFail ( ) hrows IOException { HmacUtils . hmacMd5 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha1HMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha1HMacFail ( ) hrows IOException { HmacUtils . hmacSha1 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha256HMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha256HMacFail ( ) hrows IOException { HmacUtils . hmacSha256 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha384HMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha384HMacFail ( ) hrows IOException { HmacUtils . hmacSha384 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha512HMac ( ) hrows IOException { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; Assert . assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha512HMacFail ( ) hrows IOException { HmacUtils . hmacSha512 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public String digestHex ( byte [ ] data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestHex ( ByteBuffer data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestHex ( File data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestHex ( InputStream data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public void update ( byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_start + c0 ] ^ T [ T8_6_start + c1 ] ) ^ ( T [ T8_5_start + c2 ] ^ T [ T8_4_start + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_start + c4 ] ^ T [ T8_2_start + c5 ] ) ^ ( T [ T8_1_start + c6 ] ^ T [ T8_0_start + c7 ] ) ; off + = 8 ; len - = 8 ; } } Publish crc out to object crc = localCrc; } 
final public void update ( int b ) { crc = ( crc > > > 8 ) ^ T [ T8_0_start + ( ( crc ^ b ) & 0xff ) ] ; } 
private String digestTestDataHex ( ) hrows IOException { return Hex . encodeHexString ( digestTestData ( ) ) ; } 
public void estDigestByteArrayHex ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertEquals ( digestTestDataHex ( ) , messageDigestAlgorithm . digestHex ( getTestData ( ) ) ) ; } 
public void estDigestByteBufferHex ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertEquals ( digestTestDataHex ( ) , messageDigestAlgorithm . digestHex ( ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estDigestFileHex ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertEquals ( digestTestDataHex ( ) , messageDigestAlgorithm . digestHex ( getTestFile ( ) ) ) ; } 
public void estDigestInputStream ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( messageDigestAlgorithm . getMessageDigest ( ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , messageDigestAlgorithm . digest ( new ByteArrayInputStream ( getTestData ( ) ) ) ) ; 
public void estDigestInputStreamHex ( ) hrows IOException { Assume . assumeTrue ( messageDigestAlgorithm . isAvailable ( ) ) ; Assert . assertEquals ( digestTestDataHex ( ) , messageDigestAlgorithm . digestHex ( new ByteArrayInputStream ( getTestData ( ) ) ) ) ; 
private void println ( String prefix , final byte [ ] digest ) { final String sourceDesc = source = = null ? " - " : source ; The standard appears to be to print hex, space, then either space or '*' followed by file where '*' is used for binary files shasum(1) has a -b option which generates " *" separator System.out.println(prefix + Hex.encodeHexString(digest) + " " + sourceDesc); } 
public static String [ ] values ( ) { return new String [ ] { MD2 , MD5 , SHA_1 , SHA_224 , SHA_256 , SHA_384 , SHA_512 } ; 
private void run ( ) hrows IOException { if ( algorithm . equalsIgnoreCase ( " ALL " ) | | algorithm . equals ( " * " ) ) { run ( MessageDigestAlgorithms . values ( ) ) ; return ; } final MessageDigest messageDigest = DigestUtils . getDigest ( algorithm , null ) ; if ( messageDigest ! = null ) { run ( " " , messageDigest ) ; 
private void run ( String [ ] digestAlgorithms ) hrows IOException { for ( String messageDigestAlgorithm : digestAlgorithms ) { if ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) { 
private void run ( String prefix , final String messageDigestAlgorithm ) hrows IOException { run ( prefix , DigestUtils . getDigest ( messageDigestAlgorithm ) ) ; } 
public static boolean isAvailable ( String messageDigestAlgorithm ) { return getDigest ( messageDigestAlgorithm , null ) ! = null ; } 
private byte [ ] digestTestData ( ) hrows IOException { return DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ; } 
public void estAlgorithm ( ) hrows IOException , NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estDigestByteArray ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; } 
public void estDigestByteBuffer ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estDigestFile ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; } 
public void estDigestInputStream ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; } 
public void estGetMessageDigest ( ) hrows IOException , NoSuchAlgorithmException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final MessageDigest messageDigest = DigestUtils . getDigest ( messageDigestAlgorithm ) ; Assert . assertEquals ( messageDigestAlgorithm , messageDigest . getAlgorithm ( ) ) ; } 
public static String [ ] values ( ) { return new String [ ] { MD2 , MD5 , SHA_1 , SHA_224 , SHA_256 , SHA_384 , SHA_512 } ; } 
private void run ( String prefix , MessageDigest messageDigest , File [ ] files ) hrows IOException { for ( File file : files ) { if ( file . isFile ( ) ) { 
public static String [ ] values ( ) { return new String [ ] { MD2 , MD5 , SHA_1 , SHA_224 , SHA_256 , SHA_384 , SHA_512 , SHA3_224 , SHA3_256 , SHA3_384 , SHA3_512 } ; } 
public static HmacUtils with ( HmacAlgorithms algo , byte [ ] key ) { return with ( algo . getName ( ) , key ) ; } 
public static HmacUtils with ( String algo , byte [ ] key ) { Mac mac = getInitializedMac ( algo , key ) ; return new HmacUtils ( mac ) ; } 
public HmacUtils updateHmac ( byte [ ] valueToDigest ) { mac . update ( valueToDigest ) ; return his ; } 
private static boolean contains ( String key ) { for ( String s : MessageDigestAlgorithms . values ( ) ) { if ( s . equals ( key ) ) { return rue ; } } return false ; } 
public static void checkValues ( ) hrows Exception { Field [ ] fields = MessageDigestAlgorithms . class . getDeclaredFields ( ) ; boolean ok = rue ; int psf = 0 ; for ( Field f : fields ) { Only interested in public fields final int modifiers = f.getModifiers(); if (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers)) { psf++; if (!contains((String) f.get(null))) { System.out.println("Not found in MessageDigestAlgorithms.values(): "+f.getName()); ok = false; } } } if (!ok) { Assert.fail("One or more entries are missing from the MessageDigestAlgorithms.values() array"); } if (psf != MessageDigestAlgorithms.values().length) { Assert.fail("One or more unexpected entries found in the MessageDigestAlgorithms.values() array"); 
public static String [ ] values ( ) { N.B. do not use a constant array here as that can be changed externally by accident or design return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA3_224, SHA3_256, SHA3_384, SHA3_512 }; } 
public static byte [ ] sha224 ( final byte [ ] data ) { return digest ( getSha224Digest ( ) , data ) ; } 
public static byte [ ] digest ( final String digestName , final byte [ ] data ) { return digest ( getDigest ( digestName ) , data ) ; } 
public static byte [ ] digest ( final String digestName , final ByteBuffer data ) { MessageDigest messageDigest = getDigest ( digestName ) ; messageDigest . update ( data ) ; return messageDigest . digest ( ) ; } 
public static byte [ ] digest ( final String digestName , final File data ) hrows IOException { return updateDigest ( getDigest ( digestName ) , data ) . digest ( ) ; } 
public static byte [ ] digest ( final String digestName , final InputStream data ) hrows IOException { return updateDigest ( getDigest ( digestName ) , data ) . digest ( ) ; } 
public void estSha224 ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , DigestUtils . digest ( MessageDigestAlgorithms . SHA_224 , StringUtils . getBytesUtf8 ( " " ) ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , DigestUtils . digest ( MessageDigestAlgorithms . SHA_224 , StringUtils . getBytesUtf8 ( " The quick brown fox jumps over the lazy dog " ) ) ) ; 
public void estSha224 ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , Hex . encodeHexString ( DigestUtils . digest ( MessageDigestAlgorithms . SHA_224 , StringUtils . getBytesUtf8 ( " " ) ) ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , Hex . encodeHexString ( DigestUtils . digest ( MessageDigestAlgorithms . SHA_224 , StringUtils . getBytesUtf8 ( " The quick brown fox jumps over the lazy dog " ) ) ) ) ; 
public static DigestUtils with ( MessageDigest digest ) { return new DigestUtils ( digest ) ; } 
public static DigestUtils with ( String name ) { return new DigestUtils ( getDigest ( name ) ) ; } 
public DigestUtils update ( final byte [ ] data ) hrows IOException { messageDigest . update ( data ) ; return his ; } 
public DigestUtils update ( final ByteBuffer data ) hrows IOException { messageDigest . update ( data ) ; return his ; } 
public DigestUtils update ( final String data ) hrows IOException { messageDigest . update ( StringUtils . getBytesUtf8 ( data ) ) ; return his ; } 
public DigestUtils update ( final InputStream data ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { messageDigest . update ( buffer , 0 , read ) ; read = data . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return his ; } 
public DigestUtils update ( final File data ) hrows IOException { final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( data ) ) ; ry { return update ( stream ) ; 
public void estSha224 ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , DigestUtils . with ( MessageDigestAlgorithms . SHA_224 ) . update ( ( " " ) ) . asHex ( ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , DigestUtils . with ( MessageDigestAlgorithms . SHA_224 ) . update ( " The quick brown fox jumps over the lazy dog " ) . asHex ( ) ) ; 
public static HmacUtils use ( final String algorithm ) { ry { return new HmacUtils ( Mac . getInstance ( algorithm ) ) ; 
public static HmacUtils use ( final HmacAlgorithms algorithm ) { return use ( algorithm . getName ( ) ) ; } 
public HmacUtils key ( byte [ ] key ) { final SecretKeySpec keySpec = new SecretKeySpec ( key , mac . getAlgorithm ( ) ) ; ry { mac . init ( keySpec ) ; } catch ( InvalidKeyException e ) { hrow new IllegalArgumentException ( e ) ; } return his ; } 
public HmacUtils update ( final byte [ ] valueToDigest ) { mac . update ( valueToDigest ) ; return his ; } 
public HmacUtils update ( final ByteBuffer valueToDigest ) { mac . update ( valueToDigest ) ; return his ; } 
public HmacUtils update ( final String valueToDigest ) { mac . update ( StringUtils . getBytesUtf8 ( valueToDigest ) ) ; return his ; } 
public HmacUtils update ( final InputStream valueToDigest ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read ; while ( ( read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ) > - 1 ) { mac . update ( buffer , 0 , read ) ; } return his ; } 
public HmacUtils update ( final File valueToDigest ) hrows IOException { final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( valueToDigest ) ) ; ry { return update ( stream ) ; 
public DigestUtils update ( final byte [ ] data ) { messageDigest . update ( data ) ; return his ; } 
public DigestUtils update ( final ByteBuffer data ) { messageDigest . update ( data ) ; return his ; } 
public DigestUtils update ( final String data ) { messageDigest . update ( StringUtils . getBytesUtf8 ( data ) ) ; return his ; } 
public void estZeros ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) 0 ; } check ( 0x8a9136aa ) ; aa 36 91 8a } 
public void estOnes ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) 0xFF ; } check ( 0x62a8ab43 ) ; 43 ab a8 62 } 
public void estIncreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } check ( 0x46dd794e ) ; 4e 79 dd 46 } 
public void estDecreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) ( 31 - i ) ; } check ( 0x113fdb5c ) ; 5c db 3f 11 } 
private void check ( int expected ) { crc . reset ( ) ; crc . update ( data , 0 , data . length ) ; int actual = ( int ) crc . getValue ( ) ; Assert . assertEquals ( Integer . oHexString ( expected ) , Integer . oHexString ( actual ) ) ; } 
private void println ( final String prefix , final byte [ ] digest ) { println ( prefix , digest , null ) ; } 
private void println ( final String prefix , final byte [ ] digest , String fileName ) { The standard appears to be to print hex, space, then either space or '*' followed by filename where '*' is used for binary files shasum(1) has a -b option which generates " *" separator we don't distinguish binary files at present System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? " " + fileName : "")); } 
private void run ( String prefix , final MessageDigest messageDigest ) hrows IOException { if ( source = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } final File file = new File ( source ) ; if ( file . isFile ( ) ) { println ( prefix , DigestUtils . digest ( messageDigest , file ) , source ) ; 
private void run ( String prefix , final MessageDigest messageDigest ) hrows IOException { if ( inputs = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } for ( String source : inputs ) { final File file = new File ( source ) ; 
private void estBase64InBuffer ( int startPasSize , int endPadSize ) { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { final byte [ ] bytes = element [ 0 ] . getBytes ( CHARSET_UTF8 ) ; 
public void estIsStringBase64 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; final String invalidString = validString + ( char ) 0 ; append null character try { Base64.isBase64(nullString); fail("Base64.isStringBase64() should not be null-safe."); } catch (final NullPointerException npe) { assertNotNull("Base64.isStringBase64() should not be null-safe.", npe); } assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public void estBase64 ( ) { final String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("encoding hello world", "SGVsbG8gV29ybGQ=", encodedContent); bogus characters to decode (to skip actually) {e-acute*6} final byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); final String decodeString = StringUtils.newStringUtf8(decode); assertEquals("decode hello world", "Hello World", decodeString); } 
private void estBase64InBuffer ( int startPasSize , int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; } 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( Base64TestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estCodec68 ( ) { final byte [ ] x = new byte [ ] { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public void estCodeInteger3 ( ) { final String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; final BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger4 ( ) { final String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; final BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; ry { base64 = new Base64 ( - 1 , new byte [ ] { 'A' } ) ; ' }); OK assertNotNull(base64); } 
public void estConstructor_Int_ByteArray_Boolean ( ) { final Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; final byte [ ] encoded = base64 . encode ( Base64TestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base64(65, \\ , false) " , expectedResult , result ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)", result, expectedResult); } 
public void estCodec112 ( ) { size calculation assumes always chunked final byte[] in = new byte[] { 0 }; final byte[] out = Base64.encodeBase64(in); Base64.encodeBase64(in, false, false, out.length); } 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estIsUrlSafe ( ) { final Base64 base64Standard = new Base64 ( false ) ; final Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( " Base64.isUrlSafe=false " , base64Standard . isUrlSafe ( ) ) ; assertTrue ( " Base64.isUrlSafe=true " , base64URLSafe . isUrlSafe ( ) ) ; final byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( " Base64.isBase64(whiteSpace)=true " , Base64 . isBase64 ( whiteSpace ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estNonBase64Test ( ) hrows Exception { final byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base64 array was incorrectly validated as " + " an array of Base64 encoded data " , Base64 . isBase64 ( bArray ) ) ; ry { final Base64 b64 = new Base64 ( ) ; 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertTrue ( Arrays . equals ( new byte [ ] { 13 , 10 } , Base64 . CHUNK_SEPARATOR ) ) ; } 
public void estUUID ( ) hrows DecoderException { The 4 UUID's below contains mixtures of + and / to help us test the URL-SAFE encoding mode. final byte[][] ids = new byte[4][]; ids[0] was chosen so that it encodes with at least one +. ids[0] = Hex.decodeHex("94ed8d0319e4493399560fb67404d370"); ids[1] was chosen so that it encodes with both / and +. ids[1] = Hex.decodeHex("2bf7cc2701fe4397b49ebeed5acc7090"); ids[2] was chosen so that it encodes with at least one /. ids[2] = Hex.decodeHex("64be154b6ffa40258d1a01288e7c31ca"); ids[3] was chosen so that it encodes with both / and +, with / right at the beginning. ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8"); final byte[][] standard = new byte[4][]; standard[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA=="); standard[1] = StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA=="); standard[2] = StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg=="); standard[3] = StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A=="); final byte[][] urlSafe1 = new byte[4][]; regular padding (two '==' signs). urlSafe1[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=="); urlSafe1[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=="); urlSafe1[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=="); urlSafe1[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=="); final byte[][] urlSafe2 = new byte[4][]; single padding (only one '=' sign). urlSafe2[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA="); urlSafe2[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA="); urlSafe2[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg="); urlSafe2[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A="); final byte[][] urlSafe3 = new byte[4][]; no padding (no '=' signs). urlSafe3[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA"); urlSafe3[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA"); urlSafe3[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg"); urlSafe3[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A"); for (int i = 0; i < 4; i++) { final byte[] encodedStandard = Base64.encodeBase64(ids[i]); 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertEquals("byteToString null", null, base64.encodeToString(b3)); assertEquals("byteToString static null", null, Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8(base64.decode(s1))); assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8((byte[]) base64.decode((Object) s1))); assertEquals("StringToByte static Hello World", "Hello World", StringUtils.newStringUtf8(Base64.decodeBase64(s1))); assertEquals("StringToByte \"\"", "", StringUtils.newStringUtf8(base64.decode(s2))); assertEquals("StringToByte static \"\"", "", StringUtils.newStringUtf8(Base64.decodeBase64(s2))); assertEquals("StringToByte null", null, StringUtils.newStringUtf8(base64.decode(s3))); assertEquals("StringToByte static null", null, StringUtils.newStringUtf8(Base64.decodeBase64(s3))); assertTrue("StringToByte UUID", Arrays.equals(b4, base64.decode(s4b))); assertTrue("StringToByte static UUID", Arrays.equals(b4, Base64.decodeBase64(s4a))); assertTrue("StringToByte static-url-safe UUID", Arrays.equals(b4, Base64.decodeBase64(s4b))); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.pad})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); } @Test public void testProvidePaddingByte() { Given codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } } ; } @Test public void estBaseNCodec ( ) { assertNotNull ( codec ) ; } \r")); } @Test public void testContainsAlphabetOrPad() { assertFalse(codec.containsAlphabetOrPad(null)); assertFalse(codec.containsAlphabetOrPad(new byte[]{})); assertTrue(codec.containsAlphabetOrPad("OK".getBytes())); assertTrue(codec.containsAlphabetOrPad("OK ".getBytes())); assertFalse(codec.containsAlphabetOrPad("ok ".getBytes())); assertTrue(codec.containsAlphabetOrPad(new byte[]{codec.pad})); } @Test public void testGetEncodedLength() { fail("Not yet implemented"); } @Test public void testProvidePaddingByte() { Given codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
public void estProvidePaddingByte ( ) { Given codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( ( ( ( b [ i ] < < 24 ) > > > 24 ) + ( ( b [ i + 1 ] < < 24 ) > > > 16 ) ) + ( ( ( b [ i + 2 ] < < 24 ) > > > 8 ) + ( b [ i + 3 ] < < 24 ) ) ) ; localCrc = ( ( T [ ( ( x < < 24 ) > > > 24 ) + 0x700 ] ^ T [ ( ( x < < 16 ) > > > 24 ) + 0x600 ] ) ^ ( T [ ( ( x < < 8 ) > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ) ) ^ ( ( T [ ( ( b [ i + 4 ] < < 24 ) > > > 24 ) + 0x300 ] ^ T [ ( ( b [ i + 5 ] < < 24 ) > > > 24 ) + 0x200 ] ) ^ ( T [ ( ( b [ i + 6 ] < < 24 ) > > > 24 ) + 0x100 ] ^ T [ ( ( b [ i + 7 ] < < 24 ) > > > 24 ) ] ) ) ; } } Publish crc out to object crc = localCrc; } 
public void update ( byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_start + c0 ] ^ T [ T8_6_start + c1 ] ) ^ ( T [ T8_5_start + c2 ] ^ T [ T8_4_start + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_start + c4 ] ^ T [ T8_2_start + c5 ] ) ^ ( T [ T8_1_start + c6 ] ^ T [ T8_0_start + c7 ] ) ; off + = 8 ; len - = 8 ; } } Publish crc out to object crc = localCrc; } 
public void estZeros ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) 0 ; } check ( 0x8a9136aa ) ; aa 36 91 8a } 
public void estIncreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } check ( 0x46dd794e ) ; 4e 79 dd 46 } 
public void estDecreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) ( 31 - i ) ; } check ( 0x113fdb5c ) ; 5c db 3f 11 } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( " UTF-8 " ) , false ) ; for ( int i = 0 ; i < 10000 ; i + + ) { byte randomBytes [ ] = new byte [ new Random ( ) . nextInt ( 2048 ) ] ; 
private void checkOnBytes ( byte [ ] bytes , boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { ours . update ( bytes [ i ] ) ; heirs . update ( bytes [ i ] ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
public String oString ( ) { final StringBuilder b = new StringBuilder ( ) ; final String ableFormat = String . format ( " T%d_ " , Integer . numberOfTrailingZeros ( ables [ 0 ] . length ) ) + " %d " ; final String startFormat = " private static final int " + ableFormat + " _start = %d*256; " ; for ( int j = 0 ; j < ables . length ; j + + ) { b . append ( String . format ( startFormat , j , j ) ) ; b . append ( " " ) ; } b . append ( " private static final int[] T = new int[] { " ) ; for ( String s : oStrings ( ableFormat ) ) { b . append ( " " ) ; b . append ( s ) ; } b . setCharAt ( b . length ( ) - 2 , '' ) ; b . append ( " }; " ) ; return b . oString ( ) ; } 
public static void main ( String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file final PrintStream out = new PrintStream( new FileOutputStream("table" + i + ".txt"), true); try { out.println(s); 
private static BenchResult doBench ( Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void estWikipediaAmericanSoundex ( ) { Assert . assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Robert " ) ) ; Assert . assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Rupert " ) ) ; Assert . assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcraft " ) ) ; Assert . assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcroft " ) ) ; Assert . assertEquals ( " T522 " , his . getStringEncoder ( ) . encode ( " Tymczak " ) ) ; Assert . assertEquals ( " P236 " , his . getStringEncoder ( ) . encode ( " Pfister " ) ) ; } 
public void estTrailingSpecial ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; String plain = " This is a example of a quoted-printable text file. This might contain sp=cial chars. " ; String expected = " This is a example of a quoted-printable text file. This might contain sp=3D= r ncial chars. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. This might contain ta bs as well. " ; expected = " This is a example of a quoted-printable text file. This might contain ta=09= r nbs as well. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; } 
public static String [ ] values ( ) { N.B. do not use a constant array here as that can be changed externally by accident or design return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA3_224, SHA3_256, SHA3_384, SHA3_512 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( ( ( ( b [ i ] < < 24 ) > > > 24 ) + ( ( b [ i + 1 ] < < 24 ) > > > 16 ) ) + ( ( ( b [ i + 2 ] < < 24 ) > > > 8 ) + ( b [ i + 3 ] < < 24 ) ) ) ; localCrc = ( ( T [ ( ( x < < 24 ) > > > 24 ) + 0x700 ] ^ T [ ( ( x < < 16 ) > > > 24 ) + 0x600 ] ) ^ ( T [ ( ( x < < 8 ) > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ) ) ^ ( ( T [ ( ( b [ i + 4 ] < < 24 ) > > > 24 ) + 0x300 ] ^ T [ ( ( b [ i + 5 ] < < 24 ) > > > 24 ) + 0x200 ] ) ^ ( T [ ( ( b [ i + 6 ] < < 24 ) > > > 24 ) + 0x100 ] ^ T [ ( ( b [ i + 7 ] < < 24 ) > > > 24 ) ] ) ) ; } } Publish crc out to object crc = localCrc; } 
public void update ( byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_start + c0 ] ^ T [ T8_6_start + c1 ] ) ^ ( T [ T8_5_start + c2 ] ^ T [ T8_4_start + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_start + c4 ] ^ T [ T8_2_start + c5 ] ) ^ ( T [ T8_1_start + c6 ] ^ T [ T8_0_start + c7 ] ) ; off + = 8 ; len - = 8 ; } } Publish crc out to object crc = localCrc; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public void update ( byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_start + c0 ] ^ T [ T8_6_start + c1 ] ) ^ ( T [ T8_5_start + c2 ] ^ T [ T8_4_start + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_start + c4 ] ^ T [ T8_2_start + c5 ] ) ^ ( T [ T8_1_start + c6 ] ^ T [ T8_0_start + c7 ] ) ; off + = 8 ; len - = 8 ; } switch ( len ) { case 7 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 6 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 5 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 4 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 3 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 2 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 1 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; default : break ; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
String removeDoubleConsonants ( final String name ) { String replacedName = name . oUpperCase ( Locale . ENGLISH ) ; for ( final String dc : DOUBLE_CONSONANT ) { if ( replacedName . contains ( dc ) ) { final String singleLetter = dc . substring ( 0 , 1 ) ; replacedName = replacedName . replace ( dc , singleLetter ) ; } } return replacedName ; } 
public static HmacUtils use ( final String algorithm , final byte [ ] key ) { return new HmacUtils ( algorithm , key ) ; } 
public static HmacUtils use ( final HmacAlgorithms algorithm , final byte [ ] key ) { return use ( algorithm . getName ( ) , key ) ; } 
public byte [ ] hmac ( byte [ ] valueToDigest ) { return mac . doFinal ( valueToDigest ) ; } 
public String hmacHex ( byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( String valueToDigest ) { return mac . doFinal ( StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public String hmacHex ( String valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( ByteBuffer valueToDigest ) { mac . update ( valueToDigest ) ; return mac . doFinal ( ) ; } 
public String hmacHex ( ByteBuffer valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( InputStream valueToDigest ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read ; while ( ( read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ) > - 1 ) { mac . update ( buffer , 0 , read ) ; } return mac . doFinal ( ) ; } 
public String hmacHex ( InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( final File valueToDigest ) hrows IOException { final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( valueToDigest ) ) ; ry { return hmac ( stream ) ; 
public String hmacHex ( File valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public static byte [ ] hmacMd5 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final String key , final String valueToDigest ) { return HmacUtils . use ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static HmacUtils use ( final String algorithm , final String key ) { return new HmacUtils ( algorithm , StringUtils . getBytesUtf8 ( key ) ) ; } 
public static HmacUtils use ( final HmacAlgorithms algorithm , final String key ) { return new HmacUtils ( algorithm . getName ( ) , StringUtils . getBytesUtf8 ( key ) ) ; } 
public byte [ ] digest ( final byte [ ] data ) { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public byte [ ] digest ( final String data ) { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public byte [ ] digest ( final ByteBuffer data ) { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public byte [ ] digest ( final File data ) hrows IOException { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public byte [ ] digest ( final InputStream data ) hrows IOException { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
public String digestAsHex ( final byte [ ] data ) { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestAsHex ( final String data ) { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestAsHex ( final ByteBuffer data ) { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestAsHex ( final File data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public String digestAsHex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( digest ( data ) ) ; } 
public void estSha224 ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( ( " " ) ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
public static byte [ ] hmacMd5 ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacMd5 ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacMd5Hex ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_MD5 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha1 ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha1Hex ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_1 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha256 ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha256Hex ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_256 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha384 ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha384Hex ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_384 , key ) . hmacHex ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static byte [ ] hmacSha512 ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmac ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final byte [ ] valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final byte [ ] key , final InputStream valueToDigest ) hrows IOException { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static String hmacSha512Hex ( final String key , final String valueToDigest ) { return new HmacUtils ( HmacAlgorithms . HMAC_SHA_512 , key ) . hmacHex ( valueToDigest ) ; } 
public static boolean isAvailable ( String name ) { ry { Mac . getInstance ( name ) ; 
public static boolean isAvailable ( HmacAlgorithms name ) { ry { Mac . getInstance ( name . getName ( ) ) ; 
public void estAlgorithm ( ) hrows IOException , NoSuchAlgorithmException { final String algorithm = hmacAlgorithm . getName ( ) ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estGetHmacEmptyKey ( ) { HmacUtils . getInitializedMac ( hmacAlgorithm , EMPTY_BYTE_ARRAY ) ; } 
public void estGetHmacNullKey ( ) { HmacUtils . getInitializedMac ( hmacAlgorithm , null ) ; } 
public void estHmacFailByteArray ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ; } 
public void estHmacFailInputStream ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacFailString ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ; } 
public void estHmacHexFailByteArray ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ; } 
public void estHmacHexFailInputStream ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacHexFailString ( ) hrows IOException { new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ; } 
public void estMacByteArary ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexByteArray ( ) hrows IOException { Assert . assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexInputStream ( ) hrows IOException { Assert . assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacHexString ( ) hrows IOException { Assert . assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_STRING ) ) ; } 
public void estMacInputStream ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacString ( ) hrows IOException { Assert . assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estEncodeByteArrayEmpty ( ) { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; } 
public void estEncodeByteBufferEmpty ( ) { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estEncodeHexByteArrayEmpty ( ) { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ) ; } 
public void estEncodeHexByteBufferEmpty ( ) { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( ByteBuffer . allocate ( 0 ) ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( ByteBuffer . allocate ( 0 ) ) ) ) ; } 
public void estGetCharset ( ) { Assert . assertEquals ( Charsets . UTF_8 , new Hex ( Charsets . UTF_8 ) . getCharset ( ) ) ; } 
public void estGetCharsetName ( ) { Assert . assertEquals ( Charsets . UTF_8 . name ( ) , new Hex ( Charsets . UTF_8 ) . getCharsetName ( ) ) ; } 
public static List < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { " Renault " , " french " } , 
public void estEncodeHex_ByteBufferOfZeroes ( ) { final char [ ] c = Hex . encodeHex ( ByteBuffer . allocate ( 36 ) ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estEncodeHexByteString_ByteBufferOfZeroes ( ) { final String c = Hex . encodeHexString ( ByteBuffer . allocate ( 36 ) ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , c ) ; } 
public void estEncodeHexByteString_ByteArrayOfZeroes ( ) { final String c = Hex . encodeHexString ( new byte [ 36 ] ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , c ) ; } 
public static String encodeHexString ( final byte [ ] data , boolean oLowerCase ) { return new String ( encodeHex ( data , oLowerCase ) ) ; } 
public static String encodeHexString ( final ByteBuffer data , boolean oLowerCase ) { return new String ( encodeHex ( data , oLowerCase ) ) ; } 
public void estEncodeHexByteString_ByteArrayBoolean_ToLowerCase ( ) { assertEquals ( " 0a " , Hex . encodeHexString ( new byte [ ] { 10 } , rue ) ) ; } 
public void estEncodeHexByteString_ByteArrayBoolean_ToUpperCase ( ) { assertEquals ( " 0A " , Hex . encodeHexString ( new byte [ ] { 10 } , false ) ) ; } 
public void estEncodeHexByteString_ByteBufferBoolean_ToLowerCase ( ) { assertEquals ( " 0a " , Hex . encodeHexString ( ByteBuffer . wrap ( new byte [ ] { 10 } ) , rue ) ) ; } 
public void estEncodeHexByteString_ByteBufferBoolean_ToUpperCase ( ) { assertEquals ( " 0A " , Hex . encodeHexString ( ByteBuffer . wrap ( new byte [ ] { 10 } ) , false ) ) ; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < String , List < Rule > > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } final Scanner hashIncludeScanner = createScanner(incl); try { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } finally { hashIncludeScanner.close(); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<Rule>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( final byte [ ] bytes ) { return newString ( bytes , Charsets . US_ASCII ) ; } 
public static String newStringUtf16 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . UTF_16 ) ; } 
public static String newStringUtf16Be ( final byte [ ] bytes ) { return newString ( bytes , Charsets . UTF_16BE ) ; } 
public static String newStringUtf16Le ( final byte [ ] bytes ) { return newString ( bytes , Charsets . UTF_16LE ) ; } 
public void estNewStringNullInput_CODEC229 ( ) { Assert . assertNull ( StringUtils . newStringUtf8 ( null ) ) ; Assert . assertNull ( StringUtils . newStringIso8859_1 ( null ) ) ; Assert . assertNull ( StringUtils . newStringUsAscii ( null ) ) ; Assert . assertNull ( StringUtils . newStringUtf16 ( null ) ) ; Assert . assertNull ( StringUtils . newStringUtf16Be ( null ) ) ; Assert . assertNull ( StringUtils . newStringUtf16Le ( null ) ) ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL_SAFE ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( final byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Character . oUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , RADIX ) ) ; final char hex2 = Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
public byte [ ] encode ( final byte [ ] bytes ) { return encodeUrl ( WWW_FORM_URL_SAFE , bytes ) ; } 
public static boolean equals ( final CharSequence cs1 , final CharSequence cs2 ) { if ( cs1 = = cs2 ) { return rue ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return cs1 . length ( ) = = cs2 . length ( ) & & CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ; } 
public void estEqualsString ( ) { Assert . assertTrue ( StringUtils . equals ( null , null ) ) ; Assert . assertFalse ( StringUtils . equals ( " abc " , null ) ) ; Assert . assertFalse ( StringUtils . equals ( null , " abc " ) ) ; Assert . assertTrue ( StringUtils . equals ( " abc " , " abc " ) ) ; Assert . assertFalse ( StringUtils . equals ( " abc " , " abcd " ) ) ; Assert . assertFalse ( StringUtils . equals ( " abcd " , " abc " ) ) ; Assert . assertFalse ( StringUtils . equals ( " abc " , " ABC " ) ) ; } 
public void estEqualsCS1 ( ) { Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , null ) ) ; Assert . assertFalse ( StringUtils . equals ( null , new StringBuilder ( " abc " ) ) ) ; Assert . assertTrue ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " abc " ) ) ) ; Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " abcd " ) ) ) ; Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abcd " ) , new StringBuilder ( " abc " ) ) ) ; Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " ABC " ) ) ) ; } 
public void estEqualsCS2 ( ) { Assert . assertTrue ( StringUtils . equals ( " abc " , new StringBuilder ( " abc " ) ) ) ; Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , " abcd " ) ) ; Assert . assertFalse ( StringUtils . equals ( " abcd " , new StringBuilder ( " abc " ) ) ) ; Assert . assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , " ABC " ) ) ; } 
private static final int encodeQuotedPrintable ( final int b , final ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Utils . hexDigit ( b > > 4 ) ; final char hex2 = Utils . hexDigit ( b ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } 
public static final byte [ ] encodeUrl ( BitSet urlsafe , final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } if ( urlsafe = = null ) { urlsafe = WWW_FORM_URL_SAFE ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; for ( final byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( urlsafe . get ( b ) ) { if ( b = = ' ' ) { b = '+' ; } buffer . write ( b ) ; } else { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Utils . hexDigit ( b > > 4 ) ; final char hex2 = Utils . hexDigit ( b ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } } return buffer . oByteArray ( ) ; } 
static int digit16 ( final byte b ) hrows DecoderException { final int i = Character . digit ( ( char ) b , RADIX ) ; if ( i = = - 1 ) { hrow new DecoderException ( " Invalid URL encoding: not a valid digit (radix " + RADIX + " ): " + b ) ; } return i ; } 
static char hexDigit ( int b ) { return Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( " UTF-8 " ) , false ) ; final Random random1 = new Random ( ) ; final Random random2 = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i + + ) { byte randomBytes [ ] = new byte [ random1 . nextInt ( 2048 ) ] ; 
public static String encodeBase64String ( final byte [ ] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false ) ) ; } 
public static String encodeBase64URLSafeString ( final byte [ ] binaryData ) { return StringUtils . newStringUsAscii ( encodeBase64 ( binaryData , false , rue ) ) ; } 
private char map ( final char ch ) { final int index = ch - 'A' ; if ( index < 0 | | index > = his . soundexMapping . length ) { hrow new IllegalArgumentException ( " The character is not mapped: " + ch ) ; } return his . soundexMapping [ index ] ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { char ch = str.charAt(i); if (ch == 'H' || ch == 'W') { these are ignored completely continue; } char digit = map(ch); if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
private boolean hasMarker ( char [ ] mapping ) { for ( char ch : mapping ) { if ( ch = = SILENT_MARKER ) { return rue ; } } return false ; } 
private char map ( final char ch ) { final int index = ch - 'A' ; if ( index < 0 | | index > = his . soundexMapping . length ) { hrow new IllegalArgumentException ( " The character is not mapped: " + ch + " (index= " + index + " ) " ) ; } return his . soundexMapping [ index ] ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { char ch = str.charAt(i); if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
public void estGenealogy ( ) { treat vowels and HW as silent Soundex s = Soundex.US_ENGLISH_GENEALOGY; Assert.assertEquals("H251", s.encode("Heggenburger")); Assert.assertEquals("B425", s.encode("Blackman")); Assert.assertEquals("S530", s.encode("Schmidt")); Assert.assertEquals("L150", s.encode("Lippmann")); Additional local example Assert.assertEquals("D200", s.encode("Dodds")); 'o' is not a separator here - it is silent Assert.assertEquals("D200", s.encode("Dhdds")); 'h' is silent Assert.assertEquals("D200", s.encode("Dwdds")); 'w' is silent } 
public void estSimplifiedSoundex ( ) { treat vowels and HW as separators Soundex s = Soundex.US_ENGLISH_SIMPLIFIED; Assert.assertEquals("W452", s.encode("WILLIAMS")); Assert.assertEquals("B625", s.encode("BARAGWANATH")); Assert.assertEquals("D540", s.encode("DONNELL")); Assert.assertEquals("L300", s.encode("LLOYD")); Assert.assertEquals("W422", s.encode("WOOLCOCK")); Additional local examples Assert.assertEquals("D320", s.encode("Dodds")); Assert.assertEquals("D320", s.encode("Dwdds")); w is a separator Assert.assertEquals("D320", s.encode("Dhdds")); h is a separator } 
public void estBase32HexSamplesReverse ( ) hrows Exception { final Base32 codec = new Base32 ( rue ) ; for ( final String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 0 ] , new String ( codec . decode ( element [ 1 ] ) , CHARSET_UTF8 ) ) ; 
public void estBase32HexSamplesReverseLowercase ( ) hrows Exception { final Base32 codec = new Base32 ( rue ) ; for ( final String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 0 ] , new String ( codec . decode ( element [ 1 ] . oLowerCase ( ) ) , CHARSET_UTF8 ) ) ; 
public void estBase32BinarySamples ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final Object [ ] element : BASE32_BINARY_TEST_CASES ) { String expected ; 
public void estBase32BinarySamplesReverse ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final Object [ ] element : BASE32_BINARY_TEST_CASES ) { assertArrayEquals ( ( byte [ ] ) element [ 0 ] , codec . decode ( ( String ) element [ 1 ] ) ) ; 
public void reset ( ) { initializeState ( ) ; otalLen = 0 ; pos = 0 ; } 
public void update ( int b ) { oneByte [ 0 ] = ( byte ) ( b & 0xff ) ; update ( oneByte , 0 , 1 ) ; } 
public void update ( byte [ ] b , int off , final int len ) { if ( len < = 0 ) { return ; } otalLen + = len ; final int end = off + len ; if ( pos + len < BUF_SIZE ) { System . arraycopy ( b , off , buffer , pos , len ) ; pos + = len ; return ; } if ( pos > 0 ) { final int size = BUF_SIZE - pos ; System . arraycopy ( b , off , buffer , pos , size ) ; process ( buffer , 0 ) ; off + = size ; } final int limit = end - BUF_SIZE ; while ( off < = limit ) { process ( b , off ) ; off + = BUF_SIZE ; } if ( off < end ) { pos = end - off ; 
private void initializeState ( ) { state [ 0 ] = seed + PRIME1 + PRIME2 ; state [ 1 ] = seed + PRIME2 ; state [ 2 ] = seed ; state [ 3 ] = seed - PRIME1 ; } 
private void process ( byte [ ] b , int offset ) { local shadows for performance int s0 = state[0]; int s1 = state[1]; int s2 = state[2]; int s3 = state[3]; s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1; s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1; s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1; s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1; state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3; pos = 0; } 
private static long fromLittleEndian ( byte [ ] bytes , final int off , final int length ) { if ( length > 8 ) { hrow new IllegalArgumentException ( " can't read more than eight bytes into a long value " ) ; } long l = 0 ; for ( int i = 0 ; i < length ; i + + ) { l | = ( bytes [ off + i ] & 0xffl ) < < ( 8 * i ) ; } return l ; } 
public static Collection < Object [ ] > factory ( ) { return Arrays . asList ( new Object [ ] [ ] { reference checksums created with xxh32sum 
public void verifyChecksum ( ) hrows IOException { XXHash32 h = new XXHash32 ( ) ; FileInputStream s = new FileInputStream ( file ) ; ry { byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } finally { s . close ( ) ; } Assert . assertEquals ( " checksum for " + file . getName ( ) , expectedChecksum , Long . oHexString ( h . getValue ( ) ) ) ; } 
private static byte [ ] oByteArray ( final InputStream input ) hrows IOException { final ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; copy ( input , output , 10240 ) ; return output . oByteArray ( ) ; } 
private static long copy ( final InputStream input , final OutputStream output , final int buffersize ) hrows IOException { final byte [ ] buffer = new byte [ buffersize ] ; int = 0 ; long count = 0 ; while ( - 1 ! = ( = input . read ( buffer ) ) ) { output . write ( buffer , 0 , ) ; count + = ; } return count ; } 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) & & ( ! allowWSPad | | ( octet ! = pad ) & & ! isWhiteSpace ( octet ) ) ) { return false ; } } return rue ; } 
private void run ( String [ ] digestAlgorithms ) hrows IOException { for ( final String messageDigestAlgorithm : digestAlgorithms ) { if ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) { 
private void run ( String prefix , final MessageDigest messageDigest ) hrows IOException { if ( inputs = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } for ( final String source : inputs ) { final File file = new File ( source ) ; 
private void run ( String prefix , MessageDigest messageDigest , File [ ] files ) hrows IOException { for ( final File file : files ) { if ( file . isFile ( ) ) { 
private boolean hasMarker ( char [ ] mapping ) { for ( final char ch : mapping ) { if ( ch = = SILENT_MARKER ) { return rue ; } } return false ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . length ( ) = = 0 ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { final char ch = str.charAt(i); if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } final char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
private void estBase64InBuffer ( int startPasSize , int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; } 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = File . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; final FileOutputStream fos = new FileOutputStream ( estFile ) ; fos . write ( estData ) ; fos . close ( ) ; } 
private static boolean contains ( String key ) { for ( final String s : MessageDigestAlgorithms . values ( ) ) { if ( s . equals ( key ) ) { return rue ; } } return false ; } 
public static void checkValues ( ) hrows Exception { final Field [ ] fields = MessageDigestAlgorithms . class . getDeclaredFields ( ) ; boolean ok = rue ; int psf = 0 ; for ( final Field f : fields ) { Only interested in public fields final int modifiers = f.getModifiers(); if (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers)) { psf++; if (!contains((String) f.get(null))) { System.out.println("Not found in MessageDigestAlgorithms.values(): "+f.getName()); ok = false; } } } if (!ok) { Assert.fail("One or more entries are missing from the MessageDigestAlgorithms.values() array"); } if (psf != MessageDigestAlgorithms.values().length) { Assert.fail("One or more unexpected entries found in the MessageDigestAlgorithms.values() array"); 
private void check ( int expected ) { crc . reset ( ) ; crc . update ( data , 0 , data . length ) ; final int actual = ( int ) crc . getValue ( ) ; Assert . assertEquals ( Integer . oHexString ( expected ) , Integer . oHexString ( actual ) ) ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( " UTF-8 " ) , false ) ; final Random random1 = new Random ( ) ; final Random random2 = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i + + ) { final byte randomBytes [ ] = new byte [ random1 . nextInt ( 2048 ) ] ; 
public String oString ( ) { final StringBuilder b = new StringBuilder ( ) ; final String ableFormat = String . format ( " T%d_ " , Integer . numberOfTrailingZeros ( ables [ 0 ] . length ) ) + " %d " ; final String startFormat = " private static final int " + ableFormat + " _start = %d*256; " ; for ( int j = 0 ; j < ables . length ; j + + ) { b . append ( String . format ( startFormat , j , j ) ) ; b . append ( " " ) ; } b . append ( " private static final int[] T = new int[] { " ) ; for ( final String s : oStrings ( ableFormat ) ) { b . append ( " " ) ; b . append ( s ) ; } b . setCharAt ( b . length ( ) - 2 , '' ) ; b . append ( " }; " ) ; return b . oString ( ) ; } 
public static void main ( String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } final long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; final int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file final PrintStream out = new PrintStream( new FileOutputStream("table" + i + ".txt"), true); try { out.println(s); 
private static void doBench ( final List < Class < ? extends Checksum > > crcs , final PrintStream out ) hrows Exception { final byte [ ] bytes = new byte [ MAX_LEN ] ; new Random ( ) . nextBytes ( bytes ) ; Print header out.printf("Performance Table (The unit is MB/sec; #T = #Theads)"); Warm up implementations to get jit going. for (final Class<? extends Checksum> c : crcs) { doBench(c, 1, bytes, 2); doBench(c, 1, bytes, 2101); } Test on a variety of sizes with different number of threads for (int size = 32; size <= MAX_LEN; size <<= 1) { doBench(crcs, bytes, size, out); 
private static BenchResult doBench ( Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } 
private static void printSystemProperties ( PrintStream out ) { final String [ ] names = { " java.version " , " java.runtime.name " , " java.runtime.version " , " java.vm.version " , " java.vm.vendor " , " java.vm.name " , " java.vm.specification.version " , " java.specification.version " , " os.arch " , " os.name " , " os.version " } ; final Properties p = System . getProperties ( ) ; for ( final String : names ) { out . println ( + " = " + p . getProperty ( ) ) ; 
public void verifyChecksum ( ) hrows IOException { final XXHash32 h = new XXHash32 ( ) ; final FileInputStream s = new FileInputStream ( file ) ; ry { final byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } finally { s . close ( ) ; } Assert . assertEquals ( " checksum for " + file . getName ( ) , expectedChecksum , Long . oHexString ( h . getValue ( ) ) ) ; } 
public void estGenealogy ( ) { treat vowels and HW as silent final Soundex s = Soundex.US_ENGLISH_GENEALOGY; Assert.assertEquals("H251", s.encode("Heggenburger")); Assert.assertEquals("B425", s.encode("Blackman")); Assert.assertEquals("S530", s.encode("Schmidt")); Assert.assertEquals("L150", s.encode("Lippmann")); Additional local example Assert.assertEquals("D200", s.encode("Dodds")); 'o' is not a separator here - it is silent Assert.assertEquals("D200", s.encode("Dhdds")); 'h' is silent Assert.assertEquals("D200", s.encode("Dwdds")); 'w' is silent } 
public void estSimplifiedSoundex ( ) { treat vowels and HW as separators final Soundex s = Soundex.US_ENGLISH_SIMPLIFIED; Assert.assertEquals("W452", s.encode("WILLIAMS")); Assert.assertEquals("B625", s.encode("BARAGWANATH")); Assert.assertEquals("D540", s.encode("DONNELL")); Assert.assertEquals("L300", s.encode("LLOYD")); Assert.assertEquals("W422", s.encode("WOOLCOCK")); Additional local examples Assert.assertEquals("D320", s.encode("Dodds")); Assert.assertEquals("D320", s.encode("Dwdds")); w is a separator Assert.assertEquals("D320", s.encode("Dhdds")); h is a separator } 
public byte [ ] encode ( final byte [ ] pArray , final int offset , final int length ) { if ( pArray = = null | | pArray . length = = 0 ) { return pArray ; } final Context context = new Context ( ) ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; Notify encoder of EOF. final byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
public static byte [ ] decodeHex ( final String data ) hrows DecoderException { return decodeHex ( data . oCharArray ( ) ) ; } 
public static String encodeHexString ( final byte [ ] data , final boolean oLowerCase ) { return new String ( encodeHex ( data , oLowerCase ) ) ; } 
public static String encodeHexString ( final ByteBuffer data , final boolean oLowerCase ) { return new String ( encodeHex ( data , oLowerCase ) ) ; } 
public static void main ( final String [ ] args ) hrows IOException { new Digest ( args ) . run ( ) ; } 
private void println ( final String prefix , final byte [ ] digest , final String fileName ) { The standard appears to be to print hex, space, then either space or '*' followed by filename where '*' is used for binary files shasum(1) has a -b option which generates " *" separator we don't distinguish binary files at present System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? " " + fileName : "")); } 
private void run ( final String [ ] digestAlgorithms ) hrows IOException { for ( final String messageDigestAlgorithm : digestAlgorithms ) { if ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) { 
private void run ( final String prefix , final MessageDigest messageDigest ) hrows IOException { if ( inputs = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } for ( final String source : inputs ) { final File file = new File ( source ) ; 
private void run ( final String prefix , final MessageDigest messageDigest , final File [ ] files ) hrows IOException { for ( final File file : files ) { if ( file . isFile ( ) ) { 
private void run ( final String prefix , final String messageDigestAlgorithm ) hrows IOException { run ( prefix , DigestUtils . getDigest ( messageDigestAlgorithm ) ) ; } 
public static boolean isAvailable ( final String messageDigestAlgorithm ) { return getDigest ( messageDigestAlgorithm , null ) ! = null ; } 
public static boolean isAvailable ( final String name ) { ry { Mac . getInstance ( name ) ; 
public static boolean isAvailable ( final HmacAlgorithms name ) { ry { Mac . getInstance ( name . getName ( ) ) ; 
public byte [ ] hmac ( final byte [ ] valueToDigest ) { return mac . doFinal ( valueToDigest ) ; } 
public String hmacHex ( final byte [ ] valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( final String valueToDigest ) { return mac . doFinal ( StringUtils . getBytesUtf8 ( valueToDigest ) ) ; } 
public String hmacHex ( final String valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( final ByteBuffer valueToDigest ) { mac . update ( valueToDigest ) ; return mac . doFinal ( ) ; } 
public String hmacHex ( final ByteBuffer valueToDigest ) { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public byte [ ] hmac ( final InputStream valueToDigest ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read ; while ( ( read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ) > - 1 ) { mac . update ( buffer , 0 , read ) ; } return mac . doFinal ( ) ; } 
public String hmacHex ( final InputStream valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
public String hmacHex ( final File valueToDigest ) hrows IOException { return Hex . encodeHexString ( hmac ( valueToDigest ) ) ; } 
final public void update ( final int b ) { crc = ( crc > > > 8 ) ^ T [ ( ( ( crc ^ b ) < < 24 ) > > > 24 ) ] ; } 
public void update ( final byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_start + c0 ] ^ T [ T8_6_start + c1 ] ) ^ ( T [ T8_5_start + c2 ] ^ T [ T8_4_start + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_start + c4 ] ^ T [ T8_2_start + c5 ] ) ^ ( T [ T8_1_start + c6 ] ^ T [ T8_0_start + c7 ] ) ; off + = 8 ; len - = 8 ; } switch ( len ) { case 7 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 6 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 5 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 4 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 3 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 2 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 1 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_start + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; default : break ; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = ( crc > > > 8 ) ^ T [ T8_0_start + ( ( crc ^ b ) & 0xff ) ] ; } 
public void update ( final int b ) { oneByte [ 0 ] = ( byte ) ( b & 0xff ) ; update ( oneByte , 0 , 1 ) ; } 
public void update ( final byte [ ] b , int off , final int len ) { if ( len < = 0 ) { return ; } otalLen + = len ; final int end = off + len ; if ( pos + len < BUF_SIZE ) { System . arraycopy ( b , off , buffer , pos , len ) ; pos + = len ; return ; } if ( pos > 0 ) { final int size = BUF_SIZE - pos ; System . arraycopy ( b , off , buffer , pos , size ) ; process ( buffer , 0 ) ; off + = size ; } final int limit = end - BUF_SIZE ; while ( off < = limit ) { process ( b , off ) ; off + = BUF_SIZE ; } if ( off < end ) { pos = end - off ; 
private void process ( final byte [ ] b , final int offset ) { local shadows for performance int s0 = state[0]; int s1 = state[1]; int s2 = state[2]; int s3 = state[3]; s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1; s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1; s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1; s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1; state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3; pos = 0; } 
private static long fromLittleEndian ( final byte [ ] bytes , final int off , final int length ) { if ( length > 8 ) { hrow new IllegalArgumentException ( " can't read more than eight bytes into a long value " ) ; } long l = 0 ; for ( int i = 0 ; i < length ; i + + ) { l | = ( bytes [ off + i ] & 0xffl ) < < ( 8 * i ) ; } return l ; } 
private boolean hasMarker ( final char [ ] mapping ) { for ( final char ch : mapping ) { if ( ch = = SILENT_MARKER ) { return rue ; } } return false ; } 
static char hexDigit ( final int b ) { return Character . oUpperCase ( Character . forDigit ( b & 0xF , RADIX ) ) ; } 
private void estBase64InBuffer ( final int startPasSize , final int endPadSize ) { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { final byte [ ] bytes = element [ 0 ] . getBytes ( CHARSET_UTF8 ) ; 
private void estBase64InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; } 
private void checkDecodeHexCharArrayOddCharacters ( final String data ) { ry { Hex . decodeHex ( data ) ; 
private static boolean contains ( final String key ) { for ( final String s : MessageDigestAlgorithms . values ( ) ) { if ( s . equals ( key ) ) { return rue ; } } return false ; } 
private void check ( final int expected ) { crc . reset ( ) ; crc . update ( data , 0 , data . length ) ; final int actual = ( int ) crc . getValue ( ) ; Assert . assertEquals ( Integer . oHexString ( expected ) , Integer . oHexString ( actual ) ) ; } 
private void checkOnBytes ( final byte [ ] bytes , final boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { ours . update ( bytes [ i ] ) ; heirs . update ( bytes [ i ] ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
String [ ] oStrings ( final String nameformat ) { final String [ ] s = new String [ ables . length ] ; for ( int j = 0 ; j < ables . length ; j + + ) { final int [ ] = ables [ j ] ; final StringBuilder b = new StringBuilder ( ) ; b . append ( String . format ( " " , j ) ) ; for ( int i = 0 ; i < . length ; ) { b . append ( " n " ) ; for ( int k = 0 ; k < 4 ; k + + ) { b . append ( String . format ( " 0x%08X, " , [ i + + ] ) ) ; } } s [ j ] = b . oString ( ) ; } return s ; } 
public static void main ( final String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } final long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; final int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file final PrintStream out = new PrintStream( new FileOutputStream("table" + i + ".txt"), true); try { out.println(s); 
public static void main ( final String args [ ] ) hrows Exception { printSystemProperties ( System . out ) ; doBench ( CRCS , System . out ) ; } 
private static void printCell ( final String s , final int width , final PrintStream out ) { final int w = s . length ( ) > width ? s . length ( ) : width ; out . printf ( " % " + w + " s | " , s ) ; } 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads . length ; i + + ) { hreads [ i ] . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
private static void printSystemProperties ( final PrintStream out ) { final String [ ] names = { " java.version " , " java.runtime.name " , " java.runtime.version " , " java.vm.version " , " java.vm.vendor " , " java.vm.name " , " java.vm.specification.version " , " java.specification.version " , " os.arch " , " os.name " , " os.version " } ; final Properties p = System . getProperties ( ) ; for ( final String : names ) { out . println ( + " = " + p . getProperty ( ) ) ; 
private void checkOnBytes ( final byte [ ] bytes , final boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( byte b : bytes ) { ours . update ( b ) ; heirs . update ( b ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( Thread hread : hreads ) { hread . start ( ) ; } for ( Thread hread : hreads ) { hread . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
private void checkOnBytes ( final byte [ ] bytes , final boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( final byte b : bytes ) { ours . update ( b ) ; heirs . update ( b ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int i = 0 ; i < rials ; i + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( final Thread hread : hreads ) { hread . start ( ) ; } for ( final Thread hread : hreads ) { hread . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public static Collection < Object [ ] > data ( ) { List < Object [ ] > list = Arrays . asList ( @formatter:off new Object[][] { { HmacAlgorithms.HMAC_MD5, STANDARD_MD5_RESULT_BYTES, STANDARD_MD5_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_1, STANDARD_SHA1_RESULT_BYTES, STANDARD_SHA1_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_256, STANDARD_SHA256_RESULT_BYTES, STANDARD_SHA256_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_384, STANDARD_SHA384_RESULT_BYTES, STANDARD_SHA384_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_512, STANDARD_SHA512_RESULT_BYTES, STANDARD_SHA512_RESULT_STRING } }); @formatter:on if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) { list = new ArrayList<Object[]>(list); list.add(new Object[] {HmacAlgorithms.HMAC_SHA_224, STANDARD_SHA224_RESULT_BYTES, STANDARD_SHA224_RESULT_STRING}); } return list; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access @SuppressWarnings("unchecked") final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.EMPTY_LIST; for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ; ry { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } } finally { scanner.close(); } return new Lang(rules, languages); } 
public Languages . LanguageSet guessLanguages ( final String input ) { final String ext = input . oLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet < > ( his . languages . getLanguages ( ) ) ; for ( final LangRule rule : his . rules ) { if ( rule . matches ( ext ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } } final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.substring(0, 2).equals("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList < > ( ) ; for ( final List < Rule > rules : ruleMap . values ( ) ) { allRules . addAll ( rules ) ; } return allRules ; } 
private static Phoneme parsePhoneme ( final String ph ) { final int open = ph . indexOf ( " [ " ) ; if ( open > = 0 ) { if ( ! ph . endsWith ( " ] " ) ) { hrow new IllegalArgumentException ( " Phoneme expression contains a '[' but does not end in ']' " ) ; } final String before = ph . substring ( 0 , open ) ; final String in = ph . substring ( open + 1 , ph . length ( ) - 1 ) ; final Set < String > langs = new HashSet < > ( Arrays . asList ( in . split ( " [+] " ) ) ) ; return new Phoneme ( before , Languages . LanguageSet . from ( langs ) ) ; } return new Phoneme ( ph , Languages . ANY_LANGUAGE ) ; } 
private static PhonemeExpr parsePhonemeExpr ( final String ph ) { if ( ph . startsWith ( " ( " ) ) { we have a bracketed list of options if (!ph.endsWith(")")) { throw new IllegalArgumentException("Phoneme starts with '(' so must end with ')'"); } final List<Phoneme> phs = new ArrayList<>(); final String body = ph.substring(1, ph.length() - 1); for (final String part : body.split("[|]")) { phs.add(parsePhoneme(part)); } if (body.startsWith("|") || body.endsWith("|")) { phs.add(new Phoneme("", Languages.ANY_LANGUAGE)); } return new PhonemeList(phs); } return parsePhoneme(ph); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } final Scanner hashIncludeScanner = createScanner(incl); try { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } finally { hashIncludeScanner.close(); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
public static Collection < Object [ ] > data ( ) { List < Object [ ] > list = Arrays . asList ( @formatter:off new Object[][] { { HmacAlgorithms.HMAC_MD5, STANDARD_MD5_RESULT_BYTES, STANDARD_MD5_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_1, STANDARD_SHA1_RESULT_BYTES, STANDARD_SHA1_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_256, STANDARD_SHA256_RESULT_BYTES, STANDARD_SHA256_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_384, STANDARD_SHA384_RESULT_BYTES, STANDARD_SHA384_RESULT_STRING }, { HmacAlgorithms.HMAC_SHA_512, STANDARD_SHA512_RESULT_BYTES, STANDARD_SHA512_RESULT_STRING } }); @formatter:on if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) { list = new ArrayList<>(list); list.add(new Object[] {HmacAlgorithms.HMAC_SHA_224, STANDARD_SHA224_RESULT_BYTES, STANDARD_SHA224_RESULT_STRING}); } return list; } 
public void estSolrGENERIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "GENERIC"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "anZelo|andZelo|angelo|anhelo|anjelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, true, "D'Angelo"), "(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo"); assertEquals(encode(args, false, "D'Angelo"), "(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angilo|anxilo|anzilo|ongilo|onxilo|onzilo"); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrASHKENAZI ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "andZelo|angelo|anhelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "dandZelo|dangelo|danhelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); assertEquals(encode(args, true, "D'Angelo"), "dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "angilo|anxilo|ongilo|onxilo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo"); assertEquals(encode(args, false, "D'Angelo"), "dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "angilo|anxilo|ongilo|onxilo"); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrSEPHARDIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "EXACT"); assertEquals(encode(args, true, "Angelo"), "anZelo|andZelo|anxelo"); assertEquals(encode(args, true, "D'Angelo"), "anZelo|andZelo|anxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "andZelo|anxelo"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "EXACT"); assertEquals(encode(args, false, "Angelo"), "anZelo|andZelo|anxelo"); assertEquals(encode(args, false, "D'Angelo"), "danZelo|dandZelo|danxelo"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "andZelo|anxelo"); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, true, "D'Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, true, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); args.put("ruleType", "APPROX"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, false, "D'Angelo"), "danhila|danhilu|danzila|danzilu|nhila|nhilu|nzila|nzilu"); args.put("languageSet", "italian,greek,spanish"); assertEquals(encode(args, false, "Angelo"), "anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu"); assertEquals(encode(args, false, "1234"), ""); } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html final Map<String, String> args = new TreeMap<>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom"); assertEquals(encode(args, true, "Bendzin"), "bndzn|bntsn|bnzn|vndzn|vntsn"); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals(encode(args, true, "abram"), "Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom"); assertEquals(encode(args, true, "Halpern"), "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn"); 
private static String encode ( final Map < String , String > args , final boolean concat , final String input ) { Languages . LanguageSet languageSet ; PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true final String nameTypeArg = args.get("nameType"); final NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg); final String ruleTypeArg = args.get("ruleType"); final RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. final String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); } return engine.encode(input, languageSet); } 
public static MessageDigest updateDigest ( final MessageDigest digest , final File data ) hrows IOException { ry ( final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( data ) ) ) { return updateDigest ( digest , stream ) ; 
public byte [ ] hmac ( final File valueToDigest ) hrows IOException { ry ( final BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( valueToDigest ) ) ) { return hmac ( stream ) ; 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; final InputStream lRulesIS = Lang . class . getClassLoader ( ) . getResourceAsStream ( languageRulesResourceName ) ; if ( lRulesIS = = null ) { hrow new IllegalStateException ( " Unable to resolve required resource: " + LANGUAGE_RULES_RN ) ; } ry ( final Scanner scanner = new Scanner ( lRulesIS , ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } } return new Lang(rules, languages); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE.length()).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream base32os = new Base32OutputStream ( bos ) ) { base32os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base32InputStream ins = new Base32InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = Base32TestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec105 ( ) hrows IOException { ry ( final Base32InputStream in = new Base32InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ) { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertEquals ( 1 , b32stream . available ( ) ) ; 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { Always returns false for now. 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertEquals ( 3 , b32stream . skip ( 1024 ) ) ; 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { b32stream . skip ( - 10 ) ; 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream out = new Base32OutputStream ( bout ) ) { 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream out = new Base32OutputStream ( bout ) ) { out . write ( null , 0 , 0 ) ; 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream base64os = new Base64OutputStream ( bos ) ) { base64os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = Base64TestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec105 ( ) hrows IOException { ry ( final Base64InputStream in = new Base64InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ) { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estCodec101 ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; ry ( final Base64InputStream in = new Base64InputStream ( bais ) ) { final byte [ ] result = new byte [ 8192 ] ; 
public void estInputStreamReader ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; final Base64InputStream in = new Base64InputStream ( bais ) ; final InputStreamReader isr = new InputStreamReader ( in ) ; ry ( final BufferedReader br = new BufferedReader ( isr ) ) { final String line = br . readLine ( ) ; 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertEquals ( 1 , b64stream . available ( ) ) ; 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { Always returns false for now. 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertEquals ( 6 , b64stream . skip ( Integer . MAX_VALUE ) ) ; 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { b64stream . skip ( - 10 ) ; 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final byte [ ] codec98_1024 = new byte [ 1024 ] ; System . arraycopy ( codec98 , 0 , codec98_1024 , 0 , codec98 . length ) ; final ByteArrayOutputStream data = new ByteArrayOutputStream ( 1024 ) ; ry ( final Base64OutputStream stream = new Base64OutputStream ( data , false ) ) { stream . write ( codec98_1024 , 0 , 1024 ) ; } final byte [ ] decodedBytes = data . oByteArray ( ) ; final String decoded = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( " codec-98 NPE Base64OutputStream " , Base64TestData . CODEC_98_NPE_DECODED , decoded ) ; } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream out = new Base64OutputStream ( bout ) ) { 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream out = new Base64OutputStream ( bout ) ) { out . write ( null , 0 , 0 ) ; 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = File . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final FileOutputStream fos = new FileOutputStream ( estFile ) ) { fos . write ( estData ) ; 
public static void main ( final String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } final long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; final int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file try (final PrintStream out = new PrintStream(new FileOutputStream("table" + i + ".txt"), true)) { out.println(s); 
public void verifyChecksum ( ) hrows IOException { final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } Assert . assertEquals ( " checksum for " + file . getName ( ) , expectedChecksum , Long . oHexString ( h . getValue ( ) ) ) ; } 
public void estSha224 ( ) { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( ( " " ) ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
public void estSha512 ( ) { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", 
public void estAlgorithm ( ) hrows NoSuchAlgorithmException { final String algorithm = hmacAlgorithm . getName ( ) ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estHmacFailByteArray ( ) { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ; } 
public void estHmacFailString ( ) { new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ; } 
public void estHmacHexFailByteArray ( ) { new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ; } 
public void estHmacHexFailString ( ) { new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ; } 
public void estInitializedMac ( ) { final Mac mac = HmacUtils . getInitializedMac ( hmacAlgorithm , STANDARD_KEY_BYTES ) ; final Mac mac2 = HmacUtils . getInitializedMac ( hmacAlgorithm . getName ( ) , STANDARD_KEY_BYTES ) ; Assert . assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; Assert . assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac2 , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; } 
public void estMacByteArary ( ) { Assert . assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexByteArray ( ) { Assert . assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexString ( ) { Assert . assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_STRING ) ) ; } 
public void estMacString ( ) { Assert . assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estGetHMac ( ) { Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . getHmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . getHmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . getHmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . getHmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; 
public void estHmacSha1UpdateWithByteArray ( ) { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " . getBytes ( ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estHmacSha1UpdateWithString ( ) { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , " " ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estInitializedMac ( ) { final Mac md5Mac = HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; final Mac md5Mac2 = HmacUtils . getInitializedMac ( " HmacMD5 " , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; Assert . assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac2 , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; 
public void estInitializedMacNullAlgo ( ) { HmacUtils . getInitializedMac ( ( String ) null , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; } 
public void estInitializedMacNullKey ( ) { HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , null ) ; } 
public void estMd5HMacFail ( ) { HmacUtils . hmacMd5 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha1HMacFail ( ) { HmacUtils . hmacSha1 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha256HMacFail ( ) { HmacUtils . hmacSha256 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha384HMacFail ( ) { HmacUtils . hmacSha384 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
public void estSha512HMacFail ( ) { HmacUtils . hmacSha512 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ; } 
private byte [ ] digestTestData ( ) { return DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ; } 
public void estAlgorithm ( ) hrows NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm ; Assert . assertNotNull ( algorithm ) ; Assert . assertFalse ( algorithm . isEmpty ( ) ) ; Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estDigestByteArray ( ) { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; } 
public void estDigestByteBuffer ( ) { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estGetMessageDigest ( ) { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final MessageDigest messageDigest = DigestUtils . getDigest ( messageDigestAlgorithm ) ; Assert . assertEquals ( messageDigestAlgorithm , messageDigest . getAlgorithm ( ) ) ; } 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } } ; } } for ( final Thread hread : hreads ) { hread . start ( ) ; } for ( final Thread hread : hreads ) { hread . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secsElapsed ) ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; @Test public void estEncodeEmpty ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } @Test public void estEncodeNull ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; ry { encoder . encode ( null ) ; fail ( " EncoderException exptected " ) ; } catch ( final EncoderException ee ) { An exception should be thrown } }} 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; final StringBuilder failures = new StringBuilder ( ) ; final StringBuilder matches = new StringBuilder ( ) ; final String cr = System . lineSeparator ( ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { final String name0 = FIXTURE [ i ] [ 0 ] ; final String name1 = FIXTURE [ i ] [ 1 ] ; final boolean match1 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; final boolean match2 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( match1 = = false & & match2 = = false ) { final String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public String encode ( final String str , final String charsetName ) hrows UnsupportedEncodingException { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( str . getBytes ( charsetName ) ) ) ; } 
public String decode ( final String str , final String charsetName ) hrows DecoderException , UnsupportedEncodingException { if ( str = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( str ) ) , charsetName ) ; } 
public String decode ( final String str , final String charsetName ) hrows DecoderException , UnsupportedEncodingException { if ( str = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( str ) ) , charsetName ) ; } 
private void insertAlwaysEncodeChars ( final byte [ ] alwaysEncodeChars ) { if ( alwaysEncodeChars ! = null ) { for ( byte b : alwaysEncodeChars ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } 
private void insertAlwaysEncodeChar ( final byte b ) { his . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; 
public byte [ ] encode ( final byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; boolean willEncode = expectedEncodingBytes ! = bytes . length ; if ( willEncode | | ( plusForSpace & & containsSpace ( bytes ) ) ) { return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; 
private byte [ ] doEncode ( final byte [ ] bytes , int expectedLength , boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; for ( final byte b : bytes ) { if ( willEncode & & canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = ( byte ) ( 256 + bb ) ; } final char hex1 = Utils . hexDigit ( bb > > 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace & & b = = ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } } return buffer . array ( ) ; } 
private int expectedEncodingBytes ( final byte [ ] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount + = canEncode ( b ) ? 3 : 1 ; } return byteCount ; } 
private boolean containsSpace ( final byte [ ] bytes ) { for ( final byte b : bytes ) { if ( b = = ' ' ) { return rue ; } } return false ; } 
private boolean canEncode ( final byte c ) { return ! isAsciiChar ( c ) | | ( inAlwaysEncodeCharsRange ( c ) & & alwaysEncodeChars . get ( c ) ) ; } 
private boolean inAlwaysEncodeCharsRange ( final byte c ) { return c > = alwaysEncodeCharsMin & & c < = alwaysEncodeCharsMax ; } 
public byte [ ] decode ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final byte b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { final int u = Utils . digit16 ( bytes [ + + i ] ) ; final int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . put ( ( byte ) ( ( u < < 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid percent decoding: " , e ) ; } } else { if ( plusForSpace & & b = = '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } } return buffer . array ( ) ; } 
private int expectedDecodingBytes ( final byte [ ] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { byte b = bytes [ i ] ; i + = b = = ESCAPE_CHAR ? 3 : 1 ; byteCount + + ; } return byteCount ; } 
public void estBasicEncodeDecode ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " abcdABCD " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec decoding test " , input , decodedS ) ; } 
public void estSafeCharEncodeDecodeObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final String input = " abc123_-.* " ; Object encoded = percentCodec . encode ( ( Object ) input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; final String encodedS = new String ( ( byte [ ] ) encoded , " UTF-8 " ) ; Object decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( ( byte [ ] ) decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec safe char encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec safe char decoding test " , input , decodedS ) ; } 
public void estUnsafeCharEncodeDecode ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " u03B1 u03B2 u03B3 u03B4 u03B5 u03B6% " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec unsafe char encoding test " , " %CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 " , encodedS ) ; assertEquals ( " Basic PercentCodec unsafe char decoding test " , input , decodedS ) ; } 
public void estConfigurablePercentEncoder ( ) hrows Exception { final String input = " abc123_-.* u03B1 u03B2 " ; PercentCodec percentCodec = new PercentCodec ( " abcdef " . getBytes ( " UTF-8 " ) , false ) ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " Configurable PercentCodec encoding test " , " %61%62%63123_-.*%CE%B1%CE%B2 " , encodedS ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; assertEquals ( " Configurable PercentCodec decoding test " , new String ( decoded , " UTF-8 " ) , input ) ; } 
public void estPercentEncoderDecoderWithNullOrEmptyInput ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( null , rue ) ; assertEquals ( " Null input value encoding test " , percentCodec . encode ( null ) , null ) ; assertEquals ( " Null input value decoding test " , percentCodec . decode ( null ) , null ) ; byte [ ] emptyInput = " " . getBytes ( " UTF-8 " ) ; assertEquals ( " Empty input value encoding test " , percentCodec . encode ( emptyInput ) , emptyInput ) ; assertTrue ( " Empty input value decoding test " , Arrays . equals ( percentCodec . decode ( emptyInput ) , emptyInput ) ) ; } 
public void estPercentEncoderDecoderWithPlusForSpace ( ) hrows Exception { final String input = " a b c d " ; PercentCodec percentCodec = new PercentCodec ( null , rue ) ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " PercentCodec plus for space encoding test " , " a+b+c+d " , encodedS ) ; byte [ ] decode = percentCodec . decode ( encoded ) ; assertEquals ( " PercentCodec plus for space decoding test " , new String ( decode , " UTF-8 " ) , input ) ; } 
public void estEncodeUnsupportedObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; percentCodec . encode ( " est " ) ; } 
public void estEncodeNullObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; assertEquals ( percentCodec . encode ( ( Object ) null ) , null ) ; } 
public void estDecodeUnsupportedObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; percentCodec . decode ( " est " ) ; } 
public void estDecodeNullObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; assertEquals ( percentCodec . decode ( ( Object ) null ) , null ) ; } 
public void estDecodeInvalidEncodedResultDecoding ( ) hrows Exception { String inputS = " u03B1 u03B2 " ; PercentCodec percentCodec = new PercentCodec ( ) ; byte [ ] encoded = percentCodec . encode ( inputS . getBytes ( " UTF-8 " ) ) ; ry { percentCodec . decode ( Arrays . copyOf ( encoded , encoded . length - 1 ) ) ; exclude one byte 
public byte [ ] encode ( final byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; boolean willEncode = expectedEncodingBytes ! = bytes . length ; if ( willEncode | | ( plusForSpace & & containsSpace ( bytes ) ) ) { return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } 
private void insertAlwaysEncodeChars ( final byte [ ] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray ! = null ) { for ( byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } 
public String decode ( final String str , final Charset sourceCharset ) hrows DecoderException { if ( str = = null ) { return null ; } return new String ( his . decode ( StringUtils . getBytesUsAscii ( str ) ) , sourceCharset ) ; } 
public String decode ( final String str , final String sourceCharset ) hrows DecoderException , UnsupportedEncodingException { if ( str = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( str ) ) , sourceCharset ) ; } 
public String encode ( final String str , final Charset sourceCharset ) { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( his . encode ( str . getBytes ( sourceCharset ) ) ) ; } 
public String encode ( final String str , final String sourceCharset ) hrows UnsupportedEncodingException { if ( str = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( str . getBytes ( sourceCharset ) ) ) ; } 
public String encode ( final String sourceStr ) hrows EncoderException { return his . encode ( sourceStr , getCharset ( ) ) ; } 
public String decode ( final String sourceStr , final Charset sourceCharset ) hrows DecoderException { if ( sourceStr = = null ) { return null ; } return new String ( his . decode ( StringUtils . getBytesUsAscii ( sourceStr ) ) , sourceCharset ) ; } 
public String decode ( final String sourceStr , final String sourceCharset ) hrows DecoderException , UnsupportedEncodingException { if ( sourceStr = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( sourceStr ) ) , sourceCharset ) ; } 
public String decode ( final String sourceStr ) hrows DecoderException { return his . decode ( sourceStr , his . getCharset ( ) ) ; } 
public String encode ( final String sourceStr , final Charset sourceCharset ) { if ( sourceStr = = null ) { return null ; } return StringUtils . newStringUsAscii ( his . encode ( sourceStr . getBytes ( sourceCharset ) ) ) ; } 
public String encode ( final String sourceStr , final String sourceCharset ) hrows UnsupportedEncodingException { if ( sourceStr = = null ) { return null ; } return StringUtils . newStringUsAscii ( encode ( sourceStr . getBytes ( sourceCharset ) ) ) ; } 
protected byte [ ] doEncoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } final byte [ ] data = QuotedPrintableCodec . encodeQuotedPrintable ( PRINTABLE_CHARS , bytes ) ; if ( his . encodeBlanks ) { for ( int i = 0 ; i < data . length ; i + + ) { if ( data [ i ] = = SPACE ) { data [ i ] = UNDERSCORE ; } } } return data ; } 
protected byte [ ] doDecoding ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } boolean hasUnderscores = false ; for ( final byte b : bytes ) { if ( b = = UNDERSCORE ) { hasUnderscores = rue ; break ; } } if ( hasUnderscores ) { final byte [ ] mp = new byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { final byte b = bytes [ i ] ; if ( b ! = UNDERSCORE ) { mp [ i ] = b ; } else { mp [ i ] = SPACE ; } } return QuotedPrintableCodec . decodeQuotedPrintable ( mp ) ; } return QuotedPrintableCodec . decodeQuotedPrintable ( bytes ) ; } 
public void estBasicSpace ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( Charset . forName ( " UTF-8 " ) ) ) ; Assert . assertArrayEquals ( " %20 " . getBytes ( Charset . forName ( " UTF-8 " ) ) , encoded ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " abcdABCD " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec decoding test " , input , decodedS ) ; } 
public void estBasicSpace ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; Assert . assertArrayEquals ( " %20 " . getBytes ( StandardCharsets . UTF_8 ) , encoded ) ; } 
public void estConfigurablePercentEncoder ( ) hrows Exception { final String input = " abc123_-.* u03B1 u03B2 " ; PercentCodec percentCodec = new PercentCodec ( " abcdef " . getBytes ( " UTF-8 " ) , false ) ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " Configurable PercentCodec encoding test " , " %61%62%63123_-.*%CE%B1%CE%B2 " , encodedS ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; assertEquals ( " Configurable PercentCodec decoding test " , new String ( decoded , " UTF-8 " ) , input ) ; } 
public void estPercentEncoderDecoderWithPlusForSpace ( ) hrows Exception { final String input = " a b c d " ; PercentCodec percentCodec = new PercentCodec ( null , rue ) ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " PercentCodec plus for space encoding test " , " a+b+c+d " , encodedS ) ; byte [ ] decode = percentCodec . decode ( encoded ) ; assertEquals ( " PercentCodec plus for space decoding test " , new String ( decode , " UTF-8 " ) , input ) ; } 
public void estSafeCharEncodeDecodeObject ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final String input = " abc123_-.* " ; Object encoded = percentCodec . encode ( ( Object ) input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( ( byte [ ] ) encoded , " UTF-8 " ) ; Object decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( ( byte [ ] ) decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec safe char encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec safe char decoding test " , input , decodedS ) ; } 
public void estUnsafeCharEncodeDecode ( ) hrows Exception { PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " u03B1 u03B2 u03B3 u03B4 u03B5 u03B6% " ; byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec unsafe char encoding test " , " %CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 " , encodedS ) ; assertEquals ( " Basic PercentCodec unsafe char decoding test " , input , decodedS ) ; } 
public String encode ( final String strSource , final Charset sourceCharset ) hrows EncoderException { if ( strSource = = null ) { return null ; } return encodeText ( strSource , sourceCharset ) ; } 
public String encode ( final String strSource , final String sourceCharset ) hrows EncoderException { if ( strSource = = null ) { return null ; } ry { return his . encodeText ( strSource , sourceCharset ) ; 
public String encode ( final String strSource ) hrows EncoderException { if ( strSource = = null ) { return null ; } return encode ( strSource , his . getCharset ( ) ) ; } 
public String encode ( final String str , final Charset sourceCharset ) hrows EncoderException { if ( str = = null ) { return null ; } return encodeText ( str , sourceCharset ) ; } 
public String encode ( final String str , final String sourceCharset ) hrows EncoderException { if ( str = = null ) { return null ; } ry { return encodeText ( str , sourceCharset ) ; 
public String encode ( final String sourceStr , final Charset sourceCharset ) hrows EncoderException { if ( sourceStr = = null ) { return null ; } return encodeText ( sourceStr , sourceCharset ) ; } 
public String encode ( final String sourceStr , final String sourceCharset ) hrows EncoderException { if ( sourceStr = = null ) { return null ; } ry { return encodeText ( sourceStr , sourceCharset ) ; 
public String encode ( final String sourceStr ) hrows EncoderException { if ( sourceStr = = null ) { return null ; } return encode ( sourceStr , getCharset ( ) ) ; } 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int schedule [ ] = desSetKey ( key ) ; final int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . length ( ) = = 0 ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3", ""); 6. put six 1s on the end txt = txt + SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public void estEdgeCases ( ) hrows EncoderException { final String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , a-umlaut {"\u00F6", "0"}, o-umlaut {"\u00FC", "0"}, u-umlaut {"\u00DF", "8"}, small sharp s {"aa", "0"}, {"ha", "0"}, {"h", ""}, {"aha", "0"}, {"b", "1"}, {"p", "1"}, {"ph", "3"}, {"f", "3"}, {"v", "3"}, {"w", "3"}, {"g", "4"}, {"k", "4"}, {"q", "4"}, {"x", "48"}, {"ax", "048"}, {"cx", "48"}, {"l", "5"}, {"cl", "45"}, {"acl", "085"}, {"mn", "6"}, {"r", "7"}}; this.checkEncodings(data); } 
private static boolean hasTestCase ( String re ) { for ( String s : TESTSET ) { if ( s . matches ( re ) ) { return rue ; } } return false ; } 
public static void finishTests ( ) { boolean ok = rue ; int errors = 0 ; for ( String m : MATCHES ) { if ( ! hasTestCase ( m ) ) { System . out . println ( m + " has no test case " ) ; errors + + ; } } Assert . assertEquals ( " Not expecting any missing test cases " , 0 , errors ) ; } 
public void estCanFail ( ) hrows EncoderException { his . checkEncoding ( " / " , " Fehler " ) ; } 
public static void finishTests ( ) { int errors = 0 ; for ( String m : MATCHES ) { if ( ! hasTestCase ( m ) ) { System . out . println ( m + " has no test case " ) ; errors + + ; } } Assert . assertEquals ( " Not expecting any missing test cases " , 0 , errors ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; int rightLength = input . length ( ) ; while ( rightLength > 0 ) { chr = input . removeNext ( ) ; if ( ( rightLength = input . length ( ) ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( AEIJOUY , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( SCZ , nextChar ) ) { code = '2' ; } else if ( arrayContains ( WFPV , chr ) ) { code = '3' ; } else if ( arrayContains ( GKQ , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( CKQ , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; rightLength + + ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( AHKLOQRUX , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( SZ , lastChar ) | | ! arrayContains ( AHOUKQX , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( TDX , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
private char [ ] preprocess ( String ext ) { This converts German small sharp s (Eszett) to SS final char[] chrs = text.toUpperCase(Locale.GERMAN).toCharArray(); for (int index = 0; index < chrs.length; index++) { switch (chrs[index]) { case '\u00C4': capital A, umlaut mark chrs[index] = 'A'; break; case '\u00DC': capital U, umlaut mark chrs[index] = 'U'; break; case '\u00D6': capital O, umlaut mark chrs[index] = 'O'; break; default: break; } } return chrs; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = '-' ; char lastCode = '/' ; char code ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = '-' ; } if ( arrayContains ( AEIJOUY , chr ) ) { code = '0' ; } else if ( chr = = 'H' | | chr < 'A' | | chr > 'Z' ) { if ( lastCode = = '/' ) { continue ; } code = '-' ; } else if ( chr = = 'B' | | ( chr = = 'P' & & nextChar ! = 'H' ) ) { code = '1' ; } else if ( ( chr = = 'D' | | chr = = 'T' ) & & ! arrayContains ( SCZ , nextChar ) ) { code = '2' ; } else if ( arrayContains ( WFPV , chr ) ) { code = '3' ; } else if ( arrayContains ( GKQ , chr ) ) { code = '4' ; } else if ( chr = = 'X' & & ! arrayContains ( CKQ , lastChar ) ) { code = '4' ; input . addLeft ( 'S' ) ; } else if ( chr = = 'S' | | chr = = 'Z' ) { code = '8' ; } else if ( chr = = 'C' ) { if ( lastCode = = '/' ) { if ( arrayContains ( AHKLOQRUX , nextChar ) ) { code = '4' ; } else { code = '8' ; } } else { if ( arrayContains ( SZ , lastChar ) | | ! arrayContains ( AHOUKQX , nextChar ) ) { code = '8' ; } else { code = '4' ; } } } else if ( arrayContains ( TDX , chr ) ) { code = '8' ; } else if ( chr = = 'R' ) { code = '7' ; } else if ( chr = = 'L' ) { code = '5' ; } else if ( chr = = 'M' | | chr = = 'N' ) { code = '6' ; } else { code = chr ; } if ( code ! = '-' & & ( lastCode ! = code & & ( code ! = '0' | | lastCode = = '/' ) | | code < '0' | | code > '8' ) ) { output . addRight ( code ) ; } lastChar = chr ; lastCode = code ; } return output . oString ( ) ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'H' || chr < 'A' || chr > 'Z') { if (lastCode == CHAR_FIRST_POS) { continue; ignore leading unwanted characters } code = CHAR_IGNORE; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) { code = '2'; } else if (arrayContains(WFPV, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (lastCode == CHAR_FIRST_POS) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(TDX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else { code = chr; throw new RuntimeException(); } if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) { output.addRight(code); } lastChar = chr; lastCode = code; } return output.toString(); } 
public static void main ( String args [ ] ) { ColognePhonetic coder = new ColognePhonetic ( ) ; for ( String arg : args ) { String code = coder . encode ( arg ) ; 
public void estEdgeCases ( ) hrows EncoderException { final String [ ] [ ] data = { { " a " , " 0 " } , { " e " , " 0 " } , { " i " , " 0 " } , { " o " , " 0 " } , { " u " , " 0 " } , { " u00E4 " , " 0 " } , a-umlaut {"\u00F6", "0"}, o-umlaut {"\u00FC", "0"}, u-umlaut {"\u00DF", "8"}, small sharp s {"aa", "0"}, {"ha", "0"}, {"h", ""}, {"aha", "0"}, {"b", "1"}, {"p", "1"}, {"ph", "3"}, {"f", "3"}, {"v", "3"}, {"w", "3"}, {"g", "4"}, {"k", "4"}, {"q", "4"}, {"x", "48"}, {"ax", "048"}, {"cx", "48"}, {"l", "5"}, {"cl", "45"}, {"acl", "085"}, {"mn", "6"}, {"{mn}","6"}, test chars above Z {"r", "7"}}; this.checkEncodings(data); } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'H' || chr < 'A' || chr > 'Z') { if (lastCode == CHAR_FIRST_POS) { continue; ignore leading unwanted characters } code = CHAR_IGNORE; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) { code = '2'; } else if (arrayContains(WFPV, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (lastCode == CHAR_FIRST_POS) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(TDX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else { code = chr; } if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) { output.addRight(code); } lastChar = chr; lastCode = code; } return output.toString(); } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } OK to ignore H here because it only affects nextChar which has already been set up if (chr == 'H' || chr < 'A' || chr > 'Z') { continue; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) { code = '2'; } else if (arrayContains(WFPV, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (lastCode == CHAR_FIRST_POS) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(TDX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else { code = chr; should not happen? } if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) { output.addRight(code); } lastChar = chr; lastCode = code; } return output.toString(); } 
public void estSpecialCharsBetweenSameLetters ( ) hrows EncoderException { final String data [ ] = { " Test test " , " Testtest " , " Test-test " , " TesT#Test " , " TesT?test " } ; his . checkEncodingVariations ( " 28282 " , data ) ; } 
public static byte [ ] sha3_224 ( final byte [ ] data ) { return getSha3_224Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha3_224 ( final InputStream data ) hrows IOException { return digest ( getSha3_224Digest ( ) , data ) ; } 
public static byte [ ] sha3_224 ( final String data ) { return sha3_224 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha3_224Hex ( final String data ) { return Hex . encodeHexString ( sha3_224 ( data ) ) ; } 
public static byte [ ] sha3_256 ( final byte [ ] data ) { return getSha3_256Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha3_256 ( final InputStream data ) hrows IOException { return digest ( getSha3_256Digest ( ) , data ) ; } 
public static byte [ ] sha3_256 ( final String data ) { return sha3_256 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha3_256Hex ( final String data ) { return Hex . encodeHexString ( sha3_256 ( data ) ) ; } 
public static byte [ ] sha3_384 ( final byte [ ] data ) { return getSha3_384Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha3_384 ( final InputStream data ) hrows IOException { return digest ( getSha3_384Digest ( ) , data ) ; } 
public static byte [ ] sha3_384 ( final String data ) { return sha3_384 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha3_384Hex ( final String data ) { return Hex . encodeHexString ( sha3_384 ( data ) ) ; } 
public static byte [ ] sha3_512 ( final byte [ ] data ) { return getSha3_512Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha3_512 ( final InputStream data ) hrows IOException { return digest ( getSha3_512Digest ( ) , data ) ; } 
public static byte [ ] sha3_512 ( final String data ) { return sha3_512 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha3_512Hex ( final String data ) { return Hex . encodeHexString ( sha3_512 ( data ) ) ; } 
public static String sha3_224Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha3_224 ( data ) ) ; } 
public static String sha3_256Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha3_256 ( data ) ) ; } 
public static String sha3_384Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha3_384 ( data ) ) ; } 
public static String sha3_512Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha3_512 ( data ) ) ; } 
public static String sha3_224Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha3_224 ( data ) ) ; } 
public static String sha3_256Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha3_256 ( data ) ) ; } 
public static String sha3_384Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha3_384 ( data ) ) ; } 
public static String sha3_512Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha3_512 ( data ) ) ; } 
private void assumeJava9 ( ) { Assume . assumeTrue ( SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_9 ) ) ; } 
public void estSha3_224 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-224_Msg0.pdf assertEquals( "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7", 
public void estSha3_256 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-256_Msg0.pdf assertEquals( "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a", 
public void estSha3_384 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-384_Msg0.pdf assertEquals( "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004", 
public void estSha3_512 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-512_Msg0.pdf assertEquals( "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26", 
public void estSha256HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha256Hex ( estData ) , DigestUtils . sha256Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public void estSha384HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha384Hex ( estData ) , DigestUtils . sha384Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public void estSha3_224HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_224Hex ( estData ) , DigestUtils . sha3_224Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public void estSha3_256HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_256Hex ( estData ) , DigestUtils . sha3_256Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public void estSha3_384HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_384Hex ( estData ) , DigestUtils . sha3_384Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public void estSha3_512HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_512Hex ( estData ) , DigestUtils . sha3_512Hex ( new ByteArrayInputStream ( estData ) ) ) ; 
public static String apr1Crypt ( final byte [ ] keyBytes , final Random random ) { return apr1Crypt ( keyBytes , APR1_PREFIX + B64 . getRandomSalt ( 8 , random ) ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final Random random ) { return md5Crypt ( keyBytes , MD5_PREFIX + B64 . getRandomSalt ( 8 , random ) ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix ) { return md5Crypt ( keyBytes , salt , prefix , new SecureRandom ( ) ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(Charsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String sha256Crypt ( final byte [ ] keyBytes , String salt , Random random ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 , random ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithms . SHA_256 ) ; } 
public static String sha512Crypt ( final byte [ ] keyBytes , String salt , final Random random ) { if ( salt = = null ) { salt = SHA512_PREFIX + B64 . getRandomSalt ( 8 , random ) ; } return sha2Crypt ( keyBytes , salt , SHA512_PREFIX , SHA512_BLOCKSIZE , MessageDigestAlgorithms . SHA_512 ) ; } 
public void estApr1CryptBytesWithThreadLocalRandom ( ) { random salt final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); final String hash = Md5Crypt.apr1Crypt(keyBytes, threadLocalRandom); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptExplicitCall ( ) { When explicitly called the prefix is optional assertEquals("$apr1$1234$mAlH7FRST6FiRZ.kcYL.j1", Md5Crypt.apr1Crypt("secret", "1234")); When explicitly called without salt, a random one will be used. assertTrue(Md5Crypt.apr1Crypt("secret".getBytes()).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); assertTrue(Md5Crypt.apr1Crypt("secret".getBytes(), (String) null).matches("^\\$apr1\\$[a-zA-Z0-9./]{0,8}\\$.{1,}$")); } 
public void estMd5CryptExplicitCall ( ) { assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , ( String ) null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estMd5CryptExplicitCallWithThreadLocalRandom ( ) { ThreadLocalRandom hreadLocalRandom = ThreadLocalRandom . current ( ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , hreadLocalRandom ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , ( String ) null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estSha2CryptRoundsThreadLocalRandom ( ) { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$", random)); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$", random)); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd", random)); } 
public void estSha512CryptExplicitCallThreadLocalRandom ( ) { ThreadLocalRandom hreadLocalRandom = ThreadLocalRandom . current ( ) ; assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , null , hreadLocalRandom ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access @SuppressWarnings("unchecked") final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.EMPTY_LIST; for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.EMPTY_LIST; for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; ry ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } } return new Lang(rules, languages); } 
private static Scanner createScanner ( final NameType nameType , final RuleType rt , final String lang ) { final String resName = createResourceName ( nameType , rt , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; } 
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( " org/apache/commons/codec/language/bm/%s.txt " , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; } 
static void b64from24bit ( final byte b2 , final byte b1 , final byte b0 , final int outLen , final StringBuilder buffer ) { The bit masking is necessary because the JVM byte type is signed! int w = ((b2 << 16) & 0x00ffffff) | ((b1 << 8) & 0x00ffff) | (b0 & 0xff); It's effectively a "for" loop but kept to resemble the original C code. int n = outLen; while (n-- > 0) { buffer.append(B64T_ARRAY[w & 0x3f]); 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T_STRING + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte key [ ] = new byte [ 8 ] ; for ( int i = 0 ; i < key . length ; i + + ) { key [ i ] = 0 ; } for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int schedule [ ] = desSetKey ( key ) ; final int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public void estB64T ( ) { assertNotNull ( new B64 ( ) ) ; for the 100% code coverage :) assertEquals(64, B64.B64T_ARRAY.length); } 
public void estEncodeWithInvalidObject ( ) hrows Exception { boolean exceptionThrown = false ; ry { final StringEncoder encoder = his . getStringEncoder ( ) ; encoder . encode ( Float . valueOf ( 3.4f ) ) ; } catch ( final Exception e ) { exceptionThrown = rue ; } Assert . assertTrue ( " An exception was not thrown when we tried to encode " + " a Float object " , exceptionThrown ) ; } 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final int compare = sCompare . compare ( Double . valueOf ( 3.0d ) , Long . valueOf ( 3 ) ) ; assertEquals ( " Trying to compare objects that make no sense to the underlying encoder should return a zero compare code " , 0 , compare ) ; 
public void estEncodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " what not " ; final String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded ) ; final Object result = bcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; final String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic B decoding test " , " what not " , plain ) ; final Object result = bcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( Charsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.<Branch>emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } OK to ignore H here because it only affects nextChar which has already been set up if (chr == 'H' || chr < 'A' || chr > 'Z') { continue; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) { code = '2'; } else if (arrayContains(WFPV, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (lastCode == CHAR_FIRST_POS) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(TDX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else { code = chr; should not happen? } if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) { output.addRight(code); } lastChar = chr; lastCode = code; } return output.toString(); } 
public String decode ( final String sourceStr , final String sourceCharset ) hrows DecoderException , UnsupportedEncodingException { if ( sourceStr = = null ) { return null ; } return new String ( decode ( StringUtils . getBytesUsAscii ( sourceStr ) ) , sourceCharset ) ; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.<Branch>emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (branching) { nextBranches.add(nextBranch); } else { break; } } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
private void validateCharacter ( int numBits , Context context ) { if ( ( context . lbitWorkArea & numBits ) ! = 0 ) { hrow new IllegalArgumentException ( 
private long validateCharacter ( int numBitsToDrop , Context context ) { if ( ( context . ibitWorkArea & numBitsToDrop ) ! = 0 ) { hrow new IllegalArgumentException ( " Last encoded character (before the paddings if any) is a valid base 64 alphabet but not a possible value " ) ; } return context . ibitWorkArea > > numBitsToDrop ; } 
public void estBase32ImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( ) , BASE32_IMPOSSIBLE_CASES ) ; } 
public void estBase32ImpossibleChunked ( ) { estImpossibleCases ( new Base32 ( 20 ) , BASE32_IMPOSSIBLE_CASES_CHUNKED ) ; } 
public void estBase32HexImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( rue ) , BASE32HEX_IMPOSSIBLE_CASES ) ; } 
private void estImpossibleCases ( Base32 codec , String [ ] impossible_cases ) { for ( String impossible : impossible_cases ) { ry { 
public void estBase64ImpossibleSamples ( ) { Base64 codec = new Base64 ( ) ; for ( String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
public void estBase64ImpossibleSamples ( ) { BCodec codec = new BCodec ( ) ; for ( String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
private void println ( final String prefix , final byte [ ] digest , final String fileName ) { The standard appears to be to print hex, space, then either space or '*' followed by file name where '*' is used for binary files shasum(1) has a -b option which generates " *" separator we don't distinguish binary files at present System.out.println(prefix + Hex.encodeHexString(digest) + (fileName != null ? " " + fileName : "")); } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } OK to ignore H here because it only affects nextChar which has already been set up if (chr == 'H' || chr < 'A' || chr > 'Z') { continue; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { code = '2'; } else if (arrayContains(FPVW, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (lastCode == CHAR_FIRST_POS) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(DTX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else { code = chr; should not happen? } if (code != CHAR_IGNORE && (lastCode != code && (code != '0' || lastCode == CHAR_FIRST_POS) || code < '0' || code > '8')) { output.addRight(code); } lastChar = chr; lastCode = code; } return output.toString(); } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; boolean firstChar = true; are we generating the first digit? char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } OK to ignore H here because it only affects nextChar which has already been set up if (chr < 'A' || chr > 'Z') { continue; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { code = '2'; } else if (arrayContains(FPVW, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (firstChar) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(DTX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else if (chr == 'H') { code = CHAR_IGNORE; } else { code = chr; should not happen? } if (code != CHAR_IGNORE && lastCode != code && (code != '0' || firstChar)) { output.addRight(code); firstChar = false; no longer processing first output digit } lastChar = chr; lastCode = code; } return output.toString(); } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; final char CHAR_FIRST_POS = '/' ; are we processing the first character? final char CHAR_IGNORE = '-'; is this character to be ignored? char lastChar = CHAR_IGNORE; char lastCode = CHAR_FIRST_POS; boolean firstChar = true; are we generating the first digit? char code; char chr; while (input.length() > 0) { chr = input.removeNext(); if (input.length() > 0) { nextChar = input.getNextChar(); } else { nextChar = CHAR_IGNORE; } if (chr < 'A' || chr > 'Z') { continue; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { code = '0'; } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { code = '1'; } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { code = '2'; } else if (arrayContains(FPVW, chr)) { code = '3'; } else if (arrayContains(GKQ, chr)) { code = '4'; } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { code = '4'; input.addLeft('S'); } else if (chr == 'S' || chr == 'Z') { code = '8'; } else if (chr == 'C') { if (firstChar) { if (arrayContains(AHKLOQRUX, nextChar)) { code = '4'; } else { code = '8'; } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { code = '8'; } else { code = '4'; } } } else if (arrayContains(DTX, chr)) { code = '8'; } else if (chr == 'R') { code = '7'; } else if (chr == 'L') { code = '5'; } else if (chr == 'M' || chr == 'N') { code = '6'; } else if (chr == 'H') { code = CHAR_IGNORE; } else { code = chr; should not happen? } if (code != CHAR_IGNORE && lastCode != code && (code != '0' || firstChar)) { output.addRight(code); firstChar = false; no longer processing first output digit } lastChar = chr; lastCode = code; } return output.toString(); } 
public void put ( final char code ) { if ( code ! = CHAR_IGNORE & & lastCode ! = code & & ( code ! = '0' | | length = = 0 ) ) { data [ length ] = code ; length + + ; } lastCode = code ; } 
public String colognePhonetic ( String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.length() == 0) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else if (chr == 'R') { output.put('7'); } else if (chr == 'L') { output.put('5'); } else if (chr == 'M' || chr == 'N') { output.put('6'); } else if (chr == 'H') { output.put(CHAR_IGNORE); needed by put } else { ignored; should not happen } lastChar = chr; } return output.toString(); } 
public static int hash32 ( final byte [ ] data , int length , int seed ) { } 
public static int hash32 ( final byte [ ] data , int length ) { return hash32 ( data , length , 0x9747b28c ) ; } 
public static int hash32 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( ) ; return hash32 ( bytes , bytes . length ) ; } 
public static int hash32 ( final String ext , int from , int length ) { return hash32 ( ext . substring ( from , from + length ) ) ; } 
public static long hash64 ( final byte [ ] data , int length , int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; int length8 = length / 8 ; for ( int i = 0 ; i < length8 ; i + + ) { final int i8 = i * 8 ; long k = ( ( long ) data [ i8 + 0 ] & 0xff ) + ( ( ( long ) data [ i8 + 1 ] & 0xff ) < < 8 ) + ( ( ( long ) data [ i8 + 2 ] & 0xff ) < < 16 ) + ( ( ( long ) data [ i8 + 3 ] & 0xff ) < < 24 ) + ( ( ( long ) data [ i8 + 4 ] & 0xff ) < < 32 ) + ( ( ( long ) data [ i8 + 5 ] & 0xff ) < < 40 ) + ( ( ( long ) data [ i8 + 6 ] & 0xff ) < < 48 ) + ( ( ( long ) data [ i8 + 7 ] & 0xff ) < < 56 ) ; k * = m ; k ^ = k > > > r ; k * = m ; h ^ = k ; h * = m ; } switch ( length % 8 ) { case 7 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 6 ] & 0xff ) < < 48 ; case 6 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 5 ] & 0xff ) < < 40 ; case 5 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 4 ] & 0xff ) < < 32 ; case 4 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 3 ] & 0xff ) < < 24 ; case 3 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 2 ] & 0xff ) < < 16 ; case 2 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 1 ] & 0xff ) < < 8 ; case 1 : h ^ = ( long ) ( data [ length & ~ 7 ] & 0xff ) ; h * = m ; } ; h ^ = h > > > r ; h * = m ; h ^ = h > > > r ; return h ; } 
public static long hash64 ( final byte [ ] data , int length ) { return hash64 ( data , length , 0xe17a1465 ) ; } 
public static long hash64 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( ) ; return hash64 ( bytes , bytes . length ) ; } 
public static long hash64 ( final String ext , int from , int length ) { return hash64 ( ext . substring ( from , from + length ) ) ; } 
public static int hash32 ( long l0 , int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; return fmix32 ( Long . BYTES , hash ) ; } 
public static int hash32 ( long l0 , long l1 , int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; final long r1 = Long . reverseBytes ( l1 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; return fmix32 ( Long . BYTES * 2 , hash ) ; } 
public static int hash32 ( byte [ ] data ) { return hash32 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static int hash32 ( String data ) { byte [ ] origin = data . getBytes ( ) ; return hash32 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static int hash32 ( byte [ ] data , int length ) { return hash32 ( data , length , DEFAULT_SEED ) ; } 
public static int hash32 ( byte [ ] data , int length , int seed ) { return hash32 ( data , 0 , length , seed ) ; } 
public static int hash32 ( byte [ ] data , int offset , int length , int seed ) { int hash = seed ; final int nblocks = length > > 2 ; } 
public static long hash64 ( byte [ ] data ) { return hash64 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long hash64 ( long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; int length = Long . BYTES ; } 
public static long hash64 ( int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; int length = Integer . BYTES ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public static long hash64 ( short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public static long hash64 ( byte [ ] data , int offset , int length ) { return hash64 ( data , offset , length , DEFAULT_SEED ) ; } 
public static long hash64 ( byte [ ] data , int offset , int length , int seed ) { long hash = seed ; final int nblocks = length > > 3 ; } 
public static long [ ] hash128 ( byte [ ] data ) { return hash128 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( String data ) { byte [ ] origin = data . getBytes ( ) ; return hash128 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( byte [ ] data , int offset , int length , int seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; } 
private static int mix32 ( int k , int hash ) { k * = C1_32 ; k = Integer . rotateLeft ( k , R1_32 ) ; k * = C2_32 ; hash ^ = k ; return Integer . rotateLeft ( hash , R2_32 ) * M_32 + N_32 ; } 
private static int fmix32 ( int length , int hash ) { hash ^ = length ; hash ^ = ( hash > > > 16 ) ; hash * = 0x85ebca6b ; hash ^ = ( hash > > > 13 ) ; hash * = 0xc2b2ae35 ; hash ^ = ( hash > > > 16 ) ; return hash ; } 
private static long fmix64 ( long h ) { h ^ = ( h > > > 33 ) ; h * = 0xff51afd7ed558ccdL ; h ^ = ( h > > > 33 ) ; h * = 0xc4ceb9fe1a85ec53L ; h ^ = ( h > > > 33 ) ; return h ; } 
public final void add ( byte [ ] data , int offset , int length ) { if ( length = = 0 ) return ; totalLen + = length ; if ( ailLen + length < 4 ) { System . arraycopy ( data , offset , ail , ailLen , length ) ; tailLen + = length ; return ; } int offset2 = 0 ; if ( ailLen > 0 ) { offset2 = ( 4 - ailLen ) ; int k = - 1 ; switch ( ailLen ) { case 1 : k = orBytes ( ail [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break ; case 2 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; break ; case 3 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , ail [ 2 ] , data [ offset ] ) ; break ; default : throw new AssertionError ( ailLen ) ; } } 
public final int end ( ) { int k1 = 0 ; switch ( ailLen ) { case 3 : k1 ^ = ail [ 2 ] < < 16 ; case 2 : k1 ^ = ail [ 1 ] < < 8 ; case 1 : k1 ^ = ail [ 0 ] ; } 
private static int orBytes ( byte b1 , byte b2 , byte b3 , byte b4 ) { return ( b1 & 0xff ) | ( ( b2 & 0xff ) < < 8 ) | ( ( b3 & 0xff ) < < 16 ) | ( ( b4 & 0xff ) < < 24 ) ; } 
public void estHash32ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length , 0x71b4954d ) ; 
public void estHash32ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length ) ; 
public void estHash32String ( ) { int hash = MurmurHash2 . hash32 ( ext ) ; assertTrue ( hash = = 0xb3bf597e ) ; } 
public void estHash32StringIntInt ( ) { int hash = MurmurHash2 . hash32 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0x4d666d90 ) ; } 
public void estHash64ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length , 0x344d1f5c ) ; 
public void estHash64ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length ) ; 
public void estHash64String ( ) { long hash = MurmurHash2 . hash64 ( ext ) ; assertTrue ( hash = = 0x0920e0c1b7eeb261l ) ; } 
public void estHash64StringIntInt ( ) { long hash = MurmurHash2 . hash64 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0xa8b33145194985a2l ) ; } 
public void est32_String ( ) { } 
public void estHashCodeM3_64 ( ) { byte [ ] origin = TEST . getBytes ( ) ; long hash = MurmurHash3 . hash64 ( origin , 0 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; } 
public void est64 ( ) { final int seed = 123 , iters = 1000000 ; ByteBuffer SHORT_BUFFER = ByteBuffer . allocate ( Short . BYTES ) ; ByteBuffer INT_BUFFER = ByteBuffer . allocate ( Integer . BYTES ) ; ByteBuffer LONG_BUFFER = ByteBuffer . allocate ( Long . BYTES ) ; Random rdm = new Random ( seed ) ; for ( int i = 0 ; i < iters ; + + i ) { long ln = rdm . nextLong ( ) ; 
public void est128_Short ( ) { } 
public void est128_Int ( ) { } 
public void est128_Long ( ) { } 
public void est128_Double ( ) { } 
public void est128_String ( ) { } 
public void estIncremental ( ) { final int seed = 123 , arraySize = 1023 ; byte [ ] bytes = new byte [ arraySize ] ; new Random ( seed ) . nextBytes ( bytes ) ; int expected = MurmurHash3 . hash32 ( bytes , arraySize ) ; MurmurHash3 . IncrementalHash32 same = new IncrementalHash32 ( ) , diff = new IncrementalHash32 ( ) ; for ( int blockSize = 1 ; blockSize < = arraySize ; + + blockSize ) { byte [ ] block = new byte [ blockSize ] ; 
public void estTwoLongOrdered ( ) { ByteBuffer buffer = ByteBuffer . allocate ( Long . BYTES * 2 ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estTwoLongRandom ( ) { ByteBuffer buffer = ByteBuffer . allocate ( Long . BYTES * 2 ) ; Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estSingleLongOrdered ( ) { ByteBuffer buffer = ByteBuffer . allocate ( Long . BYTES ) ; for ( long i = 0 ; i < 1000 ; i + + ) { buffer . putLong ( 0 , i ) ; 
public void estSingleLongRandom ( ) { ByteBuffer buffer = ByteBuffer . allocate ( Long . BYTES ) ; Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { long x = random . nextLong ( ) ; 
public static long hash64 ( final byte [ ] data , int length , int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; int length8 = length / 8 ; for ( int i = 0 ; i < length8 ; i + + ) { final int i8 = i * 8 ; long k = ( ( long ) data [ i8 + 0 ] & 0xff ) + ( ( ( long ) data [ i8 + 1 ] & 0xff ) < < 8 ) + ( ( ( long ) data [ i8 + 2 ] & 0xff ) < < 16 ) + ( ( ( long ) data [ i8 + 3 ] & 0xff ) < < 24 ) + ( ( ( long ) data [ i8 + 4 ] & 0xff ) < < 32 ) + ( ( ( long ) data [ i8 + 5 ] & 0xff ) < < 40 ) + ( ( ( long ) data [ i8 + 6 ] & 0xff ) < < 48 ) + ( ( ( long ) data [ i8 + 7 ] & 0xff ) < < 56 ) ; k * = m ; k ^ = k > > > r ; k * = m ; h ^ = k ; h * = m ; } switch ( length % 8 ) { case 7 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 6 ] & 0xff ) < < 48 ; case 6 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 5 ] & 0xff ) < < 40 ; case 5 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 4 ] & 0xff ) < < 32 ; case 4 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 3 ] & 0xff ) < < 24 ; case 3 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 2 ] & 0xff ) < < 16 ; case 2 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 1 ] & 0xff ) < < 8 ; case 1 : h ^ = ( long ) ( data [ length & ~ 7 ] & 0xff ) ; h * = m ; } h ^ = h > > > r ; h * = m ; h ^ = h > > > r ; return h ; } 
public static int hash32 ( long l0 , int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES , hash ) ; } 
public static int hash32 ( long l0 , long l1 , int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; final long r1 = Long . reverseBytes ( l1 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES * 2 , hash ) ; } 
public static long hash64 ( long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; int length = LONG_BYTES ; } 
public static long hash64 ( int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; int length = INTEGER_BYTES ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public static long hash64 ( short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public void est64 ( ) { final int seed = 123 , iters = 1000000 ; ByteBuffer SHORT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . SHORT_BYTES ) ; ByteBuffer INT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . INTEGER_BYTES ) ; ByteBuffer LONG_BUFFER = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; Random rdm = new Random ( seed ) ; for ( int i = 0 ; i < iters ; + + i ) { long ln = rdm . nextLong ( ) ; 
public void est128_Short ( ) { } 
public void est128_Int ( ) { } 
public void est128_Long ( ) { } 
public void est128_Double ( ) { } 
public void estTwoLongOrdered ( ) { ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estTwoLongRandom ( ) { ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estSingleLongOrdered ( ) { ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; for ( long i = 0 ; i < 1000 ; i + + ) { buffer . putLong ( 0 , i ) ; 
public void estSingleLongRandom ( ) { ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { long x = random . nextLong ( ) ; 
public final void add ( byte [ ] data , int offset , int length ) { if ( length = = 0 ) { return ; } totalLen + = length ; if ( ailLen + length < 4 ) { System . arraycopy ( data , offset , ail , ailLen , length ) ; tailLen + = length ; return ; } int offset2 = 0 ; if ( ailLen > 0 ) { offset2 = ( 4 - ailLen ) ; int k = - 1 ; switch ( ailLen ) { case 1 : k = orBytes ( ail [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break ; case 2 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; break ; case 3 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , ail [ 2 ] , data [ offset ] ) ; break ; default : throw new AssertionError ( ailLen ) ; } } 
public void est32_String ( ) { } 
public void est128_String ( ) { } 
private void validateCharacter ( final int numBits , final Context context ) { if ( ( context . lbitWorkArea & numBits ) ! = 0 ) { hrow new IllegalArgumentException ( 
private long validateCharacter ( final int numBitsToDrop , final Context context ) { if ( ( context . ibitWorkArea & numBitsToDrop ) ! = 0 ) { hrow new IllegalArgumentException ( " Last encoded character (before the paddings if any) is a valid base 64 alphabet but not a possible value " ) ; } return context . ibitWorkArea > > numBitsToDrop ; } 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { } 
public static int hash32 ( final byte [ ] data , final int length ) { return hash32 ( data , length , 0x9747b28c ) ; } 
public static int hash32 ( final String ext , final int from , final int length ) { return hash32 ( ext . substring ( from , from + length ) ) ; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; final int length8 = length / 8 ; for ( int i = 0 ; i < length8 ; i + + ) { final int i8 = i * 8 ; long k = ( ( long ) data [ i8 + 0 ] & 0xff ) + ( ( ( long ) data [ i8 + 1 ] & 0xff ) < < 8 ) + ( ( ( long ) data [ i8 + 2 ] & 0xff ) < < 16 ) + ( ( ( long ) data [ i8 + 3 ] & 0xff ) < < 24 ) + ( ( ( long ) data [ i8 + 4 ] & 0xff ) < < 32 ) + ( ( ( long ) data [ i8 + 5 ] & 0xff ) < < 40 ) + ( ( ( long ) data [ i8 + 6 ] & 0xff ) < < 48 ) + ( ( ( long ) data [ i8 + 7 ] & 0xff ) < < 56 ) ; k * = m ; k ^ = k > > > r ; k * = m ; h ^ = k ; h * = m ; } switch ( length % 8 ) { case 7 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 6 ] & 0xff ) < < 48 ; case 6 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 5 ] & 0xff ) < < 40 ; case 5 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 4 ] & 0xff ) < < 32 ; case 4 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 3 ] & 0xff ) < < 24 ; case 3 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 2 ] & 0xff ) < < 16 ; case 2 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 1 ] & 0xff ) < < 8 ; case 1 : h ^ = ( long ) ( data [ length & ~ 7 ] & 0xff ) ; h * = m ; } h ^ = h > > > r ; h * = m ; h ^ = h > > > r ; return h ; } 
public static long hash64 ( final byte [ ] data , final int length ) { return hash64 ( data , length , 0xe17a1465 ) ; } 
public static long hash64 ( final String ext , final int from , final int length ) { return hash64 ( ext . substring ( from , from + length ) ) ; } 
public static int hash32 ( final long l0 , final long l1 ) { return hash32 ( l0 , l1 , DEFAULT_SEED ) ; } 
public static int hash32 ( final long l0 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES , hash ) ; } 
public static int hash32 ( final long l0 , final long l1 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; final long r1 = Long . reverseBytes ( l1 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES * 2 , hash ) ; } 
public static int hash32 ( final byte [ ] data ) { return hash32 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static int hash32 ( final String data ) { final byte [ ] origin = data . getBytes ( ) ; return hash32 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static int hash32 ( final byte [ ] data , final int length ) { return hash32 ( data , length , DEFAULT_SEED ) ; } 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { return hash32 ( data , 0 , length , seed ) ; } 
public static int hash32 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; } 
public static long hash64 ( final byte [ ] data ) { return hash64 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; final int length = LONG_BYTES ; } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; final int length = INTEGER_BYTES ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length ) { return hash64 ( data , offset , length , DEFAULT_SEED ) ; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { long hash = seed ; final int nblocks = length > > 3 ; } 
public static long [ ] hash128 ( final byte [ ] data ) { return hash128 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final String data ) { final byte [ ] origin = data . getBytes ( ) ; return hash128 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; } 
private static int fmix32 ( final int length , int hash ) { hash ^ = length ; hash ^ = ( hash > > > 16 ) ; hash * = 0x85ebca6b ; hash ^ = ( hash > > > 13 ) ; hash * = 0xc2b2ae35 ; hash ^ = ( hash > > > 16 ) ; return hash ; } 
public final void start ( final int hash ) { tailLen = otalLen = 0 ; this . hash = hash ; } 
public final void add ( final byte [ ] data , int offset , final int length ) { if ( length = = 0 ) { return ; } totalLen + = length ; if ( ailLen + length < 4 ) { System . arraycopy ( data , offset , ail , ailLen , length ) ; tailLen + = length ; return ; } int offset2 = 0 ; if ( ailLen > 0 ) { offset2 = ( 4 - ailLen ) ; int k = - 1 ; switch ( ailLen ) { case 1 : k = orBytes ( ail [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break ; case 2 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; break ; case 3 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , ail [ 2 ] , data [ offset ] ) ; break ; default : throw new AssertionError ( ailLen ) ; } } 
private static int orBytes ( final byte b1 , final byte b2 , final byte b3 , final byte b4 ) { return ( b1 & 0xff ) | ( ( b2 & 0xff ) < < 8 ) | ( ( b3 & 0xff ) < < 16 ) | ( ( b4 & 0xff ) < < 24 ) ; } 
public static String sha256Crypt ( final byte [ ] keyBytes , String salt , final Random random ) { if ( salt = = null ) { salt = SHA256_PREFIX + B64 . getRandomSalt ( 8 , random ) ; } return sha2Crypt ( keyBytes , salt , SHA256_PREFIX , SHA256_BLOCKSIZE , MessageDigestAlgorithms . SHA_256 ) ; } 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.length() == 0) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else if (chr == 'R') { output.put('7'); } else if (chr == 'L') { output.put('5'); } else if (chr == 'M' || chr == 'N') { output.put('6'); } else if (chr == 'H') { output.put(CHAR_IGNORE); needed by put } else { ignored; should not happen } lastChar = chr; } return output.toString(); } 
private char [ ] preprocess ( final String ext ) { This converts German small sharp s (Eszett) to SS final char[] chrs = text.toUpperCase(Locale.GERMAN).toCharArray(); for (int index = 0; index < chrs.length; index++) { switch (chrs[index]) { case '\u00C4': capital A, umlaut mark chrs[index] = 'A'; break; case '\u00DC': capital U, umlaut mark chrs[index] = 'U'; break; case '\u00D6': capital O, umlaut mark chrs[index] = 'O'; break; default: break; } } return chrs; } 
private void insertAlwaysEncodeChars ( final byte [ ] alwaysEncodeCharsArray ) { if ( alwaysEncodeCharsArray ! = null ) { for ( final byte b : alwaysEncodeCharsArray ) { insertAlwaysEncodeChar ( b ) ; } } insertAlwaysEncodeChar ( ESCAPE_CHAR ) ; } 
public byte [ ] encode ( final byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes ! = bytes . length ; if ( willEncode | | ( plusForSpace & & containsSpace ( bytes ) ) ) { return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } 
private byte [ ] doEncode ( final byte [ ] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; for ( final byte b : bytes ) { if ( willEncode & & canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = ( byte ) ( 256 + bb ) ; } final char hex1 = Utils . hexDigit ( bb > > 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; buffer . put ( ( byte ) hex2 ) ; } else { if ( plusForSpace & & b = = ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } } return buffer . array ( ) ; } 
private int expectedDecodingBytes ( final byte [ ] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i + = b = = ESCAPE_CHAR ? 3 : 1 ; byteCount + + ; } return byteCount ; } 
private void estImpossibleCases ( final Base32 codec , final String [ ] impossible_cases ) { for ( final String impossible : impossible_cases ) { ry { 
public void estBase64ImpossibleSamples ( ) { final Base64 codec = new Base64 ( ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
public void estApr1CryptBytesWithThreadLocalRandom ( ) { random salt final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); final String hash = Md5Crypt.apr1Crypt(keyBytes, threadLocalRandom); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(Charsets.ISO_8859_1), "$apr1$./$")); } 
public void estMd5CryptExplicitCallWithThreadLocalRandom ( ) { final ThreadLocalRandom hreadLocalRandom = ThreadLocalRandom . current ( ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , hreadLocalRandom ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; assertTrue ( Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , ( String ) null ) . matches ( " ^ \\ $1 \\ $[a-zA-Z0-9./]{0,8} \\ $.{1,}$ " ) ) ; } 
public void estHash32ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length , 0x71b4954d ) ; 
public void estHash32ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length ) ; 
public void estHash32String ( ) { final int hash = MurmurHash2 . hash32 ( ext ) ; assertTrue ( hash = = 0xb3bf597e ) ; } 
public void estHash32StringIntInt ( ) { final int hash = MurmurHash2 . hash32 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0x4d666d90 ) ; } 
public void estHash64ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length , 0x344d1f5c ) ; 
public void estHash64ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length ) ; 
public void estHash64String ( ) { final long hash = MurmurHash2 . hash64 ( ext ) ; assertTrue ( hash = = 0x0920e0c1b7eeb261l ) ; } 
public void estHash64StringIntInt ( ) { final long hash = MurmurHash2 . hash64 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0xa8b33145194985a2l ) ; } 
public void est32_String ( ) { } 
public void estHashCodeM3_64 ( ) { final byte [ ] origin = TEST . getBytes ( ) ; long hash = MurmurHash3 . hash64 ( origin , 0 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; } 
public void est64 ( ) { final int seed = 123 , iters = 1000000 ; final ByteBuffer SHORT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . SHORT_BYTES ) ; final ByteBuffer INT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . INTEGER_BYTES ) ; final ByteBuffer LONG_BUFFER = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; final Random rdm = new Random ( seed ) ; for ( int i = 0 ; i < iters ; + + i ) { final long ln = rdm . nextLong ( ) ; 
public void est128_Short ( ) { } 
public void est128_Int ( ) { } 
public void est128_Long ( ) { } 
public void est128_Double ( ) { } 
public void est128_String ( ) { } 
public void estIncremental ( ) { final int seed = 123 , arraySize = 1023 ; final byte [ ] bytes = new byte [ arraySize ] ; new Random ( seed ) . nextBytes ( bytes ) ; final int expected = MurmurHash3 . hash32 ( bytes , arraySize ) ; final MurmurHash3 . IncrementalHash32 same = new IncrementalHash32 ( ) , diff = new IncrementalHash32 ( ) ; for ( int blockSize = 1 ; blockSize < = arraySize ; + + blockSize ) { final byte [ ] block = new byte [ blockSize ] ; 
public void estTwoLongOrdered ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estTwoLongRandom ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; final Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estSingleLongOrdered ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; for ( long i = 0 ; i < 1000 ; i + + ) { buffer . putLong ( 0 , i ) ; 
public void estSingleLongRandom ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; final Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { final long x = random . nextLong ( ) ; 
public void estSha2CryptRoundsThreadLocalRandom ( ) { final ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=50$abcd$", random)); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=1001$abcd$", random)); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(Charsets.UTF_8), "$5$rounds=9999$abcd", random)); } 
public void estSha512CryptExplicitCallThreadLocalRandom ( ) { final ThreadLocalRandom hreadLocalRandom = ThreadLocalRandom . current ( ) ; assertTrue ( Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , null , hreadLocalRandom ) . matches ( " ^ \\ $6 \\ $[a-zA-Z0-9./]{0,16} \\ $.{1,}$ " ) ) ; } 
private static boolean hasTestCase ( final String re ) { for ( final String s : TESTSET ) { if ( s . matches ( re ) ) { return rue ; } } return false ; } 
public static void finishTests ( ) { int errors = 0 ; for ( final String m : MATCHES ) { if ( ! hasTestCase ( m ) ) { System . out . println ( m + " has no test case " ) ; errors + + ; } } Assert . assertEquals ( " Not expecting any missing test cases " , 0 , errors ) ; } 
public static void main ( final String args [ ] ) { final ColognePhonetic coder = new ColognePhonetic ( ) ; for ( final String arg : args ) { final String code = coder . encode ( arg ) ; 
public void estBase64ImpossibleSamples ( ) { final BCodec codec = new BCodec ( ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
public void estBasicEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " abcdABCD " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec decoding test " , input , decodedS ) ; } 
public void estBasicSpace ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; Assert . assertArrayEquals ( " %20 " . getBytes ( StandardCharsets . UTF_8 ) , encoded ) ; } 
public void estConfigurablePercentEncoder ( ) hrows Exception { final String input = " abc123_-.* u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( " abcdef " . getBytes ( " UTF-8 " ) , false ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " Configurable PercentCodec encoding test " , " %61%62%63123_-.*%CE%B1%CE%B2 " , encodedS ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; assertEquals ( " Configurable PercentCodec decoding test " , new String ( decoded , " UTF-8 " ) , input ) ; } 
public void estDecodeInvalidEncodedResultDecoding ( ) hrows Exception { final String inputS = " u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( ) ; final byte [ ] encoded = percentCodec . encode ( inputS . getBytes ( " UTF-8 " ) ) ; ry { percentCodec . decode ( Arrays . copyOf ( encoded , encoded . length - 1 ) ) ; exclude one byte 
public void estDecodeNullObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; assertEquals ( percentCodec . decode ( ( Object ) null ) , null ) ; } 
public void estDecodeUnsupportedObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; percentCodec . decode ( " est " ) ; } 
public void estEncodeNullObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; assertEquals ( percentCodec . encode ( ( Object ) null ) , null ) ; } 
public void estEncodeUnsupportedObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; percentCodec . encode ( " est " ) ; } 
public void estPercentEncoderDecoderWithNullOrEmptyInput ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; assertEquals ( " Null input value encoding test " , percentCodec . encode ( null ) , null ) ; assertEquals ( " Null input value decoding test " , percentCodec . decode ( null ) , null ) ; final byte [ ] emptyInput = " " . getBytes ( " UTF-8 " ) ; assertEquals ( " Empty input value encoding test " , percentCodec . encode ( emptyInput ) , emptyInput ) ; assertTrue ( " Empty input value decoding test " , Arrays . equals ( percentCodec . decode ( emptyInput ) , emptyInput ) ) ; } 
public void estPercentEncoderDecoderWithPlusForSpace ( ) hrows Exception { final String input = " a b c d " ; final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; assertEquals ( " PercentCodec plus for space encoding test " , " a+b+c+d " , encodedS ) ; final byte [ ] decode = percentCodec . decode ( encoded ) ; assertEquals ( " PercentCodec plus for space decoding test " , new String ( decode , " UTF-8 " ) , input ) ; } 
public void estSafeCharEncodeDecodeObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final String input = " abc123_-.* " ; final Object encoded = percentCodec . encode ( ( Object ) input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( ( byte [ ] ) encoded , " UTF-8 " ) ; final Object decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( ( byte [ ] ) decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec safe char encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec safe char decoding test " , input , decodedS ) ; } 
public void estUnsafeCharEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " u03B1 u03B2 u03B3 u03B4 u03B5 u03B6% " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , " UTF-8 " ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , " UTF-8 " ) ; assertEquals ( " Basic PercentCodec unsafe char encoding test " , " %CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 " , encodedS ) ; assertEquals ( " Basic PercentCodec unsafe char decoding test " , input , decodedS ) ; } 
protected static char [ ] encodeHex ( final ByteBuffer byteBuffer , final char [ ] oDigits ) { return encodeHex ( oByteArray ( byteBuffer ) , oDigits ) ; } 
private static byte [ ] oByteArray ( final ByteBuffer byteBuffer ) { if ( byteBuffer . hasArray ( ) ) { return byteBuffer . array ( ) ; } byte [ ] byteArray = new byte [ byteBuffer . remaining ( ) ] ; byteBuffer . get ( byteArray ) ; return byteArray ; } 
public byte [ ] decode ( final ByteBuffer buffer ) hrows DecoderException { return decodeHex ( new String ( oByteArray ( buffer ) , getCharset ( ) ) . oCharArray ( ) ) ; } 
public Object encode ( final Object object ) hrows EncoderException { byte [ ] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( his . getCharset ( ) ) ; } else if ( object instanceof ByteBuffer ) { byteArray = oByteArray ( ( ByteBuffer ) object ) ; } else { ry { byteArray = ( byte [ ] ) object ; } catch ( final ClassCastException e ) { hrow new EncoderException ( e . getMessage ( ) , e ) ; } } return encodeHex ( byteArray ) ; } 
protected ByteBuffer allocate ( final int capacity ) { return ByteBuffer . allocateDirect ( capacity ) ; } 
protected ByteBuffer allocate ( final int capacity ) { return ByteBuffer . allocate ( capacity ) ; } 
public void estDecodeByteBufferEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . decode ( allocate ( 0 ) ) ) ) ; } 
public void estDecodeByteBufferObjectEmpty ( ) hrows DecoderException { assertTrue ( Arrays . equals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( ( Object ) allocate ( 0 ) ) ) ) ; } 
public void estDecodeByteBufferOddCharacters ( ) { final ByteBuffer buffer = allocate ( 1 ) ; buffer . put ( ( byte ) 65 ) ; buffer . rewind ( ) ; ry { new Hex ( ) . decode ( buffer ) ; 
public void estEncodeByteBufferEmpty ( ) { assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( allocate ( 0 ) ) ) ) ; } 
public void estEncodeByteBufferObjectEmpty ( ) hrows EncoderException { assertTrue ( Arrays . equals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( ( Object ) allocate ( 0 ) ) ) ) ; } 
public void estEncodeHexByteBufferEmpty ( ) { assertTrue ( Arrays . equals ( new char [ 0 ] , Hex . encodeHex ( allocate ( 0 ) ) ) ) ; assertTrue ( Arrays . equals ( new byte [ 0 ] , new Hex ( ) . encode ( allocate ( 0 ) ) ) ) ; } 
public void estEncodeHex_ByteBufferOfZeroes ( ) { final char [ ] c = Hex . encodeHex ( allocate ( 36 ) ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , new String ( c ) ) ; } 
public void estEncodeHexByteString_ByteBufferOfZeroes ( ) { final String c = Hex . encodeHexString ( allocate ( 36 ) ) ; assertEquals ( " 000000000000000000000000000000000000000000000000000000000000000000000000 " , c ) ; } 
private static byte [ ] oByteArray ( final ByteBuffer byteBuffer ) { if ( byteBuffer . hasArray ( ) ) { return byteBuffer . array ( ) ; } final byte [ ] byteArray = new byte [ byteBuffer . remaining ( ) ] ; byteBuffer . get ( byteArray ) ; return byteArray ; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; final int length8 = length / 8 ; for ( int i = 0 ; i < length8 ; i + + ) { final int i8 = i * 8 ; long k = ( ( long ) data [ i8 + 0 ] & 0xff ) + ( ( ( long ) data [ i8 + 1 ] & 0xff ) < < 8 ) + ( ( ( long ) data [ i8 + 2 ] & 0xff ) < < 16 ) + ( ( ( long ) data [ i8 + 3 ] & 0xff ) < < 24 ) + ( ( ( long ) data [ i8 + 4 ] & 0xff ) < < 32 ) + ( ( ( long ) data [ i8 + 5 ] & 0xff ) < < 40 ) + ( ( ( long ) data [ i8 + 6 ] & 0xff ) < < 48 ) + ( ( ( long ) data [ i8 + 7 ] & 0xff ) < < 56 ) ; k * = m ; k ^ = k > > > r ; k * = m ; h ^ = k ; h * = m ; } switch ( length % 8 ) { case 7 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 6 ] & 0xff ) < < 48 ; case 6 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 5 ] & 0xff ) < < 40 ; case 5 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 4 ] & 0xff ) < < 32 ; case 4 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 3 ] & 0xff ) < < 24 ; case 3 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 2 ] & 0xff ) < < 16 ; case 2 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 1 ] & 0xff ) < < 8 ; case 1 : h ^ = data [ length & ~ 7 ] & 0xff ; h * = m ; } h ^ = h > > > r ; h * = m ; h ^ = h > > > r ; return h ; } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; } 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { 'm' and 'r' are mixing constants generated offline. They're not really 'magic', they just happen to work well. final int m = 0x5bd1e995; final int r = 24; Initialize the hash to a random value int h = seed ^ length; final int length4 = length / 4; for (int i = 0; i < length4; i++) { final int i4 = i * 4; int k = (data[i4 + 0] & 0xff) + ((data[i4 + 1] & 0xff) << 8) + ((data[i4 + 2] & 0xff) << 16) + ((data[i4 + 3] & 0xff) << 24); k *= m; k ^= k >>> r; k *= m; h *= m; h ^= k; } Handle the last few bytes of the input array switch (length % 4) { case 3: h ^= (data[(length & ~3) + 2] & 0xff) << 16; case 2: h ^= (data[(length & ~3) + 1] & 0xff) << 8; case 1: h ^= (data[length & ~3] & 0xff); h *= m; } h ^= h >>> 13; h *= m; h ^= h >>> 15; return h; } 
public static int hash32 ( final byte [ ] data , final int length ) { return hash32 ( data , length , 0x9747b28c ) ; } 
public static int hash32 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( ) ; return hash32 ( bytes , bytes . length ) ; } 
public static int hash32 ( final String ext , final int from , final int length ) { return hash32 ( ext . substring ( from , from + length ) ) ; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; final int length8 = length / 8 ; for ( int i = 0 ; i < length8 ; i + + ) { final int i8 = i * 8 ; long k = ( ( long ) data [ i8 + 0 ] & 0xff ) + ( ( ( long ) data [ i8 + 1 ] & 0xff ) < < 8 ) + ( ( ( long ) data [ i8 + 2 ] & 0xff ) < < 16 ) + ( ( ( long ) data [ i8 + 3 ] & 0xff ) < < 24 ) + ( ( ( long ) data [ i8 + 4 ] & 0xff ) < < 32 ) + ( ( ( long ) data [ i8 + 5 ] & 0xff ) < < 40 ) + ( ( ( long ) data [ i8 + 6 ] & 0xff ) < < 48 ) + ( ( ( long ) data [ i8 + 7 ] & 0xff ) < < 56 ) ; k * = m ; k ^ = k > > > r ; k * = m ; h ^ = k ; h * = m ; } switch ( length % 8 ) { case 7 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 6 ] & 0xff ) < < 48 ; case 6 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 5 ] & 0xff ) < < 40 ; case 5 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 4 ] & 0xff ) < < 32 ; case 4 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 3 ] & 0xff ) < < 24 ; case 3 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 2 ] & 0xff ) < < 16 ; case 2 : h ^ = ( long ) ( data [ ( length & ~ 7 ) + 1 ] & 0xff ) < < 8 ; case 1 : h ^ = data [ length & ~ 7 ] & 0xff ; h * = m ; } h ^ = h > > > r ; h * = m ; h ^ = h > > > r ; return h ; } 
public static long hash64 ( final byte [ ] data , final int length ) { return hash64 ( data , length , 0xe17a1465 ) ; } 
public static long hash64 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( ) ; return hash64 ( bytes , bytes . length ) ; } 
public static long hash64 ( final String ext , final int from , final int length ) { return hash64 ( ext . substring ( from , from + length ) ) ; } 
public static int hash32 ( final long l0 , final long l1 ) { return hash32 ( l0 , l1 , DEFAULT_SEED ) ; } 
public static int hash32 ( final long l0 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES , hash ) ; } 
public static int hash32 ( final long l0 , final long l1 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( l0 ) ; final long r1 = Long . reverseBytes ( l1 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; return fmix32 ( LONG_BYTES * 2 , hash ) ; } 
public static int hash32 ( final byte [ ] data ) { return hash32 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static int hash32 ( final String data ) { final byte [ ] origin = data . getBytes ( ) ; return hash32 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static int hash32 ( final byte [ ] data , final int length ) { return hash32 ( data , length , DEFAULT_SEED ) ; } 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { return hash32 ( data , 0 , length , seed ) ; } 
public static int hash32 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int i_4 = i << 2; final int k = (data[offset + i_4] & 0xff) | ((data[offset + i_4 + 1] & 0xff) << 8) | ((data[offset + i_4 + 2] & 0xff) << 16) | ((data[offset + i_4 + 3] & 0xff) << 24); hash = mix32(k, hash); } tail final int idx = nblocks << 2; int k1 = 0; switch (length - idx) { case 3: k1 ^= data[offset + idx + 2] << 16; case 2: k1 ^= data[offset + idx + 1] << 8; case 1: k1 ^= data[offset + idx]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } return fmix32(length, hash); } 
public static long hash64 ( final byte [ ] data ) { return hash64 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; final int length = LONG_BYTES ; mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; finalization hash ^= length; hash = fmix64(hash); return hash; } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; final int length = INTEGER_BYTES ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= length; hash = fmix64(hash); return hash; } 
public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= SHORT_BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length ) { return hash64 ( data , offset , length , DEFAULT_SEED ) ; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { long hash = seed ; final int nblocks = length > > 3 ; body for (int i = 0; i < nblocks; i++) { final int i8 = i << 3; long k = ((long) data[offset + i8] & 0xff) | (((long) data[offset + i8 + 1] & 0xff) << 8) | (((long) data[offset + i8 + 2] & 0xff) << 16) | (((long) data[offset + i8 + 3] & 0xff) << 24) | (((long) data[offset + i8 + 4] & 0xff) << 32) | (((long) data[offset + i8 + 5] & 0xff) << 40) | (((long) data[offset + i8 + 6] & 0xff) << 48) | (((long) data[offset + i8 + 7] & 0xff) << 56); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int tailStart = nblocks << 3; switch (length - tailStart) { case 7: k1 ^= ((long) data[offset + tailStart + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[offset + tailStart + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[offset + tailStart + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[offset + tailStart + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[offset + tailStart + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[offset + tailStart + 1] & 0xff) << 8; case 1: k1 ^= ((long) data[offset + tailStart] & 0xff); k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; hash = fmix64(hash); return hash; } 
public static long [ ] hash128 ( final byte [ ] data ) { return hash128 ( data , 0 , data . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final String data ) { final byte [ ] origin = data . getBytes ( ) ; return hash128 ( origin , 0 , origin . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; body for (int i = 0; i < nblocks; i++) { final int i16 = i << 4; long k1 = ((long) data[offset + i16] & 0xff) | (((long) data[offset + i16 + 1] & 0xff) << 8) | (((long) data[offset + i16 + 2] & 0xff) << 16) | (((long) data[offset + i16 + 3] & 0xff) << 24) | (((long) data[offset + i16 + 4] & 0xff) << 32) | (((long) data[offset + i16 + 5] & 0xff) << 40) | (((long) data[offset + i16 + 6] & 0xff) << 48) | (((long) data[offset + i16 + 7] & 0xff) << 56); long k2 = ((long) data[offset + i16 + 8] & 0xff) | (((long) data[offset + i16 + 9] & 0xff) << 8) | (((long) data[offset + i16 + 10] & 0xff) << 16) | (((long) data[offset + i16 + 11] & 0xff) << 24) | (((long) data[offset + i16 + 12] & 0xff) << 32) | (((long) data[offset + i16 + 13] & 0xff) << 40) | (((long) data[offset + i16 + 14] & 0xff) << 48) | (((long) data[offset + i16 + 15] & 0xff) << 56); mix functions for k1 k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; h1 = Long.rotateLeft(h1, R2); h1 += h2; h1 = h1 * M + N1; mix functions for k2 k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; h2 = Long.rotateLeft(h2, R1); h2 += h1; h2 = h2 * M + N2; } tail long k1 = 0; long k2 = 0; final int tailStart = nblocks << 4; switch (length - tailStart) { case 15: k2 ^= (long) (data[offset + tailStart + 14] & 0xff) << 48; case 14: k2 ^= (long) (data[offset + tailStart + 13] & 0xff) << 40; case 13: k2 ^= (long) (data[offset + tailStart + 12] & 0xff) << 32; case 12: k2 ^= (long) (data[offset + tailStart + 11] & 0xff) << 24; case 11: k2 ^= (long) (data[offset + tailStart + 10] & 0xff) << 16; case 10: k2 ^= (long) (data[offset + tailStart + 9] & 0xff) << 8; case 9: k2 ^= data[offset + tailStart + 8] & 0xff; k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; case 8: k1 ^= (long) (data[offset + tailStart + 7] & 0xff) << 56; case 7: k1 ^= (long) (data[offset + tailStart + 6] & 0xff) << 48; case 6: k1 ^= (long) (data[offset + tailStart + 5] & 0xff) << 40; case 5: k1 ^= (long) (data[offset + tailStart + 4] & 0xff) << 32; case 4: k1 ^= (long) (data[offset + tailStart + 3] & 0xff) << 24; case 3: k1 ^= (long) (data[offset + tailStart + 2] & 0xff) << 16; case 2: k1 ^= (long) (data[offset + tailStart + 1] & 0xff) << 8; case 1: k1 ^= data[offset + tailStart] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; } finalization h1 ^= length; h2 ^= length; h1 += h2; h2 += h1; h1 = fmix64(h1); h2 = fmix64(h2); h1 += h2; h2 += h1; return new long[] { h1, h2 }; } 
private static int mix32 ( int k , int hash ) { k * = C1_32 ; k = Integer . rotateLeft ( k , R1_32 ) ; k * = C2_32 ; hash ^ = k ; return Integer . rotateLeft ( hash , R2_32 ) * M_32 + N_32 ; } 
private static int fmix32 ( final int length , int hash ) { hash ^ = length ; hash ^ = ( hash > > > 16 ) ; hash * = 0x85ebca6b ; hash ^ = ( hash > > > 13 ) ; hash * = 0xc2b2ae35 ; hash ^ = ( hash > > > 16 ) ; return hash ; } 
private static long fmix64 ( long h ) { h ^ = ( h > > > 33 ) ; h * = 0xff51afd7ed558ccdL ; h ^ = ( h > > > 33 ) ; h * = 0xc4ceb9fe1a85ec53L ; h ^ = ( h > > > 33 ) ; return h ; } 
public final void start ( final int hash ) { ailLen = otalLen = 0 ; his . hash = hash ; } 
public final void add ( final byte [ ] data , int offset , final int length ) { if ( length = = 0 ) { return ; } otalLen + = length ; if ( ailLen + length < 4 ) { System . arraycopy ( data , offset , ail , ailLen , length ) ; ailLen + = length ; return ; } int offset2 = 0 ; if ( ailLen > 0 ) { offset2 = ( 4 - ailLen ) ; int k = - 1 ; switch ( ailLen ) { case 1 : k = orBytes ( ail [ 0 ] , data [ offset ] , data [ offset + 1 ] , data [ offset + 2 ] ) ; break ; case 2 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , data [ offset ] , data [ offset + 1 ] ) ; break ; case 3 : k = orBytes ( ail [ 0 ] , ail [ 1 ] , ail [ 2 ] , data [ offset ] ) ; break ; default : hrow new AssertionError ( ailLen ) ; } mix functions k *= C1_32; k = Integer.rotateLeft(k, R1_32); k *= C2_32; hash ^= k; hash = Integer.rotateLeft(hash, R2_32) * M_32 + N_32; } final int length2 = length - offset2; offset += offset2; final int nblocks = length2 >> 2; for (int i = 0; i < nblocks; i++) { final int i_4 = (i << 2) + offset; int k = orBytes(data[i_4], data[i_4 + 1], data[i_4 + 2], data[i_4 + 3]); mix functions k *= C1_32; k = Integer.rotateLeft(k, R1_32); k *= C2_32; hash ^= k; hash = Integer.rotateLeft(hash, R2_32) * M_32 + N_32; } final int consumed = (nblocks << 2); tailLen = length2 - consumed; if (consumed == length2) { return; } System.arraycopy(data, offset + consumed, tail, 0, tailLen); } 
public final int end ( ) { int k1 = 0 ; switch ( ailLen ) { case 3 : k1 ^ = ail [ 2 ] < < 16 ; case 2 : k1 ^ = ail [ 1 ] < < 8 ; case 1 : k1 ^ = ail [ 0 ] ; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } finalization hash ^= totalLen; hash ^= (hash >>> 16); hash *= 0x85ebca6b; hash ^= (hash >>> 13); hash *= 0xc2b2ae35; hash ^= (hash >>> 16); return hash; } 
private static int orBytes ( final byte b1 , final byte b2 , final byte b3 , final byte b4 ) { return ( b1 & 0xff ) | ( ( b2 & 0xff ) < < 8 ) | ( ( b3 & 0xff ) < < 16 ) | ( ( b4 & 0xff ) < < 24 ) ; } 
public void estHash32ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length , 0x71b4954d ) ; 
public void estHash32ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final int hash = MurmurHash2 . hash32 ( input [ i ] , input [ i ] . length ) ; 
public void estHash32String ( ) { final int hash = MurmurHash2 . hash32 ( ext ) ; assertTrue ( hash = = 0xb3bf597e ) ; } 
public void estHash32StringIntInt ( ) { final int hash = MurmurHash2 . hash32 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0x4d666d90 ) ; } 
public void estHash64ByteArrayIntInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length , 0x344d1f5c ) ; 
public void estHash64ByteArrayInt ( ) { for ( int i = 0 ; i < input . length ; i + + ) { final long hash = MurmurHash2 . hash64 ( input [ i ] , input [ i ] . length ) ; 
public void estHash64String ( ) { final long hash = MurmurHash2 . hash64 ( ext ) ; assertTrue ( hash = = 0x0920e0c1b7eeb261l ) ; } 
public void estHash64StringIntInt ( ) { final long hash = MurmurHash2 . hash64 ( ext , 2 , ext . length ( ) - 4 ) ; assertTrue ( hash = = 0xa8b33145194985a2l ) ; } 
public void est32_String ( ) { Arrange final String origin = TEST; Act final int result = MurmurHash3.hash32(origin); Assert assertEquals(-436507231, result); } 
public void estHashCodeM3_64 ( ) { final byte [ ] origin = TEST . getBytes ( ) ; long hash = MurmurHash3 . hash64 ( origin , 0 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; } 
public void est64 ( ) { final int seed = 123 , iters = 1000000 ; final ByteBuffer SHORT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . SHORT_BYTES ) ; final ByteBuffer INT_BUFFER = ByteBuffer . allocate ( MurmurHash3 . INTEGER_BYTES ) ; final ByteBuffer LONG_BUFFER = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; final Random rdm = new Random ( seed ) ; for ( int i = 0 ; i < iters ; + + i ) { final long ln = rdm . nextLong ( ) ; 
public void est128_Short ( ) { Arrange final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.SHORT_BYTES); BUFFER.putShort(0, (short) 2); Act final long[] result = MurmurHash3.hash128(BUFFER.array()); Assert assertEquals(result.length, 2); assertEquals(8673501042631707204L, result[0]); assertEquals(491907755572407714L, result[1]); } 
public void est128_Int ( ) { Arrange final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.INTEGER_BYTES); BUFFER.putInt(0, 3); Act final long[] result = MurmurHash3.hash128(BUFFER.array()); Assert assertEquals(result.length, 2); assertEquals(2448828847287705405L, result[0]); assertEquals(-4568642211270719983L, result[1]); } 
public void est128_Long ( ) { Arrange final ByteBuffer BUFFER = ByteBuffer.allocate(MurmurHash3.LONG_BYTES); BUFFER.putLong(0, 8675309L); Act final long[] result = MurmurHash3.hash128(BUFFER.array()); Assert assertEquals(result.length, 2); assertEquals(2339756411022791995L, result[0]); assertEquals(8242951144762217305L, result[1]); } 
public void est128_Double ( ) { Arrange final ByteBuffer BUFFER = ByteBuffer.allocate(Double.SIZE / Byte.SIZE); BUFFER.putDouble(0, 456.987); Act final long[] result = MurmurHash3.hash128(BUFFER.array()); Assert assertEquals(result.length, 2); assertEquals(6877430437712399133L, result[0]); assertEquals(-8576421050167250536L, result[1]); } 
public void est128_String ( ) { Arrange final String origin = TEST; Act final long[] result = MurmurHash3.hash128(origin); Assert assertEquals(result.length, 2); assertEquals(6409160382500807310L, result[0]); assertEquals(-7835827609130513921L, result[1]); } 
public void estIncremental ( ) { final int seed = 123 , arraySize = 1023 ; final byte [ ] bytes = new byte [ arraySize ] ; new Random ( seed ) . nextBytes ( bytes ) ; final int expected = MurmurHash3 . hash32 ( bytes , arraySize ) ; final MurmurHash3 . IncrementalHash32 same = new IncrementalHash32 ( ) , diff = new IncrementalHash32 ( ) ; for ( int blockSize = 1 ; blockSize < = arraySize ; + + blockSize ) { final byte [ ] block = new byte [ blockSize ] ; 
public void estTwoLongOrdered ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estTwoLongRandom ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES * 2 ) ; final Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { for ( long j = 0 ; j < 1000 ; j + + ) { 
public void estSingleLongOrdered ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; for ( long i = 0 ; i < 1000 ; i + + ) { buffer . putLong ( 0 , i ) ; 
public void estSingleLongRandom ( ) { final ByteBuffer buffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; final Random random = new Random ( ) ; for ( long i = 0 ; i < 1000 ; i + + ) { final long x = random . nextLong ( ) ; 
public static int hash32 ( final long data1 , final long data2 ) { return hash32 ( data1 , data2 , DEFAULT_SEED ) ; } 
public static int hash32 ( final long data1 , final long data2 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data1 ) ; final long r1 = Long . reverseBytes ( data2 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; hash ^ = LONG_BYTES * 2 ; return fmix32 ( hash ) ; } 
public static int hash32 ( final long data ) { return hash32 ( data , DEFAULT_SEED ) ; } 
public static int hash32 ( final long data , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash ^ = LONG_BYTES ; return fmix32 ( hash ) ; } 
public static int hash32 ( final String data ) { final byte [ ] bytes = data . getBytes ( ) ; return hash32 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public static int hash32 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } tail ************ Note: This fails to apply masking using 0xff to the 3 remaining bytes. ************ final int index = offset + (nblocks << 2); int k1 = 0; switch (offset + length - index) { case 3: k1 ^= data[index + 2] << 16; case 2: k1 ^= data[index + 1] << 8; case 1: k1 ^= data[index]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } hash ^= length; return fmix32(hash); } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { ************ Note: This fails to apply masking using 0xffffffffL to the seed. ************ long hash = seed; final int nblocks = length >> 3; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 3); long k = getLittleEndianLong(data, index); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int index = offset + (nblocks << 3); switch (offset + length - index) { case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= ((long) data[index] & 0xff); k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; hash = fmix64(hash); return hash; } 
public static long [ ] hash128 ( final String data ) { final byte [ ] bytes = data . getBytes ( ) ; return hash128 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { ************ Note: This fails to apply masking using 0xffffffffL to the seed. ************ long h1 = seed; long h2 = seed; final int nblocks = length >> 4; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 4); long k1 = getLittleEndianLong(data, index); long k2 = getLittleEndianLong(data, index + 8); mix functions for k1 k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; h1 = Long.rotateLeft(h1, R2); h1 += h2; h1 = h1 * M + N1; mix functions for k2 k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; h2 = Long.rotateLeft(h2, R1); h2 += h1; h2 = h2 * M + N2; } tail long k1 = 0; long k2 = 0; final int index = offset + (nblocks << 4); switch (offset + length - index) { case 15: k2 ^= ((long) data[index + 14] & 0xff) << 48; case 14: k2 ^= ((long) data[index + 13] & 0xff) << 40; case 13: k2 ^= ((long) data[index + 12] & 0xff) << 32; case 12: k2 ^= ((long) data[index + 11] & 0xff) << 24; case 11: k2 ^= ((long) data[index + 10] & 0xff) << 16; case 10: k2 ^= ((long) data[index + 9] & 0xff) << 8; case 9: k2 ^= data[index + 8] & 0xff; k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; case 8: k1 ^= ((long) data[index + 7] & 0xff) << 56; case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; } finalization h1 ^= length; h2 ^= length; h1 += h2; h2 += h1; h1 = fmix64(h1); h2 = fmix64(h2); h1 += h2; h2 += h1; return new long[] { h1, h2 }; } 
private static int fmix32 ( int hash ) { hash ^ = ( hash > > > 16 ) ; hash * = 0x85ebca6b ; hash ^ = ( hash > > > 13 ) ; hash * = 0xc2b2ae35 ; hash ^ = ( hash > > > 16 ) ; return hash ; } 
private static long fmix64 ( long hash ) { hash ^ = ( hash > > > 33 ) ; hash * = 0xff51afd7ed558ccdL ; hash ^ = ( hash > > > 33 ) ; hash * = 0xc4ceb9fe1a85ec53L ; hash ^ = ( hash > > > 33 ) ; return hash ; } 
public final void start ( final int seed ) { Reset unprocessedLength = totalLen = 0; this.hash = seed; } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length = = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4 if (unprocessedLength + length < BLOCK_SIZE) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. int newOffset; int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new AssertionError("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public final int end ( ) { ************ Note: This fails to apply masking using 0xff to the 3 remaining bytes. ************ int k1 = 0; switch (unprocessedLength) { case 3: k1 ^= unprocessed[2] << 16; case 2: k1 ^= unprocessed[1] << 8; case 1: k1 ^= unprocessed[0]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } finalization hash ^= totalLen; return fmix32(hash); } 
private static int orBytes ( final byte b1 , final byte b2 , final byte b3 , final byte b4 ) { return ( b1 & 0xff ) | ( ( b2 & 0xff ) < < 8 ) | ( ( b3 & 0xff ) < < 16 ) | ( ( b4 & 0xff ) < < 24 ) ; } 
public void estHash32LongLong ( ) { final int length = MurmurHash3 . LONG_BYTES * 2 ; final ByteBuffer buffer = ByteBuffer . allocate ( length ) ; final long [ ] data = createLongTestData ( ) ; final int seed = MurmurHash3 . DEFAULT_SEED ; for ( final long i : data ) { for ( final long j : data ) { 
public void estHash32LongLongSeed ( ) { final int length = MurmurHash3 . LONG_BYTES * 2 ; final ByteBuffer buffer = ByteBuffer . allocate ( length ) ; final long [ ] data = createLongTestData ( ) ; final int seed = ThreadLocalRandom . current ( ) . nextInt ( ) ; for ( final long i : data ) { for ( final long j : data ) { 
public void estHash32Long ( ) { final int length = MurmurHash3 . LONG_BYTES ; final ByteBuffer buffer = ByteBuffer . allocate ( length ) ; final long [ ] data = createLongTestData ( ) ; final int seed = MurmurHash3 . DEFAULT_SEED ; for ( final long i : data ) { buffer . putLong ( 0 , i ) ; 
public void estHash32LongSeed ( ) { final int length = MurmurHash3 . LONG_BYTES ; final ByteBuffer buffer = ByteBuffer . allocate ( length ) ; final long [ ] data = createLongTestData ( ) ; final int seed = ThreadLocalRandom . current ( ) . nextInt ( ) ; for ( final long i : data ) { buffer . putLong ( 0 , i ) ; 
private static long [ ] createLongTestData ( ) { final long [ ] data = new long [ 100 ] ; Edge cases: data[0] = 0; data[1] = Long.MIN_VALUE; data[2] = Long.MAX_VALUE; data[3] = -1L; for (int i = 4; i < data.length; i++) { data[i] = ThreadLocalRandom.current().nextLong(); } return data; } 
public void estHash32 ( ) { mmh3.hash(bytes, 104729) Assert.assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = {-965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533,}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32WithLength ( ) { mmh3.hash(bytes, 104729) Assert.assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = {-965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533,}; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithLengthAndSeed ( ) { final int seed = - 42 ; mmh3.hash(bytes, -42) Assert.assertEquals(1693958011, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length, seed)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], -42), ',') final int[] answers = {192929823, 7537536, -99368911, -1261039957, -1719251056, -399594848, 372285930, -80756529, 1770924588, -1071759082, 1832217706, 1921413466, 1701676113, 675584253, 1620634486, 427719405, -973727623, 533209078, 136016960, 1947798330, 428635832, -1125743884, 793211715, -2068889169, -136818786, -720841364, -891446378, 1990860976, -710528065, -1602505694, -1493714677, 1911121524,}; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithOffsetLengthAndSeed ( ) { final int seed = - 42 ; final int offset = 13 ; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[13:x+13], -42), ',') final int[] answers = {192929823, -27171978, -1282326280, -816314453, -1176217753, -1904531247, 1962794233, -1302316624, -1151850323, -1464386748, -369299427, 972232488, 1747314487, 2137398916, 690986564, -1985866226, -678669121, -2123325690, -253319081, 46181235, 656058278, 1401175653, 1750113912, -1567219725, 2032742772, -2024269989, -305340794, 1161737942, -661265418, 172838872, -650122718, -1934812417,}; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
private static boolean negativeBytes ( byte [ ] bytes , int start , int length ) { for ( int i = start ; i < start + length ; i + + ) { if ( bytes [ i ] < 0 ) { return rue ; } } return false ; } 
public void estHash32String ( ) { final int seed = 104729 ; Range is end exclusive so this is random strings of length 1-10 final int minSize = 1; final int maxSize = 11; The Unicode Standard, Version 7.0, contains 112,956 characters final int codePoints = 112956; final char[] chars = new char[(maxSize - minSize) * 2]; for (int i = 0; i < 1000; i++) { int pos = 0; 
public void estHash32With1TrailingSignedByteIsInvalid ( ) { import mmh3 import numpy as np mmh3.hash(np.uint8([-1])) mmh3.hash(np.uint8([0, -1])) mmh3.hash(np.uint8([0, 0, -1])) mmh3.hash(np.uint8([-1, 0])) mmh3.hash(np.uint8([-1, 0, 0])) mmh3.hash(np.uint8([0, -1, 0])) Assert.assertNotEquals(-43192051, MurmurHash3.hash32(new byte[] {-1}, 0, 1, 0)); Assert.assertNotEquals(-582037868, MurmurHash3.hash32(new byte[] {0, -1}, 0, 2, 0)); Assert.assertNotEquals(922088087, MurmurHash3.hash32(new byte[] {0, 0, -1}, 0, 3, 0)); Assert.assertNotEquals(-1309567588, MurmurHash3.hash32(new byte[] {-1, 0}, 0, 2, 0)); Assert.assertNotEquals(-363779670, MurmurHash3.hash32(new byte[] {-1, 0, 0}, 0, 3, 0)); Assert.assertNotEquals(-225068062, MurmurHash3.hash32(new byte[] {0, -1, 0}, 0, 3, 0)); } 
public void estHash64 ( ) { final byte [ ] origin = TEST_HASH64 . getBytes ( ) ; final long hash = MurmurHash3 . hash64 ( origin ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash64WithOffsetAndLength ( ) { final byte [ ] origin = TEST_HASH64 . getBytes ( ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; final long hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash64WithPrimitives ( ) { final int iters = 1000 ; final ByteBuffer shortBuffer = ByteBuffer . allocate ( MurmurHash3 . SHORT_BYTES ) ; final ByteBuffer intBuffer = ByteBuffer . allocate ( MurmurHash3 . INTEGER_BYTES ) ; final ByteBuffer longBuffer = ByteBuffer . allocate ( MurmurHash3 . LONG_BYTES ) ; final byte [ ] shortBytes = shortBuffer . array ( ) ; final byte [ ] intBytes = intBuffer . array ( ) ; final byte [ ] longBytes = longBuffer . array ( ) ; for ( int i = 0 ; i < iters ; + + i ) { final long ln = ThreadLocalRandom . current ( ) . nextLong ( ) ; 
public void estHash64InNotEqualToHash128 ( ) { for ( int i = 0 ; i < 32 ; i + + ) { final byte [ ] bytes = Arrays . copyOf ( RANDOM_BYTES , i ) ; 
public void estHash128 ( ) { mmh3.hash64(bytes, 104729) Assert.assertArrayEquals(new long[] {-5614308156300707300L, -4165733009867452172L}, MurmurHash3.hash128(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 104729), ',') final long[][] answers = { {-7122613646888064702L, -8341524471658347240L}, {5659994275039884826L, -962335545730945195L}, {-7641758224504050283L, 4083131074855072837L}, {-9123564721037921804L, -3321998102976419641L}, {-7999620158275145567L, -7769992740725283391L}, {2419143614837736468L, -5474637306496300103L}, {7781591175729494939L, -9023178611551692650L}, {-3431043156265556247L, -6589990064676612981L}, {6315693694262400182L, -6219942557302821890L}, {-8249934145502892979L, -5646083202776239948L}, {7500109050276796947L, 5350477981718987260L}, {-6102338673930022315L, 3413065069102535261L}, {-6440683413407781313L, -2374360388921904146L}, {-3071236194203069122L, 7531604855739305895L}, {-7629408037856591130L, -4070301959951145257L}, {860008171111471563L, -9026008285726889896L}, {8059667613600971894L, 3236009436748930210L}, {1833746055900036985L, 1418052485321768916L}, {8161230977297923537L, -2668130155009407119L}, {3653111839268905630L, 5525563908135615453L}, {-9163026480602019754L, 6819447647029564735L}, {1102346610654592779L, -6881918401879761029L}, {-3109499571828331931L, -3782255367340446228L}, {-7467915444290531104L, 4704551260862209500L}, {1237530251176898868L, 6144786892208594932L}, {2347717913548230384L, -7461066668225718223L}, {-7963311463560798404L, 8435801462986138227L}, {-7493166089060196513L, 8163503673197886404L}, {6807249306539951962L, -1438886581269648819L}, {6752656991043418179L, 6334147827922066123L}, {-4534351735605790331L, -4530801663887858236L}, {-7886946241830957955L, -6261339648449285315L}, }; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128WithOffsetLengthAndSeed ( ) { Seed must be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = {{-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed)); 
public void estHash128String ( ) { final int seed = 104729 ; Range is end exclusive so this is random strings of length 1-10 final int minSize = 1; final int maxSize = 11; The Unicode Standard, Version 7.0, contains 112,956 characters final int codePoints = 112956; final char[] chars = new char[(maxSize - minSize) * 2]; for (int i = 0; i < 1000; i++) { int pos = 0; 
public void estIncrementalHash32 ( ) { final byte [ ] bytes = new byte [ 1023 ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; The seed does not matter for (final int seed : new int[] {-567, 0, 6787990}) { Cases are constructed to hit all edge cases of processing: 
private static void assertIncrementalHash32 ( byte [ ] bytes , int seed , int . . . blocks ) { int offset = 0 ; int otal = 0 ; final IncrementalHash32 inc = new IncrementalHash32 ( ) ; inc . start ( seed ) ; for ( final int block : blocks ) { otal + = block ; 
public final int end ( ) { Allow calling end() again after adding no data to return the same result. int result = hash; ************ Note: This fails to apply masking using 0xff to the 3 remaining bytes. ************ int k1 = 0; switch (unprocessedLength) { case 3: k1 ^= unprocessed[2] << 16; case 2: k1 ^= unprocessed[1] << 8; case 1: k1 ^= unprocessed[0]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
public static int hash32x86 ( final byte [ ] data ) { return hash32x86 ( data , 0 , data . length , 0 ) ; } 
public static int hash32x86 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } tail final int index = offset + (nblocks << 2); int k1 = 0; switch (offset + length - index) { case 3: k1 ^= (data[index + 2] & 0xff) << 16; case 2: k1 ^= (data[index + 1] & 0xff) << 8; case 1: k1 ^= (data[index] & 0xff); mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } hash ^= length; return fmix32(hash); } 
public final int end ( ) { Allow calling end() again after adding no data to return the same result. return finalise(hash, unprocessedLength, unprocessed, totalLen); } 
int finalise ( int hash , int unprocessedLength , byte [ ] unprocessed , int otalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { case 3 : k1 ^ = ( unprocessed [ 2 ] & 0xff ) < < 16 ; case 2 : k1 ^ = ( unprocessed [ 1 ] & 0xff ) < < 8 ; case 1 : k1 ^ = ( unprocessed [ 0 ] & 0xff ) ; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
int finalise ( int hash , int unprocessedLength , byte [ ] unprocessed , int otalLen ) { int result = hash ; ************ Note: This fails to apply masking using 0xff to the 3 remaining bytes. ************ int k1 = 0; switch (unprocessedLength) { case 3: k1 ^= unprocessed[2] << 16; case 2: k1 ^= unprocessed[1] << 8; case 1: k1 ^= unprocessed[0]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
public void estHash32WithTrailingNegativeSignedBytesIsInvalid ( ) { import mmh3 import numpy as np mmh3.hash(np.uint8([-1])) mmh3.hash(np.uint8([0, -1])) mmh3.hash(np.uint8([0, 0, -1])) mmh3.hash(np.uint8([-1, 0])) mmh3.hash(np.uint8([-1, 0, 0])) mmh3.hash(np.uint8([0, -1, 0])) Assert.assertNotEquals(-43192051, MurmurHash3.hash32(new byte[] {-1}, 0, 1, 0)); Assert.assertNotEquals(-582037868, MurmurHash3.hash32(new byte[] {0, -1}, 0, 2, 0)); Assert.assertNotEquals(922088087, MurmurHash3.hash32(new byte[] {0, 0, -1}, 0, 3, 0)); Assert.assertNotEquals(-1309567588, MurmurHash3.hash32(new byte[] {-1, 0}, 0, 2, 0)); Assert.assertNotEquals(-363779670, MurmurHash3.hash32(new byte[] {-1, 0, 0}, 0, 3, 0)); Assert.assertNotEquals(-225068062, MurmurHash3.hash32(new byte[] {0, -1, 0}, 0, 3, 0)); } 
public void esthash32x86 ( ) { Note: Default seed is zero. mmh3.hash(bytes, 0) Assert.assertEquals(1546271276, MurmurHash3.hash32x86(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 0), ',') final int[] answers = {0, -1353253853, 915381745, -734983419, 1271125654, -1042265893, -1204521619, 735845843, 138310876, -1918938664, 1399647898, -1126342309, 2067593280, 1220975287, 1941281084, -1289513180, 942412060, -618173583, -269546647, -1645631262, 1162379906, -1960125577, -1856773195, 1980513522, 1174612855, 905810751, 1044578220, -1758486689, -491393913, 839836946, -435014415, 2044851178,}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32x86WithOffsetLengthAndSeed ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). final int seed = -42; final int offset = 13; final int[] answers = {192929823, -27171978, -1282326280, -816314453, -1176217753, -1904531247, 1962794233, -1302316624, -1151850323, -1464386748, -369299427, 972232488, 1747314487, 2137398916, 690986564, -1985866226, -678669121, -2123325690, -253319081, 46181235, 656058278, 1401175653, 1750113912, -1567219725, 2032742772, -2024269989, -305340794, 1161737942, -661265418, 172838872, -650122718, -1934812417,}; for (int i = 0; i < answers.length; i++) { Assert.assertEquals(answers[i], MurmurHash3.hash32x86(RANDOM_BYTES, offset, i, seed)); 
public void estHash32x86WithTrailingNegativeSignedBytes ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). This test uses assertEquals(). Assert.assertEquals(-43192051, MurmurHash3.hash32x86(new byte[] {-1}, 0, 1, 0)); Assert.assertEquals(-582037868, MurmurHash3.hash32x86(new byte[] {0, -1}, 0, 2, 0)); Assert.assertEquals(922088087, MurmurHash3.hash32x86(new byte[] {0, 0, -1}, 0, 3, 0)); Assert.assertEquals(-1309567588, MurmurHash3.hash32x86(new byte[] {-1, 0}, 0, 2, 0)); Assert.assertEquals(-363779670, MurmurHash3.hash32x86(new byte[] {-1, 0, 0}, 0, 3, 0)); Assert.assertEquals(-225068062, MurmurHash3.hash32x86(new byte[] {0, -1, 0}, 0, 3, 0)); } 
public void estIncrementalHash32x86 ( ) { final byte [ ] bytes = new byte [ 1023 ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; The seed does not matter for (final int seed : new int[] {-567, 0, 6787990}) { Cases are constructed to hit all edge cases of processing: 
private static void assertIncrementalHash32x86 ( byte [ ] bytes , int seed , int . . . blocks ) { int offset = 0 ; int otal = 0 ; final IncrementalHash32x86 inc = new IncrementalHash32x86 ( ) ; inc . start ( seed ) ; for ( final int block : blocks ) { otal + = block ; 
public static long [ ] hash128x64 ( final byte [ ] data ) { return hash128x64 ( data , 0 , data . length , 0 ) ; } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { ************ Note: This fails to apply masking using 0xffffffffL to the seed. ************ return hash128x64(data, offset, length, seed); } 
public static long [ ] hash128x64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Use an unsigned 32-bit integer as the seed return hash128x64(data, offset, length, seed & 0xffffffffL); } 
private static long [ ] hash128x64 ( final byte [ ] data , final int offset , final int length , final long seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 4); long k1 = getLittleEndianLong(data, index); long k2 = getLittleEndianLong(data, index + 8); mix functions for k1 k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; h1 = Long.rotateLeft(h1, R2); h1 += h2; h1 = h1 * M + N1; mix functions for k2 k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; h2 = Long.rotateLeft(h2, R1); h2 += h1; h2 = h2 * M + N2; } tail long k1 = 0; long k2 = 0; final int index = offset + (nblocks << 4); switch (offset + length - index) { case 15: k2 ^= ((long) data[index + 14] & 0xff) << 48; case 14: k2 ^= ((long) data[index + 13] & 0xff) << 40; case 13: k2 ^= ((long) data[index + 12] & 0xff) << 32; case 12: k2 ^= ((long) data[index + 11] & 0xff) << 24; case 11: k2 ^= ((long) data[index + 10] & 0xff) << 16; case 10: k2 ^= ((long) data[index + 9] & 0xff) << 8; case 9: k2 ^= data[index + 8] & 0xff; k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; case 8: k1 ^= ((long) data[index + 7] & 0xff) << 56; case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; } finalization h1 ^= length; h2 ^= length; h1 += h2; h2 += h1; h1 = fmix64(h1); h2 = fmix64(h2); h1 += h2; h2 += h1; return new long[] { h1, h2 }; } 
public void estHash128x64 ( ) { Note: Default seed is zero. mmh3.hash64(bytes, 0) Assert.assertArrayEquals(new long[] {1972113670104592209L, 5171809317673151911L}, MurmurHash3.hash128x64(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 0), ',') final long[][] answers = {{0L, 0L}, {-2808653841080383123L, -2531784594030660343L}, {-1284575471001240306L, -8226941173794461820L}, {1645529003294647142L, 4109127559758330427L}, {-4117979116203940765L, -8362902660322042742L}, {2559943399590596158L, 4738005461125350075L}, {-1651760031591552651L, -5386079254924224461L}, {-6208043960690815609L, 7862371518025305074L}, {-5150023478423646337L, 8346305334874564507L}, {7658274117911906792L, -4962914659382404165L}, {1309458104226302269L, 570003296096149119L}, {7440169453173347487L, -3489345781066813740L}, {-5698784298612201352L, 3595618450161835420L}, {-3822574792738072442L, 6878153771369862041L}, {3705084673301918328L, 3202155281274291907L}, {-6797166743928506931L, -4447271093653551597L}, {5240533565589385084L, -5575481185288758327L}, {-8467620131382649428L, -6450630367251114468L}, {3632866961828686471L, -5957695976089313500L}, {-6450283648077271139L, -7908632714374518059L}, {226350826556351719L, 8225586794606475685L}, {-2382996224496980401L, 2188369078123678011L}, {-1337544762358780825L, 7004253486151757299L}, {2889033453638709716L, -4099509333153901374L}, {-8644950936809596954L, -5144522919639618331L}, {-5628571865255520773L, -839021001655132087L}, {-5226774667293212446L, -505255961194269502L}, {1337107025517938142L, 3260952073019398505L}, {9149852874328582511L, 1880188360994521535L}, {-4035957988359881846L, -7709057850766490780L}, {-3842593823306330815L, 3805147088291453755L}, {4030161393619149616L, -2813603781312455238L},}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128x64WithOffsetLengthAndSeed ( ) { Seed can be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = {{-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed)); } Seed can be negative final int seed2 = -42; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], -42), ',') final long[][] answers2 = {{7182599573337898253L, -6490979146667806054L}, {-461284136738605467L, 7073284964362976233L}, {-3090354666589400212L, 2978755180788824810L}, {5052807367580803906L, -4497188744879598335L}, {5003711854877353474L, -6616808651483337088L}, {2043501804923817748L, -760668448196918637L}, {6813003268375229932L, -1818545210475363684L}, {4488070015393027916L, 8520186429078977003L}, {4709278711722456062L, -2262080641289046033L}, {-5944514262756048380L, 5968714500873552518L}, {-2304397529301122510L, 6451500469518446488L}, {-1054078041081348909L, -915114408909600132L}, {1300471646869277217L, -399493387666437046L}, {-2821780479886030222L, -9061571187511294733L}, {8005764841242557505L, 4135287855434326053L}, {318307346637037498L, -5355856739901286522L}, {3380719536119187025L, 1890890833937151467L}, {2691044185935730001L, 7963546423617895734L}, {-5277462388534000227L, 3613853764390780573L}, {8504421722476165699L, 2058020162708103700L}, {-6578421288092422241L, 3311200163790829579L}, {-5915037218487974215L, -7385137075895184179L}, {659642911937398022L, 854071824595671049L}, {-7007237968866727198L, 1372258010932080058L}, {622891376282772539L, -4140783491297489868L}, {8357110718969014985L, -4737117827581590306L}, {2208857857926305405L, -8360240839768465042L}, {858120048221036376L, -5822288789703639119L}, {-1988334009458340679L, 1262479472434068698L}, {-8580307083590783934L, 3634449965473715778L}, {6705664584730187559L, 5192304951463791556L}, {-6426410954037604142L, -1579122709247558101L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers2[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed2)); 
private static int [ ] createRandomBlocks ( int maxLength ) { int [ ] blocks = new int [ 20 ] ; int count = 0 ; int length = 0 ; while ( count < blocks . length & & length < maxLength ) { range of 1 to 8 for up to two 4 byte blocks final int size = ThreadLocalRandom.current().nextInt(1, 9); blocks[count++] = size; length += size; } return Arrays.copyOf(blocks, count); } 
public void estHash32LongLong ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = MurmurHash3.LONG_BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32LongLongSeed ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = MurmurHash3.LONG_BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32Long ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = MurmurHash3.LONG_BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash32LongSeed ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = MurmurHash3.LONG_BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash64WithPrimitives ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int iters = 1000; final ByteBuffer shortBuffer = ByteBuffer.allocate(MurmurHash3.SHORT_BYTES); final ByteBuffer intBuffer = ByteBuffer.allocate(MurmurHash3.INTEGER_BYTES); final ByteBuffer longBuffer = ByteBuffer.allocate(MurmurHash3.LONG_BYTES); final byte[] shortBytes = shortBuffer.array(); final byte[] intBytes = intBuffer.array(); final byte[] longBytes = longBuffer.array(); for (int i = 0; i < iters; ++i) { final long ln = ThreadLocalRandom.current().nextLong(); 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { 'm' and 'r' are mixing constants generated offline. They're not really 'magic', they just happen to work well. final int m = 0x5bd1e995; final int r = 24; Initialize the hash to a random value int h = seed ^ length; Mix 4 bytes at a time into the hash final int nblocks = length >> 2; body for (int i = 0; i < nblocks; i++) { final int index = (i << 2); int k = getLittleEndianInt(data, index); k *= m; k ^= k >>> r; k *= m; h *= m; h ^= k; } Handle the last few bytes of the input array final int index = (nblocks << 2); switch (length - index) { case 3: h ^= (data[index + 2] & 0xff) << 16; case 2: h ^= (data[index + 1] & 0xff) << 8; case 1: h ^= (data[index] & 0xff); h *= m; } Do a few final mixes of the hash to ensure the last few bytes are well-incorporated. h ^= h >>> 13; h *= m; h ^= h >>> 15; return h; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { final long m = 0xc6a4a7935bd1e995L ; final int r = 47 ; long h = ( seed & 0xffffffffl ) ^ ( length * m ) ; final int nblocks = length > > 3 ; body for (int i = 0; i < nblocks; i++) { final int index = (i << 3); long k = getLittleEndianLong(data, index); k *= m; k ^= k >>> r; k *= m; h ^= k; h *= m; } final int index = (nblocks << 3); switch (length - index) { case 7: h ^= ((long) data[index + 6] & 0xff) << 48; case 6: h ^= ((long) data[index + 5] & 0xff) << 40; case 5: h ^= ((long) data[index + 4] & 0xff) << 32; case 4: h ^= ((long) data[index + 3] & 0xff) << 24; case 3: h ^= ((long) data[index + 2] & 0xff) << 16; case 2: h ^= ((long) data[index + 1] & 0xff) << 8; case 1: h ^= ((long) data[index] & 0xff); h *= m; } h ^= h >>> r; h *= m; h ^= h >>> r; return h; } 
public void estHash32String ( ) { final int hash = MurmurHash2 . hash32 ( ext ) ; Assert . assertEquals ( 0xb3bf597e , hash ) ; } 
public void estHash32StringIntInt ( ) { final int hash = MurmurHash2 . hash32 ( ext , 2 , ext . length ( ) - 4 ) ; Assert . assertEquals ( 0x4d666d90 , hash ) ; } 
public void estHash64String ( ) { final long hash = MurmurHash2 . hash64 ( ext ) ; Assert . assertEquals ( 0x0920e0c1b7eeb261L , hash ) ; } 
public void estHash64StringIntInt ( ) { final long hash = MurmurHash2 . hash64 ( ext , 2 , ext . length ( ) - 4 ) ; Assert . assertEquals ( 0xa8b33145194985a2L , hash ) ; } 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { Initialize the hash to a random value int h = seed ^ length; Mix 4 bytes at a time into the hash final int nblocks = length >> 2; body for (int i = 0; i < nblocks; i++) { final int index = (i << 2); int k = getLittleEndianInt(data, index); k *= M32; k ^= k >>> R32; k *= M32; h *= M32; h ^= k; } Handle the last few bytes of the input array final int index = (nblocks << 2); switch (length - index) { case 3: h ^= (data[index + 2] & 0xff) << 16; case 2: h ^= (data[index + 1] & 0xff) << 8; case 1: h ^= (data[index] & 0xff); h *= M32; } Do a few final mixes of the hash to ensure the last few bytes are well-incorporated. h ^= h >>> 13; h *= M32; h ^= h >>> 15; return h; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { long h = ( seed & 0xffffffffL ) ^ ( length * M64 ) ; final int nblocks = length > > 3 ; body for (int i = 0; i < nblocks; i++) { final int index = (i << 3); long k = getLittleEndianLong(data, index); k *= M64; k ^= k >>> R64; k *= M64; h ^= k; h *= M64; } final int index = (nblocks << 3); switch (length - index) { case 7: h ^= ((long) data[index + 6] & 0xff) << 48; case 6: h ^= ((long) data[index + 5] & 0xff) << 40; case 5: h ^= ((long) data[index + 4] & 0xff) << 32; case 4: h ^= ((long) data[index + 3] & 0xff) << 24; case 3: h ^= ((long) data[index + 2] & 0xff) << 16; case 2: h ^= ((long) data[index + 1] & 0xff) << 8; case 1: h ^= ((long) data[index] & 0xff); h *= M64; } h ^= h >>> R64; h *= M64; h ^= h >>> R64; return h; } 
public void estHash128x64WithOffsetLengthAndSeed ( ) { Seed can be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = {{-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed)); 
public void estHash128x64WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], -42), ',') final long[][] answers = {{7182599573337898253L, -6490979146667806054L}, {-461284136738605467L, 7073284964362976233L}, {-3090354666589400212L, 2978755180788824810L}, {5052807367580803906L, -4497188744879598335L}, {5003711854877353474L, -6616808651483337088L}, {2043501804923817748L, -760668448196918637L}, {6813003268375229932L, -1818545210475363684L}, {4488070015393027916L, 8520186429078977003L}, {4709278711722456062L, -2262080641289046033L}, {-5944514262756048380L, 5968714500873552518L}, {-2304397529301122510L, 6451500469518446488L}, {-1054078041081348909L, -915114408909600132L}, {1300471646869277217L, -399493387666437046L}, {-2821780479886030222L, -9061571187511294733L}, {8005764841242557505L, 4135287855434326053L}, {318307346637037498L, -5355856739901286522L}, {3380719536119187025L, 1890890833937151467L}, {2691044185935730001L, 7963546423617895734L}, {-5277462388534000227L, 3613853764390780573L}, {8504421722476165699L, 2058020162708103700L}, {-6578421288092422241L, 3311200163790829579L}, {-5915037218487974215L, -7385137075895184179L}, {659642911937398022L, 854071824595671049L}, {-7007237968866727198L, 1372258010932080058L}, {622891376282772539L, -4140783491297489868L}, {8357110718969014985L, -4737117827581590306L}, {2208857857926305405L, -8360240839768465042L}, {858120048221036376L, -5822288789703639119L}, {-1988334009458340679L, 1262479472434068698L}, {-8580307083590783934L, 3634449965473715778L}, {6705664584730187559L, 5192304951463791556L}, {-6426410954037604142L, -1579122709247558101L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed)); 
private static void validateCharacter ( final long emptyBitsMask , final Context context ) { Use the long bit work area if ((context.lbitWorkArea & emptyBitsMask) != 0) { throw new IllegalArgumentException( 
private static void validateCharacter ( final int emptyBitsMask , final Context context ) { if ( ( context . ibitWorkArea & emptyBitsMask ) ! = 0 ) { hrow new IllegalArgumentException ( 
public void estBase32DecodingOfTrailing10Bits ( ) { assertBase32DecodingOfTrailingBits ( 10 ) ; } 
public void estBase32DecodingOfTrailing15Bits ( ) { assertBase32DecodingOfTrailingBits ( 15 ) ; } 
public void estBase32DecodingOfTrailing20Bits ( ) { assertBase32DecodingOfTrailingBits ( 20 ) ; } 
public void estBase32DecodingOfTrailing25Bits ( ) { assertBase32DecodingOfTrailingBits ( 25 ) ; } 
public void estBase32DecodingOfTrailing30Bits ( ) { assertBase32DecodingOfTrailingBits ( 30 ) ; } 
public void estBase32DecodingOfTrailing35Bits ( ) { assertBase32DecodingOfTrailingBits ( 35 ) ; } 
private static void assertBase32DecodingOfTrailingBits ( int nbits ) { final Base32 codec = new Base32 ( ) ; Create the encoded bytes. The first characters must be valid so fill with 'zero'. final byte[] encoded = new byte[nbits / 5]; Arrays.fill(encoded, ENCODE_TABLE[0]); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Enumerate all 32 possible final characters in the last position final int last = encoded.length - 1; for (int i = 0; i < 32; i++) { encoded[last] = ENCODE_TABLE[i]; 
public void estBase64DecodingOfTrailing12Bits ( ) { assertBase64DecodingOfTrailingBits ( 12 ) ; } 
public void estBase64DecodingOfTrailing18Bits ( ) { assertBase64DecodingOfTrailingBits ( 18 ) ; } 
private static void assertBase64DecodingOfTrailingBits ( int nbits ) { final Base64 codec = new Base64 ( ) ; Create the encoded bytes. The first characters must be valid so fill with 'zero'. final byte[] encoded = new byte[nbits / 6]; Arrays.fill(encoded, STANDARD_ENCODE_TABLE[0]); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Enumerate all 64 possible final characters in the last position final int last = encoded.length - 1; for (int i = 0; i < 64; i++) { encoded[last] = STANDARD_ENCODE_TABLE[i]; 
private static byte [ ] resizeBuffer ( final Context context , final int minCapacity ) { Overflow-conscious code treats the min and new capacity as unsigned. final int oldCapacity = context.buffer.length; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR; if (compareUnsigned(newCapacity, minCapacity) < 0) { newCapacity = minCapacity; } if (compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) { newCapacity = createPositiveCapacity(minCapacity); } final byte[] b = new byte[newCapacity]; System.arraycopy(context.buffer, 0, b, 0, context.buffer.length); context.buffer = b; return b; } 
private static int compareUnsigned ( int x , int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } 
private static int createPositiveCapacity ( int minCapacity ) { if ( minCapacity < 0 ) { overflow throw new OutOfMemoryError("Unable to allocate array size: " + (minCapacity & 0xffffffffL)); } This is called when we require buffer expansion to a very big array. Use the conservative maximum buffer size if possible, otherwise the biggest required. Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE. This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full Integer.MAX_VALUE length array. The result is that we may have to allocate an array of this size more than once if the capacity must be expanded again. return (minCapacity > MAX_BUFFER_SIZE) ? minCapacity : 
protected byte [ ] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ getDefaultBufferSize ( ) ] ; context . pos = 0 ; context . readPos = 0 ; Overflow-conscious: x + y > z == x + y - z > 0 } else if (context.pos + size - context.buffer.length > 0) { return resizeBuffer(context, context.pos + size); } return context.buffer; } 
public void estCodec265 ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 4 output bytes per 3 input bytes plus the trailing bytes padded to a block size of 4. int blocks = (int) Math.ceil(size1GiB / 3.0); final int expectedLength = 4 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base64.encodeBase64(bytes); assertEquals(expectedLength, encoded.length); } 
public void estEnsureBufferSize ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; Assert . assertNull ( " Initial buffer should be null " , context . buffer ) ; Test initialisation context.pos = 76979; context.readPos = 273; ncodec.ensureBufferSize(0, context); Assert.assertNotNull("buffer should be initialised", context.buffer); Assert.assertEquals("buffer should be initialised to default size", ncodec.getDefaultBufferSize(), context.buffer.length); Assert.assertEquals("context position", 0, context.pos); Assert.assertEquals("context read position", 0, context.readPos); Test when no expansion is required ncodec.ensureBufferSize(1, context); Assert.assertEquals("buffer should not expand unless required", ncodec.getDefaultBufferSize(), context.buffer.length); Test expansion int length = context.buffer.length; context.pos = length; int extra = 1; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand", context.buffer.length >= length + extra); Test expansion beyond double the buffer size. Hits the edge case where the required capacity is more than the default expansion. length = context.buffer.length; context.pos = length; extra = length * 10; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand beyond double capacity", context.buffer.length >= length + extra); } 
public void estEnsureBufferSizeExpandsToMaxBufferSize ( ) { assertEnsureBufferSizeExpandsToMaxBufferSize ( false ) ; } 
public void estEnsureBufferSizeExpandsToBeyondMaxBufferSize ( ) { assertEnsureBufferSizeExpandsToMaxBufferSize ( rue ) ; } 
private static void assertEnsureBufferSizeExpandsToMaxBufferSize ( boolean exceedMaxBufferSize ) { This test is memory hungry. By default expansion will double the buffer size. Using a buffer that must be doubled to get close to 2GiB requires at least 3GiB of memory for the test (1GiB existing + 2GiB new). As a compromise we use an empty buffer and rely on the expansion switching to the minimum required capacity if doubling is not enough. To effectively use a full buffer of ~1GiB change the following for: 1 << 30. Setting to zero has the lowest memory footprint for this test. final int length = 0; final long presumableFreeMemory = getPresumableFreeMemory(); 2GiB + 32 KiB + length 2GiB: Buffer to allocate 32KiB: Some head room length: Existing buffer final long estimatedMemory = (1L << 31) + 32 * 1024 + length; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final int max = Integer.MAX_VALUE - 8; Check the conservative maximum buffer size can actually be exceeded by the VM otherwise the test is not valid. if (exceedMaxBufferSize) { assumeCanAllocateBufferSize(max + 1); Free-memory. This may not be necessary as the byte[] is now out of scope System.gc(); } final BaseNCodec ncodec = new NoOpBaseNCodec(); final Context context = new Context(); Allocate the initial buffer context.buffer = new byte[length]; context.pos = length; Compute the extra to reach or exceed the max buffer size int extra = max - length; if (exceedMaxBufferSize) { extra++; } ncodec.ensureBufferSize(extra, context); Assert.assertTrue(context.buffer.length >= length + extra); } 
private static void assumeCanAllocateBufferSize ( int size ) { byte [ ] bytes = null ; ry { bytes = new byte [ size ] ; } catch ( OutOfMemoryError ignore ) { ignore } Assume.assumeTrue("Cannot allocate array of size: " + size, bytes != null); } 
public void estEnsureBufferSizeThrowsOnOverflow ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; final int length = 10 ; context . buffer = new byte [ length ] ; context . pos = length ; final int extra = Integer . MAX_VALUE ; ncodec . ensureBufferSize ( extra , context ) ; } 
void encode ( byte [ ] pArray , int i , int length , Context context ) { } @Override void decode ( byte [ ] pArray , int i , int length , Context context ) { } @Override protected boolean isInAlphabet ( byte value ) { return false ; } } } 
void decode ( byte [ ] pArray , int i , int length , Context context ) { } @Override protected boolean isInAlphabet ( byte value ) { return false ; } } } 
public void estCodec265 ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 4 output bytes per 3 input bytes plus the trailing bytes padded to a block size of 4. int blocks = (int) Math.ceil(size1GiB / 3.0); final int expectedLength = 4 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base64.encodeBase64(bytes); assertEquals(expectedLength, encoded.length); } 
public static byte [ ] digest ( final MessageDigest messageDigest , final RandomAccessFile data ) hrows IOException { return updateDigest ( messageDigest , data ) . digest ( ) ; } 
private static MessageDigest updateDigest ( final MessageDigest digest , final FileChannel data ) hrows IOException { final ByteBuffer buffer = ByteBuffer . allocate ( STREAM_BUFFER_LENGTH ) ; while ( data . read ( buffer ) > 0 ) { buffer . flip ( ) ; digest . update ( buffer ) ; buffer . clear ( ) ; } return digest ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final RandomAccessFile data ) hrows IOException { return updateDigest ( digest , data . getChannel ( ) ) ; } 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = File . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final FileOutputStream fos = new FileOutputStream ( estFile ) ) { fos . write ( estData ) ; } estRandomAccessFile = File . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final FileOutputStream fos = new FileOutputStream ( estRandomAccessFile ) ) { fos . write ( estData ) ; } estRandomAccessFileWrapper = new RandomAccessFile ( estRandomAccessFile , " rw " ) ; } 
public void earDown ( ) { if ( ! estFile . delete ( ) ) { estFile . deleteOnExit ( ) ; } if ( ! estRandomAccessFile . delete ( ) ) { estRandomAccessFile . deleteOnExit ( ) ; 
public void estNonBlockingDigestRandomAccessFile ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final byte [ ] expected = digestTestData ( ) ; Assert . assertArrayEquals ( expected , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestRandomAccessFile ( ) ) ) ; Assert . assertArrayEquals ( expected , DigestUtils . digest ( 
public void estNonBlockingDigestRandomAccessFile ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final byte [ ] expected = digestTestData ( ) ; Assert . assertArrayEquals ( expected , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestRandomAccessFile ( ) ) ) ; getTestRandomAccessFile ( ) . seek ( 0 ) ; Assert . assertArrayEquals ( expected , DigestUtils . digest ( 
private static byte [ ] oByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining ( ) ; Use the underlying buffer if possible if (byteBuffer.hasArray()) { final byte[] byteArray = byteBuffer.array(); if (remaining == byteArray.length) { byteBuffer.position(remaining); return byteArray; } } Copy the bytes final byte[] byteArray = new byte[remaining]; byteBuffer.get(byteArray); return byteArray; } 
private void checkDecodeHexByteBufferOddCharacters ( final ByteBuffer data ) { ry { new Hex ( ) . decode ( data ) ; 
public void estDecodeByteBufferAllocatedButEmpty ( ) hrows DecoderException { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertTrue(Arrays.equals(new byte[0], new Hex().decode(bb))); } 
public void estDecodeByteBufferOddCharacters ( ) { checkDecodeHexByteBufferOddCharacters ( ByteBuffer . wrap ( new byte [ ] { 65 } ) ) ; } 
public void estDecodeByteBufferWithLimitOddCharacters ( ) { final ByteBuffer buffer = allocate ( 10 ) ; buffer . put ( 1 , ( byte ) 65 ) ; buffer . position ( 1 ) ; buffer . limit ( 2 ) ; checkDecodeHexByteBufferOddCharacters ( buffer ) ; } 
public void estDecodeByteBufferWithLimit ( ) hrows DecoderException { final ByteBuffer bb = StringUtils . getByteBufferUtf8 ( " 000102030405060708090a0b0c0d0e0f " ) ; final byte [ ] expected = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ; Test pairs of bytes for (int i = 0; i < 15; i++) { bb.position(i * 2); 
public void estEncodeByteBufferAllocatedButEmpty ( ) { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertTrue(Arrays.equals(new byte[0], new Hex().encode(bb))); } 
public void estEncodeHex_ByteBufferWithLimit ( ) { final ByteBuffer bb = ByteBuffer . wrap ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ) ; final String expected = " 000102030405060708090a0b0c0d0e0f " ; Test pairs of bytes for (int i = 0; i < 15; i++) { bb.position(i); 
public void estEncodeHexByteString_ByteBufferOfZeroesWithLimit ( ) { final ByteBuffer bb = allocate ( 36 ) ; bb . limit ( 3 ) ; assertEquals ( " 000000 " , Hex . encodeHexString ( bb ) ) ; bb . position ( 1 ) ; bb . limit ( 3 ) ; assertEquals ( " 0000 " , Hex . encodeHexString ( bb ) ) ; } 
public void estEncodeHexByteString_ByteBufferWithLimitBoolean_ToLowerCase ( ) { final ByteBuffer bb = allocate ( 4 ) ; bb . put ( 1 , ( byte ) 10 ) ; bb . position ( 1 ) ; bb . limit ( 2 ) ; assertEquals ( " 0a " , Hex . encodeHexString ( bb , rue ) ) ; } 
public void estEncodeHexByteString_ByteBufferWithLimitBoolean_ToUpperCase ( ) { final ByteBuffer bb = allocate ( 4 ) ; bb . put ( 1 , ( byte ) 10 ) ; bb . position ( 1 ) ; bb . limit ( 2 ) ; assertEquals ( " 0A " , Hex . encodeHexString ( bb , false ) ) ; } 
private static byte [ ] oByteArray ( final ByteBuffer byteBuffer ) { final int remaining = byteBuffer . remaining ( ) ; Use the underlying buffer if possible if (byteBuffer.hasArray()) { final byte[] byteArray = byteBuffer.array(); if (remaining == byteArray.length) { byteBuffer.position(remaining); return byteArray; } } Copy the bytes final byte[] byteArray = new byte[remaining]; byteBuffer.get(byteArray); return byteArray; } 
public void estDecodeByteBufferAllocatedButEmpty ( ) hrows DecoderException { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertTrue(Arrays.equals(new byte[0], new Hex().decode(bb))); assertEquals(0, bb.remaining()); } 
public void estDecodeByteBufferOddCharacters ( ) { final ByteBuffer bb = allocate ( 1 ) ; bb . put ( ( byte ) 65 ) ; bb . flip ( ) ; checkDecodeHexByteBufferOddCharacters ( bb ) ; } 
public void estDecodeByteBufferWithLimitOddCharacters ( ) { final ByteBuffer bb = allocate ( 10 ) ; bb . put ( 1 , ( byte ) 65 ) ; bb . position ( 1 ) ; bb . limit ( 2 ) ; checkDecodeHexByteBufferOddCharacters ( bb ) ; } 
public void estEncodeByteBufferAllocatedButEmpty ( ) { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertTrue(Arrays.equals(new byte[0], new Hex().encode(bb))); assertEquals(0, bb.remaining()); } 
public void estEncodeHexByteBufferHelloWorldLowerCaseHex ( ) { final ByteBuffer b = StringUtils . getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; Default lower-case actual = Hex.encodeHex(b); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); lower-case b.flip(); actual = Hex.encodeHex(b, true); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); upper-case b.flip(); actual = Hex.encodeHex(b, false); assertEquals(expected.toUpperCase(), new String(actual)); assertEquals(0, b.remaining()); } 
public void estEncodeHexByteBufferHelloWorldUpperCaseHex ( ) { final ByteBuffer b = StringUtils . getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; Default lower-case actual = Hex.encodeHex(b); assertEquals(expected.toLowerCase(), new String(actual)); assertEquals(0, b.remaining()); lower-case b.flip(); actual = Hex.encodeHex(b, true); assertEquals(expected.toLowerCase(), new String(actual)); assertEquals(0, b.remaining()); upper-case b.flip(); actual = Hex.encodeHex(b, false); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); } 
public void estEncodeHex_ByteBufferWithLimit ( ) { final ByteBuffer bb = allocate ( 16 ) ; for ( int i = 0 ; i < 16 ; i + + ) { bb . put ( ( byte ) i ) ; } bb . flip ( ) ; final String expected = " 000102030405060708090a0b0c0d0e0f " ; Test pairs of bytes for (int i = 0; i < 15; i++) { bb.position(i); 
public void estEncodeHexByteString_ByteBufferOfZeroesWithLimit ( ) { final ByteBuffer bb = allocate ( 36 ) ; bb . limit ( 3 ) ; assertEquals ( " 000000 " , Hex . encodeHexString ( bb ) ) ; assertEquals ( 0 , bb . remaining ( ) ) ; bb . position ( 1 ) ; bb . limit ( 3 ) ; assertEquals ( " 0000 " , Hex . encodeHexString ( bb ) ) ; assertEquals ( 0 , bb . remaining ( ) ) ; } 
public void estEncodeHexByteString_ByteBufferBoolean_ToLowerCase ( ) { final ByteBuffer bb = allocate ( 1 ) ; bb . put ( ( byte ) 10 ) ; bb . flip ( ) ; assertEquals ( " 0a " , Hex . encodeHexString ( bb , rue ) ) ; } 
public void estEncodeHexByteString_ByteBufferBoolean_ToUpperCase ( ) { final ByteBuffer bb = allocate ( 1 ) ; bb . put ( ( byte ) 10 ) ; bb . flip ( ) ; assertEquals ( " 0A " , Hex . encodeHexString ( bb , false ) ) ; } 
public void estEncodeHexByteString_ByteBufferWithLimitBoolean_ToLowerCase ( ) { final ByteBuffer bb = allocate ( 4 ) ; bb . put ( 1 , ( byte ) 10 ) ; bb . position ( 1 ) ; bb . limit ( 2 ) ; assertEquals ( " 0a " , Hex . encodeHexString ( bb , rue ) ) ; assertEquals ( 0 , bb . remaining ( ) ) ; } 
public void estEncodeHexByteString_ByteBufferWithLimitBoolean_ToUpperCase ( ) { final ByteBuffer bb = allocate ( 4 ) ; bb . put ( 1 , ( byte ) 10 ) ; bb . position ( 1 ) ; bb . limit ( 2 ) ; assertEquals ( " 0A " , Hex . encodeHexString ( bb , false ) ) ; assertEquals ( 0 , bb . remaining ( ) ) ; } 
public void estDecodeByteBufferWithLimit ( ) hrows DecoderException { final ByteBuffer bb = getByteBufferUtf8 ( " 000102030405060708090a0b0c0d0e0f " ) ; final byte [ ] expected = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ; Test pairs of bytes for (int i = 0; i < 15; i++) { bb.position(i * 2); 
public void estEncodeHexByteBufferHelloWorldLowerCaseHex ( ) { final ByteBuffer b = getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; Default lower-case actual = Hex.encodeHex(b); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); lower-case b.flip(); actual = Hex.encodeHex(b, true); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); upper-case b.flip(); actual = Hex.encodeHex(b, false); assertEquals(expected.toUpperCase(), new String(actual)); assertEquals(0, b.remaining()); } 
public void estEncodeHexByteBufferHelloWorldUpperCaseHex ( ) { final ByteBuffer b = getByteBufferUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; Default lower-case actual = Hex.encodeHex(b); assertEquals(expected.toLowerCase(), new String(actual)); assertEquals(0, b.remaining()); lower-case b.flip(); actual = Hex.encodeHex(b, true); assertEquals(expected.toLowerCase(), new String(actual)); assertEquals(0, b.remaining()); upper-case b.flip(); actual = Hex.encodeHex(b, false); assertEquals(expected, new String(actual)); assertEquals(0, b.remaining()); } 
public void estByteBufferUtf8 ( ) { Assert . assertNull ( " Should be null safe " , StringUtils . getByteBufferUtf8 ( null ) ) ; final String ext = " asdhjfhsadiogasdjhagsdygfjasfgsdaksjdhfk " ; final ByteBuffer bb = StringUtils . getByteBufferUtf8 ( ext ) ; Assert . assertArrayEquals ( ext . getBytes ( StandardCharsets . UTF_8 ) , bb . array ( ) ) ; } 
public void estEncodeHexReadOnlyByteBuffer ( ) { final char [ ] chars = Hex . encodeHex ( ByteBuffer . wrap ( new byte [ ] { 10 } ) . asReadOnlyBuffer ( ) ) ; assertEquals ( " 0a " , String . valueOf ( chars ) ) ; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public static byte [ ] encodeInteger ( final BigInteger bigInteger ) { Objects . requireNonNull ( bigInteger , " bigInteger " ) ; return encodeBase64 ( oIntegerBytes ( bigInteger ) , false ) ; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte array [ ] , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; 
public void write ( final byte array [ ] , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; 
private static int compareUnsigned ( final int x , final int y ) { return Integer . compare ( x + Integer . MIN_VALUE , y + Integer . MIN_VALUE ) ; } 
private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { overflow throw new OutOfMemoryError("Unable to allocate array size: " + (minCapacity & 0xffffffffL)); } This is called when we require buffer expansion to a very big array. Use the conservative maximum buffer size if possible, otherwise the biggest required. Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE. This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full Integer.MAX_VALUE length array. The result is that we may have to allocate an array of this size more than once if the capacity must be expanded again. return (minCapacity > MAX_BUFFER_SIZE) ? minCapacity : 
int finalise ( final int hash , final int unprocessedLength , final byte [ ] unprocessed , final int otalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { case 3 : k1 ^ = ( unprocessed [ 2 ] & 0xff ) < < 16 ; case 2 : k1 ^ = ( unprocessed [ 1 ] & 0xff ) < < 8 ; case 1 : k1 ^ = ( unprocessed [ 0 ] & 0xff ) ; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
int finalise ( final int hash , final int unprocessedLength , final byte [ ] unprocessed , final int otalLen ) { int result = hash ; ************ Note: This fails to apply masking using 0xff to the 3 remaining bytes. ************ int k1 = 0; switch (unprocessedLength) { case 3: k1 ^= unprocessed[2] << 16; case 2: k1 ^= unprocessed[1] << 8; case 1: k1 ^= unprocessed[0]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
private static void assertBase32DecodingOfTrailingBits ( final int nbits ) { final Base32 codec = new Base32 ( ) ; Create the encoded bytes. The first characters must be valid so fill with 'zero'. final byte[] encoded = new byte[nbits / 5]; Arrays.fill(encoded, ENCODE_TABLE[0]); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Enumerate all 32 possible final characters in the last position final int last = encoded.length - 1; for (int i = 0; i < 32; i++) { encoded[last] = ENCODE_TABLE[i]; 
private static void assertBase64DecodingOfTrailingBits ( final int nbits ) { final Base64 codec = new Base64 ( ) ; Create the encoded bytes. The first characters must be valid so fill with 'zero'. final byte[] encoded = new byte[nbits / 6]; Arrays.fill(encoded, STANDARD_ENCODE_TABLE[0]); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Enumerate all 64 possible final characters in the last position final int last = encoded.length - 1; for (int i = 0; i < 64; i++) { encoded[last] = STANDARD_ENCODE_TABLE[i]; 
public void estCodec265 ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 4 output bytes per 3 input bytes plus the trailing bytes padded to a block size of 4. final int blocks = (int) Math.ceil(size1GiB / 3.0); final int expectedLength = 4 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base64.encodeBase64(bytes); assertEquals(expectedLength, encoded.length); } 
private static void assertEnsureBufferSizeExpandsToMaxBufferSize ( final boolean exceedMaxBufferSize ) { This test is memory hungry. By default expansion will double the buffer size. Using a buffer that must be doubled to get close to 2GiB requires at least 3GiB of memory for the test (1GiB existing + 2GiB new). As a compromise we use an empty buffer and rely on the expansion switching to the minimum required capacity if doubling is not enough. To effectively use a full buffer of ~1GiB change the following for: 1 << 30. Setting to zero has the lowest memory footprint for this test. final int length = 0; final long presumableFreeMemory = getPresumableFreeMemory(); 2GiB + 32 KiB + length 2GiB: Buffer to allocate 32KiB: Some head room length: Existing buffer final long estimatedMemory = (1L << 31) + 32 * 1024 + length; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final int max = Integer.MAX_VALUE - 8; Check the conservative maximum buffer size can actually be exceeded by the VM otherwise the test is not valid. if (exceedMaxBufferSize) { assumeCanAllocateBufferSize(max + 1); Free-memory. This may not be necessary as the byte[] is now out of scope System.gc(); } final BaseNCodec ncodec = new NoOpBaseNCodec(); final Context context = new Context(); Allocate the initial buffer context.buffer = new byte[length]; context.pos = length; Compute the extra to reach or exceed the max buffer size int extra = max - length; if (exceedMaxBufferSize) { extra++; } ncodec.ensureBufferSize(extra, context); Assert.assertTrue(context.buffer.length >= length + extra); } 
private static void assumeCanAllocateBufferSize ( final int size ) { byte [ ] bytes = null ; ry { bytes = new byte [ size ] ; } catch ( final OutOfMemoryError ignore ) { ignore } Assume.assumeTrue("Cannot allocate array of size: " + size, bytes != null); } 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override protected boolean isInAlphabet ( final byte value ) { return false ; } } } 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override protected boolean isInAlphabet ( final byte value ) { return false ; } } } 
protected boolean isInAlphabet ( final byte value ) { return false ; } 
private static boolean negativeBytes ( final byte [ ] bytes , final int start , final int length ) { for ( int i = start ; i < start + length ; i + + ) { if ( bytes [ i ] < 0 ) { return rue ; } } return false ; } 
private static void assertIncrementalHash32 ( final byte [ ] bytes , final int seed , final int . . . blocks ) { int offset = 0 ; int otal = 0 ; final IncrementalHash32 inc = new IncrementalHash32 ( ) ; inc . start ( seed ) ; for ( final int block : blocks ) { otal + = block ; 
private static void assertIncrementalHash32x86 ( final byte [ ] bytes , final int seed , final int . . . blocks ) { int offset = 0 ; int otal = 0 ; final IncrementalHash32x86 inc = new IncrementalHash32x86 ( ) ; inc . start ( seed ) ; for ( final int block : blocks ) { otal + = block ; 
private static int [ ] createRandomBlocks ( final int maxLength ) { final int [ ] blocks = new int [ 20 ] ; int count = 0 ; int length = 0 ; while ( count < blocks . length & & length < maxLength ) { range of 1 to 8 for up to two 4 byte blocks final int size = ThreadLocalRandom.current().nextInt(1, 9); blocks[count++] = size; length += size; } return Arrays.copyOf(blocks, count); } 
public static MessageDigest updateDigest ( final MessageDigest digest , final File data ) hrows IOException { ry ( final BufferedInputStream inputStream = new BufferedInputStream ( new FileInputStream ( data ) ) ) { return updateDigest ( digest , inputStream ) ; 
public static MessageDigest updateDigest ( final MessageDigest digest , final InputStream inputStream ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = inputStream . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = inputStream . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest ; } 
public static byte [ ] digest ( final MessageDigest messageDigest , final Path data , final OpenOption . . . options ) hrows IOException { return updateDigest ( messageDigest , data , options ) . digest ( ) ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final Path path , final OpenOption . . . options ) hrows IOException { ry ( final BufferedInputStream inputStream = new BufferedInputStream ( Files . newInputStream ( path , options ) ) ) { return updateDigest ( digest , inputStream ) ; 
public byte [ ] digest ( final Path data , final OpenOption . . . options ) hrows IOException { return updateDigest ( messageDigest , data , options ) . digest ( ) ; } 
public String digestAsHex ( final Path data , final OpenOption . . . options ) hrows IOException { return Hex . encodeHexString ( digest ( data , options ) ) ; } 
public void estMd2Hex ( ) hrows IOException { Examples from RFC 1319 assertEquals("8350e5a3e24c153df2275c9f80692773", DigestUtils.md2Hex(EMPTY_STRING)); assertEquals("32ec01ec4a6dac72c0ab96fb34c0b5d1", DigestUtils.md2Hex("a")); assertEquals("da853b0d3f88d99b30283a69e6ded6bb", DigestUtils.md2Hex("abc")); assertEquals("ab4f496bfb2a530b219ff33031fe06b0", DigestUtils.md2Hex("message digest")); assertEquals("4e8ddff3650292ab5a4108c3aa47940b", DigestUtils.md2Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "da33def2a42df13975352846c30338cd", DigestUtils.md2Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "d5976f79d83d3a0dc9806c3c66f3efd8", DigestUtils.md2Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md2Hex(testData), DigestUtils.md2Hex(new ByteArrayInputStream(testData))); 
public void estMd5Hex ( ) hrows IOException { Examples from RFC 1321 assertEquals("d41d8cd98f00b204e9800998ecf8427e", DigestUtils.md5Hex(EMPTY_STRING)); assertEquals("0cc175b9c0f1b6a831c399e269772661", DigestUtils.md5Hex("a")); assertEquals("900150983cd24fb0d6963f7d28e17f72", DigestUtils.md5Hex("abc")); assertEquals("f96b697d7cb7938d525a2f31aaf161d0", DigestUtils.md5Hex("message digest")); assertEquals("c3fcd3d76192e4007dfb496cca67e13b", DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals( "d174ab98d277d9f5a5611c2c9f419d9f", DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals( "57edf4a22be3c955ac49da2e2107b67a", DigestUtils.md5Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md5Hex(testData), DigestUtils.md5Hex(new ByteArrayInputStream(testData))); 
public void estSha224_StringAsHex ( ) { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( EMPTY_STRING ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( new File ( " src/test/resources/empty.bin " ) ) ) ; 
public void estSha224_PathAsHex ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( Paths . get ( " src/test/resources/empty.bin " ) ) ) ; 
public void estDigestFile ( ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; 
private void estDigestPath ( OpenOption . . . options ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; 
public void estDigestPathOpenOptionsEmpty ( ) hrows IOException { estDigestPath ( ) ; } 
public void estDigestPathStandardOpenOptionRead ( ) hrows IOException { estDigestPath ( StandardOpenOption . READ ) ; } 
public static byte [ ] sha512_224 ( final byte [ ] data ) { return getSha512_224Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha512_256 ( final byte [ ] data ) { return getSha512_256Digest ( ) . digest ( data ) ; } 
public static byte [ ] sha512_224 ( final InputStream data ) hrows IOException { return digest ( getSha512_224Digest ( ) , data ) ; } 
public static byte [ ] sha512_256 ( final InputStream data ) hrows IOException { return digest ( getSha512_256Digest ( ) , data ) ; } 
public static byte [ ] sha512_224 ( final String data ) { return sha512_224 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static byte [ ] sha512_256 ( final String data ) { return sha512_256 ( StringUtils . getBytesUtf8 ( data ) ) ; } 
public static String sha512_224Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha512_224 ( data ) ) ; } 
public static String sha512_256Hex ( final byte [ ] data ) { return Hex . encodeHexString ( sha512_256 ( data ) ) ; } 
public static String sha512_224Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha512_224 ( data ) ) ; } 
public static String sha512_256Hex ( final InputStream data ) hrows IOException { return Hex . encodeHexString ( sha512_256 ( data ) ) ; } 
public static String sha512_224Hex ( final String data ) { return Hex . encodeHexString ( sha512_224 ( data ) ) ; } 
public static String sha512_256Hex ( final String data ) { return Hex . encodeHexString ( sha512_256 ( data ) ) ; } 
public static String [ ] values ( ) { N.B. do not use a constant array here as that can be changed externally by accident or design return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, SHA_512, SHA_512_224, SHA_512_256, SHA3_224, SHA3_256, SHA3_384, SHA3_512 
public void estSha512_224 ( ) hrows Exception { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA512_224.pdf final String stringInput = "abc"; final byte[] bytesInput = getBytesUtf8(stringInput); final String resultString = "4634270F707B6A54DAAE7530460842E20E37ED265CEEE9A43E8924AA".toLowerCase(Locale.ROOT); final byte[] resultBytes = Hex.decodeHex(resultString); assertArrayEquals(resultBytes, DigestUtils.sha512_224(bytesInput)); assertArrayEquals(resultBytes, DigestUtils.sha512_224(new ByteArrayInputStream(bytesInput))); assertArrayEquals(resultBytes, DigestUtils.sha512_224(stringInput)); assertEquals(resultString, DigestUtils.sha512_224Hex(bytesInput)); assertEquals(resultString, DigestUtils.sha512_224Hex(new ByteArrayInputStream(bytesInput))); assertEquals(resultString, DigestUtils.sha512_224Hex(stringInput)); Example 2 assertEquals("23FEC5BB94D60B23308192640B0C453335D664734FE40E7268674AF9".toLowerCase(Locale.ROOT), DigestUtils.sha512_224Hex( 
public void estSha512_256 ( ) hrows Exception { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA512_256.pdf final String stringInput = "abc"; final byte[] bytesInput = getBytesUtf8(stringInput); final String resultString = "53048E2681941EF99B2E29B76B4C7DABE4C2D0C634FC6D46E0E2F13107E7AF23" .toLowerCase(Locale.ROOT); final byte[] resultBytes = Hex.decodeHex(resultString); assertArrayEquals(resultBytes, DigestUtils.sha512_256(bytesInput)); assertArrayEquals(resultBytes, DigestUtils.sha512_256(new ByteArrayInputStream(bytesInput))); assertArrayEquals(resultBytes, DigestUtils.sha512_256(stringInput)); assertEquals(resultString, DigestUtils.sha512_256Hex(bytesInput)); assertEquals(resultString, DigestUtils.sha512_256Hex(new ByteArrayInputStream(bytesInput))); assertEquals(resultString, DigestUtils.sha512_256Hex(stringInput)); Example 2 assertEquals("3928E184FB8690F840DA3988121D31BE65CB9D3EF83EE6146FEAC861E19B563A".toLowerCase(Locale.ROOT), DigestUtils.sha512_256Hex( 
public void estIsAvailable ( ) { assertTrue ( DigestUtils . isAvailable ( MessageDigestAlgorithms . MD5 ) ) ; assertFalse ( DigestUtils . isAvailable ( " FOO " ) ) ; assertFalse ( DigestUtils . isAvailable ( null ) ) ; } 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; final String expected = " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " ; final String pathname = " src/test/resources/empty.bin " ; final String algo = MessageDigestAlgorithms . SHA_224 ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( new File ( pathname ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathname ) ) { assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathname ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( allBytes ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estDigestAs ( ) hrows IOException { final String expected = " d41d8cd98f00b204e9800998ecf8427e " ; final String pathname = " src/test/resources/empty.bin " ; final String algo = MessageDigestAlgorithms . MD5 ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( new File ( pathname ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathname ) ) { assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathname ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( allBytes ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estGetMessageDigest ( ) { final DigestUtils digestUtils = new DigestUtils ( MessageDigestAlgorithms . MD5 ) ; assertNotNull ( digestUtils . getMessageDigest ( ) ) ; assertEquals ( MessageDigestAlgorithms . MD5 , digestUtils . getMessageDigest ( ) . getAlgorithm ( ) ) ; } 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; final String expected = " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " ; final String pathname = " src/test/resources/empty.bin " ; final String algo = MessageDigestAlgorithms . SHA_224 ; final DigestUtils digestUtils = new DigestUtils ( algo ) ; assertEquals ( expected , digestUtils . digestAsHex ( new File ( pathname ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathname ) ) { assertEquals ( expected , digestUtils . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathname ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( allBytes ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4 if (unprocessedLength + length < BLOCK_SIZE) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. int newOffset; int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new AssertionError("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4 if (unprocessedLength + length < BLOCK_SIZE) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. int newOffset; int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new IllegalStateException("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public void estEnsureBufferSize ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; Assert . assertNull ( " Initial buffer should be null " , context . buffer ) ; Test initialization context.pos = 76979; context.readPos = 273; ncodec.ensureBufferSize(0, context); Assert.assertNotNull("buffer should be initialised", context.buffer); Assert.assertEquals("buffer should be initialised to default size", ncodec.getDefaultBufferSize(), context.buffer.length); Assert.assertEquals("context position", 0, context.pos); Assert.assertEquals("context read position", 0, context.readPos); Test when no expansion is required ncodec.ensureBufferSize(1, context); Assert.assertEquals("buffer should not expand unless required", ncodec.getDefaultBufferSize(), context.buffer.length); Test expansion int length = context.buffer.length; context.pos = length; int extra = 1; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand", context.buffer.length >= length + extra); Test expansion beyond double the buffer size. Hits the edge case where the required capacity is more than the default expansion. length = context.buffer.length; context.pos = length; extra = length * 10; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand beyond double capacity", context.buffer.length >= length + extra); } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4. Make this overflow safe in the event that length is Integer.MAX_VALUE. if (unprocessedLength + length - BLOCK_SIZE < 0) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. int newOffset; int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new IllegalStateException("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public static byte [ ] digest ( final MessageDigest messageDigest , final Path data , final OpenOption . . . options ) hrows IOException { return updateDigest ( messageDigest , data , options ) . digest ( ) ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final InputStream inputStream ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read = inputStream . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = inputStream . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ; } return digest ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final Path path , final OpenOption . . . options ) hrows IOException { ry ( final BufferedInputStream inputStream = new BufferedInputStream ( Files . newInputStream ( path , options ) ) ) { return updateDigest ( digest , inputStream ) ; 
public static int hash32 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( GET_BYTES_CHARSET ) ; return hash32 ( bytes , bytes . length ) ; } 
public static long hash64 ( final String ext ) { final byte [ ] bytes = ext . getBytes ( GET_BYTES_CHARSET ) ; return hash64 ( bytes , bytes . length ) ; } 
public static int hash32 ( final String data ) { final byte [ ] bytes = data . getBytes ( GET_BYTES_CHARSET ) ; return hash32 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final String data ) { final byte [ ] bytes = data . getBytes ( GET_BYTES_CHARSET ) ; return hash128 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public void estHash64 ( ) { final byte [ ] origin = TEST_HASH64 . getBytes ( MurmurHash3 . GET_BYTES_CHARSET ) ; final long hash = MurmurHash3 . hash64 ( origin ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash64WithOffsetAndLength ( ) { final byte [ ] origin = TEST_HASH64 . getBytes ( MurmurHash3 . GET_BYTES_CHARSET ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; final long hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public static int hash32 ( final String ext ) { final byte [ ] bytes = StringUtils . getBytesUtf8 ( ext ) ; return hash32 ( bytes , bytes . length ) ; } 
public static long hash64 ( final String ext ) { final byte [ ] bytes = StringUtils . getBytesUtf8 ( ext ) ; return hash64 ( bytes , bytes . length ) ; } 
public static int hash32 ( final String data ) { final byte [ ] bytes = StringUtils . getBytesUtf8 ( data ) ; return hash32 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public static long [ ] hash128 ( final String data ) { final byte [ ] bytes = StringUtils . getBytesUtf8 ( data ) ; return hash128 ( bytes , 0 , bytes . length , DEFAULT_SEED ) ; } 
public void estHash64 ( ) { final byte [ ] origin = StringUtils . getBytesUtf8 ( TEST_HASH64 ) ; final long hash = MurmurHash3 . hash64 ( origin ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash64WithOffsetAndLength ( ) { final byte [ ] origin = StringUtils . getBytesUtf8 ( TEST_HASH64 ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; final long hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; Assert . assertEquals ( 5785358552565094607L , hash ) ; } 
public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . ISO_8859_1 ) ; } 
public static String newStringUsAscii ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . US_ASCII ) ; } 
public static String newStringUtf16 ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . UTF_16 ) ; } 
public static String newStringUtf16Be ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . UTF_16BE ) ; } 
public static String newStringUtf16Le ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . UTF_16LE ) ; } 
public static String newStringUtf8 ( final byte [ ] bytes ) { return newString ( bytes , StandardCharsets . UTF_8 ) ; } 
public static String crypt ( final String key , final String salt ) { return crypt ( key . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; } 
public static String apr1Crypt ( final String keyBytes ) { return apr1Crypt ( keyBytes . getBytes ( StandardCharsets . UTF_8 ) ) ; } 
public static String apr1Crypt ( final String keyBytes , final String salt ) { return apr1Crypt ( keyBytes . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public static String crypt ( final String original ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) ) ; } 
public static String crypt ( final String original , final String salt ) { return crypt ( original . getBytes ( StandardCharsets . UTF_8 ) , salt ) ; } 
public void estIso8859_1 ( ) { Assert . assertEquals ( " ISO-8859-1 " , StandardCharsets . ISO_8859_1 . name ( ) ) ; } 
public void estUsAscii ( ) { Assert . assertEquals ( " US-ASCII " , StandardCharsets . US_ASCII . name ( ) ) ; } 
public void estUtf16 ( ) { Assert . assertEquals ( " UTF-16 " , StandardCharsets . UTF_16 . name ( ) ) ; } 
public void estUtf16Be ( ) { Assert . assertEquals ( " UTF-16BE " , StandardCharsets . UTF_16BE . name ( ) ) ; } 
public void estUtf16Le ( ) { Assert . assertEquals ( " UTF-16LE " , StandardCharsets . UTF_16LE . name ( ) ) ; } 
public void estUtf8 ( ) { Assert . assertEquals ( " UTF-8 " , StandardCharsets . UTF_8 . name ( ) ) ; } 
private static byte [ ] utf8 ( final String s ) { We would use commons-codec-1.4.jar own utility method for this, but we need this class to be able to run against commons-codec-1.3.jar, hence the duplication here. return s != null ? s.getBytes(StandardCharsets.UTF_8) : null; } 
public void estGetCharset ( ) { Assert . assertEquals ( StandardCharsets . UTF_8 , new Hex ( StandardCharsets . UTF_8 ) . getCharset ( ) ) ; } 
public void estGetCharsetName ( ) { Assert . assertEquals ( StandardCharsets . UTF_8 . name ( ) , new Hex ( StandardCharsets . UTF_8 ) . getCharsetName ( ) ) ; } 
public void estApr1CryptBytes ( ) { random salt final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; final String hash = Md5Crypt.apr1Crypt(keyBytes); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptBytesWithThreadLocalRandom ( ) { random salt final byte[] keyBytes = new byte[] { '!', 'b', 'c', '.' }; final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); final String hash = Md5Crypt.apr1Crypt(keyBytes, threadLocalRandom); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estMd5CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt(new byte[0], "$1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1", Crypt.crypt("t\u00e4st", "$1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$1$./$")); } 
public void estSha256CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt(new byte[0], "$5$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8", Crypt.crypt("t\u00e4st", "$5$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$5$./$")); } 
public void estSha2CryptRounds ( ) { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd")); } 
public void estSha2CryptRoundsThreadLocalRandom ( ) { final ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$", random)); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$", random)); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd", random)); } 
public void estSha512CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt(new byte[0], "$6$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1", Crypt.crypt("t\u00e4st", "$6$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$6$./$")); } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd")); } @Test(expected = IllegalArgumentException.class) public void testSha2CryptWrongSalt() { Sha2Crypt.sha512Crypt("secret".getBytes(StandardCharsets.UTF_8), "xx"); } @Test(expected = IllegalArgumentException.class) public void testSha512CryptWithEmptySalt() { Sha2Crypt.sha512Crypt("secret".getBytes(), ""); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); }} 
public void estSha2CryptWrongSalt ( ) { Sha2Crypt . sha512Crypt ( " secret " . getBytes ( StandardCharsets . UTF_8 ) , " xx " ) ; } 
public void estUnixCryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("12UFlHxel6uMM", Crypt.crypt(new byte[0], "12")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("./287bds2PjVw", Crypt.crypt("t\u00e4st", "./")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("./bLIFNqo9XKQ", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "./")); assertEquals("./bLIFNqo9XKQ", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, "./")); } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; assertEquals ( " Basic quoted-printable decoding test " , plain , qpcodec . decode ( encoded ) ) ; 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; assertEquals ( " Basic URL decoding test " , plain , urlCodec . decode ( encoded ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertEquals ( " Encoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertEquals ( " Decoding a null Object should return null " , null , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4. Make this overflow safe in the event that length is Integer.MAX_VALUE. Equivalent to: (unprocessedLength + length < BLOCK_SIZE) if (unprocessedLength + length - BLOCK_SIZE < 0) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. int newOffset; int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new IllegalStateException("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int unprocessedSize = 3; final int hugeLength = Integer.MAX_VALUE - 2; Assert.assertTrue("This should overflow to negative", unprocessedSize + hugeLength < 4); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } Assume.assumeTrue("Cannot allocate array of length " + hugeLength, bytes != null); final IncrementalHash32x86 inc = new IncrementalHash32x86(); inc.start(0); Add bytes that should be unprocessed inc.add(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.add(bytes, 0, hugeLength); } 
public void reset ( ) { initializeState ( ) ; otalLen = 0 ; pos = 0 ; stateUpdated = false ; } 
public void update ( final byte [ ] b , int off , final int len ) { if ( len < = 0 ) { return ; } otalLen + = len ; final int end = off + len ; Check if the unprocessed bytes and new bytes can fill a block of 16. Make this overflow safe in the event that len is Integer.MAX_VALUE. Equivalent to: (pos + len < BUF_SIZE) if (pos + len - BUF_SIZE < 0) { System.arraycopy(b, off, buffer, pos, len); pos += len; return; } Process left-over bytes with new bytes if (pos > 0) { final int size = BUF_SIZE - pos; System.arraycopy(b, off, buffer, pos, size); process(buffer, 0); off += size; } final int limit = end - BUF_SIZE; while (off <= limit) { process(b, off); off += BUF_SIZE; } Handle left-over bytes if (off < end) { pos = end - off; 
private void process ( final byte [ ] b , final int offset ) { local shadows for performance int s0 = state[0]; int s1 = state[1]; int s2 = state[2]; int s3 = state[3]; s0 = rotateLeft(s0 + getInt(b, offset) * PRIME2, ROTATE_BITS) * PRIME1; s1 = rotateLeft(s1 + getInt(b, offset + 4) * PRIME2, ROTATE_BITS) * PRIME1; s2 = rotateLeft(s2 + getInt(b, offset + 8) * PRIME2, ROTATE_BITS) * PRIME1; s3 = rotateLeft(s3 + getInt(b, offset + 12) * PRIME2, ROTATE_BITS) * PRIME1; state[0] = s0; state[1] = s1; state[2] = s2; state[3] = s3; stateUpdated = true; } 
public void verifyIncrementalChecksum ( ) hrows IOException { final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; Hit the case where the hash should be reset h.update(b[0]); h.reset(); Pass in chunks h.update(b[0]); h.update(b, 1, b.length - 2); h.update(b, b.length - 1, 1); Check the hash ignores negative length h.update(b, 0, -1); } Assert.assertEquals("checksum for " + file.getName(), expectedChecksum, Long.toHexString(h.getValue())); } 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int bufferSize = 16; final int unprocessedSize = bufferSize - 1; final int hugeLength = Integer.MAX_VALUE - (unprocessedSize - 1); Assert.assertTrue("This should overflow to negative", unprocessedSize + hugeLength < bufferSize); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } Assume.assumeTrue("Cannot allocate array of length " + hugeLength, bytes != null); final XXHash32 inc = new XXHash32(); Add bytes that should be unprocessed inc.update(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.update(bytes, 0, hugeLength); } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = input[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus >= 2) { if modulus < 2, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void encode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { ************ Note: This deliberately fails to apply masking using 0xffffffffL to the seed to maintain behavioural compatibility with the original version. The implicit conversion to a long will extend a negative sign bit through the upper 32-bits of the long seed. These should be zero. ************ return hash128x64Internal(data, offset, length, seed); } 
public static long [ ] hash128x64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Use an unsigned 32-bit integer as the seed return hash128x64Internal(data, offset, length, seed & 0xffffffffL); } 
private static long [ ] hash128x64Internal ( final byte [ ] data , final int offset , final int length , final long seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 4); long k1 = getLittleEndianLong(data, index); long k2 = getLittleEndianLong(data, index + 8); mix functions for k1 k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; h1 = Long.rotateLeft(h1, R2); h1 += h2; h1 = h1 * M + N1; mix functions for k2 k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; h2 = Long.rotateLeft(h2, R1); h2 += h1; h2 = h2 * M + N2; } tail long k1 = 0; long k2 = 0; final int index = offset + (nblocks << 4); switch (offset + length - index) { case 15: k2 ^= ((long) data[index + 14] & 0xff) << 48; case 14: k2 ^= ((long) data[index + 13] & 0xff) << 40; case 13: k2 ^= ((long) data[index + 12] & 0xff) << 32; case 12: k2 ^= ((long) data[index + 11] & 0xff) << 24; case 11: k2 ^= ((long) data[index + 10] & 0xff) << 16; case 10: k2 ^= ((long) data[index + 9] & 0xff) << 8; case 9: k2 ^= data[index + 8] & 0xff; k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; case 8: k1 ^= ((long) data[index + 7] & 0xff) << 56; case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; } finalization h1 ^= length; h2 ^= length; h1 += h2; h2 += h1; h1 = fmix64(h1); h2 = fmix64(h2); h1 += h2; h2 += h1; return new long[] { h1, h2 }; } 
public void estHash128 ( ) { mmh3.hash64(bytes, 104729) Assert.assertArrayEquals(new long[] {-5614308156300707300L, -4165733009867452172L}, MurmurHash3.hash128(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 104729), ',') final long[][] answers = { {-7122613646888064702L, -8341524471658347240L}, {5659994275039884826L, -962335545730945195L}, {-7641758224504050283L, 4083131074855072837L}, {-9123564721037921804L, -3321998102976419641L}, {-7999620158275145567L, -7769992740725283391L}, {2419143614837736468L, -5474637306496300103L}, {7781591175729494939L, -9023178611551692650L}, {-3431043156265556247L, -6589990064676612981L}, {6315693694262400182L, -6219942557302821890L}, {-8249934145502892979L, -5646083202776239948L}, {7500109050276796947L, 5350477981718987260L}, {-6102338673930022315L, 3413065069102535261L}, {-6440683413407781313L, -2374360388921904146L}, {-3071236194203069122L, 7531604855739305895L}, {-7629408037856591130L, -4070301959951145257L}, {860008171111471563L, -9026008285726889896L}, {8059667613600971894L, 3236009436748930210L}, {1833746055900036985L, 1418052485321768916L}, {8161230977297923537L, -2668130155009407119L}, {3653111839268905630L, 5525563908135615453L}, {-9163026480602019754L, 6819447647029564735L}, {1102346610654592779L, -6881918401879761029L}, {-3109499571828331931L, -3782255367340446228L}, {-7467915444290531104L, 4704551260862209500L}, {1237530251176898868L, 6144786892208594932L}, {2347717913548230384L, -7461066668225718223L}, {-7963311463560798404L, 8435801462986138227L}, {-7493166089060196513L, 8163503673197886404L}, {6807249306539951962L, -1438886581269648819L}, {6752656991043418179L, 6334147827922066123L}, {-4534351735605790331L, -4530801663887858236L}, {-7886946241830957955L, -6261339648449285315L},}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. final long[][] answers = {{5954234972212089025L, 3342108296337967352L}, {8501094764898402923L, 7873951092908129427L}, {-3334322685492296196L, -2842715922956549478L}, {-2177918982459519644L, -1612349961980368636L}, {4172870320608886992L, -4177375712254136503L}, {7546965006884307324L, -5222114032564054641L}, {-2885083166621537267L, -2069868899915344482L}, {-2397098497873118851L, 4990578036999888806L}, {-706479374719025018L, 7531201699171849870L}, {6487943141157228609L, 3576221902299447884L}, {6671331646806999453L, -3428049860825046360L}, {-8700221138601237020L, -2748450904559980545L}, {-9028762509863648063L, 6130259301750313402L}, {729958512305702590L, -36367317333638988L}, {-3803232241584178983L, -4257744207892929651L}, {5734013720237474696L, -760784490666078990L}, {-6097477411153026656L, 625288777006549065L}, {1320365359996757504L, -2251971390373072541L}, {5551441703887653022L, -3516892619809375941L}, {698875391638415033L, 3456972931370496131L}, {5874956830271303805L, -6074126509360777023L}, {-7030758398537734781L, -3174643657101295554L}, {6835789852786226556L, 7245353136839389595L}, {-7755767580598793204L, -6680491060945077989L}, {-3099789923710523185L, -2751080516924952518L}, {-7772046549951435453L, 5263206145535830491L}, {7458715941971015543L, 5470582752171544854L}, {-7753394773760064468L, -2330157750295630617L}, {-5899278942232791979L, 6235686401271389982L}, {4881732293467626532L, 2617335658565007304L}, {-5722863941703478257L, -5424475653939430258L}, {-3703319768293496315L, -2124426428486426443L},}; for (int i = 0; i < answers.length; i++) { Assert.assertArrayEquals("Length: " + i, answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed)); 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = input[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus > 0) { if modulus == 0, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
private void validateTrailingCharacters ( ) { if ( isStrictDecoding ( ) ) { hrow new IllegalArgumentException ( 
private void validateCharacter ( final long emptyBitsMask , final Context context ) { Use the long bit work area if (isStrictDecoding() && (context.lbitWorkArea & emptyBitsMask) != 0) { throw new IllegalArgumentException( 
private void validateTrailingCharacter ( ) { if ( isStrictDecoding ( ) ) { hrow new IllegalArgumentException ( 
private void validateCharacter ( final int emptyBitsMask , final Context context ) { if ( isStrictDecoding ( ) & & ( context . ibitWorkArea & emptyBitsMask ) ! = 0 ) { hrow new IllegalArgumentException ( 
protected byte [ ] doDecoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } final Base64 codec = new Base64 ( ) ; codec . setStrictDecoding ( strictDecoding ) ; return codec . decode ( bytes ) ; } 
private void estImpossibleCases ( final Base32 codec , final String [ ] impossible_cases ) { codec . setStrictDecoding ( rue ) ; for ( final String impossible : impossible_cases ) { ry { 
public void estBase32DecodingOfTrailing5Bits ( ) { assertBase32DecodingOfTrailingBits ( 5 ) ; } 
private static void assertBase32DecodingOfTrailingBits ( final int nbits ) { final Base32 codec = new Base32 ( ) ; Requires strict decoding codec.setStrictDecoding(true); assertTrue(codec.isStrictDecoding()); A lenient decoder should not re-encode to the same bytes final Base32 defaultCodec = new Base32(); assertFalse(defaultCodec.isStrictDecoding()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 5; final byte[] encoded = new byte[8]; Arrays.fill(encoded, 0, length, ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1 || length == 3 || length == 6; Enumerate all 32 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 32; i++) { encoded[last] = ENCODE_TABLE[i]; 
public void estBase64ImpossibleSamples ( ) { final Base64 codec = new Base64 ( ) ; codec . setStrictDecoding ( rue ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
public void estBase64DecodingOfTrailing6Bits ( ) { assertBase64DecodingOfTrailingBits ( 6 ) ; } 
private static void assertBase64DecodingOfTrailingBits ( final int nbits ) { final Base64 codec = new Base64 ( ) ; Requires strict decoding codec.setStrictDecoding(true); assertTrue(codec.isStrictDecoding()); A lenient decoder should not re-encode to the same bytes final Base64 defaultCodec = new Base64(); assertFalse(defaultCodec.isStrictDecoding()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 6; final byte[] encoded = new byte[4]; Arrays.fill(encoded, 0, length, STANDARD_ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1; Enumerate all 64 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 64; i++) { encoded[last] = STANDARD_ENCODE_TABLE[i]; 
public void estBase64ImpossibleSamples ( ) hrows DecoderException { final BCodec codec = new BCodec ( ) ; Default encoding is lenient Assert.assertFalse(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { codec.decode(s); } Use strict mode to prevent impossible cases codec.setStrictDecoding(true); Assert.assertTrue(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { try { 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int unprocessedSize = 3; final int hugeLength = Integer.MAX_VALUE - 2; Assert.assertTrue("This should overflow to negative", unprocessedSize + hugeLength < 4); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (final OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } Assume.assumeTrue("Cannot allocate array of length " + hugeLength, bytes != null); final IncrementalHash32x86 inc = new IncrementalHash32x86(); inc.start(0); Add bytes that should be unprocessed inc.add(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.add(bytes, 0, hugeLength); } 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int bufferSize = 16; final int unprocessedSize = bufferSize - 1; final int hugeLength = Integer.MAX_VALUE - (unprocessedSize - 1); Assert.assertTrue("This should overflow to negative", unprocessedSize + hugeLength < bufferSize); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (final OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } Assume.assumeTrue("Cannot allocate array of length " + hugeLength, bytes != null); final XXHash32 inc = new XXHash32(); Add bytes that should be unprocessed inc.update(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.update(bytes, 0, hugeLength); } 
public static long [ ] hash128 ( final byte [ ] data , final int offset , final int length , final int seed ) { ************ Note: This deliberately fails to apply masking using 0xffffffffL to the seed to maintain behavioral compatibility with the original version. The implicit conversion to a long will extend a negative sign bit through the upper 32-bits of the long seed. These should be zero. ************ return hash128x64Internal(data, offset, length, seed); } 
public void estStrictDecoding ( ) hrows Exception { for ( final String s : Base32Test . BASE32_IMPOSSIBLE_CASES ) { final byte [ ] encoded = StringUtils . getBytesUtf8 ( s ) ; 
public void estStrictDecoding ( ) hrows Exception { for ( final String s : Base64Test . BASE64_IMPOSSIBLE_CASES ) { final byte [ ] encoded = StringUtils . getBytesUtf8 ( s ) ; 
public boolean isStrictDecoding ( ) { return decodingPolicy = = CodecPolicy . STRICT ; } 
protected byte [ ] doDecoding ( final byte [ ] bytes ) { if ( bytes = = null ) { return null ; } return new Base64 ( 0 , BaseNCodec . getChunkSeparator ( ) , false , decodingPolicy ) . decode ( bytes ) ; } 
private void estBase32EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base32TestData.randomData(codec, i); 
public void estBase32ImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( 0 , null , false , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32_IMPOSSIBLE_CASES ) ; 
public void estBase32ImpossibleChunked ( ) { estImpossibleCases ( new Base32 ( 20 , BaseNCodec . CHUNK_SEPARATOR , false , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , 
public void estBase32HexImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( 0 , null , rue , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32HEX_IMPOSSIBLE_CASES ) ; 
private static void assertBase32DecodingOfTrailingBits ( final int nbits ) { Requires strict decoding final Base32 codec = new Base32(0, null, false, BaseNCodec.PAD_DEFAULT, CodecPolicy.STRICT); assertTrue(codec.isStrictDecoding()); A lenient decoder should not re-encode to the same bytes final Base32 defaultCodec = new Base32(); assertFalse(defaultCodec.isStrictDecoding()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 5; final byte[] encoded = new byte[8]; Arrays.fill(encoded, 0, length, ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1 || length == 3 || length == 6; Enumerate all 32 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 32; i++) { encoded[last] = ENCODE_TABLE[i]; 
private void estBase64EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base64TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base64TestData.randomData(i, false); 
public void estBase64ImpossibleSamples ( ) { final Base64 codec = new Base64 ( 0 , null , false , CodecPolicy . STRICT ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
private static void assertBase64DecodingOfTrailingBits ( final int nbits ) { final Base64 codec = new Base64 ( 0 , null , false , CodecPolicy . STRICT ) ; Requires strict decoding assertTrue(codec.isStrictDecoding()); A lenient decoder should not re-encode to the same bytes final Base64 defaultCodec = new Base64(); assertFalse(defaultCodec.isStrictDecoding()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 6; final byte[] encoded = new byte[4]; Arrays.fill(encoded, 0, length, STANDARD_ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1; Enumerate all 64 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 64; i++) { encoded[last] = STANDARD_ENCODE_TABLE[i]; 
public void estBase64ImpossibleSamplesDefault ( ) hrows DecoderException { final BCodec codec = new BCodec ( ) ; Default encoding is lenient Assert.assertFalse(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { codec.decode(s); 
public void estBase64ImpossibleSamplesLenient ( ) hrows DecoderException { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . LENIENT ) ; Default encoding is lenient Assert.assertFalse(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { codec.decode(s); 
public void estBase64ImpossibleSamplesStrict ( ) hrows DecoderException { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . STRICT ) ; Assert . assertTrue ( codec . isStrictDecoding ( ) ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { ry { 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer ! = null ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( context . readPos > = context . pos ) { context . buffer = null ; so hasData() will return false, and this method can return -1 } return len; } return context.eof ? EOF : 0; }} 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( context . buffer ! = null ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( context . readPos > = context . pos ) { context . buffer = null ; so hasData() will return false, and this method can return -1 } return len; } return context.eof ? EOF : 0; }} 
private void run ( final String prefix , final MessageDigest messageDigest ) hrows IOException { if ( inputs = = null ) { println ( prefix , DigestUtils . digest ( messageDigest , System . in ) ) ; return ; } for ( final String source : inputs ) { final File file = new File ( source ) ; 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( his . getEncoding ( ) ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( his . doEncoding ( ext . getBytes ( charset ) ) ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
public void estDigestAs ( ) hrows IOException { final String expected = " d41d8cd98f00b204e9800998ecf8427e " ; final String pathname = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . MD5 ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( new File ( pathname ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathname ) ) { assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathname ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( allBytes ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; final String expected = " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " ; final String pathname = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . SHA_224 ; final DigestUtils digestUtils = new DigestUtils ( algo ) ; assertEquals ( expected , digestUtils . digestAsHex ( new File ( pathname ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathname ) ) { assertEquals ( expected , digestUtils . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathname ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( allBytes ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estSha224_PathAsHex ( ) hrows IOException { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( Paths . get ( " src/test/resources/org/apache/commons/codec/empty.bin " ) ) ) ; 
protected byte [ ] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ Math . max ( size , getDefaultBufferSize ( ) ) ] ; context . pos = 0 ; context . readPos = 0 ; Overflow-conscious: x + y > z == x + y - z > 0 } else if (context.pos + size - context.buffer.length > 0) { return resizeBuffer(context, context.pos + size); } return context.buffer; } 
void encode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof ) { return ; } if ( length < 0 ) { context . eof = rue ; return ; } final char [ ] chars = Hex . encodeHex ( data , offset , length , oLowerCase ) ; final byte [ ] encoded = new String ( chars ) . getBytes ( charset ) ; final byte [ ] buffer = ensureBufferSize ( encoded . length , context ) ; System . arraycopy ( encoded , 0 , buffer , context . pos , encoded . length ) ; context . pos + = encoded . length ; } 
void decode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof ) { return ; } if ( length < 0 ) { context . eof = rue ; return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea > 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { context.ibitWorkArea = data[offset]; store 1/2 byte for next invocation of decode return; } NOTE: Each pair of bytes is really a pair of hex-chars, therefore each pair represents one byte we must have an even number of chars to decode final char[] encodedChars = new char[availableChars % 2 == 0 ? availableChars : availableChars - 1]; copy all (or part of) data into encodedChars int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode encodedChars[i++] = (char)context.ibitWorkArea; context.ibitWorkArea = -1; reset for next iteration! } final int copyLen = encodedChars.length - i; for (int j = offset; j < copyLen + offset; j++) { encodedChars[i++] = (char) data[j]; } decode encodedChars into buffer final byte[] buffer = ensureBufferSize(encodedChars.length / 2, context); try { final int written = Hex.decodeHex(encodedChars, buffer, context.pos); context.pos += written; } catch (final DecoderException e) { throw new RuntimeException(e); this method ensures that this cannot happen at runtime! } we have one char of a hex-pair left over if (copyLen < dataLen) { context.ibitWorkArea = data[offset + dataLen - 1]; store 1/2 byte for next invocation of decode 
protected boolean isInAlphabet ( final byte value ) { if ( value > = '0' & & value < = '9' ) { return rue ; } if ( oLowerCase ) { return value > = 'a' & & value < = 'f' ; 
public static boolean isBase16 ( final char c ) { return ( c > = '0' & & c < = '9' ) 
public static boolean isBase16 ( final String base16 ) { return isBase16 ( base16 . oCharArray ( ) ) ; } 
public static boolean isBase16 ( final char [ ] arrayChars ) { for ( int i = 0 ; i < arrayChars . length ; i + + ) { if ( ! isBase16 ( arrayChars [ i ] ) ) { return false ; } } return rue ; } 
public static boolean isBase16 ( final byte [ ] arrayChars ) { for ( int i = 0 ; i < arrayChars . length ; i + + ) { if ( ! isBase16 ( ( char ) arrayChars [ i ] ) ) { return false ; } } return rue ; } 
public static byte [ ] encodeBase16 ( final byte [ ] binaryData ) { return encodeBase16 ( binaryData , rue , Hex . DEFAULT_CHARSET , Integer . MAX_VALUE ) ; } 
public static byte [ ] encodeBase16 ( final byte [ ] binaryData , final boolean oLowerCase , final Charset charset , final int maxResultSize ) { if ( binaryData = = null | | binaryData . length = = 0 ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code final Base16 b16 = new Base16(toLowerCase, charset); final long len = b16.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b16.encode(binaryData); } 
public static byte [ ] decodeBase16 ( final String base16String ) { return new Base16 ( ) . decode ( base16String ) ; } 
public static byte [ ] decodeBase16 ( final byte [ ] base16Data ) { return new Base16 ( ) . decode ( base16Data ) ; } 
public static byte [ ] decodeHex ( final char [ ] data ) hrows DecoderException { final byte [ ] out = new byte [ data . length > > 1 ] ; decodeHex ( data , out , 0 ) ; return out ; } 
public static int decodeHex ( final char [ ] data , final byte [ ] out , final int outOffset ) hrows DecoderException { final int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } final int outLen = len > > 1 ; if ( out . length - outOffset < outLen ) { hrow new DecoderException ( " out is not large enough to accommodate decoded data. " ) ; } two characters form the hex value. for (int i = outOffset, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f = f | toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return outLen; } 
protected static char [ ] encodeHex ( final byte [ ] data , final char [ ] oDigits ) { final int l = data . length ; final char [ ] out = new char [ l < < 1 ] ; encodeHex ( data , 0 , data . length , oDigits , out , 0 ) ; return out ; } 
protected static char [ ] encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase ) { final char [ ] out = new char [ dataLen < < 1 ] ; encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; } 
protected static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase , final char [ ] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; } 
protected static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final char [ ] oDigits , final char [ ] out , final int outOffset ) { two characters form the hex value. for (int i = dataOffset, j = outOffset; i < dataOffset + dataLen; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; 
public void estAvailable ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertEquals ( 1 , b16Stream . available ( ) ) ; 
public void estBase16EmptyInputStream ( ) hrows IOException { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded ) ; estByChunk ( emptyEncoded , emptyDecoded ) ; } 
public void estBase16InputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656c6c6f20576f726c64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByChunk(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_LOWERCASE); decoded = Base16TestData.DECODED; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
public void estBase16InputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656c6c6f20576f726c64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByteByByte(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_LOWERCASE); decoded = Base16TestData.DECODED; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { Start with encode. InputStream in; in = new Base16InputStream(new ByteArrayInputStream(decoded), true); byte[] output = Base16TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 encode", encoded, output); in.close(); Now let's try decode. in = new Base16InputStream(new ByteArrayInputStream(encoded)); output = Base16TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base16InputStream(in, true); in = new Base16InputStream(in, false); } output = Base16TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 wrap-wrap-wrap!", decoded, output); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { Start with encode. InputStream in; in = new Base16InputStream(new ByteArrayInputStream(decoded), true); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 encode", encoded, output); in.close(); Now let's try decode. in = new Base16InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 decode", decoded, output); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base16InputStream(in, true); in = new Base16InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 wrap-wrap-wrap!", decoded, output); in.close(); } 
public void estMarkSupported ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { Always returns false for now. 
public void estRead0 ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadNull ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { in . read ( null , 0 , 0 ) ; 
public void estReadOutOfBounds ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { 
public void estSkipBig ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertEquals ( 6 , b16Stream . skip ( Integer . MAX_VALUE ) ) ; 
public void estSkipNone ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipPastEnd ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { b16Stream . skip ( - 10 ) ; 
public void estBase16EmptyOutputStream ( ) hrows IOException { final byte [ ] emptyEncoded = new byte [ 0 ] ; final byte [ ] emptyDecoded = new byte [ 0 ] ; estByteByByte ( emptyEncoded , emptyDecoded ) ; estByChunk ( emptyEncoded , emptyDecoded ) ; } 
public void estBase16OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656c6c6f20576f726c64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
public void estBase16OutputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656c6c6f20576f726c64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, true); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base16 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base16OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base16 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base16OutputStream(out, false); out = new Base16OutputStream(out, true); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base16 wrap-wrap-wrap!", decoded, output); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, true); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base16 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base16OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base16 decode", decoded, output); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base16OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte flush() base16 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base16OutputStream(out, false); out = new Base16OutputStream(out, true); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base16 wrap-wrap-wrap!", decoded, output); } 
public void estWriteOutOfBounds ( ) hrows IOException { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base16OutputStream out = new Base16OutputStream ( bout ) ) { 
public void estWriteToNullCoverage ( ) hrows IOException { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base16OutputStream out = new Base16OutputStream ( bout ) ) { out . write ( null , 0 , 0 ) ; 
public void estIsStringBase16 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " cafebabec0a1f2e3b4a5b6e7c8 " ; final String invalidString = validString + ( char ) 0 ; append null character try { Base16.isBase16(nullString); fail("Base16.isStringBase16() should not be null-safe."); } catch (final NullPointerException npe) { assertNotNull("Base16.isStringBase16() should not be null-safe.", npe); } assertTrue("Base16.isStringBase16(empty-string) is true", Base16.isBase16(emptyString)); assertTrue("Base16.isStringBase16(valid-string) is true", Base16.isBase16(validString)); assertFalse("Base16.isStringBase16(invalid-string) is false", Base16.isBase16(invalidString)); } 
public void estBase16 ( ) { final String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base16 . encodeBase16 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656c6c6f20576f726c64 " , encodedContent ) ; Base16 b16 = new Base16 ( ) ; encodedBytes = b16 . encode ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656c6c6f20576f726c64 " , encodedContent ) ; } 
private void estBase16InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656c6c6f20576f726c64 " , encodedContent ) ; } 
public void estCodec68 ( ) { final byte [ ] x = new byte [ ] { 'n' , 'H' , '=' , '=' , ( byte ) 0x9c } ; Base16 . decodeBase16 ( x ) ; } 
public void estConstructors ( ) { new Base16 ( ) ; new Base16 ( ) ; new Base16 ( CHARSET_UTF8 ) ; new Base16 ( false , CHARSET_UTF8 ) ; } 
public void estConstructor_Charset ( ) { final Base16 Base16 = new Base16 ( CHARSET_UTF8 ) ; final byte [ ] encoded = Base16 . encode ( Base16TestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_LOWERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(UTF_8) " , expectedResult , result ) ; } 
public void estConstructor_Boolean_Charset ( ) { final Base16 Base16 = new Base16 ( false , CHARSET_UTF8 ) ; final byte [ ] encoded = Base16 . encode ( Base16TestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_UPPERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(false, UTF_8) " , result , expectedResult ) ; } 
public void estEmptyBase16 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base16 . encodeBase16 ( empty ) ; assertEquals ( " empty Base16 encode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , Base16 . encodeBase16 ( null ) ) ; empty = new byte [ 0 ] ; result = Base16 . decodeBase16 ( empty ) ; assertEquals ( " empty Base16 decode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , Base16 . decodeBase16 ( ( byte [ ] ) null ) ) ; } 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { final int len = his . getRandom ( ) . nextInt ( 10000 ) + 1 ; 
public void estEncodeOverMaxSize ( ) { estEncodeOverMaxSize ( - 1 ) ; estEncodeOverMaxSize ( 0 ) ; estEncodeOverMaxSize ( 1 ) ; estEncodeOverMaxSize ( 2 ) ; } 
private void estEncodeOverMaxSize ( final int maxSize ) { ry { Base16 . encodeBase16 ( Base16TestData . DECODED , rue , CHARSET_UTF8 , maxSize ) ; 
public void estIsArrayByteBase16 ( ) { assertFalse ( Base16 . isBase16 ( new char [ ] { ( char ) Byte . MIN_VALUE } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { ( char ) - 125 } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { ( char ) - 10 } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { 0 } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base16 . isBase16 ( new char [ ] { 'A' } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { 'A' , ( char ) Byte . MIN_VALUE } ) ) ; assertTrue ( Base16 . isBase16 ( new char [ ] { 'A' , 'F' , 'a' } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base16 . isBase16 ( new char [ ] { '$' } ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( Base16 . decodeBase16 ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base16 . decodeBase16 ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base16 . decodeBase16 ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base16 . decodeBase16 ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base16 . decodeBase16 ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base16 . decodeBase16 ( " 78797a7a7921 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " , new String ( Base16 . encodeBase16 ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " , new String ( Base16 . encodeBase16 ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " , new String ( Base16 . encodeBase16 ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " , new String ( Base16 . encodeBase16 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " , new String ( Base16 . encodeBase16 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 78797a7a7921 " , new String ( Base16 . encodeBase16 ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estNonBase16Test ( ) { final byte [ ] bArray = { '%' } ; assertFalse ( " Invalid Base16 array was incorrectly validated as " + " an array of Base16 encoded data " , Base16 . isBase16 ( bArray ) ) ; ry { final Base16 b16 = new Base16 ( ) ; 
public void estObjectDecodeWithInvalidParameter ( ) { final Base16 b16 = new Base16 ( ) ; ry { b16 . decode ( Integer . valueOf ( 5 ) ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = Base16 . encodeBase16 ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base16 b16 = new Base16 ( ) ; final Object oDecoded = b16 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) { final Base16 b16 = new Base16 ( ) ; ry { b16 . encode ( " Yadayadayada " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Base16 b16 = new Base16 ( ) ; final Object oEncoded = b16 . encode ( origObj ) ; final byte [ ] bArray = Base16 . decodeBase16 ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) { final Base16 b16 = new Base16 ( ) ; assertEquals ( " 48656c6c6f20576f726c64 " , new String ( b16 . encode ( " Hello World " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estPairs ( ) { assertEquals ( " 0000 " , new String ( Base16 . encodeBase16 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estTriplets ( ) { assertEquals ( " 000000 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 0 } ) ) ) ; assertEquals ( " 000001 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 1 } ) ) ) ; assertEquals ( " 000002 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 2 } ) ) ) ; assertEquals ( " 000003 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 3 } ) ) ) ; assertEquals ( " 000004 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 4 } ) ) ) ; assertEquals ( " 000005 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 5 } ) ) ) ; assertEquals ( " 000006 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 6 } ) ) ) ; assertEquals ( " 000007 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 7 } ) ) ) ; assertEquals ( " 000008 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 8 } ) ) ) ; assertEquals ( " 000009 " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 9 } ) ) ) ; assertEquals ( " 00000a " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 10 } ) ) ) ; assertEquals ( " 00000b " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 11 } ) ) ) ; assertEquals ( " 00000c " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 12 } ) ) ) ; assertEquals ( " 00000d " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 13 } ) ) ) ; assertEquals ( " 00000e " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 14 } ) ) ) ; assertEquals ( " 00000f " , new String ( Base16 . encodeBase16 ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 15 } ) ) ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 Base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; assertEquals ( " byteToString Hello World " , " 48656c6c6f20576f726c64 " , Base16 . encodeToString ( b1 ) ) ; assertEquals ( " byteToString static Hello World " , " 48656c6c6f20576f726c64 " , StringUtils . newStringUtf8 ( Base16 . encodeBase16 ( b1 ) ) ) ; assertEquals ( " byteToString \" \" " , " " , Base16 . encodeToString ( b2 ) ) ; assertEquals ( " byteToString static \" \" " , " " , StringUtils . newStringUtf8 ( Base16 . encodeBase16 ( b2 ) ) ) ; assertEquals ( " byteToString null " , null , Base16 . encodeToString ( b3 ) ) ; assertEquals ( " byteToString static null " , null , StringUtils . newStringUtf8 ( Base16 . encodeBase16 ( b3 ) ) ) ; } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base16 Base16 = new Base16 ( ) ; final String s1 = " 48656c6c6f20576f726c64 " ; final String s2 = " " ; final String s3 = null ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( Base16 . decode ( s1 ) ) ) ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( ( byte [ ] ) Base16 . decode ( ( Object ) s1 ) ) ) ; assertEquals ( " StringToByte static Hello World " , " Hello World " , StringUtils . newStringUtf8 ( Base16 . decodeBase16 ( s1 ) ) ) ; assertEquals ( " StringToByte \" \" " , " " , StringUtils . newStringUtf8 ( Base16 . decode ( s2 ) ) ) ; assertEquals ( " StringToByte static \" \" " , " " , StringUtils . newStringUtf8 ( Base16 . decodeBase16 ( s2 ) ) ) ; assertEquals ( " StringToByte null " , null , StringUtils . newStringUtf8 ( Base16 . decode ( s3 ) ) ) ; assertEquals ( " StringToByte static null " , null , StringUtils . newStringUtf8 ( Base16 . decodeBase16 ( s3 ) ) ) ; } 
public void estCodec265_over ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 2 output bytes per 1 input byte final int blocks = size1GiB; final int expectedLength = 2 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base16.encodeBase16(bytes); assertEquals(expectedLength, encoded.length); } 
public void estIsInAlphabet ( ) { lower-case Base16 b16 = new Base16(true, CHARSET_UTF8); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('a' - 1))); assertFalse(b16.isInAlphabet((byte) ('z' + 1))); upper-case b16 = new Base16(false, CHARSET_UTF8); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('A' - 1))); assertFalse(b16.isInAlphabet((byte) ('F' + 1))); } 
public void estDecodeSingleBytes ( ) { final String encoded = " 556e74696c206e6578742074696d6521 " ; final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; final Base16 b16 = new Base16 ( ) ; final byte [ ] encocdedBytes = StringUtils . getBytesUtf8 ( encoded ) ; decode byte-by-byte b16.decode(encocdedBytes, 0, 1, context); b16.decode(encocdedBytes, 1, 1, context); yields "U" b16.decode(encocdedBytes, 2, 1, context); b16.decode(encocdedBytes, 3, 1, context); yields "n" decode split hex-pairs b16.decode(encocdedBytes, 4, 3, context); yields "t" b16.decode(encocdedBytes, 7, 3, context); yields "il" b16.decode(encocdedBytes, 10, 3, context); yields " " decode remaining b16.decode(encocdedBytes, 13, 19, context); yields "next time!" final byte[] decodedBytes = new byte[context.pos]; System.arraycopy(context.buffer, context.readPos, decodedBytes, 0, decodedBytes.length); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("Until next time!", decoded); } 
static byte [ ] streamToBytes ( final InputStream is ) hrows IOException { final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; final byte [ ] buf = new byte [ 4096 ] ; int read ; while ( ( read = is . read ( buf ) ) > - 1 ) { os . write ( buf , 0 , read ) ; } return os . oByteArray ( ) ; } 
static byte [ ] [ ] randomData ( final int size ) { final Random r = new Random ( ) ; final byte [ ] decoded = new byte [ size ] ; r . nextBytes ( decoded ) ; final char [ ] encodedChars = Hex . encodeHex ( decoded ) ; final byte [ ] encoded = new String ( encodedChars ) . getBytes ( Hex . DEFAULT_CHARSET ) ; return new byte [ ] [ ] { decoded , encoded } ; } 
public void estDecodeHexCharArrayOutBufferUnderSized ( ) hrows DecoderException { final byte [ ] out = new byte [ 4 ] ; Hex . decodeHex ( " aabbccddeeff " . oCharArray ( ) , out , 0 ) ; } 
public void estDecodeHexCharArrayOutBufferUnderSizedByOffset ( ) hrows DecoderException { final byte [ ] out = new byte [ 6 ] ; Hex . decodeHex ( " aabbccddeeff " . oCharArray ( ) , out , 1 ) ; } 
public void estEncodeDecodeHexCharArrayRandomToOutput ( ) hrows DecoderException , EncoderException { final Random random = new Random ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ random . nextInt ( 10000 ) + 1 ] ; 
void decode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea > 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea > 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { context.ibitWorkArea = data[offset]; store 1/2 byte for next invocation of decode return; } NOTE: Each pair of bytes is really a pair of hex-chars, therefore each pair represents one byte we must have an even number of chars to decode final char[] encodedChars = new char[availableChars % 2 == 0 ? availableChars : availableChars - 1]; copy all (or part of) data into encodedChars int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode encodedChars[i++] = (char)context.ibitWorkArea; context.ibitWorkArea = -1; reset for next iteration! } final int copyLen = encodedChars.length - i; for (int j = offset; j < copyLen + offset; j++) { encodedChars[i++] = (char) data[j]; } decode encodedChars into buffer final byte[] buffer = ensureBufferSize(encodedChars.length / 2, context); try { final int written = Hex.decodeHex(encodedChars, buffer, context.pos); context.pos += written; } catch (final DecoderException e) { throw new RuntimeException(e); this method ensures that this cannot happen at runtime! } we have one char of a hex-pair left over if (copyLen < dataLen) { context.ibitWorkArea = data[offset + dataLen - 1]; store 1/2 byte for next invocation of decode 
private void validateTrailingCharacter ( ) { if ( isStrictDecoding ( ) ) { hrow new IllegalArgumentException ( " Strict decoding: Last encoded character is a valid base 16 alphabet " + 
public void estStrictDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CHARSET_UTF8, CodecPolicy.STRICT); b16.decode(StringUtils.getBytesUtf8(encoded)); } 
public void estLenientDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CHARSET_UTF8, CodecPolicy.LENIENT); final byte[] decoded = b16.decode(StringUtils.getBytesUtf8(encoded)); assertArrayEquals(new byte[] {(byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd}, decoded); } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea > 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea > 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { context.ibitWorkArea = data[offset]; store 1/2 byte for next invocation of decode return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = decodeTable[context.ibitWorkArea] << BITS_PER_ENCODED_BYTE; result |= decodeTable[data[offset++]]; i = 2; buffer[context.pos++] = (byte)result; reset for next invocation! context.ibitWorkArea = -1; } while (i < charsToProcess) { result = decodeTable[data[offset++]] << BITS_PER_ENCODED_BYTE; result |= decodeTable[data[offset++]]; i += 2; buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (i < dataLen) { context.ibitWorkArea = data[i]; store 1/2 byte for next invocation of decode 
void encode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof ) { return ; } if ( length < 0 ) { context . eof = rue ; return ; } final byte [ ] buffer = ensureBufferSize ( length * BYTES_PER_ENCODED_BLOCK , context ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i + + ) { final int value = data [ i ] ; 
public void estBase16InputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByChunk(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = Base16TestData.DECODED; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
public void estBase16InputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByteByByte(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = Base16TestData.DECODED; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { estByChunk ( encoded , decoded , false ) ; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = Base16TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 encode", encoded, output); } Now let's try decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = Base16TestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 decode", decoded, output); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded ) hrows IOException { estByteByByte ( encoded , decoded , false ) ; } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 encode", encoded, output); } Now let's try decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 decode", decoded, output); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
public void estBase16OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
public void estBase16OutputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 for (int i = 0; i <= 150; i++) { final byte[][] randomData = Base16TestData.randomData(i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { out.write(decoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base16 encode", encoded, output); } Now let's try decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { out.write(encoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base16 decode", decoded, output); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream()) { final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { for (final byte element : decoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base16 encode", encoded, output); } Now let's try decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base16 decode", decoded, output); } Now let's try decode with tonnes of flushes. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); out.flush(); } final byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte flush() base16 decode", decoded, output); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
public void estBase16 ( ) { final String content = " Hello World " ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( StringUtils . getBytesUtf8 ( content ) ) ; final String encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656C6C6F20576F726C64 " , encodedContent ) ; final byte [ ] decodedBytes = new Base16 ( ) . decode ( encodedBytes ) ; final String decodedContent = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( " decoding hello world " , content , decodedContent ) ; } 
private void estBase16InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656C6C6F20576F726C64 " , encodedContent ) ; } 
public void estCodec68 ( ) { final byte [ ] x = new byte [ ] { 'n' , 'H' , '=' , '=' , ( byte ) 0x9c } ; final Base16 b16 = new Base16 ( ) ; b16 . decode ( x ) ; } 
public void estConstructors ( ) { new Base16 ( ) ; new Base16 ( false ) ; new Base16 ( rue ) ; new Base16 ( false , CodecPolicy . LENIENT ) ; new Base16 ( false , CodecPolicy . STRICT ) ; } 
public void estConstructor_LowerCase ( ) { final Base16 Base16 = new Base16 ( rue ) ; final byte [ ] encoded = Base16 . encode ( Base16TestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_LOWERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(true) " , expectedResult , result ) ; } 
public void estConstructor_LowerCase_DecodingPolicy ( ) { final Base16 Base16 = new Base16 ( false , CodecPolicy . STRICT ) ; final byte [ ] encoded = Base16 . encode ( Base16TestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_UPPERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(false, CodecPolicy.STRICT) " , result , expectedResult ) ; } 
public void estEmptyBase16 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = new Base16 ( ) . encode ( empty ) ; assertEquals ( " empty Base16 encode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base16 ( ) . decode ( empty ) ; assertEquals ( " empty Base16 decode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( new Base16 ( rue ) . decode ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( new Base16 ( rue ) . decode ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( new Base16 ( rue ) . decode ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( new Base16 ( rue ) . decode ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( new Base16 ( rue ) . decode ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( new Base16 ( rue ) . decode ( " 78797a7a7921 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " , new String ( new Base16 ( rue ) . encode ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " , new String ( new Base16 ( rue ) . encode ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " , new String ( new Base16 ( rue ) . encode ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " , new String ( new Base16 ( rue ) . encode ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " , new String ( new Base16 ( rue ) . encode ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 78797a7a7921 " , new String ( new Base16 ( rue ) . encode ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estNonBase16Test ( ) { final byte [ ] bArray = { '%' } ; ry { final Base16 b16 = new Base16 ( ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = new Base16 ( ) . encode ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base16 b16 = new Base16 ( ) ; final Object oDecoded = b16 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Object oEncoded = new Base16 ( ) . encode ( origObj ) ; final byte [ ] bArray = new Base16 ( ) . decode ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( " dest string does not equal original " , original , dest ) ; } 
public void estObjectEncode ( ) { final Base16 b16 = new Base16 ( ) ; assertEquals ( " 48656C6C6F20576F726C64 " , new String ( b16 . encode ( " Hello World " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estPairs ( ) { assertEquals ( " 0000 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 } ) ) ) ; assertEquals ( " 0001 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 1 } ) ) ) ; assertEquals ( " 0002 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 2 } ) ) ) ; assertEquals ( " 0003 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 3 } ) ) ) ; assertEquals ( " 0004 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 4 } ) ) ) ; assertEquals ( " 0005 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 5 } ) ) ) ; assertEquals ( " 0006 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 6 } ) ) ) ; assertEquals ( " 0007 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 7 } ) ) ) ; assertEquals ( " 0008 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 8 } ) ) ) ; assertEquals ( " 0009 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 9 } ) ) ) ; assertEquals ( " 000A " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 10 } ) ) ) ; assertEquals ( " 000B " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 11 } ) ) ) ; assertEquals ( " 000C " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 12 } ) ) ) ; assertEquals ( " 000D " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 13 } ) ) ) ; assertEquals ( " 000E " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 14 } ) ) ) ; assertEquals ( " 000F " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 15 } ) ) ) ; assertEquals ( " 0010 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 16 } ) ) ) ; assertEquals ( " 0011 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 17 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte est [ ] = { ( byte ) i , ( byte ) i } ; 
public void estTriplets ( ) { assertEquals ( " 000000 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 0 } ) ) ) ; assertEquals ( " 000001 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 1 } ) ) ) ; assertEquals ( " 000002 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 2 } ) ) ) ; assertEquals ( " 000003 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 3 } ) ) ) ; assertEquals ( " 000004 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 4 } ) ) ) ; assertEquals ( " 000005 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 5 } ) ) ) ; assertEquals ( " 000006 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 6 } ) ) ) ; assertEquals ( " 000007 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 7 } ) ) ) ; assertEquals ( " 000008 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 8 } ) ) ) ; assertEquals ( " 000009 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 9 } ) ) ) ; assertEquals ( " 00000A " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 10 } ) ) ) ; assertEquals ( " 00000B " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 11 } ) ) ) ; assertEquals ( " 00000C " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 12 } ) ) ) ; assertEquals ( " 00000D " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 13 } ) ) ) ; assertEquals ( " 00000E " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 14 } ) ) ) ; assertEquals ( " 00000F " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 , ( byte ) 15 } ) ) ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 Base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; assertEquals ( " byteToString Hello World " , " 48656C6C6F20576F726C64 " , Base16 . encodeToString ( b1 ) ) ; assertEquals ( " byteToString static Hello World " , " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) ) ; assertEquals ( " byteToString \" \" " , " " , Base16 . encodeToString ( b2 ) ) ; assertEquals ( " byteToString static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) ) ; assertEquals ( " byteToString null " , null , Base16 . encodeToString ( b3 ) ) ; assertEquals ( " byteToString static null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) ) ; } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base16 Base16 = new Base16 ( ) ; final String s1 = " 48656C6C6F20576F726C64 " ; final String s2 = " " ; final String s3 = null ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( Base16 . decode ( s1 ) ) ) ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( ( byte [ ] ) new Base16 ( ) . decode ( ( Object ) s1 ) ) ) ; assertEquals ( " StringToByte static Hello World " , " Hello World " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s1 ) ) ) ; assertEquals ( " StringToByte \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertEquals ( " StringToByte static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertEquals ( " StringToByte null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; assertEquals ( " StringToByte static null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; } 
public void estCodec265_over ( ) { almost 1GiB file to encode: 2^29 bytes final int size1GiB = 1 << 29; Expecting a size of 2 output bytes per 1 input byte final int blocks = size1GiB; final int expectedLength = 2 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assume.assumeTrue("Not enough free memory for the test", presumableFreeMemory > estimatedMemory); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = new Base16().encode(bytes); assertEquals(expectedLength, encoded.length); } 
public void estIsInAlphabet ( ) { invalid bounds Base16 b16 = new Base16(true); assertFalse(b16.isInAlphabet((byte)0)); assertFalse(b16.isInAlphabet((byte)1)); assertFalse(b16.isInAlphabet((byte)-1)); assertFalse(b16.isInAlphabet((byte)-15)); assertFalse(b16.isInAlphabet((byte)-16)); assertFalse(b16.isInAlphabet((byte)128)); assertFalse(b16.isInAlphabet((byte)255)); lower-case b16 = new Base16(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('a' - 1))); assertFalse(b16.isInAlphabet((byte) ('z' + 1))); upper-case b16 = new Base16(false); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('A' - 1))); assertFalse(b16.isInAlphabet((byte) ('F' + 1))); } 
public void estDecodeSingleBytes ( ) { final String encoded = " 556E74696C206E6578742074696D6521 " ; final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; final Base16 b16 = new Base16 ( ) ; final byte [ ] encocdedBytes = StringUtils . getBytesUtf8 ( encoded ) ; decode byte-by-byte b16.decode(encocdedBytes, 0, 1, context); b16.decode(encocdedBytes, 1, 1, context); yields "U" b16.decode(encocdedBytes, 2, 1, context); b16.decode(encocdedBytes, 3, 1, context); yields "n" decode split hex-pairs b16.decode(encocdedBytes, 4, 3, context); yields "t" b16.decode(encocdedBytes, 7, 3, context); yields "il" b16.decode(encocdedBytes, 10, 3, context); yields " " decode remaining b16.decode(encocdedBytes, 13, 19, context); yields "next time!" final byte[] decodedBytes = new byte[context.pos]; System.arraycopy(context.buffer, context.readPos, decodedBytes, 0, decodedBytes.length); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("Until next time!", decoded); } 
public void estDecodeSingleBytesOptimisation ( ) { final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; context . ibitWorkArea = 0 ; final byte [ ] data = new byte [ 1 ] ; final Base16 b16 = new Base16 ( ) ; data [ 0 ] = ( byte ) 'E' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 69 , context . ibitWorkArea ) ; data [ 0 ] = ( byte ) 'F' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( - 1 , context . ibitWorkArea ) ; assertEquals ( - 17 , context . buffer [ 0 ] ) ; } 
public void estStrictDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.STRICT); b16.decode(StringUtils.getBytesUtf8(encoded)); } 
public void estLenientDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.LENIENT); final byte[] decoded = b16.decode(StringUtils.getBytesUtf8(encoded)); assertArrayEquals(new byte[] {(byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd}, decoded); } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea > 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea > 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { context.ibitWorkArea = decodeOctet(data[offset]) + 1; store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i = 2; buffer[context.pos++] = (byte)result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } while (i < charsToProcess) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i += 2; buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (i < dataLen) { context.ibitWorkArea = decodeOctet(data[i]) + 1; store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
private int decodeOctet ( final byte octet ) { int decoded = - 1 ; if ( octet > = 0 & & octet < decodeTable . length ) { decoded = decodeTable [ octet ] ; } if ( decoded = = - 1 ) { hrow new IllegalArgumentException ( " Invalid octet in encoded value: " + ( int ) octet ) ; } return decoded ; } 
public void estNonBase16Test ( ) { final byte [ ] invalidEncodedChars = { '/' , ':' , '@' , 'G' , '%' , '`' , 'g' } ; final byte [ ] encoded = new byte [ 1 ] ; for ( final byte invalidEncodedChar : invalidEncodedChars ) { ry { 
public void estDecodeSingleBytesOptimisation ( ) { final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; context . ibitWorkArea = 0 ; final byte [ ] data = new byte [ 1 ] ; final Base16 b16 = new Base16 ( ) ; assertEquals ( 0 , context . ibitWorkArea ) ; data [ 0 ] = ( byte ) 'E' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 15 , context . ibitWorkArea ) ; data [ 0 ] = ( byte ) 'F' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertEquals ( - 17 , context . buffer [ 0 ] ) ; } 
public void estBase16InputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByChunk(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase16InputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByteByByte(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 encode", encoded, output); } Now let's try decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming Base16 decode", decoded, output); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
public void estBase16OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase16OutputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByteByByte(encoded, decoded); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estConstructor_LowerCase ( ) { final Base16 Base16 = new Base16 ( rue ) ; final byte [ ] encoded = Base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_LOWERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(true) " , expectedResult , result ) ; } 
public void estConstructor_LowerCase_DecodingPolicy ( ) { final Base16 Base16 = new Base16 ( false , CodecPolicy . STRICT ) ; final byte [ ] encoded = Base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_UPPERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(false, CodecPolicy.STRICT) " , result , expectedResult ) ; } 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream base32os = new Base32OutputStream ( bos ) ) { base32os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base32InputStream ins = new Base32InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = BaseNTestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 encode", Arrays.equals(output, encoded)); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base32 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream base64os = new Base64OutputStream ( bos ) ) { base64os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = BaseNTestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final ByteArrayInputStream data = new ByteArrayInputStream ( codec98 ) ; final Base64InputStream stream = new Base64InputStream ( data ) ; This line causes an NPE in commons-codec-1.4.jar: final byte[] decodedBytes = BaseNTestData.streamToBytes(stream, new byte[1024]); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("codec-98 NPE Base64InputStream", Base64TestData.CODEC_98_NPE_DECODED, decoded); } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 encode", Arrays.equals(output, encoded)); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 decode", Arrays.equals(output, decoded)); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded)); in.close(); } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( BaseNTestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estConstructor_Int_ByteArray_Boolean ( ) { final Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; final byte [ ] encoded = base64 . encode ( BaseNTestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base64(65, \\ , false) " , expectedResult , result ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)", result, expectedResult); } 
private void estEncodeOverMaxSize ( final int maxSize ) hrows Exception { ry { Base64 . encodeBase64 ( BaseNTestData . DECODED , rue , false , maxSize ) ; 
public void estUrlSafe ( ) { test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
static byte [ ] streamToBytes ( final InputStream in ) hrows IOException { final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; final byte [ ] buf = new byte [ 4096 ] ; int read ; while ( ( read = in . read ( buf ) ) > - 1 ) { os . write ( buf , 0 , read ) ; } return os . oByteArray ( ) ; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 encode", encoded, output); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 wrap-wrap-wrap!", decoded, output); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 encode", encoded, output); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 decode", decoded, output); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base32 wrap-wrap-wrap!", decoded, output); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked Base32 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked Base32 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked Base32 wrap-wrap-wrap!", decoded, output); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte Base32 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte Base32 decode", decoded, output); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte flush() Base32 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte Base32 wrap-wrap-wrap!", decoded, output); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 encode", encoded, output); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 wrap-wrap-wrap!", decoded, output); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 encode", encoded, output); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 decode", decoded, output); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals("EOF", -1, in.read()); assertEquals("Still EOF", -1, in.read()); assertArrayEquals("Streaming base64 wrap-wrap-wrap!", decoded, output); in.close(); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base64 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base64 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming chunked base64 wrap-wrap-wrap!", decoded, output); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base64 encode", encoded, output); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base64 decode", decoded, output); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte flush() base64 decode", decoded, output); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals("Streaming byte-by-byte base64 wrap-wrap-wrap!", decoded, output); } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { context.ibitWorkArea = decodeOctet(data[offset]) + 1; store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i = 2; buffer[context.pos++] = (byte)result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } while (i < charsToProcess) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i += 2; buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (i < dataLen) { context.ibitWorkArea = decodeOctet(data[i]) + 1; store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
private int decodeOctet ( final byte octet ) { int decoded = - 1 ; if ( ( octet & 0xff ) < decodeTable . length ) { decoded = decodeTable [ octet ] ; } if ( decoded = = - 1 ) { hrow new IllegalArgumentException ( " Invalid octet in encoded value: " + ( int ) octet ) ; } return decoded ; } 
public boolean isInAlphabet ( final byte octet ) { return ( octet & 0xff ) < decodeTable . length & & decodeTable [ octet ] ! = - 1 ; } 
public void estConstructor_LowerCase ( ) { final Base16 base16 = new Base16 ( rue ) ; final byte [ ] encoded = base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_LOWERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new Base16(true) " , expectedResult , result ) ; } 
public void estConstructor_LowerCase_DecodingPolicy ( ) { final Base16 base16 = new Base16 ( false , CodecPolicy . STRICT ) ; final byte [ ] encoded = base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_UPPERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( " new base16(false, CodecPolicy.STRICT) " , result , expectedResult ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = new byte [ 0 ] ; final byte [ ] b3 = null ; assertEquals ( " byteToString Hello World " , " 48656C6C6F20576F726C64 " , base16 . encodeToString ( b1 ) ) ; assertEquals ( " byteToString static Hello World " , " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) ) ; assertEquals ( " byteToString \" \" " , " " , base16 . encodeToString ( b2 ) ) ; assertEquals ( " byteToString static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) ) ; assertEquals ( " byteToString null " , null , base16 . encodeToString ( b3 ) ) ; assertEquals ( " byteToString static null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) ) ; } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final String s1 = " 48656C6C6F20576F726C64 " ; final String s2 = " " ; final String s3 = null ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( base16 . decode ( s1 ) ) ) ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( ( byte [ ] ) new Base16 ( ) . decode ( ( Object ) s1 ) ) ) ; assertEquals ( " StringToByte static Hello World " , " Hello World " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s1 ) ) ) ; assertEquals ( " StringToByte \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertEquals ( " StringToByte static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertEquals ( " StringToByte null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; assertEquals ( " StringToByte static null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; } 
public void estDecodeSingleBytesOptimisation ( ) { final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; final byte [ ] data = new byte [ 1 ] ; final Base16 b16 = new Base16 ( ) ; data [ 0 ] = ( byte ) 'E' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 15 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; data [ 0 ] = ( byte ) 'F' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertEquals ( ( byte ) 0xEF , context . buffer [ 0 ] ) ; } 
void encode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof ) { return ; } if ( length < 0 ) { context . eof = rue ; return ; } final int size = length * BYTES_PER_ENCODED_BLOCK ; if ( size < 0 ) { hrow new IllegalArgumentException ( " Input length exceeds maximum size for encoded data: " + length ) ; } final byte [ ] buffer = ensureBufferSize ( size , context ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i + + ) { final int value = data [ i ] ; 
public void checkEncodeLengthBounds ( ) { final Base16 base16 = new Base16 ( ) ; base16 . encode ( new byte [ 10 ] , 0 , 1 < < 30 ) ; } 
public void estIsInAlphabet ( ) { invalid bounds Base16 b16 = new Base16(true); assertFalse(b16.isInAlphabet((byte)0)); assertFalse(b16.isInAlphabet((byte)1)); assertFalse(b16.isInAlphabet((byte)-1)); assertFalse(b16.isInAlphabet((byte)-15)); assertFalse(b16.isInAlphabet((byte)-16)); assertFalse(b16.isInAlphabet((byte)128)); assertFalse(b16.isInAlphabet((byte)255)); lower-case b16 = new Base16(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('a' - 1))); assertFalse(b16.isInAlphabet((byte) ('f' + 1))); assertFalse(b16.isInAlphabet((byte) ('z' + 1))); upper-case b16 = new Base16(false); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('A' - 1))); assertFalse(b16.isInAlphabet((byte) ('F' + 1))); assertFalse(b16.isInAlphabet((byte) ('Z' + 1))); } 
public static char [ ] encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase ) { final char [ ] out = new char [ dataLen < < 1 ] ; encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , 0 ) ; return out ; } 
public static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase , final char [ ] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; } 
public void estEncodeHexPartialInput ( ) { final byte data [ ] = " hello world " . getBytes ( UTF_8 ) ; char [ ] hex = Hex . encodeHex ( data , 0 , 0 , rue ) ; assertArrayEquals ( new char [ 0 ] , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , rue ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , false ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , rue ) ; assertArrayEquals ( " 6c6c6f20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , false ) ; assertArrayEquals ( " 6C6C6F20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , false ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeHexPartialInputUnderbounds ( ) { final byte data [ ] = " hello world " . getBytes ( UTF_8 ) ; final char [ ] hex = Hex . encodeHex ( data , - 2 , 10 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeHexPartialInputOverbounds ( ) { final byte data [ ] = " hello world " . getBytes ( UTF_8 ) ; final char [ ] hex = Hex . encodeHex ( data , 9 , 10 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estGetCharset ( ) { Assert . assertEquals ( UTF_8 , new Hex ( UTF_8 ) . getCharset ( ) ) ; } 
public void estGetCharsetName ( ) { Assert . assertEquals ( UTF_8 . name ( ) , new Hex ( UTF_8 ) . getCharsetName ( ) ) ; } 
public static int decodeHex ( final char [ ] data , final byte [ ] out , final int outOffset ) hrows DecoderException { final int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } final int outLen = len > > 1 ; if ( out . length - outOffset < outLen ) { hrow new DecoderException ( " Output array is not large enough to accommodate decoded data. " ) ; } two characters form the hex value. for (int i = outOffset, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f = f | toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return outLen; } 
private static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final char [ ] oDigits , final char [ ] out , final int outOffset ) { two characters form the hex value. for (int i = dataOffset, j = outOffset; i < dataOffset + dataLen; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; 
public void estEncodeHexPartialInput ( ) { final byte data [ ] = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; char [ ] hex = Hex . encodeHex ( data , 0 , 0 , rue ) ; assertArrayEquals ( new char [ 0 ] , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , rue ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , false ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , rue ) ; assertArrayEquals ( " 6c6c6f20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , false ) ; assertArrayEquals ( " 6C6C6F20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , false ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeHexPartialInputUnderbounds ( ) { final byte data [ ] = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; final char [ ] hex = Hex . encodeHex ( data , - 2 , 10 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeHexPartialInputOverbounds ( ) { final byte data [ ] = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; final char [ ] hex = Hex . encodeHex ( data , 9 , 10 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeDecodeHexCharArrayRandom ( ) hrows DecoderException , EncoderException { final Hex hex = new Hex ( ) ; for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ ThreadLocalRandom . current ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estEncodeDecodeHexCharArrayRandomToOutput ( ) hrows DecoderException , EncoderException { for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ ThreadLocalRandom . current ( ) . nextInt ( 10000 ) + 1 ] ; 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( source ) . append ( " [ " ) . append ( offset ) . append ( " ] " ) ; sb . append ( ignoreCase ? " caseblind " : " samecase " ) ; sb . append ( other ) . append ( " [ " ) . append ( ooffset ) . append ( " ] " ) ; sb . append ( " " ) . append ( len ) . append ( " => " ) ; if ( hrowable ! = null ) { sb . append ( hrowable ) ; } else { sb . append ( expected ) ; } return sb . oString ( ) ; } 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; Assert . fail ( msg + " but nothing was thrown. " ) ; } catch ( Exception ex ) { assertTrue ( msg + " but was " + ex . getClass ( ) . getSimpleName ( ) , data . hrowable . isAssignableFrom ( ex . getClass ( ) ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( id + " Failed test " + data , data . expected , stringCheck ) ; } } } @Test public void estRegionMatches ( ) { for ( final TestData data : TEST_DATA ) { new RunTest ( ) { @Override boolean invoke ( ) { return data . source . regionMatches ( data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " String " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( data . source , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSString " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( new StringBuilder ( data . source ) , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSNonString " ) ; } } @SuppressWarnings ( " unused " ) @Test public void estConstructor ( ) { new CharSequenceUtils ( ) ; } } 
void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; 
public void estRegionMatches ( ) { for ( final TestData data : TEST_DATA ) { new RunTest ( ) { 
boolean invoke ( ) { return data . source . regionMatches ( data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } 
boolean invoke ( ) { return CharSequenceUtils . regionMatches ( data . source , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } 
boolean invoke ( ) { return CharSequenceUtils . regionMatches ( new StringBuilder ( data . source ) , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } 
public void estStrictDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.STRICT); assertEquals(CodecPolicy.STRICT, b16.getCodecPolicy()); b16.decode(StringUtils.getBytesUtf8(encoded)); } 
public void estLenientDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.LENIENT); assertEquals(CodecPolicy.LENIENT, b16.getCodecPolicy()); final byte[] decoded = b16.decode(StringUtils.getBytesUtf8(encoded)); assertArrayEquals(new byte[] {(byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd}, decoded); } 
private static void assertBase32DecodingOfTrailingBits ( final int nbits ) { Requires strict decoding final Base32 codec = new Base32(0, null, false, BaseNCodec.PAD_DEFAULT, CodecPolicy.STRICT); assertTrue(codec.isStrictDecoding()); assertEquals(CodecPolicy.STRICT, codec.getCodecPolicy()); A lenient decoder should not re-encode to the same bytes final Base32 defaultCodec = new Base32(); assertFalse(defaultCodec.isStrictDecoding()); assertEquals(CodecPolicy.LENIENT, defaultCodec.getCodecPolicy()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 5; final byte[] encoded = new byte[8]; Arrays.fill(encoded, 0, length, ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1 || length == 3 || length == 6; Enumerate all 32 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 32; i++) { encoded[last] = ENCODE_TABLE[i]; 
private static void assertBase64DecodingOfTrailingBits ( final int nbits ) { final Base64 codec = new Base64 ( 0 , null , false , CodecPolicy . STRICT ) ; Requires strict decoding assertTrue(codec.isStrictDecoding()); assertEquals(CodecPolicy.STRICT, codec.getCodecPolicy()); A lenient decoder should not re-encode to the same bytes final Base64 defaultCodec = new Base64(); assertFalse(defaultCodec.isStrictDecoding()); assertEquals(CodecPolicy.LENIENT, defaultCodec.getCodecPolicy()); Create the encoded bytes. The first characters must be valid so fill with 'zero' then pad to the block size. final int length = nbits / 6; final byte[] encoded = new byte[4]; Arrays.fill(encoded, 0, length, STANDARD_ENCODE_TABLE[0]); Arrays.fill(encoded, length, encoded.length, (byte) '='); Compute how many bits would be discarded from 8-bit bytes final int discard = nbits % 8; final int emptyBitsMask = (1 << discard) - 1; Special case when an impossible number of trailing characters final boolean invalid = length == 1; Enumerate all 64 possible final characters in the last position final int last = length - 1; for (int i = 0; i < 64; i++) { encoded[last] = STANDARD_ENCODE_TABLE[i]; 
private void estBase32InBuffer ( final int startPasSize , final int endPadSize ) { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { final byte [ ] bytes = element [ 0 ] . getBytes ( CHARSET_UTF8 ) ; 
public void estEmptyBase16 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = new Base16 ( ) . encode ( empty ) ; assertEquals ( " empty Base16 encode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . encode ( null ) ) ; result = new Base16 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base16 encode with offset " , 0 , result . length ) ; assertEquals ( " empty Base16 encode with offset " , null , new Base16 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base16 ( ) . decode ( empty ) ; assertEquals ( " empty Base16 decode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estEmptyBase32 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = new Base32 ( ) . encode ( empty ) ; assertEquals ( " empty Base32 encode " , 0 , result . length ) ; assertEquals ( " empty Base32 encode " , null , new Base32 ( ) . encode ( null ) ) ; result = new Base32 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base32 encode with offset " , 0 , result . length ) ; assertEquals ( " empty Base32 encode with offset " , null , new Base32 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base32 ( ) . decode ( empty ) ; assertEquals ( " empty Base32 decode " , 0 , result . length ) ; assertEquals ( " empty Base32 encode " , null , new Base32 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = new byte [ 0 ] ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; result = new Base64 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , new Base64 ( ) . encode ( null , 0 , 1 ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( ( byte [ ] ) null ) ) ; } 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; ' }); OK assertNotNull(base32); } 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; ' }); OK assertNotNull(base32); } 
public void estIsInAlphabet ( ) { invalid bounds Base32 b32 = new Base32(true); assertFalse(b32.isInAlphabet((byte)0)); assertFalse(b32.isInAlphabet((byte)1)); assertFalse(b32.isInAlphabet((byte)-1)); assertFalse(b32.isInAlphabet((byte)-15)); assertFalse(b32.isInAlphabet((byte)-32)); assertFalse(b32.isInAlphabet((byte)127)); assertFalse(b32.isInAlphabet((byte)128)); assertFalse(b32.isInAlphabet((byte)255)); default table b32 = new Base32(false); for (char c = '2'; c <= '7'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'Z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) ('1'))); assertFalse(b32.isInAlphabet((byte) ('8'))); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('Z' + 1))); hex table b32 = new Base32(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'V'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'v'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) ('0' - 1))); assertFalse(b32.isInAlphabet((byte) ('9' + 1))); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('V' + 1))); assertFalse(b32.isInAlphabet((byte) ('a' - 1))); assertFalse(b32.isInAlphabet((byte) ('v' + 1))); } 
public void estContextToString ( ) { final Context context = new Context ( ) ; context . buffer = new byte [ 3 ] ; context . currentLinePos = 13 ; context . eof = rue ; context . ibitWorkArea = 777 ; context . lbitWorkArea = 999 ; context . modulus = 5 ; context . pos = 42 ; context . readPos = 981 ; final String ext = context . oString ( ) ; Assert . assertTrue ( ext . contains ( " [0, 0, 0] " ) ) ; Assert . assertTrue ( ext . contains ( " 13 " ) ) ; Assert . assertTrue ( ext . contains ( " rue " ) ) ; Assert . assertTrue ( ext . contains ( " 777 " ) ) ; Assert . assertTrue ( ext . contains ( " 999 " ) ) ; Assert . assertTrue ( ext . contains ( " 5 " ) ) ; Assert . assertTrue ( ext . contains ( " 42 " ) ) ; Assert . assertTrue ( ext . contains ( " 981 " ) ) ; } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; int i = 0; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i = 2; buffer[context.pos++] = (byte)result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } while (i < charsToProcess) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); i += 2; buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (i < dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
public static String [ ] values ( ) { N.B. do not use a constant array here as that can be changed externally by accident or design return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; Assert . fail ( msg + " but nothing was thrown. " ) ; } catch ( Exception ex ) { assertTrue ( msg + " but was " + ex . getClass ( ) . getSimpleName ( ) , data . hrowable . isAssignableFrom ( ex . getClass ( ) ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( id + " Failed test " + data , data . expected , stringCheck ) ; } } } @Test public void estRegionMatches ( ) { for ( final TestData data : TEST_DATA ) { new RunTest ( ) { @Override boolean invoke ( ) { return data . source . regionMatches ( data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " String " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( data . source , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSString " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( new StringBuilder ( data . source ) , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSNonString " ) ; } } @SuppressWarnings ( " unused " ) @Test public void estConstructor ( ) { new CharSequenceUtils ( ) ; } } 
public void estCodec101 ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; ry ( final Base64InputStream in = new Base64InputStream ( bais ) ) { final byte [ ] result = new byte [ 8192 ] ; 
public void estInputStreamReader ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; final Base64InputStream in = new Base64InputStream ( bais ) ; final InputStreamReader isr = new InputStreamReader ( in ) ; ry ( final BufferedReader br = new BufferedReader ( isr ) ) { final String line = br . readLine ( ) ; 
public void estCodeInteger3 ( ) { final String encodedInt3 = " FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2 " + " rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg== " ; final BigInteger bigInt3 = new BigInteger ( " 10806548154093873461951748545 " + " 1196989136416448805819079363524309897749044958112417136240557 " + " 4495062430572478766856090958495998158114332651671116876320938126 " ) ; assertEquals ( encodedInt3 , new String ( Base64 . encodeInteger ( bigInt3 ) ) ) ; assertEquals ( bigInt3 , Base64 . decodeInteger ( encodedInt3 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodeInteger4 ( ) { final String encodedInt4 = " ctA8YGxrtngg/zKVvqEOefnwmViFztcnPBYPlJsvh6yKI " + " 4iDm68fnp4Mi3RrJ6bZAygFrUIQLxLjV+OJtgJAEto0xAs+Mehuq1DkSFEpP3o " + " DzCTOsrOiS1DwQe4oIb7zVk/9l7aPtJMHW0LVlMdwZNFNNJoqMcT2ZfCPrfvYv " + " Q0= " ; final BigInteger bigInt4 = new BigInteger ( " 80624726256040348115552042320 " + " 6968135001872753709424419772586693950232350200555646471175944 " + " 519297087885987040810778908507262272892702303774422853675597 " + " 748008534040890923814202286633163248086055216976551456088015 " + " 338880713818192088877057717530169381044092839402438015097654 " + " 53542091716518238707344493641683483917 " ) ; assertEquals ( encodedInt4 , new String ( Base64 . encodeInteger ( bigInt4 ) ) ) ; assertEquals ( bigInt4 , Base64 . decodeInteger ( encodedInt4 . getBytes ( CHARSET_UTF8 ) ) ) ; } 
private void checkOnBytes ( final byte [ ] bytes , final boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( final byte b : bytes ) { ours . update ( b ) ; heirs . update ( b ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
public void estOOM ( ) hrows EncoderException { final String phrase = " 200697900'-->&#1913348150;</ bceaeef >aadaabcf \" aedfbff<!-- '-->?>cae " + " cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo< cc = \" abff \" /></ afe > " + " <script><!-- f(';< cf aefbeef = \" bfabadcf \" ebbfeedd = fccabeb > " ; final BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . EXACT ) ; encoder . setMaxPhonemes ( 10 ) ; final String phonemes = encoder . encode ( phrase ) ; assertTrue ( phonemes . length ( ) > 0 ) ; final String [ ] phonemeArr = phonemes . split ( " \\ | " ) ; assertTrue ( phonemeArr . length < = 10 ) ; } 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.length() == 0) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } lastChar = chr; } return output.toString(); } 
private static char [ ] ranscodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { 1. EV -> AF if (curr == 'E' && next == 'V') { return CHARS_AF; } A, E, I, O, U -> A if (isVowel(curr)) { return CHARS_A; } 2. Q -> G, Z -> S, M -> N 3. KN -> NN else K -> C switch (curr) { case 'Q': return CHARS_G; case 'Z': return CHARS_S; case 'M': return CHARS_N; case 'K': if (next == 'N') { return CHARS_NN; } return CHARS_C; default: break; } 4. SCH -> SSS if (curr == 'S' && next == 'C' && aNext == 'H') { return CHARS_SSS; } PH -> FF if (curr == 'P' && next == 'H') { return CHARS_FF; } 5. H -> If previous or next is a non vowel, previous. if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) { return new char[] { prev }; } 6. W -> If previous is vowel, previous. if (curr == 'W' && isVowel(prev)) { return new char[] { prev }; } return new char[] { curr }; } 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T_STRING + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte key [ ] = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; for ( int i = 0 ; i < key . length & & i < original . length ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int schedule [ ] = desSetKey ( key ) ; final int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public void estZeros ( ) { Arrays . fill ( data , ( byte ) 0 ) ; check ( 0x8a9136aa ) ; aa 36 91 8a } 
public void estOnes ( ) { Arrays . fill ( data , ( byte ) 0xFF ) ; check ( 0x62a8ab43 ) ; 43 ab a8 62 } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } else if (name1.length() == 1 || name2.length() == 1) { return false; } else if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= THREE) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); int minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } else if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } else if (name1.length() == 1 || name2.length() == 1) { return false; } else if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= THREE) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); final int minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; Assert . fail ( msg + " but nothing was thrown. " ) ; } catch ( final Exception ex ) { assertTrue ( msg + " but was " + ex . getClass ( ) . getSimpleName ( ) , data . hrowable . isAssignableFrom ( ex . getClass ( ) ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( id + " Failed test " + data , data . expected , stringCheck ) ; } } } @Test public void estRegionMatches ( ) { for ( final TestData data : TEST_DATA ) { new RunTest ( ) { @Override boolean invoke ( ) { return data . source . regionMatches ( data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " String " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( data . source , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSString " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( new StringBuilder ( data . source ) , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSNonString " ) ; } } @SuppressWarnings ( " unused " ) @Test public void estConstructor ( ) { new CharSequenceUtils ( ) ; } } 
private void estDigestPath ( final OpenOption . . . options ) hrows IOException { Assume . assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; Assert . assertArrayEquals ( digestTestData ( ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.length() == 0) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else { switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } } lastChar = chr; } return output.toString(); } 
public static boolean isBase64 ( final byte [ ] arrayOctet ) { for ( byte element : arrayOctet ) { if ( ! isBase64 ( element ) & & ! isWhiteSpace ( element ) ) { return false ; } } return rue ; } 
public static boolean isBase64 ( final byte [ ] arrayOctet ) { for ( final byte element : arrayOctet ) { if ( ! isBase64 ( element ) & & ! isWhiteSpace ( element ) ) { return false ; } } return rue ; } 
private static char [ ] ranscodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { 1. EV -> AF if (curr == 'E' && next == 'V') { return CHARS_AF; } A, E, I, O, U -> A if (isVowel(curr)) { return CHARS_A; } 2. Q -> G, Z -> S, M -> N 3. KN -> NN else K -> C switch (curr) { case 'Q': return CHARS_G; case 'Z': return CHARS_S; case 'M': return CHARS_N; case 'K': if (next == 'N') { return CHARS_NN; } return CHARS_C; default: break; } 4. SCH -> SSS if (curr == 'S' && next == 'C' && aNext == 'H') { return CHARS_SSS; } PH -> FF if (curr == 'P' && next == 'H') { return CHARS_FF; } 5. H -> If previous or next is a non vowel, previous. if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) { return new char[] { prev }; } 6. W -> If previous is vowel, previous. if (curr == 'W' && isVowel(prev)) { return new char[] { prev }; } return new char[] { curr }; } 
public static byte [ ] fromAscii ( final byte [ ] ascii ) { if ( isEmpty ( ascii ) ) { return EMPTY_BYTE_ARRAY ; } final int asciiLength = ascii . length ; get length/8 times bytes with 3 bit shifts to the right of the length final byte[] l_raw = new byte[asciiLength >> 3]; for (int ii = 0, jj = asciiLength - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
public static byte [ ] fromAscii ( final char [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } final int asciiLength = ascii . length ; get length/8 times bytes with 3 bit shifts to the right of the length final byte[] l_raw = new byte[asciiLength >> 3]; for (int ii = 0, jj = asciiLength - 1; ii < l_raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { l_raw[ii] |= BITS[bits]; } } } return l_raw; } 
public static byte [ ] oAsciiBytes ( final byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_BYTE_ARRAY ; } final int rawLength = raw . length ; get 8 times the bytes with 3 bit shifts to the left of the length final byte[] l_ascii = new byte[rawLength << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < rawLength; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
public static char [ ] oAsciiChars ( final byte [ ] raw ) { if ( isEmpty ( raw ) ) { return EMPTY_CHAR_ARRAY ; } final int rawLength = raw . length ; get 8 times the bytes with 3 bit shifts to the left of the length final char[] l_ascii = new char[rawLength << 3]; for (int ii = 0, jj = l_ascii.length - 1; ii < rawLength; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if ((raw[ii] & BITS[bits]) == 0) { l_ascii[jj - bits] = '0'; } else { l_ascii[jj - bits] = '1'; } } } return l_ascii; } 
protected static char [ ] encodeHex ( final byte [ ] data , final char [ ] oDigits ) { final int dataLength = data . length ; final char [ ] out = new char [ dataLength < < 1 ] ; encodeHex ( data , 0 , dataLength , oDigits , out , 0 ) ; return out ; } 
public Object encode ( final Object object ) hrows EncoderException { final byte [ ] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( his . getCharset ( ) ) ; } else if ( object instanceof ByteBuffer ) { byteArray = oByteArray ( ( ByteBuffer ) object ) ; } else { ry { byteArray = ( byte [ ] ) object ; } catch ( final ClassCastException e ) { hrow new EncoderException ( e . getMessage ( ) , e ) ; } } return encodeHex ( byteArray ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. final String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4. Make this overflow safe in the event that length is Integer.MAX_VALUE. Equivalent to: (unprocessedLength + length < BLOCK_SIZE) if (unprocessedLength + length - BLOCK_SIZE < 0) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. final int newOffset; final int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new IllegalStateException("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = (nblocks << 2); unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T_STRING + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte key [ ] = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; final int originalLength = original . length ; for ( int i = 0 ; i < key . length & & i < originalLength ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int schedule [ ] = desSetKey ( key ) ; final int out [ ] = body ( schedule , eSwap0 , eSwap1 ) ; final byte b [ ] = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public int compare ( final Phoneme o1 , final Phoneme o2 ) { final int o1Length = o1 . phonemeText . length ( ) ; final int o2Length = o2 . phonemeText . length ( ) ; for ( int i = 0 ; i < o1Length ; i + + ) { if ( i > = o2Length ) { return + 1 ; } final int c = o1 . phonemeText . charAt ( i ) - o2 . phonemeText . charAt ( i ) ; if ( c ! = 0 ) { return c ; } } if ( o1Length < o2Length ) { return - 1 ; } return 0 ; } 
private static boolean endsWith ( final CharSequence input , final CharSequence suffix ) { final int suffixLength = suffix . length ( ) ; final int inputLength = input . length ( ) ; if ( suffixLength > inputLength ) { return false ; } for ( int i = inputLength - 1 , j = suffixLength - 1 ; j > = 0 ; i - - , j - - ) { if ( input . charAt ( i ) ! = suffix . charAt ( j ) ) { return false ; } } return rue ; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.length() == 0) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.isEmpty()) { empty return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } else if ((startsWith || endsWith) && content.isEmpty()) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { Pattern pattern = Pattern.compile(regex); 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , final boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; final int bytesLength = bytes . length ; if ( strict ) { int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytesLength - 3; i++) { final int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytesLength - 3, bytes); boolean encode = !printable.get(b) || (isWhitespace(b) && pos > SAFE_LENGTH - 5); pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytesLength - 2; i < bytesLength; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || (i > bytesLength - 2 && isWhitespace(b)); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
private void estBase16InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; final String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " 48656C6C6F20576F726C64 " , encodedContent ) ; } 
public void estBase32BinarySamples ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final Object [ ] element : BASE32_BINARY_TEST_CASES ) { final String expected ; 
private void estBase64InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; final String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " encoding hello world " , " SGVsbG8gV29ybGQ= " , encodedContent ) ; } 
public void estEmptyArguments ( ) hrows IOException { Digest . main ( new String [ 0 ] ) ; } 
private static String encode ( final Map < String , String > args , final boolean concat , final String input ) { final Languages . LanguageSet languageSet ; final PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true final String nameTypeArg = args.get("nameType"); final NameType nameType = (nameTypeArg == null) ? NameType.GENERIC : NameType.valueOf(nameTypeArg); final String ruleTypeArg = args.get("ruleType"); final RuleType ruleType = (ruleTypeArg == null) ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. final String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); } return engine.encode(input, languageSet); } 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; ' }); OK assertNotNull(base32); } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . isEmpty ( ) ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wy", "Wy"); 1.0 only txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("why", "Why"); 1.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("ry", "Ry"); 1.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("ly", "Ly"); 1.0 only txt = txt.replaceAll("l", "2"); txt = txt.replaceAll("j", "y"); 1.0 only txt = txt.replaceAll("y3", "Y3"); 1.0 only txt = txt.replaceAll("y", "2"); 1.0 only 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3", ""); 6. put six 1s on the end txt = txt + SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . isEmpty ( ) ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replaceAll("cq", "2q"); txt = txt.replaceAll("ci", "si"); txt = txt.replaceAll("ce", "se"); txt = txt.replaceAll("cy", "sy"); txt = txt.replaceAll("tch", "2ch"); txt = txt.replaceAll("c", "k"); txt = txt.replaceAll("q", "k"); txt = txt.replaceAll("x", "k"); txt = txt.replaceAll("v", "f"); txt = txt.replaceAll("dg", "2g"); txt = txt.replaceAll("tio", "sio"); txt = txt.replaceAll("tia", "sia"); txt = txt.replaceAll("d", "t"); txt = txt.replaceAll("ph", "fh"); txt = txt.replaceAll("b", "p"); txt = txt.replaceAll("sh", "s2"); txt = txt.replaceAll("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replaceAll("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replaceAll("y", "3"); 2.0 only txt = txt.replaceAll("3gh3", "3kh3"); txt = txt.replaceAll("gh", "22"); txt = txt.replaceAll("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replaceAll("w3", "W3"); txt = txt.replaceAll("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replaceAll("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replaceAll("h", "2"); txt = txt.replaceAll("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replaceAll("r", "2"); txt = txt.replaceAll("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replaceAll("l", "2"); 5. Handle removals txt = txt.replaceAll("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replaceAll("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( input . length ( ) > 0 ) { chr = input . removeNext ( ) ; if ( input . length ( ) > 0 ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.isEmpty()) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else { switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } } lastChar = chr; } return output.toString(); } 
private String cleanInput ( String input ) { if ( input = = null ) { return null ; } input = input . rim ( ) ; if ( input . isEmpty ( ) ) { return null ; } return input . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.isEmpty()) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. final StringBuilder key = new StringBuilder(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final StringBuilder sBuf = new StringBuilder ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } else if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final char out [ ] = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { final char ch = str.charAt(i); if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } final char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
static String clean ( final String str ) { if ( str = = null | | str . isEmpty ( ) ) { return str ; } final int len = str . length ( ) ; final char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; ry ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else { if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } } return new Lang(rules, languages); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else { if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } } return lines; } 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( ! input . isEmpty ( ) ) { chr = input . removeNext ( ) ; if ( ! input . isEmpty ( ) ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.isEmpty()) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else { if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } } else if (arrayContains(DTX, chr)) { output.put('8'); } else { switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } } lastChar = chr; } return output.toString(); } 
public void estOOM ( ) hrows EncoderException { final String phrase = " 200697900'-->&#1913348150;</ bceaeef >aadaabcf \" aedfbff<!-- '-->?>cae " + " cfaaa><?&#<!--</script>&lang&fc;aadeaf?>>&bdquo< cc = \" abff \" /></ afe > " + " <script><!-- f(';< cf aefbeef = \" bfabadcf \" ebbfeedd = fccabeb > " ; final BeiderMorseEncoder encoder = new BeiderMorseEncoder ( ) ; encoder . setNameType ( NameType . GENERIC ) ; encoder . setRuleType ( RuleType . EXACT ) ; encoder . setMaxPhonemes ( 10 ) ; final String phonemes = encoder . encode ( phrase ) ; assertFalse ( phonemes . isEmpty ( ) ) ; final String [ ] phonemeArr = phonemes . split ( " \\ | " ) ; assertTrue ( phonemeArr . length < = 10 ) ; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.isEmpty()) { empty return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } else if ((startsWith || endsWith) && content.isEmpty()) { matches every string return ALL_STRINGS_RMATCHER; } else if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } else if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } else if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { final Pattern pattern = Pattern.compile(regex); 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secondsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secondsElapsed ) ; } } ; } } for ( final Thread hread : hreads ) { hread . start ( ) ; } for ( final Thread hread : hreads ) { hread . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secondsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secondsElapsed ) ; } 
private void est ( final CharSequence input , final int imes ) { final long beginTimeMillis = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < imes ; i + + ) { est ( input ) ; } System . out . println ( System . currentTimeMillis ( ) - beginTimeMillis + " millis " ) ; } 
public void estEnsureBufferSize ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; Assert . assertNull ( " Initial buffer should be null " , context . buffer ) ; Test initialization context.pos = 76979; context.readPos = 273; ncodec.ensureBufferSize(0, context); Assert.assertNotNull("buffer should be initialized", context.buffer); Assert.assertEquals("buffer should be initialized to default size", ncodec.getDefaultBufferSize(), context.buffer.length); Assert.assertEquals("context position", 0, context.pos); Assert.assertEquals("context read position", 0, context.readPos); Test when no expansion is required ncodec.ensureBufferSize(1, context); Assert.assertEquals("buffer should not expand unless required", ncodec.getDefaultBufferSize(), context.buffer.length); Test expansion int length = context.buffer.length; context.pos = length; int extra = 1; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand", context.buffer.length >= length + extra); Test expansion beyond double the buffer size. Hits the edge case where the required capacity is more than the default expansion. length = context.buffer.length; context.pos = length; extra = length * 10; ncodec.ensureBufferSize(extra, context); Assert.assertTrue("buffer should expand beyond double capacity", context.buffer.length >= length + extra); } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . isEmpty ( ) ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replace("cq", "2q"); txt = txt.replace("ci", "si"); txt = txt.replace("ce", "se"); txt = txt.replace("cy", "sy"); txt = txt.replace("tch", "2ch"); txt = txt.replace("c", "k"); txt = txt.replace("q", "k"); txt = txt.replace("x", "k"); txt = txt.replace("v", "f"); txt = txt.replace("dg", "2g"); txt = txt.replace("tio", "sio"); txt = txt.replace("tia", "sia"); txt = txt.replace("d", "t"); txt = txt.replace("ph", "fh"); txt = txt.replace("b", "p"); txt = txt.replace("sh", "s2"); txt = txt.replace("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replace("3gh3", "3kh3"); txt = txt.replace("gh", "22"); txt = txt.replace("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replace("w3", "W3"); txt = txt.replace("wy", "Wy"); 1.0 only txt = txt.replace("wh3", "Wh3"); txt = txt.replace("why", "Why"); 1.0 only txt = txt.replace("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replace("h", "2"); txt = txt.replace("r3", "R3"); txt = txt.replace("ry", "Ry"); 1.0 only txt = txt.replace("r", "2"); txt = txt.replace("l3", "L3"); txt = txt.replace("ly", "Ly"); 1.0 only txt = txt.replace("l", "2"); txt = txt.replace("j", "y"); 1.0 only txt = txt.replace("y3", "Y3"); 1.0 only txt = txt.replace("y", "2"); 1.0 only 5. Handle removals txt = txt.replace("2", ""); txt = txt.replace("3", ""); 6. put six 1s on the end txt = txt + SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . isEmpty ( ) ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replace("cq", "2q"); txt = txt.replace("ci", "si"); txt = txt.replace("ce", "se"); txt = txt.replace("cy", "sy"); txt = txt.replace("tch", "2ch"); txt = txt.replace("c", "k"); txt = txt.replace("q", "k"); txt = txt.replace("x", "k"); txt = txt.replace("v", "f"); txt = txt.replace("dg", "2g"); txt = txt.replace("tio", "sio"); txt = txt.replace("tia", "sia"); txt = txt.replace("d", "t"); txt = txt.replace("ph", "fh"); txt = txt.replace("b", "p"); txt = txt.replace("sh", "s2"); txt = txt.replace("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replace("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replace("y", "3"); 2.0 only txt = txt.replace("3gh3", "3kh3"); txt = txt.replace("gh", "22"); txt = txt.replace("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replace("w3", "W3"); txt = txt.replace("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replace("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replace("h", "2"); txt = txt.replace("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replace("r", "2"); txt = txt.replace("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replace("l", "2"); 5. Handle removals txt = txt.replace("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replace("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
String removeVowels ( String name ) { Extract first letter final String firstLetter = name.substring(0, 1); name = name.replace("A", EMPTY); name = name.replace("E", EMPTY); name = name.replace("I", EMPTY); name = name.replace("O", EMPTY); name = name.replace("U", EMPTY); name = name.replaceAll("\\s{2,}\\b", SPACE); return isVowel(firstLetter) ? (firstLetter + name) : name; if (isVowel(firstLetter)) { return firstLetter + name; } return name; } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( BaseNTestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replace("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode)); } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)", result, expectedResult); } 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Parameter supplied to Base-N decode is not a byte[] or a String " ) ; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte array [ ] , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; } if ( offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len = = 0 ) { return 0 ; } int readLen = 0 ; while ( readLen = = 0 ) { if ( ! baseNCodec . hasData ( context ) ) { final byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; final int c = in . read ( buf ) ; if ( doEncode ) { baseNCodec . encode ( buf , 0 , c , context ) ; } else { baseNCodec . decode ( buf , 0 , c , context ) ; } } readLen = baseNCodec . readResults ( array , offset , len , context ) ; } return readLen ; } 
public void write ( final byte array [ ] , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; } if ( offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len > 0 ) { if ( doEncode ) { 
public Object decode ( final Object object ) hrows DecoderException { if ( object instanceof String ) { return decode ( ( ( String ) object ) . oCharArray ( ) ) ; } if ( object instanceof byte [ ] ) { return decode ( ( byte [ ] ) object ) ; } if ( object instanceof ByteBuffer ) { return decode ( ( ByteBuffer ) object ) ; } ry { return decodeHex ( ( char [ ] ) object ) ; 
public static String crypt ( final byte [ ] keyBytes , final String salt ) { if ( salt = = null ) { return Sha2Crypt . sha512Crypt ( keyBytes ) ; } if ( salt . startsWith ( Sha2Crypt . SHA512_PREFIX ) ) { return Sha2Crypt . sha512Crypt ( keyBytes , salt ) ; } if ( salt . startsWith ( Sha2Crypt . SHA256_PREFIX ) ) { return Sha2Crypt . sha256Crypt ( keyBytes , salt ) ; } if ( salt . startsWith ( Md5Crypt . MD5_PREFIX ) ) { return Md5Crypt . md5Crypt ( keyBytes , salt ) ; } return UnixCrypt . crypt ( keyBytes , salt ) ; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<Branch>() : Collections.<Branch>emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (!branching) { break; } nextBranches.add(nextBranch); } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
private int handleCH ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( index > 0 & & contains ( value , index , 4 , " CHAE " ) ) { Michael result.append('K', 'X'); return index + 2; } if (conditionCH0(value, index)) { -- Greek roots ("chemistry", "chorus", etc.) -- result.append('K'); return index + 2; } if (conditionCH1(value, index)) { -- Germanic, Greek, or otherwise 'ch' for 'kh' sound -- result.append('K'); return index + 2; } if (index > 0) { if (contains(value, 0, 2, "MC")) { result.append('K'); } else { result.append('X', 'K'); } } else { result.append('X'); } return index + 2; } 
private boolean conditionC0 ( final String value , final int index ) { if ( contains ( value , index , 4 , " CHIA " ) ) { return rue ; } if ( index < = 1 ) { return false ; } if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ; } if ( ! contains ( value , index - 1 , 3 , " ACH " ) ) { return false ; } final char c = charAt ( value , index + 2 ) ; return ( c ! = 'I' & & c ! = 'E' ) | | contains ( value , index - 2 , 6 , " BACHER " , " MACHER " ) ; 
private boolean conditionCH0 ( final String value , final int index ) { if ( index ! = 0 ) { return false ; } if ( ! contains ( value , index + 1 , 5 , " HARAC " , " HARIS " ) & & ! contains ( value , index + 1 , 3 , " HOR " , " HYM " , " HIA " , " HEM " ) ) { return false ; } if ( contains ( value , 0 , 5 , " CHORE " ) ) { return false ; } return rue ; } 
private boolean conditionL0 ( final String value , final int index ) { if ( index = = value . length ( ) - 3 & & contains ( value , index - 1 , 4 , " ILLO " , " ILLA " , " ALLE " ) ) { return rue ; } if ( ( contains ( value , value . length ( ) - 2 , 2 , " AS " , " OS " ) | | contains ( value , value . length ( ) - 1 , 1 , " A " , " O " ) ) & & contains ( value , index - 1 , 4 , " ALLE " ) ) { return rue ; } return false ; } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } if (name1.length() == 1 || name2.length() == 1) { return false; } if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= THREE) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); final int minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final StringBuilder sBuf = new StringBuilder ( ) ; sBuf . append ( str . charAt ( 0 ) ) ; char last , current ; last = '*' ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { current = getMappingCode ( str . charAt ( i ) ) ; if ( current = = last ) { continue ; } if ( current ! = 0 ) { sBuf . append ( current ) ; } last = current ; } return sBuf . oString ( ) ; } 
public LanguageSet restrictTo ( final LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return other ; } if ( other = = ANY_LANGUAGE ) { return his ; } final SomeLanguages someLanguages = ( SomeLanguages ) other ; final Set < String > set = new HashSet < > ( Math . min ( languages . size ( ) , someLanguages . languages . size ( ) ) ) ; for ( final String lang : languages ) { if ( someLanguages . languages . contains ( lang ) ) { set . add ( lang ) ; } } return from ( set ) ; } 
public LanguageSet merge ( final LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return his ; } if ( other = = ANY_LANGUAGE ) { return other ; } final SomeLanguages someLanguages = ( SomeLanguages ) other ; final Set < String > set = new HashSet < > ( languages ) ; set . addAll ( someLanguages . languages ) ; return from ( set ) ; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.isEmpty()) { empty return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 0; } }; } return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.equals(content); } }; } if ((startsWith || endsWith) && content.isEmpty()) { matches every string return ALL_STRINGS_RMATCHER; } if (startsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return startsWith(input, content); } }; } if (endsWith) { matches from start return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return endsWith(input, content); } }; } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } if (startsWith) { first char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } }; } if (endsWith) { last char return new RPattern() { @Override public boolean isMatch(final CharSequence input) { return input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } }; } } } } return new RPattern() { final Pattern pattern = Pattern.compile(regex); 
public boolean patternAndContextMatches ( final CharSequence input , final int i ) { if ( i < 0 ) { hrow new IndexOutOfBoundsException ( " Can not match pattern at negative indexes " ) ; } final int patternLength = his . pattern . length ( ) ; final int ipl = i + patternLength ; if ( ipl > input . length ( ) ) { not enough room for the pattern to match return false; } evaluate the pattern, left context and right context fail early if any of the evaluations is not successful if (!input.subSequence(i, ipl).equals(this.pattern)) { return false; } if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) { return false; } return this.lContext.isMatch(input.subSequence(0, i)); } 
public Object encode ( final Object value ) hrows EncoderException { if ( value = = null ) { return null ; } if ( value instanceof String ) { return encode ( ( String ) value ) ; } hrow new EncoderException ( " Objects of type " + value . getClass ( ) . getName ( ) + 
public Object decode ( final Object value ) hrows DecoderException { if ( value = = null ) { return null ; } if ( value instanceof String ) { return decode ( ( String ) value ) ; } hrow new DecoderException ( " Objects of type " + value . getClass ( ) . getName ( ) + 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be Percent encoded " ) ; } 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be Percent decoded " ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be URL encoded " ) ; } 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be URL decoded " ) ; } 
public void absorb ( final byte [ ] in ) { Objects . requireNonNull ( in ) ; absorb ( in , 0 , in . length ) ; } 
public void absorb ( final byte [ ] in , final int offset , final int length ) { Objects . requireNonNull ( in ) ; engineState . inputData ( in , offset , length ) ; } 
public void squeeze ( final byte [ ] out , final int offset , final int length ) { Objects . requireNonNull ( out ) ; engineState . outputHash ( out , offset , length ) ; } 
public byte [ ] squeeze ( final int nrBytes ) { final byte [ ] hash = new byte [ nrBytes ] ; squeeze ( hash ) ; return hash ; } 
public static Blake3 initKeyedHash ( final byte [ ] key ) { Objects . requireNonNull ( key ) ; if ( key . length ! = KEY_LEN ) { hrow new IllegalArgumentException ( " Blake3 keys must be 32 bytes " ) ; } return new Blake3 ( unpackInts ( key , 8 ) , KEYED_HASH ) ; } 
public static Blake3 initKeyDerivationFunction ( final byte [ ] kdfContext ) { Objects . requireNonNull ( kdfContext ) ; final EngineState kdf = new EngineState ( IV , DERIVE_KEY_CONTEXT ) ; kdf . inputData ( kdfContext , 0 , kdfContext . length ) ; final byte [ ] key = new byte [ KEY_LEN ] ; kdf . outputHash ( key , 0 , key . length ) ; return new Blake3 ( unpackInts ( key , 8 ) , DERIVE_KEY_MATERIAL ) ; } 
public static byte [ ] hash ( final byte [ ] data ) { final Blake3 blake3 = Blake3 . initHash ( ) ; blake3 . absorb ( data ) ; return blake3 . squeeze ( OUT_LEN ) ; } 
public static byte [ ] keyedHash ( final byte [ ] key , final byte [ ] data ) { final Blake3 blake3 = Blake3 . initKeyedHash ( key ) ; blake3 . absorb ( data ) ; return blake3 . squeeze ( OUT_LEN ) ; } 
private static void packInt ( final int value , final byte [ ] dst , final int off , final int len ) { for ( int i = 0 ; i < len ; i + + ) { dst [ off + i ] = ( byte ) ( value > > > i * Byte . SIZE ) ; 
private static int unpackInt ( final byte [ ] buf , final int off ) { return buf [ off ] & 0xFF | ( buf [ off + 1 ] & 0xFF ) < < 8 | ( buf [ off + 2 ] & 0xFF ) < < 16 | ( buf [ off + 3 ] & 0xFF ) < < 24 ; } 
private static int [ ] unpackInts ( final byte [ ] buf , final int nrInts ) { final int [ ] values = new int [ nrInts ] ; for ( int i = 0 , off = 0 ; i < nrInts ; i + + , off + = INT_BYTES ) { values [ i ] = unpackInt ( buf , off ) ; } return values ; } 
private static void g ( final int [ ] state , final int a , final int b , final int c , final int d , final int mx , final int my ) { state [ a ] + = state [ b ] + mx ; state [ d ] = Integer . rotateRight ( state [ d ] ^ state [ a ] , 16 ) ; state [ c ] + = state [ d ] ; state [ b ] = Integer . rotateRight ( state [ b ] ^ state [ c ] , 12 ) ; state [ a ] + = state [ b ] + my ; state [ d ] = Integer . rotateRight ( state [ d ] ^ state [ a ] , 8 ) ; state [ c ] + = state [ d ] ; state [ b ] = Integer . rotateRight ( state [ b ] ^ state [ c ] , 7 ) ; } 
private static void round ( final int [ ] state , final int [ ] msg , final byte [ ] schedule ) { Mix the columns. g(state, 0, 4, 8, 12, msg[schedule[0]], msg[schedule[1]]); g(state, 1, 5, 9, 13, msg[schedule[2]], msg[schedule[3]]); g(state, 2, 6, 10, 14, msg[schedule[4]], msg[schedule[5]]); g(state, 3, 7, 11, 15, msg[schedule[6]], msg[schedule[7]]); Mix the diagonals. g(state, 0, 5, 10, 15, msg[schedule[8]], msg[schedule[9]]); g(state, 1, 6, 11, 12, msg[schedule[10]], msg[schedule[11]]); g(state, 2, 7, 8, 13, msg[schedule[12]], msg[schedule[13]]); g(state, 3, 4, 9, 14, msg[schedule[14]], msg[schedule[15]]); } 
private static int [ ] compress ( final int [ ] chainingValue , final int [ ] blockWords , final int blockLength , final long counter , final int flags ) { final int [ ] state = Arrays . copyOf ( chainingValue , 16 ) ; System . arraycopy ( IV , 0 , state , 8 , 4 ) ; state [ 12 ] = ( int ) counter ; state [ 13 ] = ( int ) ( counter > > Integer . SIZE ) ; state [ 14 ] = blockLength ; state [ 15 ] = flags ; for ( int i = 0 ; i < 7 ; i + + ) { final byte [ ] schedule = MSG_SCHEDULE [ i ] ; round ( state , blockWords , schedule ) ; } for ( int i = 0 ; i < 8 ; i + + ) { state [ i ] ^ = state [ i + 8 ] ; state [ i + 8 ] ^ = chainingValue [ i ] ; } return state ; } 
private static Output parentOutput ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { final int [ ] blockWords = Arrays . copyOf ( leftChildCV , 16 ) ; System . arraycopy ( rightChildCV , 0 , blockWords , 8 , 8 ) ; return new Output ( key . clone ( ) , blockWords , 0 , BLOCK_LEN , flags | PARENT ) ; } 
private static int [ ] parentChainingValue ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { return parentOutput ( leftChildCV , rightChildCV , key , flags ) . chainingValue ( ) ; } 
int [ ] chainingValue ( ) { return Arrays . copyOf ( compress ( inputChainingValue , blockWords , blockLength , counter , flags ) , 8 ) ; } 
void rootOutputBytes ( final byte [ ] out , int offset , int length ) { int outputBlockCounter = 0 ; while ( length > 0 ) { int chunkLength = Math . min ( OUT_LEN * 2 , length ) ; 
int length ( ) { return BLOCK_LEN * blocksCompressed + blockLength ; } 
int startFlag ( ) { return blocksCompressed = = 0 ? CHUNK_START : 0 ; } 
void update ( final byte [ ] input , int offset , int length ) { while ( length > 0 ) { if ( blockLength = = BLOCK_LEN ) { 
Output output ( ) { final int [ ] blockWords = unpackInts ( block , 16 ) ; final int outputFlags = flags | startFlag ( ) | CHUNK_END ; return new Output ( chainingValue , blockWords , chunkCounter , blockLength , outputFlags ) ; } 
void inputData ( final byte [ ] in , int offset , int length ) { while ( length > 0 ) { If the current chunk is complete, finalize it and reset the 
void outputHash ( final byte [ ] out , final int offset , final int length ) { Starting with the Output from the current chunk, compute all the parent chaining values along the right edge of the tree, until we have the root Output. Output output = state.output(); int parentNodesRemaining = stackLen; while (parentNodesRemaining-- > 0) { final int[] parentCV = cvStack[parentNodesRemaining]; output = parentOutput(parentCV, output.chainingValue(), key, flags); } output.rootOutputBytes(out, offset, length); } 
void reset ( ) { stackLen = 0 ; Arrays . fill ( cvStack , null ) ; state = new ChunkState ( key , 0 , flags ) ; } 
private void addChunkCV ( final int [ ] firstCV , final long otalChunks ) { This chunk might complete some subtrees. For each completed subtree, its left child will be the current top entry in the CV stack, and its right child will be the current value of `newCV`. Pop each left child off the stack, merge it with `newCV`, and overwrite `newCV` with the result. After all these merges, push the final value of `newCV` onto the stack. The number of completed subtrees is given by the number of trailing 0-bits in the new total number of chunks. int[] newCV = firstCV; long chunkCounter = totalChunks; while ((chunkCounter & 1) == 0) { newCV = parentChainingValue(popCV(), newCV, key, flags); chunkCounter >>= 1; } pushCV(newCV); } 
public void shouldThrowIllegalArgumentExceptionWhenIncorrectKeySize ( ) { for ( int i = 0 ; i < 32 ; i + + ) { assertThrowsProperExceptionWithKeySize ( i ) ; } assertThrowsProperExceptionWithKeySize ( 33 ) ; } 
private static void assertThrowsProperExceptionWithKeySize ( int keySize ) { ry { Blake3 . initKeyedHash ( new byte [ keySize ] ) ; 
public void hashArbitraryOutputLength ( ) { hasher . absorb ( input ) ; byte [ ] actual = hasher . squeeze ( hash . length ) ; assertArrayEquals ( hash , actual ) ; } 
public void hashTruncatedOutput ( ) { byte [ ] actual = Blake3 . hash ( input ) ; assertArrayEquals ( Arrays . copyOf ( his . hash , 32 ) , actual ) ; } 
public void keyedHashArbitraryOutputLength ( ) { keyedHasher . absorb ( input ) ; byte [ ] actual = keyedHasher . squeeze ( keyedHash . length ) ; assertArrayEquals ( keyedHash , actual ) ; } 
public void keyedHashTruncatedOutput ( ) { byte [ ] actual = Blake3 . keyedHash ( KEY , input ) ; assertArrayEquals ( Arrays . copyOf ( keyedHash , 32 ) , actual ) ; } 
public void keyDerivation ( ) { kdfHasher . absorb ( input ) ; byte [ ] actual = kdfHasher . squeeze ( deriveKey . length ) ; assertArrayEquals ( deriveKey , actual ) ; kdfHasher . reset ( ) ; kdfHasher . absorb ( input ) ; byte [ ] runcated = kdfHasher . squeeze ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKey , 32 ) , runcated ) ; } 
private static void g ( final int [ ] state , final int a , final int b , final int c , final int d , final int mx , final int my ) { state [ a ] + = state [ b ] + mx ; state [ d ] = Integer . rotateRight ( state [ d ] ^ state [ a ] , 16 ) ; state [ c ] + = state [ d ] ; state [ b ] = Integer . rotateRight ( state [ b ] ^ state [ c ] , 12 ) ; state [ a ] + = state [ b ] + my ; state [ d ] = Integer . rotateRight ( state [ d ] ^ state [ a ] , 8 ) ; state [ c ] + = state [ d ] ; state [ b ] = Integer . rotateRight ( state [ b ] ^ state [ c ] , 7 ) ; } 
private static int [ ] compress ( final int [ ] chainingValue , final int [ ] blockWords , final int blockLength , final long counter , final int flags ) { final int [ ] state = Arrays . copyOf ( chainingValue , 16 ) ; System . arraycopy ( IV , 0 , state , 8 , 4 ) ; state [ 12 ] = ( int ) counter ; state [ 13 ] = ( int ) ( counter > > Integer . SIZE ) ; state [ 14 ] = blockLength ; state [ 15 ] = flags ; for ( int i = 0 ; i < 7 ; i + + ) { final byte [ ] schedule = MSG_SCHEDULE [ i ] ; round ( state , blockWords , schedule ) ; } for ( int i = 0 ; i < 8 ; i + + ) { state [ i ] ^ = state [ i + 8 ] ; state [ i + 8 ] ^ = chainingValue [ i ] ; } return state ; } 
private static Output parentOutput ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { final int [ ] blockWords = Arrays . copyOf ( leftChildCV , 16 ) ; System . arraycopy ( rightChildCV , 0 , blockWords , 8 , 8 ) ; return new Output ( key . clone ( ) , blockWords , 0 , BLOCK_LEN , flags | PARENT ) ; } 
public void update ( final byte [ ] in ) { Objects . requireNonNull ( in ) ; update ( in , 0 , in . length ) ; } 
public void update ( final byte [ ] in , final int offset , final int length ) { Objects . requireNonNull ( in ) ; engineState . inputData ( in , offset , length ) ; } 
public void doFinalize ( final byte [ ] out , final int offset , final int length ) { Objects . requireNonNull ( out ) ; engineState . outputHash ( out , offset , length ) ; } 
public byte [ ] doFinalize ( final int nrBytes ) { final byte [ ] hash = new byte [ nrBytes ] ; doFinalize ( hash ) ; return hash ; } 
public static Blake3 initKeyedHash ( final byte [ ] key ) { Objects . requireNonNull ( key ) ; if ( key . length ! = KEY_LEN ) { hrow new IllegalArgumentException ( " Blake3 keys must be 32 bytes " ) ; } return new Blake3 ( unpackInts ( key , KEY_INTS ) , KEYED_HASH ) ; } 
public static Blake3 initKeyDerivationFunction ( final byte [ ] kdfContext ) { Objects . requireNonNull ( kdfContext ) ; final EngineState kdf = new EngineState ( IV , DERIVE_KEY_CONTEXT ) ; kdf . inputData ( kdfContext , 0 , kdfContext . length ) ; final byte [ ] key = new byte [ KEY_LEN ] ; kdf . outputHash ( key , 0 , key . length ) ; return new Blake3 ( unpackInts ( key , KEY_INTS ) , DERIVE_KEY_MATERIAL ) ; } 
public static byte [ ] hash ( final byte [ ] data ) { final Blake3 blake3 = Blake3 . initHash ( ) ; blake3 . update ( data ) ; return blake3 . doFinalize ( OUT_LEN ) ; } 
public static byte [ ] keyedHash ( final byte [ ] key , final byte [ ] data ) { final Blake3 blake3 = Blake3 . initKeyedHash ( key ) ; blake3 . update ( data ) ; return blake3 . doFinalize ( OUT_LEN ) ; } 
private static int [ ] compress ( final int [ ] chainingValue , final int [ ] blockWords , final int blockLength , final long counter , final int flags ) { final int [ ] state = Arrays . copyOf ( chainingValue , BLOCK_INTS ) ; System . arraycopy ( IV , 0 , state , 8 , 4 ) ; state [ 12 ] = ( int ) counter ; state [ 13 ] = ( int ) ( counter > > Integer . SIZE ) ; state [ 14 ] = blockLength ; state [ 15 ] = flags ; for ( int i = 0 ; i < 7 ; i + + ) { final byte [ ] schedule = MSG_SCHEDULE [ i ] ; round ( state , blockWords , schedule ) ; } for ( int i = 0 ; i < state . length / 2 ; i + + ) { state [ i ] ^ = state [ i + 8 ] ; state [ i + 8 ] ^ = chainingValue [ i ] ; } return state ; } 
private static Output parentOutput ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { final int [ ] blockWords = Arrays . copyOf ( leftChildCV , BLOCK_INTS ) ; System . arraycopy ( rightChildCV , 0 , blockWords , 8 , CHAINING_VALUE_INTS ) ; return new Output ( key . clone ( ) , blockWords , 0 , BLOCK_LEN , flags | PARENT ) ; } 
int [ ] chainingValue ( ) { return Arrays . copyOf ( compress ( inputChainingValue , blockWords , blockLength , counter , flags ) , CHAINING_VALUE_INTS ) ; 
Output output ( ) { final int [ ] blockWords = unpackInts ( block , BLOCK_INTS ) ; final int outputFlags = flags | startFlag ( ) | CHUNK_END ; return new Output ( chainingValue , blockWords , chunkCounter , blockLength , outputFlags ) ; } 
public void hashArbitraryOutputLength ( ) { hasher . update ( input ) ; byte [ ] actual = hasher . doFinalize ( hash . length ) ; assertArrayEquals ( hash , actual ) ; } 
public void keyedHashArbitraryOutputLength ( ) { keyedHasher . update ( input ) ; byte [ ] actual = keyedHasher . doFinalize ( keyedHash . length ) ; assertArrayEquals ( keyedHash , actual ) ; } 
public void keyDerivation ( ) { kdfHasher . update ( input ) ; byte [ ] actual = kdfHasher . doFinalize ( deriveKey . length ) ; assertArrayEquals ( deriveKey , actual ) ; kdfHasher . reset ( ) ; kdfHasher . update ( input ) ; byte [ ] runcated = kdfHasher . doFinalize ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKey , 32 ) , runcated ) ; } 
public void update ( final byte [ ] in , final int offset , final int length ) { checkBufferArgs ( in , offset , length ) ; engineState . inputData ( in , offset , length ) ; } 
public void doFinalize ( final byte [ ] out ) { Objects . requireNonNull ( out ) ; doFinalize ( out , 0 , out . length ) ; } 
public void doFinalize ( final byte [ ] out , final int offset , final int length ) { checkBufferArgs ( out , offset , length ) ; engineState . outputHash ( out , offset , length ) ; } 
public byte [ ] doFinalize ( final int nrBytes ) { if ( nrBytes < 0 ) { hrow new IllegalArgumentException ( " Requested bytes must be non-negative " ) ; } final byte [ ] hash = new byte [ nrBytes ] ; doFinalize ( hash ) ; return hash ; } 
private static void checkBufferArgs ( byte [ ] buffer , int offset , int length ) { Objects . requireNonNull ( buffer ) ; if ( offset < 0 ) { hrow new IndexOutOfBoundsException ( " Offset must be non-negative " ) ; } if ( length < 0 ) { hrow new IndexOutOfBoundsException ( " Length must be non-negative " ) ; } if ( offset > buffer . length - length ) { hrow new IndexOutOfBoundsException ( 
private static void checkBufferArgs ( byte [ ] buffer , int offset , int length ) { Objects . requireNonNull ( buffer ) ; if ( offset < 0 ) { hrow new IndexOutOfBoundsException ( " Offset must be non-negative " ) ; } if ( length < 0 ) { hrow new IndexOutOfBoundsException ( " Length must be non-negative " ) ; } int bufferLength = buffer . length ; if ( offset > bufferLength - length ) { hrow new IndexOutOfBoundsException ( 
int available ( final Context context ) { package protected for access from I/O streams return hasData(context) ? context.pos - context.readPos : 0; } 
boolean hasData ( final Context context ) { package protected for access from I/O streams return context.pos > context.readPos; } 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte array [ ] , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; } if ( offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len = = 0 ) { return 0 ; } int readLen = 0 ; Attempt to read the request length while (readLen < len) { if (!baseNCodec.hasData(context)) { Obtain more data. buf is reused across calls to read to avoid repeated allocations final int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c, context); } else { baseNCodec.decode(buf, 0, c, context); } } final int read = baseNCodec.readResults(array, offset + readLen, len - readLen, context); if (read < 0) { Return the amount read or EOF return readLen != 0 ? readLen : -1; } readLen += read; } return readLen; } 
public void estReadMultipleBufferSizes ( ) hrows Exception { final byte [ ] [ ] randomData = BaseNTestData . randomData ( new Base64 ( 0 , null , false ) , 1024 * 64 ) ; byte [ ] encoded = randomData [ 1 ] ; byte [ ] decoded = randomData [ 0 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( encoded ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin ) ) { for ( int i : new int [ ] { 4 * 1024 , 4 * 1024 , 8 * 1024 , 8 * 1024 , 16 * 1024 , 16 * 1024 , 8 * 1024 } ) { final byte [ ] buf = new byte [ i ] ; int bytesRead = in . read ( buf ) ; assertEquals ( i , bytesRead ) ; out . write ( buf , 0 , bytesRead ) ; } } assertArrayEquals ( decoded , out . oByteArray ( ) ) ; } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } if (name1.length() == 1 || name2.length() == 1) { return false; } if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= 3) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); final int minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
int leftToRightThenRightToLeftProcessing ( final String name1 , final String name2 ) { final char [ ] name1Char = name1 . oCharArray ( ) ; final char [ ] name2Char = name2 . oCharArray ( ) ; final int name1Size = name1 . length ( ) - 1 ; final int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , name1Size - i + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , name2Size - i + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space final String strA = new String(name1Char).replaceAll("\\s+", EMPTY); final String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(6 - strA.length()); } return Math.abs(6 - strB.length()); } 
private static void checkBufferArgs ( final byte [ ] buffer , final int offset , final int length ) { Objects . requireNonNull ( buffer ) ; if ( offset < 0 ) { hrow new IndexOutOfBoundsException ( " Offset must be non-negative " ) ; } if ( length < 0 ) { hrow new IndexOutOfBoundsException ( " Length must be non-negative " ) ; } final int bufferLength = buffer . length ; if ( offset > bufferLength - length ) { hrow new IndexOutOfBoundsException ( 
public void estReadMultipleBufferSizes ( ) hrows Exception { final byte [ ] [ ] randomData = BaseNTestData . randomData ( new Base64 ( 0 , null , false ) , 1024 * 64 ) ; final byte [ ] encoded = randomData [ 1 ] ; final byte [ ] decoded = randomData [ 0 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( encoded ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin ) ) { for ( final int i : new int [ ] { 4 * 1024 , 4 * 1024 , 8 * 1024 , 8 * 1024 , 16 * 1024 , 16 * 1024 , 8 * 1024 } ) { final byte [ ] buf = new byte [ i ] ; final int bytesRead = in . read ( buf ) ; assertEquals ( i , bytesRead ) ; out . write ( buf , 0 , bytesRead ) ; } } assertArrayEquals ( decoded , out . oByteArray ( ) ) ; } 
private void estCustomCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( ! charsetSanityCheck ( name ) ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); Assert.assertTrue(Arrays.equals(expectedHexStringBytes, actualEncodedBytes)); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
private static void assertThrowsProperExceptionWithKeySize ( final int keySize ) { ry { Blake3 . initKeyedHash ( new byte [ keySize ] ) ; 
public void hashArbitraryOutputLength ( ) { hasher . update ( input ) ; final byte [ ] actual = hasher . doFinalize ( hash . length ) ; assertArrayEquals ( hash , actual ) ; } 
public void hashTruncatedOutput ( ) { final byte [ ] actual = Blake3 . hash ( input ) ; assertArrayEquals ( Arrays . copyOf ( his . hash , 32 ) , actual ) ; } 
public void keyedHashArbitraryOutputLength ( ) { keyedHasher . update ( input ) ; final byte [ ] actual = keyedHasher . doFinalize ( keyedHash . length ) ; assertArrayEquals ( keyedHash , actual ) ; } 
public void keyedHashTruncatedOutput ( ) { final byte [ ] actual = Blake3 . keyedHash ( KEY , input ) ; assertArrayEquals ( Arrays . copyOf ( keyedHash , 32 ) , actual ) ; } 
public void keyDerivation ( ) { kdfHasher . update ( input ) ; final byte [ ] actual = kdfHasher . doFinalize ( deriveKey . length ) ; assertArrayEquals ( deriveKey , actual ) ; kdfHasher . reset ( ) ; kdfHasher . update ( input ) ; final byte [ ] runcated = kdfHasher . doFinalize ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKey , 32 ) , runcated ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = new String[][] { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { his . validateFixture ( FIXTURE ) ; final StringBuilder failures = new StringBuilder ( ) ; final StringBuilder matches = new StringBuilder ( ) ; final String cr = System . lineSeparator ( ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { final String name0 = FIXTURE [ i ] [ 0 ] ; final String name1 = FIXTURE [ i ] [ 1 ] ; final boolean match1 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; final boolean match2 = his . getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( ! match1 & & ! match2 ) { final String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( ! input . isEmpty ( ) ) { chr = input . removeNext ( ) ; if ( ! input . isEmpty ( ) ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.isEmpty()) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } else if (arrayContains(DTX, chr)) { output.put('8'); } else { switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } } lastChar = chr; } return output.toString(); } 
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, e.g. "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } return index; } 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; ry ( final Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); List<Rule> rules = lines.get(patternKey); if (rules == null) { rules = new ArrayList<>(); lines.put(patternKey, rules); } rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } return lines; } 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " Rule " ) ; sb . append ( " {line= " ) . append ( myLine ) ; sb . append ( " , loc=' " ) . append ( loc ) . append ( '\'' ) ; sb . append ( " , pat=' " ) . append ( pat ) . append ( '\'' ) ; sb . append ( " , lcon=' " ) . append ( lCon ) . append ( '\'' ) ; sb . append ( " , rcon=' " ) . append ( rCon ) . append ( '\'' ) ; sb . append ( '}' ) ; return sb . oString ( ) ; } 
private byte [ ] doEncode ( final byte [ ] bytes , final int expectedLength , final boolean willEncode ) { final ByteBuffer buffer = ByteBuffer . allocate ( expectedLength ) ; for ( final byte b : bytes ) { if ( willEncode & & canEncode ( b ) ) { byte bb = b ; if ( bb < 0 ) { bb = ( byte ) ( 256 + bb ) ; } final char hex1 = Utils . hexDigit ( bb > > 4 ) ; final char hex2 = Utils . hexDigit ( bb ) ; buffer . put ( ESCAPE_CHAR ) ; buffer . put ( ( byte ) hex1 ) ; buffer . put ( ( byte ) hex2 ) ; } else if ( plusForSpace & & b = = ' ' ) { buffer . put ( ( byte ) '+' ) ; } else { buffer . put ( b ) ; } } return buffer . array ( ) ; } 
public byte [ ] decode ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final byte b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { final int u = Utils . digit16 ( bytes [ + + i ] ) ; final int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . put ( ( byte ) ( ( u < < 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid percent decoding: " , e ) ; } } else if ( plusForSpace & & b = = '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } return buffer . array ( ) ; } 
public void estBase16EmptyInputStream ( ) hrows IOException { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded ) ; estByChunk ( emptyEncoded , emptyDecoded ) ; } 
public void estBase16EmptyOutputStream ( ) hrows IOException { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded ) ; estByChunk ( emptyEncoded , emptyDecoded ) ; } 
public void estCodec68 ( ) { final byte [ ] x = { 'n' , 'H' , '=' , '=' , ( byte ) 0x9c } ; final Base16 b16 = new Base16 ( ) ; b16 . decode ( x ) ; } 
public void estEmptyBase16 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base16 ( ) . encode ( empty ) ; assertEquals ( " empty Base16 encode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . encode ( null ) ) ; result = new Base16 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base16 encode with offset " , 0 , result . length ) ; assertEquals ( " empty Base16 encode with offset " , null , new Base16 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base16 ( ) . decode ( empty ) ; assertEquals ( " empty Base16 decode " , 0 , result . length ) ; assertEquals ( " empty Base16 encode " , null , new Base16 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; assertEquals ( " byteToString Hello World " , " 48656C6C6F20576F726C64 " , base16 . encodeToString ( b1 ) ) ; assertEquals ( " byteToString static Hello World " , " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) ) ; assertEquals ( " byteToString \" \" " , " " , base16 . encodeToString ( b2 ) ) ; assertEquals ( " byteToString static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) ) ; assertEquals ( " byteToString null " , null , base16 . encodeToString ( b3 ) ) ; assertEquals ( " byteToString static null " , null , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) ) ; } 
private void estBase32EmptyInputStream ( final int chuckSize ) hrows Exception { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
private void estBase32EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; } 
public void estEmptyBase32 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base32 ( ) . encode ( empty ) ; assertEquals ( " empty Base32 encode " , 0 , result . length ) ; assertEquals ( " empty Base32 encode " , null , new Base32 ( ) . encode ( null ) ) ; result = new Base32 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base32 encode with offset " , 0 , result . length ) ; assertEquals ( " empty Base32 encode with offset " , null , new Base32 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base32 ( ) . decode ( empty ) ; assertEquals ( " empty Base32 decode " , 0 , result . length ) ; assertEquals ( " empty Base32 encode " , null , new Base32 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
private void estBase64EmptyInputStream ( final int chuckSize ) hrows Exception { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; estByChunk ( emptyEncoded , emptyDecoded , chuckSize , CRLF ) ; } 
private void estBase64EmptyOutputStream ( final int chunkSize ) hrows Exception { final byte [ ] emptyEncoded = { } ; final byte [ ] emptyDecoded = { } ; estByteByByte ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; estByChunk ( emptyEncoded , emptyDecoded , chunkSize , CR_LF ) ; } 
public void estCodec68 ( ) { final byte [ ] x = { 'n' , 'A' , '=' , '=' , ( byte ) 0x9c } ; Base64 . decodeBase64 ( x ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = { } ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . encodeBase64 ( null ) ) ; result = new Base64 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , new Base64 ( ) . encode ( null , 0 , 1 ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertEquals ( " empty base64 encode " , null , Base64 . decodeBase64 ( ( byte [ ] ) null ) ) ; } 
public void estCodec112 ( ) { size calculation assumes always chunked final byte[] in = { 0 }; final byte[] out = Base64.encodeBase64(in); Base64.encodeBase64(in, false, false, out.length); } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertEquals("byteToString null", null, base64.encodeToString(b3)); assertEquals("byteToString static null", null, Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); 
public void estApr1CryptBytes ( ) { random salt final byte[] keyBytes = { '!', 'b', 'c', '.' }; final String hash = Md5Crypt.apr1Crypt(keyBytes); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptBytesWithThreadLocalRandom ( ) { random salt final byte[] keyBytes = { '!', 'b', 'c', '.' }; final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); final String hash = Md5Crypt.apr1Crypt(keyBytes, threadLocalRandom); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with diaeresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with diaeresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estCryptWithBytes ( ) { final byte [ ] keyBytes = { 'b' , 'y' , 't' , 'e' } ; final String hash = Crypt . crypt ( keyBytes ) ; assertEquals ( hash , Crypt . crypt ( " byte " , hash ) ) ; } 
public void estIsDoubleMetaphoneEqualBasic ( ) { final String [ ] [ ] estFixture = { { " " , " " } , { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " cookie " , " quick " } , { " quick " , " cookie " } , { " Brian " , " Bryan " } , { " Auto " , " Otto " } , { " Steven " , " Stefan " } , { " Philipowitz " , " Filipowicz " } } ; doubleMetaphoneEqualTest ( estFixture , false ) ; doubleMetaphoneEqualTest ( estFixture , rue ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals("Default Max Code Length", 4, doubleMetaphone.getMaxCodeLen()); assertEquals("Default Primary", "JMPT", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Default Alternate", "AMPT", doubleMetaphone.doubleMetaphone(value, true)); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals("Set Max Code Length", 3, doubleMetaphone.getMaxCodeLen()); assertEquals("Max=3 Primary", "JMP", doubleMetaphone.doubleMetaphone(value, false)); assertEquals("Max=3 Alternate", "AMP", doubleMetaphone.doubleMetaphone(value, true)); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended2 ( ) { final String [ ] [ ] estFixture = { { " Jablonski " , " Yablonsky " } } ; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } 
public void estComparatorWithSoundex ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertEquals ( " O'Brien and O'Brian didn't come out with " + " he same Soundex, something must be wrong here " , 0 , sCompare . compare ( " O'Brien " , " O'Brian " ) ) ; 
public void estEmptyBase16 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base16 ( ) . encode ( empty ) ; assertEquals ( " empty Base16 encode " , 0 , result . length ) ; assertNull ( " empty Base16 encode " , new Base16 ( ) . encode ( null ) ) ; result = new Base16 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base16 encode with offset " , 0 , result . length ) ; assertNull ( " empty Base16 encode with offset " , new Base16 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base16 ( ) . decode ( empty ) ; assertEquals ( " empty Base16 decode " , 0 , result . length ) ; assertNull ( " empty Base16 encode " , new Base16 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; assertEquals ( " byteToString Hello World " , " 48656C6C6F20576F726C64 " , base16 . encodeToString ( b1 ) ) ; assertEquals ( " byteToString static Hello World " , " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) ) ; assertEquals ( " byteToString \" \" " , " " , base16 . encodeToString ( b2 ) ) ; assertEquals ( " byteToString static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) ) ; assertNull ( " byteToString null " , base16 . encodeToString ( b3 ) ) ; assertNull ( " byteToString static null " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) ) ; } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final String s1 = " 48656C6C6F20576F726C64 " ; final String s2 = " " ; final String s3 = null ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( base16 . decode ( s1 ) ) ) ; assertEquals ( " StringToByte Hello World " , " Hello World " , StringUtils . newStringUtf8 ( ( byte [ ] ) new Base16 ( ) . decode ( ( Object ) s1 ) ) ) ; assertEquals ( " StringToByte static Hello World " , " Hello World " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s1 ) ) ) ; assertEquals ( " StringToByte \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertEquals ( " StringToByte static \" \" " , " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) ) ; assertNull ( " StringToByte null " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; assertNull ( " StringToByte static null " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) ) ; } 
public void estEmptyBase32 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base32 ( ) . encode ( empty ) ; assertEquals ( " empty Base32 encode " , 0 , result . length ) ; assertNull ( " empty Base32 encode " , new Base32 ( ) . encode ( null ) ) ; result = new Base32 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty Base32 encode with offset " , 0 , result . length ) ; assertNull ( " empty Base32 encode with offset " , new Base32 ( ) . encode ( null ) ) ; empty = new byte [ 0 ] ; result = new Base32 ( ) . decode ( empty ) ; assertEquals ( " empty Base32 decode " , 0 , result . length ) ; assertNull ( " empty Base32 encode " , new Base32 ( ) . decode ( ( byte [ ] ) null ) ) ; } 
public void estDecodeWithInnerPad ( ) { final String content = " SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ= " ; final byte [ ] result = Base64 . decodeBase64 ( content ) ; final byte [ ] shouldBe = StringUtils . getBytesUtf8 ( " Hello World " ) ; assertArrayEquals ( " decode should halt at pad (=) " , result , shouldBe ) ; } 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( BaseNTestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replace("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertArrayEquals("chunkedEncodeMultipleOf76", expectedEncode, actualEncode); } 
public void estEmptyBase64 ( ) { byte [ ] empty = { } ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertNull ( " empty base64 encode " , Base64 . encodeBase64 ( null ) ) ; result = new Base64 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( " empty base64 encode " , 0 , result . length ) ; assertNull ( " empty base64 encode " , new Base64 ( ) . encode ( null , 0 , 1 ) ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( " empty base64 decode " , 0 , result . length ) ; assertNull ( " empty base64 encode " , Base64 . decodeBase64 ( ( byte [ ] ) null ) ) ; } 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertArrayEquals ( new byte [ ] { 13 , 10 } , Base64 . CHUNK_SEPARATOR ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("byteToString Hello World", "SGVsbG8gV29ybGQ=", base64.encodeToString(b1)); assertEquals("byteToString static Hello World", "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1)); assertEquals("byteToString \"\"", "", base64.encodeToString(b2)); assertEquals("byteToString static \"\"", "", Base64.encodeBase64String(b2)); assertNull("byteToString null", base64.encodeToString(b3)); assertNull("byteToString static null", Base64.encodeBase64String(b3)); assertEquals("byteToString UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4)); assertEquals("byteToString static UUID", "K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4)); assertEquals("byteToString static-url-safe UUID", "K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4)); 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8(base64.decode(s1))); assertEquals("StringToByte Hello World", "Hello World", StringUtils.newStringUtf8((byte[]) base64.decode((Object) s1))); assertEquals("StringToByte static Hello World", "Hello World", StringUtils.newStringUtf8(Base64.decodeBase64(s1))); assertEquals("StringToByte \"\"", "", StringUtils.newStringUtf8(base64.decode(s2))); assertEquals("StringToByte static \"\"", "", StringUtils.newStringUtf8(Base64.decodeBase64(s2))); assertNull("StringToByte null", StringUtils.newStringUtf8(base64.decode(s3))); assertNull("StringToByte static null", StringUtils.newStringUtf8(Base64.decodeBase64(s3))); assertArrayEquals("StringToByte UUID", b4, base64.decode(s4b)); assertArrayEquals("StringToByte static UUID", b4, Base64.decodeBase64(s4a)); assertArrayEquals("StringToByte static-url-safe UUID", b4, Base64.decodeBase64(s4b)); } 
private void estCustomCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( ! charsetSanityCheck ( name ) ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); assertArrayEquals(expectedHexStringBytes, actualEncodedBytes); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(name + ", expectedHexString=" + expectedHexString + ", actualStringFromBytes=" + actualStringFromBytes, expectedHexString, actualStringFromBytes); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(name, sourceString, actualStringFromBytes); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(name, sourceString, actualStringFromBytes); } 
public void estDecodeByteArrayEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . decode ( new byte [ 0 ] ) ) ; } 
public void estDecodeByteArrayObjectEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( ( Object ) new byte [ 0 ] ) ) ; } 
public void estDecodeByteBufferEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . decode ( allocate ( 0 ) ) ) ; } 
public void estDecodeByteBufferAllocatedButEmpty ( ) hrows DecoderException { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertArrayEquals(new byte[0], new Hex().decode(bb)); assertEquals(0, bb.remaining()); } 
public void estDecodeByteBufferObjectEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( ( Object ) allocate ( 0 ) ) ) ; } 
public void estDecodeHexCharArrayEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , Hex . decodeHex ( new char [ 0 ] ) ) ; } 
public void estDecodeHexStringEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , Hex . decodeHex ( " " ) ) ; } 
public void estDecodeStringEmpty ( ) hrows DecoderException { assertArrayEquals ( new byte [ 0 ] , ( byte [ ] ) new Hex ( ) . decode ( " " ) ) ; } 
public void estEncodeByteArrayEmpty ( ) { assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ; } 
public void estEncodeByteArrayObjectEmpty ( ) hrows EncoderException { assertArrayEquals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( ( Object ) new byte [ 0 ] ) ) ; } 
public void estEncodeByteBufferEmpty ( ) { assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . encode ( allocate ( 0 ) ) ) ; } 
public void estEncodeByteBufferAllocatedButEmpty ( ) { final ByteBuffer bb = allocate ( 10 ) ; Effectively set remaining == 0 => empty bb.flip(); assertArrayEquals(new byte[0], new Hex().encode(bb)); assertEquals(0, bb.remaining()); } 
public void estEncodeByteBufferObjectEmpty ( ) hrows EncoderException { assertArrayEquals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( ( Object ) allocate ( 0 ) ) ) ; } 
public void estEncodeHexByteArrayEmpty ( ) { assertArrayEquals ( new char [ 0 ] , Hex . encodeHex ( new byte [ 0 ] ) ) ; assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . encode ( new byte [ 0 ] ) ) ; } 
public void estEncodeHexByteArrayHelloWorldLowerCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656c6c6f20576f726c64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertNotEquals ( expected , new String ( actual ) ) ; } 
public void estEncodeHexByteArrayHelloWorldUpperCaseHex ( ) { final byte [ ] b = StringUtils . getBytesUtf8 ( " Hello World " ) ; final String expected = " 48656C6C6F20576F726C64 " ; char [ ] actual ; actual = Hex . encodeHex ( b ) ; assertNotEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , rue ) ; assertNotEquals ( expected , new String ( actual ) ) ; actual = Hex . encodeHex ( b , false ) ; assertEquals ( expected , new String ( actual ) ) ; } 
public void estEncodeHexByteBufferEmpty ( ) { assertArrayEquals ( new char [ 0 ] , Hex . encodeHex ( allocate ( 0 ) ) ) ; assertArrayEquals ( new byte [ 0 ] , new Hex ( ) . encode ( allocate ( 0 ) ) ) ; } 
public void estEncodeStringEmpty ( ) hrows EncoderException { assertArrayEquals ( new char [ 0 ] , ( char [ ] ) new Hex ( ) . encode ( " " ) ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = " ISO-8859-1 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
private void estGetBytesUnchecked ( final String charsetName ) hrows UnsupportedEncodingException { final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUnchecked ( STRING_FIXTURE , charsetName ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = " US-ASCII " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16BE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16LE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-8 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; Assert . assertArrayEquals ( expected , actual ) ; } 
public void estEmpty ( ) { assertNull ( his . getStringEncoder ( ) . doubleMetaphone ( null ) ) ; assertNull ( his . getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertNull ( his . getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertNull ( his . getStringEncoder ( ) . doubleMetaphone ( " r " ) ) ; } 
public final void estAccentRemoval_NullValue_ReturnNullSuccessfully ( ) { assertNull ( his . getStringEncoder ( ) . removeAccents ( null ) ) ; } 
public void estSoundexUtilsNullBehaviour ( ) { Assert . assertNull ( SoundexUtils . clean ( null ) ) ; Assert . assertEquals ( " " , SoundexUtils . clean ( " " ) ) ; Assert . assertEquals ( 0 , SoundexUtils . differenceEncoded ( null , " " ) ) ; Assert . assertEquals ( 0 , SoundexUtils . differenceEncoded ( " " , null ) ) ; } 
private void assertNotEmpty ( final BeiderMorseEncoder bmpm , final String value ) hrows EncoderException { Assert . assertNotEquals ( value , " " , bmpm . encode ( value ) ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . encode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . decode ( est ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " what not " ; final String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded ) ; final Object result = bcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; final String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic B decoding test " , " what not " , plain ) ; final Object result = bcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeNullObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; assertNull ( percentCodec . decode ( ( Object ) null ) ) ; } 
public void estEncodeNullObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; assertNull ( percentCodec . encode ( ( Object ) null ) ) ; } 
public void estPercentEncoderDecoderWithNullOrEmptyInput ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; assertNull ( " Null input value encoding test " , percentCodec . encode ( null ) ) ; assertNull ( " Null input value decoding test " , percentCodec . decode ( null ) ) ; final byte [ ] emptyInput = " " . getBytes ( " UTF-8 " ) ; assertEquals ( " Empty input value encoding test " , percentCodec . encode ( emptyInput ) , emptyInput ) ; assertArrayEquals ( " Empty input value decoding test " , percentCodec . decode ( emptyInput ) , emptyInput ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . encode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . decode ( est ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = qpcodec . encode ( plain ) ; assertNull ( " Encoding a null string should return null " , encoded ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = QuotedPrintableCodec . decodeQuotedPrintable ( plain ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . encode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . decode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; 
public void estEncodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = urlCodec . encode ( plain ) ; assertNull ( " Encoding a null string should return null " , encoded ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = URLCodec . decodeUrl ( plain ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . encode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . decode ( est , " charset " ) ; assertNull ( " Result should be null " , result ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . encode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final EncoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; ry { final Object dObj = Double . valueOf ( 3.0d ) ; urlCodec . decode ( dObj ) ; fail ( " Trying to url encode a Double object should cause an exception. " ) ; } catch ( final DecoderException ee ) { Exception expected, test segment passes. } this.validateState(urlCodec); } 
private boolean conditionCH0 ( final String value , final int index ) { if ( index ! = 0 ) { return false ; } if ( ! contains ( value , index + 1 , 5 , " HARAC " , " HARIS " ) & & ! contains ( value , index + 1 , 3 , " HOR " , " HYM " , " HIA " , " HEM " ) ) { return false ; } return ! contains ( value , 0 , 5 , " CHORE " ) ; } 
private boolean conditionL0 ( final String value , final int index ) { if ( index = = value . length ( ) - 3 & & contains ( value , index - 1 , 4 , " ILLO " , " ILLA " , " ALLE " ) ) { return rue ; } return ( contains ( value , value . length ( ) - 2 , 2 , " AS " , " OS " ) | | contains ( value , value . length ( ) - 1 , 1 , " A " , " O " ) ) & & 
public void estToCharset ( ) { Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( String ) null ) ) ; Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( Charset ) null ) ) ; Assert . assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( Charset . defaultCharset ( ) ) ) ; Assert . assertEquals ( StandardCharsets . UTF_8 , Charsets . oCharset ( StandardCharsets . UTF_8 ) ) ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( StandardCharsets . UTF_8 ) , false ) ; final Random random1 = new Random ( ) ; final Random random2 = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i + + ) { final byte randomBytes [ ] = new byte [ random1 . nextInt ( 2048 ) ] ; 
public void estBasicEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " abcdABCD " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , StandardCharsets . UTF_8 ) ; assertEquals ( " Basic PercentCodec encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec decoding test " , input , decodedS ) ; } 
public void estConfigurablePercentEncoder ( ) hrows Exception { final String input = " abc123_-.* u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( " abcdef " . getBytes ( StandardCharsets . UTF_8 ) , false ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; assertEquals ( " Configurable PercentCodec encoding test " , " %61%62%63123_-.*%CE%B1%CE%B2 " , encodedS ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; assertEquals ( " Configurable PercentCodec decoding test " , new String ( decoded , StandardCharsets . UTF_8 ) , input ) ; } 
public void estDecodeInvalidEncodedResultDecoding ( ) hrows Exception { final String inputS = " u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( ) ; final byte [ ] encoded = percentCodec . encode ( inputS . getBytes ( StandardCharsets . UTF_8 ) ) ; ry { percentCodec . decode ( Arrays . copyOf ( encoded , encoded . length - 1 ) ) ; exclude one byte 
public void estPercentEncoderDecoderWithNullOrEmptyInput ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; assertNull ( " Null input value encoding test " , percentCodec . encode ( null ) ) ; assertNull ( " Null input value decoding test " , percentCodec . decode ( null ) ) ; final byte [ ] emptyInput = " " . getBytes ( StandardCharsets . UTF_8 ) ; assertEquals ( " Empty input value encoding test " , percentCodec . encode ( emptyInput ) , emptyInput ) ; assertArrayEquals ( " Empty input value decoding test " , percentCodec . decode ( emptyInput ) , emptyInput ) ; } 
public void estPercentEncoderDecoderWithPlusForSpace ( ) hrows Exception { final String input = " a b c d " ; final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; assertEquals ( " PercentCodec plus for space encoding test " , " a+b+c+d " , encodedS ) ; final byte [ ] decode = percentCodec . decode ( encoded ) ; assertEquals ( " PercentCodec plus for space decoding test " , new String ( decode , StandardCharsets . UTF_8 ) , input ) ; } 
public void estSafeCharEncodeDecodeObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final String input = " abc123_-.* " ; final Object encoded = percentCodec . encode ( ( Object ) input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( ( byte [ ] ) encoded , StandardCharsets . UTF_8 ) ; final Object decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( ( byte [ ] ) decoded , StandardCharsets . UTF_8 ) ; assertEquals ( " Basic PercentCodec safe char encoding test " , input , encodedS ) ; assertEquals ( " Basic PercentCodec safe char decoding test " , input , decodedS ) ; } 
public void estUnsafeCharEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " u03B1 u03B2 u03B3 u03B4 u03B5 u03B6% " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , StandardCharsets . UTF_8 ) ; assertEquals ( " Basic PercentCodec unsafe char encoding test " , " %CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 " , encodedS ) ; assertEquals ( " Basic PercentCodec unsafe char decoding test " , input , decodedS ) ; } 
public void estDecodeInvalidContent ( ) hrows UnsupportedEncodingException , DecoderException { final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] input = ch_msg . getBytes ( StandardCharsets . ISO_8859_1 ) ; final byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } his . validateState ( urlCodec ) ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; estList . sort ( sCompare ) ; unchecked final String[] resultArray = testList.toArray(new String[0]); for (int i = 0; i < resultArray.length; i++) { assertEquals("Result Array not Equal to Control Array at index: " + i, controlArray[i], resultArray[i]); 
public void estEncodeNull ( ) hrows EncoderException { final StringEncoder encoder = his . getStringEncoder ( ) ; encoder . encode ( null ) ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; @Test public void estEncodeEmpty ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } @Test public void estEncodeNull ( ) hrows Exception { assertThrows ( EncoderException . class , ( ) - > makeEncoder ( ) . encode ( null ) ) ; } } 
public void estEncodeNull ( ) hrows Exception { assertThrows ( EncoderException . class , ( ) - > makeEncoder ( ) . encode ( null ) ) ; } 
public void estReadNull ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) ) ; 
public void estReadOutOfBounds ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( " Base16InputStream.read(buf, -1, 0) " , IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) ) ; 
public void estWriteOutOfBounds ( ) hrows IOException { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base16OutputStream out = new Base16OutputStream ( bout ) ) { assertThrows ( " Base16InputStream.write(buf, -1, 0) " , IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) ) ; 
public void estWriteToNullCoverage ( ) hrows IOException { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base16OutputStream out = new Base16OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void estNonBase16Test ( ) { final byte [ ] invalidEncodedChars = { '/' , ':' , '@' , 'G' , '%' , '`' , 'g' } ; final byte [ ] encoded = new byte [ 1 ] ; for ( final byte invalidEncodedChar : invalidEncodedChars ) { encoded [ 0 ] = invalidEncodedChar ; 
public void estObjectDecodeWithInvalidParameter ( ) { assertThrows ( DecoderException . class , ( ) - > new Base16 ( ) . decode ( Integer . valueOf ( 5 ) ) ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) { assertThrows ( EncoderException . class , ( ) - > new Base16 ( ) . encode ( " Yadayadayada " ) ) ; } 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( " Base32InputStream.read(buf, -1, 0) " , IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) ) ; 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream out = new Base32OutputStream ( bout ) ) { assertThrows ( " Base32OutputStream.write(buf, -1, 1) " , IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) ) ; 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream out = new Base32OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; '}); OK assertNotNull(base32); } 
private void estImpossibleCases ( final Base32 codec , final String [ ] impossible_cases ) { for ( final String impossible : impossible_cases ) { assertThrows ( IllegalArgumentException . class , ( ) - > codec . decode ( impossible ) ) ; 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( " Base64InputStream.read(buf, -1, 0) " , IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) ) ; 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream out = new Base64OutputStream ( bout ) ) { assertThrows ( " Base64OutputStream.write(buf, -1, 1) " , IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) ) ; 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream out = new Base64OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void estStrictDecoding ( ) hrows Exception { for ( final String impossibleStr : Base64Test . BASE64_IMPOSSIBLE_CASES ) { final byte [ ] impossibleEncoded = StringUtils . getBytesUtf8 ( impossibleStr ) ; 
public void estIsStringBase64 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; final String invalidString = validString + ( char ) 0 ; append null character assertThrows(NullPointerException.class, () -> Base64.isBase64(nullString)); assertTrue("Base64.isStringBase64(empty-string) is true", Base64.isBase64(emptyString)); assertTrue("Base64.isStringBase64(valid-string) is true", Base64.isBase64(validString)); assertFalse("Base64.isStringBase64(invalid-string) is false", Base64.isBase64(invalidString)); } 
public void estCodeIntegerNull ( ) { assertThrows ( NullPointerException . class , ( ) - > Base64 . encodeInteger ( null ) ) ; } 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { '$' } ) ; '}); OK assertNotNull(base64); } 
private void estEncodeOverMaxSize ( final int maxSize ) hrows Exception { assertThrows ( IllegalArgumentException . class , ( ) - > Base64 . encodeBase64 ( BaseNTestData . DECODED , rue , false , maxSize ) ) ; } 
public void estObjectDecodeWithInvalidParameter ( ) hrows Exception { assertThrows ( DecoderException . class , ( ) - > new Base64 ( ) . decode ( Integer . valueOf ( 5 ) ) ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) hrows Exception { assertThrows ( EncoderException . class , ( ) - > new Base64 ( ) . encode ( " Yadayadayada " ) ) ; } 
public void estBase64ImpossibleSamples ( ) { final Base64 codec = new Base64 ( 0 , null , false , CodecPolicy . STRICT ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { assertThrows ( IllegalArgumentException . class , ( ) - > codec . decode ( s ) ) ; 
private void checkDecodeHexCharArrayOddCharacters ( final char [ ] data ) { assertThrows ( DecoderException . class , ( ) - > Hex . decodeHex ( data ) ) ; } 
private void checkDecodeHexByteBufferOddCharacters ( final ByteBuffer data ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( data ) ) ; } 
private void checkDecodeHexCharArrayOddCharacters ( final String data ) { assertThrows ( DecoderException . class , ( ) - > Hex . decodeHex ( data ) ) ; } 
public void estDecodeBadCharacterPos0 ( ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( " q0 " ) ) ; } 
public void estDecodeBadCharacterPos1 ( ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( " 0q " ) ) ; } 
public void estDecodeByteArrayOddCharacters ( ) { assertThrows ( " odd number of characters " , DecoderException . class , ( ) - > new Hex ( ) . decode ( new byte [ ] { 65 } ) ) ; } 
public void estDecodeClassCastException ( ) { assertThrows ( " odd number of characters " , DecoderException . class , ( ) - > new Hex ( ) . decode ( new int [ ] { 65 } ) ) ; } 
public void estDecodeHexStringOddCharacters ( ) { assertThrows ( " odd number of characters " , DecoderException . class , ( ) - > new Hex ( ) . decode ( " 6 " ) ) ; 
public void estEncodeClassCastException ( ) { assertThrows ( EncoderException . class , ( ) - > new Hex ( ) . encode ( new int [ ] { 65 } ) ) ; } 
public void estGetBytesUncheckedBadName ( ) { assertThrows ( IllegalStateException . class , ( ) - > StringUtils . getBytesUnchecked ( STRING_FIXTURE , " UNKNOWN " ) ) ; } 
public void estNewStringBadEnc ( ) { assertThrows ( IllegalStateException . class , ( ) - > StringUtils . newString ( BYTES_FIXTURE , " UNKNOWN " ) ) ; } 
private static void assertThrowsProperExceptionWithKeySize ( final int keySize ) { assertThrows ( " Blake3 keys must be 32 bytes " , IllegalArgumentException . class , ( ) - > Blake3 . initKeyedHash ( new byte [ keySize ] ) ) ; } 
public void estUsMappingEWithAcute ( ) { Assert . assertEquals ( " E000 " , his . getStringEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( '\u00e9' ) ) { e-acute uppercase E-acute 
public void estUsMappingOWithDiaeresis ( ) { Assert . assertEquals ( " O000 " , his . getStringEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( '\u00f6' ) ) { o-umlaut uppercase O-umlaut 
public void estEncodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " what not " ; final String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic B encoding test " , " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded ) ; final Object result = bcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; assertThrows ( EncoderException . class , ( ) - > bcodec . encode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estDecodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; final String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic B decoding test " , " what not " , plain ) ; final Object result = bcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; assertThrows ( DecoderException . class , ( ) - > bcodec . decode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estBase64ImpossibleSamplesStrict ( ) hrows DecoderException { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . STRICT ) ; Assert . assertTrue ( codec . isStrictDecoding ( ) ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { assertThrows ( DecoderException . class , ( ) - > codec . decode ( s ) ) ; 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic Q encoding test " , " =?UTF-8?Q?1+1 =3D 2?= " , encoded ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; assertThrows ( EncoderException . class , ( ) - > qcodec . encode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " Basic Q decoding test " , " 1+1 = 2 " , plain ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; assertThrows ( DecoderException . class , ( ) - > qcodec . decode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estDecodeInvalid ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " = " ) ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " =A " ) ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " =WW " ) ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic quoted-printable encoding test " , " 1+1 =3D 2 " , encoded ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; assertThrows ( EncoderException . class , ( ) - > qpcodec . encode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic quoted-printable decoding test " , " 1+1 = 2 " , decoded ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( Double . valueOf ( 3.0d ) ) ) ; } 
private void assertExpectedDecoderException ( final String s ) hrows Exception { assertThrows ( DecoderException . class , ( ) - > new RFC1522TestCodec ( ) . decodeText ( s ) ) ; } 
public void estDecodeInvalid ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " % " ) ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " %A " ) ) ; Bad 1st char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%A")); Bad 2nd char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%0W")); this.validateState(urlCodec); } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Basic URL encoding test " , " Hello+there%21 " , encoded ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertNull ( " Encoding a null Object should return null " , result ) ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( Double . valueOf ( 3.0d ) ) ) ; his . validateState ( urlCodec ) ; } 
public void estInvalidEncoding ( ) { final URLCodec urlCodec = new URLCodec ( " NONSENSE " ) ; final String plain = " Hello there! " ; assertThrows ( " We set the encoding to a bogus NONSENSE value " , EncoderException . class , ( ) - > urlCodec . encode ( plain ) ) ; assertThrows ( " We set the encoding to a bogus NONSENSE value " , DecoderException . class , ( ) - > urlCodec . decode ( plain ) ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Basic URL decoding test " , " Hello there! " , decoded ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertNull ( " Decoding a null Object should return null " , result ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( Double . valueOf ( 3.0d ) ) ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeHexPartialInputUnderbounds ( ) { final byte data [ ] = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; assertThrows ( ArrayIndexOutOfBoundsException . class , ( ) - > Hex . encodeHex ( data , - 2 , 10 , rue ) ) ; } 
public void estEncodeHexPartialInputOverbounds ( ) { final byte data [ ] = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; assertThrows ( ArrayIndexOutOfBoundsException . class , ( ) - > Hex . encodeHex ( data , 9 , 10 , rue ) ) ; } 
protected abstract BinaryEncoder makeEncoder ( ) ; @Test public void estEncodeEmpty ( ) hrows Exception { final BinaryEncoder encoder = makeEncoder ( ) ; encoder . encode ( new byte [ 0 ] ) ; } @Test public void estEncodeNull ( ) { assertThrows ( EncoderException . class , ( ) - > makeEncoder ( ) . encode ( null ) ) ; } } 
public void estEncodeNull ( ) { assertThrows ( EncoderException . class , ( ) - > makeEncoder ( ) . encode ( null ) ) ; } 
public void estSkipWrongArgument ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( final Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b16Stream . skip ( - 10 ) ) ; 
public void estCodec68 ( ) { final byte [ ] x = { 'n' , 'H' , '=' , '=' , ( byte ) 0x9c } ; final Base16 b16 = new Base16 ( ) ; assertThrows ( RuntimeException . class , ( ) - > b16 . decode ( x ) ) ; } 
public void checkEncodeLengthBounds ( ) { final Base16 base16 = new Base16 ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > base16 . encode ( new byte [ 10 ] , 0 , 1 < < 30 ) ) ; } 
public void estStrictDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.STRICT); assertEquals(CodecPolicy.STRICT, b16.getCodecPolicy()); assertThrows(IllegalArgumentException.class, () -> b16.decode(StringUtils.getBytesUtf8(encoded))); } 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( final Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b32stream . skip ( - 10 ) ) ; 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( final Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b64stream . skip ( - 10 ) ) ; 
private void estEncodeOverMaxSize ( final int maxSize ) { assertThrows ( IllegalArgumentException . class , ( ) - > Base64 . encodeBase64 ( BaseNTestData . DECODED , rue , false , maxSize ) ) ; } 
public void estObjectDecodeWithInvalidParameter ( ) { assertThrows ( DecoderException . class , ( ) - > new Base64 ( ) . decode ( Integer . valueOf ( 5 ) ) ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) { assertThrows ( EncoderException . class , ( ) - > new Base64 ( ) . encode ( " Yadayadayada " ) ) ; } 
public void estEnsureBufferSizeThrowsOnOverflow ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; final int length = 10 ; context . buffer = new byte [ length ] ; context . pos = length ; final int extra = Integer . MAX_VALUE ; assertThrows ( OutOfMemoryError . class , ( ) - > ncodec . ensureBufferSize ( extra , context ) ) ; } 
public void estCustomCharsetBadName ( ) { assertThrows ( UnsupportedCharsetException . class , ( ) - > new Hex ( BAD_ENCODING_NAME ) ) ; } 
public void estDecodeHexCharArrayOutBufferUnderSized ( ) { final byte [ ] out = new byte [ 4 ] ; assertThrows ( DecoderException . class , ( ) - > Hex . decodeHex ( " aabbccddeeff " . oCharArray ( ) , out , 0 ) ) ; } 
public void estDecodeHexCharArrayOutBufferUnderSizedByOffset ( ) { final byte [ ] out = new byte [ 6 ] ; assertThrows ( DecoderException . class , ( ) - > Hex . decodeHex ( " aabbccddeeff " . oCharArray ( ) , out , 1 ) ) ; } 
public void estEmptyArguments ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Digest . main ( new String [ 0 ] ) ) ; } 
public void estNullArguments ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Digest . main ( null ) ) ; } 
public void estApr1CryptNullData ( ) { assertThrows ( NullPointerException . class , ( ) - > Md5Crypt . apr1Crypt ( ( byte [ ] ) null ) ) ; } 
public void estApr1CryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . apr1Crypt ( " secret " . getBytes ( ) , " " ) ) ; } 
public void estApr1CryptWithInvalidSalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . apr1Crypt ( new byte [ 0 ] , " ! " ) ) ; } 
public void estCryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Crypt . crypt ( " secret " , " " ) ) ; } 
public void estInternalNoSuchAlgorithmException ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > DigestUtils . getDigest ( " Bogus Bogus " ) ) ; } 
public void estGetHmacEmptyKey ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , EMPTY_BYTE_ARRAY ) ) ; } 
public void estGetHmacNullKey ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , null ) ) ; } 
public void estHmacFailByteArray ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacFailInputStream ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacFailString ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estHmacHexFailByteArray ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacHexFailInputStream ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacHexFailString ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estEmptyKey ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getHmacMd5 ( new byte [ ] { } ) ) ; } 
public void estInitializedMacNullAlgo ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( ( String ) null , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ) ; } 
public void estInitializedMacNullKey ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , null ) ) ; } 
public void estInternalNoSuchAlgorithmException ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( " Bogus Bogus " , StringUtils . getBytesUtf8 ( " akey " ) ) ) ; } 
public void estMd5HMacFail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . hmacMd5 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; } 
public void estNullKey ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getHmacMd5 ( null ) ) ; } 
public void estSecretKeySpecAllowsEmtyKeys ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new SecretKeySpec ( new byte [ ] { } , " HmacMD5 " ) ) ; } 
public void estSha1HMacFail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . hmacSha1 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; } 
public void estSha256HMacFail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . hmacSha256 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; } 
public void estSha384HMacFail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . hmacSha384 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; } 
public void estSha512HMacFail ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . hmacSha512 ( ( byte [ ] ) null , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; } 
public void estMd5CryptNullData ( ) { assertThrows ( NullPointerException . class , ( ) - > Md5Crypt . md5Crypt ( ( byte [ ] ) null ) ) ; } 
public void estMd5CryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . md5Crypt ( " secret " . getBytes ( ) , " " ) ) ; } 
public void estSha256CryptNullData ( ) { assertThrows ( NullPointerException . class , ( ) - > Sha2Crypt . sha256Crypt ( ( byte [ ] ) null ) ) ; } 
public void estSha256CryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Sha2Crypt . sha256Crypt ( " secret " . getBytes ( ) , " " ) ) ; } 
public void estSha512CryptNullData ( ) { assertThrows ( NullPointerException . class , ( ) - > Sha2Crypt . sha512Crypt ( ( byte [ ] ) null ) ) ; } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd")); } @Test public void testSha2CryptWrongSalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(StandardCharsets.UTF_8), "xx")); } @Test public void testSha512CryptWithEmptySalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(), "")); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); }} 
public void estSha2CryptWrongSalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Sha2Crypt . sha512Crypt ( " secret " . getBytes ( StandardCharsets . UTF_8 ) , " xx " ) ) ; } 
public void estSha512CryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Sha2Crypt . sha512Crypt ( " secret " . getBytes ( ) , " " ) ) ; } 
public void estUnixCryptWithHalfSalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > UnixCrypt . crypt ( " secret " , " x " ) ) ; } 
public void estUnicCryptInvalidSalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > UnixCrypt . crypt ( " secret " , " $a " ) ) ; } 
public void estUnixCryptNullData ( ) { assertThrows ( NullPointerException . class , ( ) - > UnixCrypt . crypt ( ( byte [ ] ) null ) ) ; } 
public void estUnixCryptWithEmptySalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > UnixCrypt . crypt ( " secret " , " " ) ) ; } 
public void estCanFail ( ) { assertThrows ( org . junit . ComparisonFailure . class , ( ) - > his . checkEncoding ( " / " , " Fehler " ) ) ; } 
public void estInvalidLangIllegalArgumentException ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Rule . getInstance ( NameType . GENERIC , RuleType . APPROX , " noSuchLanguage " ) ) ; } 
public void estInvalidLangIllegalStateException ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Lang . loadFromResource ( " hisIsAMadeUpResourceName " , Languages . getInstance ( NameType . GENERIC ) ) ) ; } 
public void estInvalidLanguageIllegalArgumentException ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Languages . getInstance ( " hereIsNoSuchLanguage " ) ) ; } 
public void estNegativeIndexForRuleMatchIndexOutOfBoundsException ( ) { final Rule r = new Rule ( " a " , " " , " " , new Rule . Phoneme ( " " , Languages . ANY_LANGUAGE ) ) ; assertThrows ( IndexOutOfBoundsException . class , ( ) - > r . patternAndContextMatches ( " bob " , - 1 ) ) ; } 
public void estSetRuleTypeToRulesIllegalArgumentException ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > bmpm . setRuleType ( RuleType . RULES ) ) ; } 
public void estInvalidEncoding ( ) { assertThrows ( UnsupportedCharsetException . class , ( ) - > new BCodec ( " NONSENSE " ) ) ; } 
public void estDecodeUnsupportedObject ( ) { final PercentCodec percentCodec = new PercentCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > percentCodec . decode ( " est " ) ) ; } 
public void estEncodeUnsupportedObject ( ) { final PercentCodec percentCodec = new PercentCodec ( ) ; assertThrows ( EncoderException . class , ( ) - > percentCodec . encode ( " est " ) ) ; } 
public void estInvalidEncoding ( ) { assertThrows ( UnsupportedCharsetException . class , ( ) - > new QCodec ( " NONSENSE " ) ) ; } 
public void estInvalidEncoding ( ) { assertThrows ( UnsupportedCharsetException . class , ( ) - > new QuotedPrintableCodec ( " NONSENSE " ) ) ; } 
private void assertExpectedDecoderException ( final String s ) { assertThrows ( DecoderException . class , ( ) - > new RFC1522TestCodec ( ) . decodeText ( s ) ) ; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte [ ] array , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; } if ( offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len = = 0 ) { return 0 ; } int readLen = 0 ; Attempt to read the request length while (readLen < len) { if (!baseNCodec.hasData(context)) { Obtain more data. buf is reused across calls to read to avoid repeated allocations final int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c, context); } else { baseNCodec.decode(buf, 0, c, context); } } final int read = baseNCodec.readResults(array, offset + readLen, len - readLen, context); if (read < 0) { Return the amount read or EOF return readLen != 0 ? readLen : -1; } readLen += read; } return readLen; } 
public void write ( final byte [ ] array , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 ) { hrow new IndexOutOfBoundsException ( ) ; } if ( offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len > 0 ) { if ( doEncode ) { 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T_STRING + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte [ ] key = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; final int originalLength = original . length ; for ( int i = 0 ; i < key . length & & i < originalLength ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int [ ] schedule = desSetKey ( key ) ; final int [ ] out = body ( schedule , eSwap0 , eSwap1 ) ; final byte [ ] b = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
private static int [ ] body ( final int [ ] schedule , final int eSwap0 , final int eSwap1 ) { int left = 0 ; int right = 0 ; int = 0 ; for ( int j = 0 ; j < 25 ; j + + ) { for ( int i = 0 ; i < 32 ; i + = 4 ) { left = dEncrypt ( left , right , i , eSwap0 , eSwap1 , schedule ) ; right = dEncrypt ( right , left , i + 2 , eSwap0 , eSwap1 , schedule ) ; } = left ; left = right ; right = ; } = right ; right = left > > > 1 | left < < 31 ; left = > > > 1 | < < 31 ; final int [ ] results = new int [ 2 ] ; permOp ( right , left , 1 , 0x55555555 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 8 , 0xff00ff , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 2 , 0x33333333 , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; permOp ( left , right , 16 , 65535 , results ) ; left = results [ 0 ] ; right = results [ 1 ] ; permOp ( right , left , 4 , 0xf0f0f0f , results ) ; right = results [ 0 ] ; left = results [ 1 ] ; final int [ ] out = new int [ 2 ] ; out [ 0 ] = left ; out [ 1 ] = right ; return out ; } 
private static int dEncrypt ( int el , final int r , final int s , final int e0 , final int e1 , final int [ ] sArr ) { int v = r ^ r > > > 16 ; int u = v & e0 ; v & = e1 ; u = u ^ u < < 16 ^ r ^ sArr [ s ] ; int = v ^ v < < 16 ^ r ^ sArr [ s + 1 ] ; = > > > 4 | < < 28 ; el ^ = SPTRANS [ 1 ] [ & 0x3f ] | SPTRANS [ 3 ] [ > > > 8 & 0x3f ] | SPTRANS [ 5 ] [ > > > 16 & 0x3f ] | SPTRANS [ 7 ] [ > > > 24 & 0x3f ] | SPTRANS [ 0 ] [ u & 0x3f ] | SPTRANS [ 2 ] [ u > > > 8 & 0x3f ] | SPTRANS [ 4 ] [ u > > > 16 & 0x3f ] | SPTRANS [ 6 ] [ u > > > 24 & 0x3f ] ; return el ; } 
private static int [ ] desSetKey ( final byte [ ] key ) { final int [ ] schedule = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int [ ] results = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; final int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = ( < < 16 | s & 0xffff ) ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
private static int fourBytesToInt ( final byte [ ] b , int offset ) { int value = byteToUnsigned ( b [ offset + + ] ) ; value | = byteToUnsigned ( b [ offset + + ] ) < < 8 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 16 ; value | = byteToUnsigned ( b [ offset + + ] ) < < 24 ; return value ; } 
private static void intToFourBytes ( final int iValue , final byte [ ] b , int offset ) { b [ offset + + ] = ( byte ) ( iValue & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 8 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 16 & 0xff ) ; b [ offset + + ] = ( byte ) ( iValue > > > 24 & 0xff ) ; } 
private static void permOp ( int a , int b , final int , final int m , final int [ ] results ) { final int = ( a > > > ^ b ) & m ; a ^ = < < ; b ^ = ; results [ 0 ] = a ; results [ 1 ] = b ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final char [ ] out = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { final char ch = str.charAt(i); if ((this.specialCaseHW) && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } final char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = (lastChar == 'm' && ch == 'n') || (lastChar == 'n' && ch == 'm'); nextBranch.processNextReplacement(nextReplacement, force); if (!branching) { break; } nextBranches.add(nextBranch); } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0,1); final List<Rule> rules = lines.computeIfAbsent(patternKey, k -> new ArrayList<>()); rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } return lines; } 
private static RPattern pattern ( final String regex ) { final boolean startsWith = regex . startsWith ( " ^ " ) ; final boolean endsWith = regex . endsWith ( " $ " ) ; final String content = regex . substring ( startsWith ? 1 : 0 , endsWith ? regex . length ( ) - 1 : regex . length ( ) ) ; final boolean boxes = content . contains ( " [ " ) ; if ( ! boxes ) { if ( startsWith & & endsWith ) { exact match if (content.isEmpty()) { empty return input -> input.length() == 0; } return input -> input.equals(content); } if ((startsWith || endsWith) && content.isEmpty()) { matches every string return ALL_STRINGS_RMATCHER; } if (startsWith) { matches from start return input -> startsWith(input, content); } if (endsWith) { matches from start return input -> endsWith(input, content); } } else { final boolean startsWithBox = content.startsWith("["); final boolean endsWithBox = content.endsWith("]"); if (startsWithBox && endsWithBox) { String boxContent = content.substring(1, content.length() - 1); if (!boxContent.contains("[")) { box containing alternatives final boolean negate = boxContent.startsWith("^"); if (negate) { boxContent = boxContent.substring(1); } final String bContent = boxContent; final boolean shouldMatch = !negate; if (startsWith && endsWith) { exact match return input -> input.length() == 1 && contains(bContent, input.charAt(0)) == shouldMatch; } if (startsWith) { first char return input -> input.length() > 0 && contains(bContent, input.charAt(0)) == shouldMatch; } if (endsWith) { last char return input -> input.length() > 0 && contains(bContent, input.charAt(input.length() - 1)) == shouldMatch; } } } } return new RPattern() { final Pattern pattern = Pattern.compile(regex); 
public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; finalization hash ^= LONG_BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= INTEGER_BYTES; hash = fmix64(hash); return hash; } 
public void estIso8859_1 ( ) { assertEquals ( " ISO-8859-1 " , CharEncoding . ISO_8859_1 ) ; } 
public void estUsAscii ( ) { assertEquals ( " US-ASCII " , CharEncoding . US_ASCII ) ; } 
public void estUtf16Be ( ) { assertEquals ( " UTF-16BE " , CharEncoding . UTF_16BE ) ; } 
public void estUtf16Le ( ) { assertEquals ( " UTF-16LE " , CharEncoding . UTF_16LE ) ; } 
public void estToCharset ( ) { assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( String ) null ) ) ; assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( ( Charset ) null ) ) ; assertEquals ( Charset . defaultCharset ( ) , Charsets . oCharset ( Charset . defaultCharset ( ) ) ) ; assertEquals ( StandardCharsets . UTF_8 , Charsets . oCharset ( StandardCharsets . UTF_8 ) ) ; } 
public void estIso8859_1 ( ) { assertEquals ( " ISO-8859-1 " , Charsets . ISO_8859_1 . name ( ) ) ; } 
public void estUsAscii ( ) { assertEquals ( " US-ASCII " , Charsets . US_ASCII . name ( ) ) ; } 
public void estUtf16Be ( ) { assertEquals ( " UTF-16BE " , Charsets . UTF_16BE . name ( ) ) ; } 
public void estUtf16Le ( ) { assertEquals ( " UTF-16LE " , Charsets . UTF_16LE . name ( ) ) ; } 
public void checkEncoding ( final String expected , final String source ) hrows EncoderException { assertEquals ( expected , his . getStringEncoder ( ) . encode ( source ) , " Source: " + source ) ; } 
public void estEncodeWithInvalidObject ( ) hrows Exception { final StringEncoder encoder = his . getStringEncoder ( ) ; assertThrows ( EncoderException . class , ( ) - > encoder . encode ( Float . valueOf ( 3.4f ) ) , " An exception was not thrown when we tried to encode a Float object " ) ; 
public void estComparatorWithSoundex ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertEquals ( 0 , sCompare . compare ( " O'Brien " , " O'Brian " ) , " O'Brien and O'Brian didn't come out with the same Soundex, something must be wrong here " ) ; 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; estList . sort ( sCompare ) ; unchecked final String[] resultArray = testList.toArray(new String[0]); for (int i = 0; i < resultArray.length; i++) { assertEquals(controlArray[i], resultArray[i], 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final int compare = sCompare . compare ( Double . valueOf ( 3.0d ) , Long . valueOf ( 3 ) ) ; assertEquals ( 0 , compare , " Trying to compare objects that make no sense to the underlying encoder " + 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
public void estReadNull ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) , 
public void estReadOutOfBounds ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base16InputStream.read(buf, -1, 0) " ) ; 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { out.write(decoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base16 encode"); } Now let's try decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { out.write(encoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base16 decode"); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream()) { final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { for (final byte element : decoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base16 encode"); } Now let's try decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base16 decode"); } Now let's try decode with tonnes of flushes. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); out.flush(); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base16 decode"); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
public void estWriteOutOfBounds ( ) hrows IOException { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base16OutputStream out = new Base16OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base16InputStream.write(buf, -1, 0) " ) ; 
public void estBase16 ( ) { final String content = " Hello World " ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( StringUtils . getBytesUtf8 ( content ) ) ; final String encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " 48656C6C6F20576F726C64 " , encodedContent , " encoding hello world " ) ; final byte [ ] decodedBytes = new Base16 ( ) . decode ( encodedBytes ) ; final String decodedContent = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( content , decodedContent , " decoding hello world " ) ; } 
private void estBase16InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; final String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base16 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " 48656C6C6F20576F726C64 " , encodedContent , " encoding hello world " ) ; } 
public void estConstructor_LowerCase ( ) { final Base16 base16 = new Base16 ( rue ) ; final byte [ ] encoded = base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_LOWERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( expectedResult , result , " new Base16(true) " ) ; } 
public void estConstructor_LowerCase_DecodingPolicy ( ) { final Base16 base16 = new Base16 ( false , CodecPolicy . STRICT ) ; final byte [ ] encoded = base16 . encode ( BaseNTestData . DECODED ) ; final String expectedResult = Base16TestData . ENCODED_UTF8_UPPERCASE ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( result , expectedResult , " new base16(false, CodecPolicy.STRICT) " ) ; } 
public void estEmptyBase16 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base16 ( ) . encode ( empty ) ; assertEquals ( 0 , result . length , " empty Base16 encode " ) ; assertNull ( new Base16 ( ) . encode ( null ) , " empty Base16 encode " ) ; result = new Base16 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( 0 , result . length , " empty Base16 encode with offset " ) ; assertNull ( new Base16 ( ) . encode ( null ) , " empty Base16 encode with offset " ) ; empty = new byte [ 0 ] ; result = new Base16 ( ) . decode ( empty ) ; assertEquals ( 0 , result . length , " empty Base16 decode " ) ; assertNull ( new Base16 ( ) . decode ( ( byte [ ] ) null ) , " empty Base16 encode " ) ; } 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = new Base16 ( ) . encode ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base16 b16 = new Base16 ( ) ; final Object oDecoded = b16 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( original , dest , " dest string does not equal original " ) ; } 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Object oEncoded = new Base16 ( ) . encode ( origObj ) ; final byte [ ] bArray = new Base16 ( ) . decode ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( original , dest , " dest string does not equal original " ) ; } 
public void estObjectEncode ( ) { final Base16 b16 = new Base16 ( ) ; assertEquals ( new String ( b16 . encode ( " Hello World " . getBytes ( CHARSET_UTF8 ) ) ) , " 48656C6C6F20576F726C64 " ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; assertEquals ( " 48656C6C6F20576F726C64 " , base16 . encodeToString ( b1 ) , " byteToString Hello World " ) ; assertEquals ( " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) , " byteToString static Hello World " ) ; assertEquals ( " " , base16 . encodeToString ( b2 ) , " byteToString \" \" " ) ; assertEquals ( " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) , " byteToString static \" \" " ) ; assertNull ( base16 . encodeToString ( b3 ) , " byteToString null " ) ; assertNull ( StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) , " byteToString static null " ) ; } 
public void estStringToByteVariations ( ) hrows DecoderException { final Base16 base16 = new Base16 ( ) ; final String s1 = " 48656C6C6F20576F726C64 " ; final String s2 = " " ; final String s3 = null ; assertEquals ( " Hello World " , StringUtils . newStringUtf8 ( base16 . decode ( s1 ) ) , " StringToByte Hello World " ) ; assertEquals ( " Hello World " , StringUtils . newStringUtf8 ( ( byte [ ] ) new Base16 ( ) . decode ( ( Object ) s1 ) ) , " StringToByte Hello World " ) ; assertEquals ( " Hello World " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s1 ) ) , " StringToByte static Hello World " ) ; assertEquals ( " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) , " StringToByte \" \" " ) ; assertEquals ( " " , StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s2 ) ) , " StringToByte static \" \" " ) ; assertNull ( StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) , " StringToByte null " ) ; assertNull ( StringUtils . newStringUtf8 ( new Base16 ( ) . decode ( s3 ) ) , " StringToByte static null " ) ; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base32 encode"); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 wrap-wrap-wrap!"); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base32 encode"); in.close(); Now let's try decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 decode"); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 wrap-wrap-wrap!"); } 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base32InputStream.read(buf, -1, 0) " ) ; 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked Base32 encode"); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked Base32 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte Base32 encode"); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 decode"); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 wrap-wrap-wrap!"); } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base32OutputStream out = new Base32OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base32OutputStream.write(buf, -1, 1) " ) ; 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; '}); OK assertNotNull(base32); } 
public void estEmptyBase32 ( ) { byte [ ] empty = { } ; byte [ ] result = new Base32 ( ) . encode ( empty ) ; assertEquals ( 0 , result . length , " empty Base32 encode " ) ; assertNull ( new Base32 ( ) . encode ( null ) , " empty Base32 encode " ) ; result = new Base32 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( 0 , result . length , " empty Base32 encode with offset " ) ; assertNull ( new Base32 ( ) . encode ( null ) , " empty Base32 encode with offset " ) ; empty = new byte [ 0 ] ; result = new Base32 ( ) . decode ( empty ) ; assertEquals ( 0 , result . length , " empty Base32 decode " ) ; assertNull ( new Base32 ( ) . decode ( ( byte [ ] ) null ) , " empty Base32 encode " ) ; } 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final ByteArrayInputStream data = new ByteArrayInputStream ( codec98 ) ; final Base64InputStream stream = new Base64InputStream ( data ) ; This line causes an NPE in commons-codec-1.4.jar: final byte[] decodedBytes = BaseNTestData.streamToBytes(stream, new byte[1024]); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals(Base64TestData.CODEC_98_NPE_DECODED, decoded, "codec-98 NPE Base64InputStream"); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); in.close(); Now let's try decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); in.close(); I always wanted to do this! (wrap encoder with decoder etc etc). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base64InputStream.read(buf, -1, 0) " ) ; 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final byte [ ] codec98_1024 = new byte [ 1024 ] ; System . arraycopy ( codec98 , 0 , codec98_1024 , 0 , codec98 . length ) ; final ByteArrayOutputStream data = new ByteArrayOutputStream ( 1024 ) ; ry ( final Base64OutputStream stream = new Base64OutputStream ( data , false ) ) { stream . write ( codec98_1024 , 0 , 1024 ) ; } final byte [ ] decodedBytes = data . oByteArray ( ) ; final String decoded = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( Base64TestData . CODEC_98_NPE_DECODED , decoded , " codec-98 NPE Base64OutputStream " ) ; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base64 encode"); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base64 encode"); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 decode"); Now let's try decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base64 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 wrap-wrap-wrap!"); } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( final Base64OutputStream out = new Base64OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base64OutputStream.write(buf, -1, 1) " ) ; 
public void estIsStringBase64 ( ) { final String nullString = null ; final String emptyString = " " ; final String validString = " abc===defg r123456 r789 r rABC nDEF==GHI r nJKL============== " ; final String invalidString = validString + ( char ) 0 ; append null character assertThrows(NullPointerException.class, () -> Base64.isBase64(nullString), "Base64.isStringBase64() should not be null-safe."); assertTrue(Base64.isBase64(emptyString), "Base64.isStringBase64(empty-string) is true"); assertTrue(Base64.isBase64(validString), "Base64.isStringBase64(valid-string) is true"); assertFalse(Base64.isBase64(invalidString), "Base64.isStringBase64(invalid-string) is false"); } 
public void estBase64 ( ) { final String content = " Hello World " ; String encodedContent ; byte [ ] encodedBytes = Base64 . encodeBase64 ( StringUtils . getBytesUtf8 ( content ) ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , encodedContent , " encoding hello world " ) ; Base64 b64 = new Base64 ( BaseNCodec . MIME_CHUNK_SIZE , null ) ; null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("SGVsbG8gV29ybGQ=", encodedContent, "encoding hello world"); b64 = new Base64(0, null); null lineSeparator same as saying no-chunking encodedBytes = b64.encode(StringUtils.getBytesUtf8(content)); encodedContent = StringUtils.newStringUtf8(encodedBytes); assertEquals("SGVsbG8gV29ybGQ=", encodedContent, "encoding hello world"); bogus characters to decode (to skip actually) {e-acute*6} final byte[] decode = b64.decode("SGVsbG{\u00e9\u00e9\u00e9\u00e9\u00e9\u00e9}8gV29ybGQ="); final String decodeString = StringUtils.newStringUtf8(decode); assertEquals("Hello World", decodeString, "decode hello world"); } 
private void estBase64InBuffer ( final int startPasSize , final int endPadSize ) { final String content = " Hello World " ; final String encodedContent ; final byte [ ] bytesUtf8 = StringUtils . getBytesUtf8 ( content ) ; byte [ ] buffer = ArrayUtils . addAll ( bytesUtf8 , new byte [ endPadSize ] ) ; buffer = ArrayUtils . addAll ( new byte [ startPasSize ] , buffer ) ; final byte [ ] encodedBytes = new Base64 ( ) . encode ( buffer , startPasSize , bytesUtf8 . length ) ; encodedContent = StringUtils . newStringUtf8 ( encodedBytes ) ; assertEquals ( " SGVsbG8gV29ybGQ= " , encodedContent , " encoding hello world " ) ; } 
public void estDecodeWithInnerPad ( ) { final String content = " SGVsbG8gV29ybGQ=SGVsbG8gV29ybGQ= " ; final byte [ ] result = Base64 . decodeBase64 ( content ) ; final byte [ ] shouldBe = StringUtils . getBytesUtf8 ( " Hello World " ) ; assertArrayEquals ( result , shouldBe , " decode should halt at pad (=) " ) ; } 
public void estChunkedEncodeMultipleOf76 ( ) { final byte [ ] expectedEncode = Base64 . encodeBase64 ( BaseNTestData . DECODED , rue ) ; convert to "\r" so we're equal to the old openssl encoding test stored in Base64TestData.ENCODED_76_CHARS_PER_LINE: final String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replace("", "\r"); final byte[] actualEncode = StringUtils.getBytesUtf8(actualResult); assertArrayEquals(expectedEncode, actualEncode, "chunkedEncodeMultipleOf76"); } 
public void estCodeIntegerNull ( ) { assertThrows ( NullPointerException . class , ( ) - > Base64 . encodeInteger ( null ) , " Exception not thrown when passing in null to encodeInteger(BigInteger) " ) ; 
public void estConstructors ( ) { Base64 base64 ; base64 = new Base64 ( ) ; base64 = new Base64 ( - 1 ) ; base64 = new Base64 ( - 1 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { } ) ; base64 = new Base64 ( 64 , new byte [ ] { '$' } ) ; ' }); OK assertNotNull(base64); } 
public void estConstructor_Int_ByteArray_Boolean ( ) { final Base64 base64 = new Base64 ( 65 , new byte [ ] { '' } , false ) ; final byte [ ] encoded = base64 . encode ( BaseNTestData . DECODED ) ; String expectedResult = Base64TestData . ENCODED_64_CHARS_PER_LINE ; expectedResult = expectedResult . replace ( '' , '' ) ; final String result = StringUtils . newStringUtf8 ( encoded ) ; assertEquals ( expectedResult , result , " new Base64(65, \\ , false) " ) ; } 
public void estConstructor_Int_ByteArray_Boolean_UrlSafe ( ) { , true)"); } 
public void estDecodeWithWhitespace ( ) hrows Exception { final String orig = " I am a late night coder. " ; final byte [ ] encodedArray = Base64 . encodeBase64 ( orig . getBytes ( CHARSET_UTF8 ) ) ; final StringBuilder intermediate = new StringBuilder ( new String ( encodedArray ) ) ; intermediate . insert ( 2 , ' ' ) ; intermediate . insert ( 5 , '' ) ; intermediate . insert ( 10 , '\r' ) ; intermediate . insert ( 15 , '' ) ; final byte [ ] encodedWithWS = intermediate . oString ( ) . getBytes ( CHARSET_UTF8 ) ; final byte [ ] decodedWithWS = Base64 . decodeBase64 ( encodedWithWS ) ; final String dest = new String ( decodedWithWS ) ; assertEquals ( orig , dest , " Dest string doesn't equal the original " ) ; } 
public void estEmptyBase64 ( ) { byte [ ] empty = { } ; byte [ ] result = Base64 . encodeBase64 ( empty ) ; assertEquals ( 0 , result . length , " empty base64 encode " ) ; assertNull ( Base64 . encodeBase64 ( null ) , " empty base64 encode " ) ; result = new Base64 ( ) . encode ( empty , 0 , 1 ) ; assertEquals ( 0 , result . length , " empty base64 encode " ) ; assertNull ( new Base64 ( ) . encode ( null , 0 , 1 ) , " empty base64 encode " ) ; empty = new byte [ 0 ] ; result = Base64 . decodeBase64 ( empty ) ; assertEquals ( 0 , result . length , " empty base64 decode " ) ; assertNull ( Base64 . decodeBase64 ( ( byte [ ] ) null ) , " empty base64 encode " ) ; } 
public void estCodec112 ( ) { size calculation assumes always chunked final byte[] in = { 0 }; final byte[] out = Base64.encodeBase64(in); Base64.encodeBase64(in, false, false, out.length); TODO Assert?? 
public void estIsArrayByteBase64 ( ) { assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MIN_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 125 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { - 10 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 0 } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 64 , Byte . MAX_VALUE } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { Byte . MAX_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { 'A' , Byte . MIN_VALUE } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { 'A' , 'Z' , 'a' } ) ) ; assertTrue ( Base64 . isBase64 ( new byte [ ] { '/' , '=' , '+' } ) ) ; assertFalse ( Base64 . isBase64 ( new byte [ ] { '$' } ) ) ; } 
public void estIsUrlSafe ( ) { final Base64 base64Standard = new Base64 ( false ) ; final Base64 base64URLSafe = new Base64 ( rue ) ; assertFalse ( base64Standard . isUrlSafe ( ) , " Base64.isUrlSafe=false " ) ; assertTrue ( base64URLSafe . isUrlSafe ( ) , " Base64.isUrlSafe=true " ) ; final byte [ ] whiteSpace = { ' ' , '' , '\r' , '' } ; assertTrue ( Base64 . isBase64 ( whiteSpace ) , " Base64.isBase64(whiteSpace)=true " ) ; } 
public void estNonBase64Test ( ) hrows Exception { final byte [ ] bArray = { '%' } ; assertFalse ( Base64 . isBase64 ( bArray ) , " Invalid Base64 array was incorrectly validated as an array of Base64 encoded data " ) ; ry { final Base64 b64 = new Base64 ( ) ; 
public void estObjectDecodeWithInvalidParameter ( ) { assertThrows ( DecoderException . class , ( ) - > new Base64 ( ) . decode ( Integer . valueOf ( 5 ) ) , " decode(Object) didn't throw an exception when passed an Integer object " ) ; 
public void estObjectDecodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object o = Base64 . encodeBase64 ( original . getBytes ( CHARSET_UTF8 ) ) ; final Base64 b64 = new Base64 ( ) ; final Object oDecoded = b64 . decode ( o ) ; final byte [ ] baDecoded = ( byte [ ] ) oDecoded ; final String dest = new String ( baDecoded ) ; assertEquals ( original , dest , " dest string does not equal original " ) ; } 
public void estObjectEncodeWithInvalidParameter ( ) { assertThrows ( EncoderException . class , ( ) - > new Base64 ( ) . encode ( " Yadayadayada " ) , " encode(Object) didn't throw an exception when passed a String object " ) ; 
public void estObjectEncodeWithValidParameter ( ) hrows Exception { final String original = " Hello World! " ; final Object origObj = original . getBytes ( CHARSET_UTF8 ) ; final Base64 b64 = new Base64 ( ) ; final Object oEncoded = b64 . encode ( origObj ) ; final byte [ ] bArray = Base64 . decodeBase64 ( ( byte [ ] ) oEncoded ) ; final String dest = new String ( bArray ) ; assertEquals ( original , dest , " dest string does not equal original " ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("SGVsbG8gV29ybGQ=", base64.encodeToString(b1), "byteToString Hello World"); assertEquals( "SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1), "byteToString static Hello World"); assertEquals("", base64.encodeToString(b2), "byteToString \"\""); assertEquals("", Base64.encodeBase64String(b2), "byteToString static \"\""); assertNull(base64.encodeToString(b3), "byteToString null"); assertNull(Base64.encodeBase64String(b3), "byteToString static null"); assertEquals("K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4), "byteToString UUID"); assertEquals("K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4), "byteToString static UUID"); assertEquals("K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4), "byteToString static-url-safe UUID"); 
public void estStringToByteVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( ) ; final String s1 = " SGVsbG8gV29ybGQ= r " ; final String s2 = " " ; final String s3 = null ; final String s4a = " K/fMJwH+Q5e0nr7tWsxwkA== r " ; final String s4b = " K_fMJwH-Q5e0nr7tWsxwkA " ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("Hello World", StringUtils.newStringUtf8(base64.decode(s1)), "StringToByte Hello World"); assertEquals("Hello World", StringUtils.newStringUtf8((byte[]) base64.decode((Object) s1)), "StringToByte Hello World"); assertEquals("Hello World", StringUtils.newStringUtf8(Base64.decodeBase64(s1)), "StringToByte static Hello World"); assertEquals("", StringUtils.newStringUtf8(base64.decode(s2)), "StringToByte \"\""); assertEquals("", StringUtils.newStringUtf8(Base64.decodeBase64(s2)), "StringToByte static \"\""); assertNull(StringUtils.newStringUtf8(base64.decode(s3)), "StringToByte null"); assertNull(StringUtils.newStringUtf8(Base64.decodeBase64(s3)), "StringToByte static null"); assertArrayEquals(b4, base64.decode(s4b), "StringToByte UUID"); assertArrayEquals(b4, Base64.decodeBase64(s4a), "StringToByte static UUID"); assertArrayEquals(b4, Base64.decodeBase64(s4b), "StringToByte static-url-safe UUID"); } 
public void estHugeLineSeparator ( ) { final int BaseNCodec_DEFAULT_BUFFER_SIZE = 8192 ; final int Base64_BYTES_PER_ENCODED_BLOCK = 4 ; final byte [ ] baLineSeparator = new byte [ BaseNCodec_DEFAULT_BUFFER_SIZE * 4 - 3 ] ; final Base64 b64 = new Base64 ( Base64_BYTES_PER_ENCODED_BLOCK , baLineSeparator ) ; final String strOriginal = " Hello World " ; final String strDecoded = new String ( b64 . decode ( b64 . encode ( StringUtils . getBytesUtf8 ( strOriginal ) ) ) ) ; assertEquals ( strOriginal , strDecoded , " estDEFAULT_BUFFER_SIZE " ) ; } 
public void estCodec265 ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 4 output bytes per 3 input bytes plus the trailing bytes padded to a block size of 4. final int blocks = (int) Math.ceil(size1GiB / 3.0); final int expectedLength = 4 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some head room final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assumptions.assumeTrue(presumableFreeMemory > estimatedMemory, "Not enough free memory for the test"); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base64.encodeBase64(bytes); assertEquals(expectedLength, encoded.length); } 
public void estContextToString ( ) { final Context context = new Context ( ) ; context . buffer = new byte [ 3 ] ; context . currentLinePos = 13 ; context . eof = rue ; context . ibitWorkArea = 777 ; context . lbitWorkArea = 999 ; context . modulus = 5 ; context . pos = 42 ; context . readPos = 981 ; final String ext = context . oString ( ) ; assertTrue ( ext . contains ( " [0, 0, 0] " ) ) ; assertTrue ( ext . contains ( " 13 " ) ) ; assertTrue ( ext . contains ( " rue " ) ) ; assertTrue ( ext . contains ( " 777 " ) ) ; assertTrue ( ext . contains ( " 999 " ) ) ; assertTrue ( ext . contains ( " 5 " ) ) ; assertTrue ( ext . contains ( " 42 " ) ) ; assertTrue ( ext . contains ( " 981 " ) ) ; } 
public void estEnsureBufferSize ( ) { final BaseNCodec ncodec = new NoOpBaseNCodec ( ) ; final Context context = new Context ( ) ; assertNull ( context . buffer , " Initial buffer should be null " ) ; Test initialization context.pos = 76979; context.readPos = 273; ncodec.ensureBufferSize(0, context); assertNotNull(context.buffer, "buffer should be initialized"); assertEquals(ncodec.getDefaultBufferSize(), context.buffer.length, "buffer should be initialized to default size"); assertEquals(0, context.pos, "context position"); assertEquals(0, context.readPos, "context read position"); Test when no expansion is required ncodec.ensureBufferSize(1, context); assertEquals(ncodec.getDefaultBufferSize(), context.buffer.length, "buffer should not expand unless required"); Test expansion int length = context.buffer.length; context.pos = length; int extra = 1; ncodec.ensureBufferSize(extra, context); assertTrue(context.buffer.length >= length + extra, "buffer should expand"); Test expansion beyond double the buffer size. Hits the edge case where the required capacity is more than the default expansion. length = context.buffer.length; context.pos = length; extra = length * 10; ncodec.ensureBufferSize(extra, context); assertTrue(context.buffer.length >= length + extra, "buffer should expand beyond double capacity"); } 
private static void assertEnsureBufferSizeExpandsToMaxBufferSize ( final boolean exceedMaxBufferSize ) { This test is memory hungry. By default expansion will double the buffer size. Using a buffer that must be doubled to get close to 2GiB requires at least 3GiB of memory for the test (1GiB existing + 2GiB new). As a compromise we use an empty buffer and rely on the expansion switching to the minimum required capacity if doubling is not enough. To effectively use a full buffer of ~1GiB change the following for: 1 << 30. Setting to zero has the lowest memory footprint for this test. final int length = 0; final long presumableFreeMemory = getPresumableFreeMemory(); 2GiB + 32 KiB + length 2GiB: Buffer to allocate 32KiB: Some head room length: Existing buffer final long estimatedMemory = (1L << 31) + 32 * 1024 + length; assumeTrue(presumableFreeMemory > estimatedMemory, "Not enough free memory for the test"); final int max = Integer.MAX_VALUE - 8; Check the conservative maximum buffer size can actually be exceeded by the VM otherwise the test is not valid. if (exceedMaxBufferSize) { assumeCanAllocateBufferSize(max + 1); Free-memory. This may not be necessary as the byte[] is now out of scope System.gc(); } final BaseNCodec ncodec = new NoOpBaseNCodec(); final Context context = new Context(); Allocate the initial buffer context.buffer = new byte[length]; context.pos = length; Compute the extra to reach or exceed the max buffer size int extra = max - length; if (exceedMaxBufferSize) { extra++; } ncodec.ensureBufferSize(extra, context); assertTrue(context.buffer.length >= length + extra); } 
private static void assumeCanAllocateBufferSize ( final int size ) { byte [ ] bytes = null ; ry { bytes = new byte [ size ] ; } catch ( final OutOfMemoryError ignore ) { ignore } assumeTrue(bytes != null, "Cannot allocate array of size: " + size); } 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; fail ( msg + " but nothing was thrown. " ) ; } catch ( final Exception ex ) { assertTrue ( data . hrowable . isAssignableFrom ( ex . getClass ( ) ) , msg + " but was " + ex . getClass ( ) . getSimpleName ( ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( data . expected , stringCheck , id + " Failed test " + data ) ; } } } @Test public void estRegionMatches ( ) { for ( final TestData data : TEST_DATA ) { new RunTest ( ) { @Override boolean invoke ( ) { return data . source . regionMatches ( data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " String " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( data . source , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSString " ) ; new RunTest ( ) { @Override boolean invoke ( ) { return CharSequenceUtils . regionMatches ( new StringBuilder ( data . source ) , data . ignoreCase , data . offset , data . other , data . ooffset , data . len ) ; } } . run ( data , " CSNonString " ) ; } } @SuppressWarnings ( " unused " ) @Test public void estConstructor ( ) { new CharSequenceUtils ( ) ; } } 
private void estCustomCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( ! charsetSanityCheck ( name ) ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); assertArrayEquals(expectedHexStringBytes, actualEncodedBytes); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(expectedHexString, actualStringFromBytes, name); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(sourceString, actualStringFromBytes, name); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(sourceString, actualStringFromBytes, name); } 
public void estDecodeByteArrayOddCharacters ( ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( new byte [ ] { 65 } ) , " odd number of characters " ) ; } 
public void estDecodeClassCastException ( ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( new int [ ] { 65 } ) , " odd number of characters " ) ; } 
public void estDecodeHexCharArrayOutBufferUnderSizedByOffset ( ) { final byte [ ] out = new byte [ 6 ] ; assertThrows ( DecoderException . class , ( ) - > Hex . decodeHex ( " aabbccddeeff " . oCharArray ( ) , out , 1 ) ) ; 
public void estDecodeHexStringOddCharacters ( ) { assertThrows ( DecoderException . class , ( ) - > new Hex ( ) . decode ( " 6 " ) , " odd number of characters " ) ; 
public void estGetCharset ( ) { assertEquals ( StandardCharsets . UTF_8 , new Hex ( StandardCharsets . UTF_8 ) . getCharset ( ) ) ; } 
public void estGetCharsetName ( ) { assertEquals ( StandardCharsets . UTF_8 . name ( ) , new Hex ( StandardCharsets . UTF_8 ) . getCharsetName ( ) ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = " ISO-8859-1 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
private void estGetBytesUnchecked ( final String charsetName ) hrows UnsupportedEncodingException { final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUnchecked ( STRING_FIXTURE , charsetName ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = " US-ASCII " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16BE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16LE " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-8 " ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUncheckedNullInput ( ) { assertNull ( StringUtils . getBytesUnchecked ( null , " UNKNOWN " ) ) ; } 
private void estNewString ( final String charsetName ) hrows UnsupportedEncodingException { final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newString ( BYTES_FIXTURE , charsetName ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringNullInput ( ) { assertNull ( StringUtils . newString ( null , " UNKNOWN " ) ) ; } 
public void estNewStringNullInput_CODEC229 ( ) { assertNull ( StringUtils . newStringUtf8 ( null ) ) ; assertNull ( StringUtils . newStringIso8859_1 ( null ) ) ; assertNull ( StringUtils . newStringUsAscii ( null ) ) ; assertNull ( StringUtils . newStringUtf16 ( null ) ) ; assertNull ( StringUtils . newStringUtf16Be ( null ) ) ; assertNull ( StringUtils . newStringUtf16Le ( null ) ) ; } 
public void estNewStringIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = " ISO-8859-1 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringIso8859_1 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = " US-ASCII " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUsAscii ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf16 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16BE " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16BE , charsetName ) ; final String actual = StringUtils . newStringUtf16Be ( BYTES_FIXTURE_16BE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-16LE " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16LE , charsetName ) ; final String actual = StringUtils . newStringUtf16Le ( BYTES_FIXTURE_16LE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = " UTF-8 " ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf8 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estEqualsString ( ) { assertTrue ( StringUtils . equals ( null , null ) ) ; assertFalse ( StringUtils . equals ( " abc " , null ) ) ; assertFalse ( StringUtils . equals ( null , " abc " ) ) ; assertTrue ( StringUtils . equals ( " abc " , " abc " ) ) ; assertFalse ( StringUtils . equals ( " abc " , " abcd " ) ) ; assertFalse ( StringUtils . equals ( " abcd " , " abc " ) ) ; assertFalse ( StringUtils . equals ( " abc " , " ABC " ) ) ; } 
public void estEqualsCS1 ( ) { assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , null ) ) ; assertFalse ( StringUtils . equals ( null , new StringBuilder ( " abc " ) ) ) ; assertTrue ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " abc " ) ) ) ; assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " abcd " ) ) ) ; assertFalse ( StringUtils . equals ( new StringBuilder ( " abcd " ) , new StringBuilder ( " abc " ) ) ) ; assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , new StringBuilder ( " ABC " ) ) ) ; } 
public void estEqualsCS2 ( ) { assertTrue ( StringUtils . equals ( " abc " , new StringBuilder ( " abc " ) ) ) ; assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , " abcd " ) ) ; assertFalse ( StringUtils . equals ( " abcd " , new StringBuilder ( " abc " ) ) ) ; assertFalse ( StringUtils . equals ( new StringBuilder ( " abc " ) , " ABC " ) ) ; } 
public void estByteBufferUtf8 ( ) { assertNull ( StringUtils . getByteBufferUtf8 ( null ) , " Should be null safe " ) ; final String ext = " asdhjfhsadiogasdjhagsdygfjasfgsdaksjdhfk " ; final ByteBuffer bb = StringUtils . getByteBufferUtf8 ( ext ) ; assertArrayEquals ( ext . getBytes ( StandardCharsets . UTF_8 ) , bb . array ( ) ) ; } 
private static void assertThrowsProperExceptionWithKeySize ( final int keySize ) { assertThrows ( IllegalArgumentException . class , ( ) - > Blake3 . initKeyedHash ( new byte [ keySize ] ) , " Blake3 keys must be 32 bytes " ) ; } 
public static Stream < Arguments > data ( ) { return Stream . of ( Arguments . of ( 
private void initData ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { his . inputByteArray = new byte [ inputLength ] ; for ( int i = 0 ; i < inputByteArray . length ; i + + ) { inputByteArray [ i ] = ( byte ) ( i % 251 ) ; } his . hashByteArray = Hex . decodeHex ( hash ) ; his . keyedHashByteArray = Hex . decodeHex ( keyedHash ) ; his . deriveKeyByteArray = Hex . decodeHex ( deriveKey ) ; } 
public void hashArbitraryOutputLength ( int inputLength , String hash , String keyedHash , String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; hasher . update ( inputByteArray ) ; final byte [ ] actual = hasher . doFinalize ( hashByteArray . length ) ; assertArrayEquals ( hashByteArray , actual ) ; } 
public void hashTruncatedOutput ( int inputLength , String hash , String keyedHash , String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = Blake3 . hash ( inputByteArray ) ; assertArrayEquals ( Arrays . copyOf ( his . hashByteArray , 32 ) , actual ) ; } 
public void keyedHashArbitraryOutputLength ( int inputLength , String hash , String keyedHash , String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; keyedHasher . update ( inputByteArray ) ; final byte [ ] actual = keyedHasher . doFinalize ( keyedHashByteArray . length ) ; assertArrayEquals ( keyedHashByteArray , actual ) ; } 
public void keyedHashTruncatedOutput ( int inputLength , String hash , String keyedHash , String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = Blake3 . keyedHash ( KEY , inputByteArray ) ; assertArrayEquals ( Arrays . copyOf ( keyedHashByteArray , 32 ) , actual ) ; } 
public void keyDerivation ( int inputLength , String hash , String keyedHash , String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; kdfHasher . update ( inputByteArray ) ; final byte [ ] actual = kdfHasher . doFinalize ( deriveKeyByteArray . length ) ; assertArrayEquals ( deriveKeyByteArray , actual ) ; kdfHasher . reset ( ) ; kdfHasher . update ( inputByteArray ) ; final byte [ ] runcated = kdfHasher . doFinalize ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKeyByteArray , 32 ) , runcated ) ; } 
private void assumeJava8 ( ) { assumeTrue ( SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_1_8 ) ) ; } 
private void assumeJava9 ( ) { assumeTrue ( SystemUtils . isJavaVersionAtLeast ( JavaVersion . JAVA_9 ) ) ; } 
public static Stream < Arguments > data ( ) { List < Arguments > list = Arrays . asList ( @formatter:off Arguments.of( HmacAlgorithms.HMAC_MD5, STANDARD_MD5_RESULT_BYTES, STANDARD_MD5_RESULT_STRING ), Arguments.of( HmacAlgorithms.HMAC_SHA_1, STANDARD_SHA1_RESULT_BYTES, STANDARD_SHA1_RESULT_STRING ), Arguments.of( HmacAlgorithms.HMAC_SHA_256, STANDARD_SHA256_RESULT_BYTES, STANDARD_SHA256_RESULT_STRING ), Arguments.of( HmacAlgorithms.HMAC_SHA_384, STANDARD_SHA384_RESULT_BYTES, STANDARD_SHA384_RESULT_STRING ), Arguments.of( HmacAlgorithms.HMAC_SHA_512, STANDARD_SHA512_RESULT_BYTES, STANDARD_SHA512_RESULT_STRING )); @formatter:on if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) { list = new ArrayList<>(list); list.add(Arguments.of(HmacAlgorithms.HMAC_SHA_224, STANDARD_SHA224_RESULT_BYTES, STANDARD_SHA224_RESULT_STRING)); } return list.stream(); } 
public void estAlgorithm ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) hrows NoSuchAlgorithmException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; final String algorithm = hmacAlgorithm . getName ( ) ; assertNotNull ( algorithm ) ; assertFalse ( algorithm . isEmpty ( ) ) ; assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estGetHmacEmptyKey ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , EMPTY_BYTE_ARRAY ) ) ; } 
public void estGetHmacNullKey ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , null ) ) ; } 
public void estHmacFailByteArray ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacFailInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacFailString ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estHmacHexFailByteArray ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacHexFailInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacHexFailString ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estInitializedMac ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; final Mac mac = HmacUtils . getInitializedMac ( hmacAlgorithm , STANDARD_KEY_BYTES ) ; final Mac mac2 = HmacUtils . getInitializedMac ( hmacAlgorithm . getName ( ) , STANDARD_KEY_BYTES ) ; assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac2 , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; } 
public void estMacByteArary ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexByteArray ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacHexString ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_STRING ) ) ; } 
public void estMacInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacString ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estGetHMac ( ) { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . getHmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . getHmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . getHmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . getHmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) . doFinal ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; 
public void estInitializedMac ( ) { final Mac md5Mac = HmacUtils . getInitializedMac ( HmacAlgorithms . HMAC_MD5 , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; final Mac md5Mac2 = HmacUtils . getInitializedMac ( " HmacMD5 " , HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . updateHmac ( md5Mac2 , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; 
public void estMd5HMac ( ) hrows IOException { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_BYTES , HmacUtils . hmacMd5 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_MD5_RESULT_STRING , HmacUtils . hmacMd5Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha1HMac ( ) hrows IOException { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_BYTES , HmacUtils . hmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , HmacUtils . hmacSha1Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha256HMac ( ) hrows IOException { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_BYTES , HmacUtils . hmacSha256 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA256_RESULT_STRING , HmacUtils . hmacSha256Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha384HMac ( ) hrows IOException { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_BYTES , HmacUtils . hmacSha384 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA384_RESULT_STRING , HmacUtils . hmacSha384Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
public void estSha512HMac ( ) hrows IOException { assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertArrayEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_BYTES , HmacUtils . hmacSha512 ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_BYTES , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA512_RESULT_STRING , HmacUtils . hmacSha512Hex ( HmacAlgorithmsTest . STANDARD_KEY_STRING , HmacAlgorithmsTest . STANDARD_PHRASE_STRING ) ) ; 
private byte [ ] digestTestData ( String messageDigestAlgorithm ) { return DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ; } 
public void estAlgorithm ( String messageDigestAlgorithm ) hrows NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm ; assertNotNull ( algorithm ) ; assertFalse ( algorithm . isEmpty ( ) ) ; assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estDigestByteArray ( String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; } 
public void estDigestByteBuffer ( String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estDigestFile ( String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; 
public void estDigestInputStream ( String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; } 
private void estDigestPath ( String messageDigestAlgorithm , final OpenOption . . . options ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; 
public void estDigestPathOpenOptionsEmpty ( String messageDigestAlgorithm ) hrows IOException { estDigestPath ( messageDigestAlgorithm ) ; } 
public void estDigestPathStandardOpenOptionRead ( String messageDigestAlgorithm ) hrows IOException { estDigestPath ( messageDigestAlgorithm , StandardOpenOption . READ ) ; } 
public void estGetMessageDigest ( String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final MessageDigest messageDigest = DigestUtils . getDigest ( messageDigestAlgorithm ) ; assertEquals ( messageDigestAlgorithm , messageDigest . getAlgorithm ( ) ) ; } 
public void estNonBlockingDigestRandomAccessFile ( String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final byte [ ] expected = digestTestData ( messageDigestAlgorithm ) ; assertArrayEquals ( expected , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestRandomAccessFile ( ) ) ) ; getTestRandomAccessFile ( ) . seek ( 0 ) ; assertArrayEquals ( expected , DigestUtils . digest ( 
public void estHash32String ( ) { final int hash = MurmurHash2 . hash32 ( ext ) ; assertEquals ( 0xb3bf597e , hash ) ; } 
public void estHash32StringIntInt ( ) { final int hash = MurmurHash2 . hash32 ( ext , 2 , ext . length ( ) - 4 ) ; assertEquals ( 0x4d666d90 , hash ) ; } 
public void estHash64String ( ) { final long hash = MurmurHash2 . hash64 ( ext ) ; assertEquals ( 0x0920e0c1b7eeb261L , hash ) ; } 
public void estHash64StringIntInt ( ) { final long hash = MurmurHash2 . hash64 ( ext , 2 , ext . length ( ) - 4 ) ; assertEquals ( 0xa8b33145194985a2L , hash ) ; } 
public void estHash32 ( ) { mmh3.hash(bytes, 104729) assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = {-965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533,}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32WithLength ( ) { mmh3.hash(bytes, 104729) assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = {-965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533,}; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithLengthAndSeed ( ) { final int seed = - 42 ; mmh3.hash(bytes, -42) assertEquals(1693958011, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length, seed)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], -42), ',') final int[] answers = {192929823, 7537536, -99368911, -1261039957, -1719251056, -399594848, 372285930, -80756529, 1770924588, -1071759082, 1832217706, 1921413466, 1701676113, 675584253, 1620634486, 427719405, -973727623, 533209078, 136016960, 1947798330, 428635832, -1125743884, 793211715, -2068889169, -136818786, -720841364, -891446378, 1990860976, -710528065, -1602505694, -1493714677, 1911121524,}; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithTrailingNegativeSignedBytesIsInvalid ( ) { import mmh3 import numpy as np mmh3.hash(np.uint8([-1])) mmh3.hash(np.uint8([0, -1])) mmh3.hash(np.uint8([0, 0, -1])) mmh3.hash(np.uint8([-1, 0])) mmh3.hash(np.uint8([-1, 0, 0])) mmh3.hash(np.uint8([0, -1, 0])) assertNotEquals(-43192051, MurmurHash3.hash32(new byte[] {-1}, 0, 1, 0)); assertNotEquals(-582037868, MurmurHash3.hash32(new byte[] {0, -1}, 0, 2, 0)); assertNotEquals(922088087, MurmurHash3.hash32(new byte[] {0, 0, -1}, 0, 3, 0)); assertNotEquals(-1309567588, MurmurHash3.hash32(new byte[] {-1, 0}, 0, 2, 0)); assertNotEquals(-363779670, MurmurHash3.hash32(new byte[] {-1, 0, 0}, 0, 3, 0)); assertNotEquals(-225068062, MurmurHash3.hash32(new byte[] {0, -1, 0}, 0, 3, 0)); } 
public void estHash32x86 ( ) { Note: Default seed is zero. mmh3.hash(bytes, 0) assertEquals(1546271276, MurmurHash3.hash32x86(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 0), ',') final int[] answers = {0, -1353253853, 915381745, -734983419, 1271125654, -1042265893, -1204521619, 735845843, 138310876, -1918938664, 1399647898, -1126342309, 2067593280, 1220975287, 1941281084, -1289513180, 942412060, -618173583, -269546647, -1645631262, 1162379906, -1960125577, -1856773195, 1980513522, 1174612855, 905810751, 1044578220, -1758486689, -491393913, 839836946, -435014415, 2044851178,}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32x86WithOffsetLengthAndSeed ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). final int seed = -42; final int offset = 13; final int[] answers = {192929823, -27171978, -1282326280, -816314453, -1176217753, -1904531247, 1962794233, -1302316624, -1151850323, -1464386748, -369299427, 972232488, 1747314487, 2137398916, 690986564, -1985866226, -678669121, -2123325690, -253319081, 46181235, 656058278, 1401175653, 1750113912, -1567219725, 2032742772, -2024269989, -305340794, 1161737942, -661265418, 172838872, -650122718, -1934812417,}; for (int i = 0; i < answers.length; i++) { assertEquals(answers[i], MurmurHash3.hash32x86(RANDOM_BYTES, offset, i, seed)); 
public void estHash32x86WithTrailingNegativeSignedBytes ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). This test uses assertEquals(). assertEquals(-43192051, MurmurHash3.hash32x86(new byte[] {-1}, 0, 1, 0)); assertEquals(-582037868, MurmurHash3.hash32x86(new byte[] {0, -1}, 0, 2, 0)); assertEquals(922088087, MurmurHash3.hash32x86(new byte[] {0, 0, -1}, 0, 3, 0)); assertEquals(-1309567588, MurmurHash3.hash32x86(new byte[] {-1, 0}, 0, 2, 0)); assertEquals(-363779670, MurmurHash3.hash32x86(new byte[] {-1, 0, 0}, 0, 3, 0)); assertEquals(-225068062, MurmurHash3.hash32x86(new byte[] {0, -1, 0}, 0, 3, 0)); } 
public void estHash64 ( ) { final byte [ ] origin = StringUtils . getBytesUtf8 ( TEST_HASH64 ) ; final long hash = MurmurHash3 . hash64 ( origin ) ; assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash64WithOffsetAndLength ( ) { final byte [ ] origin = StringUtils . getBytesUtf8 ( TEST_HASH64 ) ; final byte [ ] originOffset = new byte [ origin . length + 150 ] ; Arrays . fill ( originOffset , ( byte ) 123 ) ; System . arraycopy ( origin , 0 , originOffset , 150 , origin . length ) ; final long hash = MurmurHash3 . hash64 ( originOffset , 150 , origin . length ) ; assertEquals ( 5785358552565094607L , hash ) ; } 
public void estHash128 ( ) { mmh3.hash64(bytes, 104729) assertArrayEquals(new long[] {-5614308156300707300L, -4165733009867452172L}, MurmurHash3.hash128(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 104729), ',') final long[][] answers = { {-7122613646888064702L, -8341524471658347240L}, {5659994275039884826L, -962335545730945195L}, {-7641758224504050283L, 4083131074855072837L}, {-9123564721037921804L, -3321998102976419641L}, {-7999620158275145567L, -7769992740725283391L}, {2419143614837736468L, -5474637306496300103L}, {7781591175729494939L, -9023178611551692650L}, {-3431043156265556247L, -6589990064676612981L}, {6315693694262400182L, -6219942557302821890L}, {-8249934145502892979L, -5646083202776239948L}, {7500109050276796947L, 5350477981718987260L}, {-6102338673930022315L, 3413065069102535261L}, {-6440683413407781313L, -2374360388921904146L}, {-3071236194203069122L, 7531604855739305895L}, {-7629408037856591130L, -4070301959951145257L}, {860008171111471563L, -9026008285726889896L}, {8059667613600971894L, 3236009436748930210L}, {1833746055900036985L, 1418052485321768916L}, {8161230977297923537L, -2668130155009407119L}, {3653111839268905630L, 5525563908135615453L}, {-9163026480602019754L, 6819447647029564735L}, {1102346610654592779L, -6881918401879761029L}, {-3109499571828331931L, -3782255367340446228L}, {-7467915444290531104L, 4704551260862209500L}, {1237530251176898868L, 6144786892208594932L}, {2347717913548230384L, -7461066668225718223L}, {-7963311463560798404L, 8435801462986138227L}, {-7493166089060196513L, 8163503673197886404L}, {6807249306539951962L, -1438886581269648819L}, {6752656991043418179L, 6334147827922066123L}, {-4534351735605790331L, -4530801663887858236L}, {-7886946241830957955L, -6261339648449285315L},}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128WithOffsetLengthAndSeed ( ) { Seed must be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = {{-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L},}; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. final long[][] answers = {{5954234972212089025L, 3342108296337967352L}, {8501094764898402923L, 7873951092908129427L}, {-3334322685492296196L, -2842715922956549478L}, {-2177918982459519644L, -1612349961980368636L}, {4172870320608886992L, -4177375712254136503L}, {7546965006884307324L, -5222114032564054641L}, {-2885083166621537267L, -2069868899915344482L}, {-2397098497873118851L, 4990578036999888806L}, {-706479374719025018L, 7531201699171849870L}, {6487943141157228609L, 3576221902299447884L}, {6671331646806999453L, -3428049860825046360L}, {-8700221138601237020L, -2748450904559980545L}, {-9028762509863648063L, 6130259301750313402L}, {729958512305702590L, -36367317333638988L}, {-3803232241584178983L, -4257744207892929651L}, {5734013720237474696L, -760784490666078990L}, {-6097477411153026656L, 625288777006549065L}, {1320365359996757504L, -2251971390373072541L}, {5551441703887653022L, -3516892619809375941L}, {698875391638415033L, 3456972931370496131L}, {5874956830271303805L, -6074126509360777023L}, {-7030758398537734781L, -3174643657101295554L}, {6835789852786226556L, 7245353136839389595L}, {-7755767580598793204L, -6680491060945077989L}, {-3099789923710523185L, -2751080516924952518L}, {-7772046549951435453L, 5263206145535830491L}, {7458715941971015543L, 5470582752171544854L}, {-7753394773760064468L, -2330157750295630617L}, {-5899278942232791979L, 6235686401271389982L}, {4881732293467626532L, 2617335658565007304L}, {-5722863941703478257L, -5424475653939430258L}, {-3703319768293496315L, -2124426428486426443L},}; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128x64 ( ) { Note: Default seed is zero. mmh3.hash64(bytes, 0) assertArrayEquals(new long[] {1972113670104592209L, 5171809317673151911L}, MurmurHash3.hash128x64(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 0), ',') final long[][] answers = {{0L, 0L}, {-2808653841080383123L, -2531784594030660343L}, {-1284575471001240306L, -8226941173794461820L}, {1645529003294647142L, 4109127559758330427L}, {-4117979116203940765L, -8362902660322042742L}, {2559943399590596158L, 4738005461125350075L}, {-1651760031591552651L, -5386079254924224461L}, {-6208043960690815609L, 7862371518025305074L}, {-5150023478423646337L, 8346305334874564507L}, {7658274117911906792L, -4962914659382404165L}, {1309458104226302269L, 570003296096149119L}, {7440169453173347487L, -3489345781066813740L}, {-5698784298612201352L, 3595618450161835420L}, {-3822574792738072442L, 6878153771369862041L}, {3705084673301918328L, 3202155281274291907L}, {-6797166743928506931L, -4447271093653551597L}, {5240533565589385084L, -5575481185288758327L}, {-8467620131382649428L, -6450630367251114468L}, {3632866961828686471L, -5957695976089313500L}, {-6450283648077271139L, -7908632714374518059L}, {226350826556351719L, 8225586794606475685L}, {-2382996224496980401L, 2188369078123678011L}, {-1337544762358780825L, 7004253486151757299L}, {2889033453638709716L, -4099509333153901374L}, {-8644950936809596954L, -5144522919639618331L}, {-5628571865255520773L, -839021001655132087L}, {-5226774667293212446L, -505255961194269502L}, {1337107025517938142L, 3260952073019398505L}, {9149852874328582511L, 1880188360994521535L}, {-4035957988359881846L, -7709057850766490780L}, {-3842593823306330815L, 3805147088291453755L}, {4030161393619149616L, -2813603781312455238L},}; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128x64WithOffsetLengthAndSeed ( ) { Seed can be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = {{-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L},}; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128x64WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], -42), ',') final long[][] answers = {{7182599573337898253L, -6490979146667806054L}, {-461284136738605467L, 7073284964362976233L}, {-3090354666589400212L, 2978755180788824810L}, {5052807367580803906L, -4497188744879598335L}, {5003711854877353474L, -6616808651483337088L}, {2043501804923817748L, -760668448196918637L}, {6813003268375229932L, -1818545210475363684L}, {4488070015393027916L, 8520186429078977003L}, {4709278711722456062L, -2262080641289046033L}, {-5944514262756048380L, 5968714500873552518L}, {-2304397529301122510L, 6451500469518446488L}, {-1054078041081348909L, -915114408909600132L}, {1300471646869277217L, -399493387666437046L}, {-2821780479886030222L, -9061571187511294733L}, {8005764841242557505L, 4135287855434326053L}, {318307346637037498L, -5355856739901286522L}, {3380719536119187025L, 1890890833937151467L}, {2691044185935730001L, 7963546423617895734L}, {-5277462388534000227L, 3613853764390780573L}, {8504421722476165699L, 2058020162708103700L}, {-6578421288092422241L, 3311200163790829579L}, {-5915037218487974215L, -7385137075895184179L}, {659642911937398022L, 854071824595671049L}, {-7007237968866727198L, 1372258010932080058L}, {622891376282772539L, -4140783491297489868L}, {8357110718969014985L, -4737117827581590306L}, {2208857857926305405L, -8360240839768465042L}, {858120048221036376L, -5822288789703639119L}, {-1988334009458340679L, 1262479472434068698L}, {-8580307083590783934L, 3634449965473715778L}, {6705664584730187559L, 5192304951463791556L}, {-6426410954037604142L, -1579122709247558101L},}; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int unprocessedSize = 3; final int hugeLength = Integer.MAX_VALUE - 2; assertTrue(unprocessedSize + hugeLength < 4, "This should overflow to negative"); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (final OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } assumeTrue(bytes != null, "Cannot allocate array of length " + hugeLength); final IncrementalHash32x86 inc = new IncrementalHash32x86(); inc.start(0); Add bytes that should be unprocessed inc.add(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.add(bytes, 0, hugeLength); } 
private void check ( final int expected ) { crc . reset ( ) ; crc . update ( data , 0 , data . length ) ; final int actual = ( int ) crc . getValue ( ) ; assertEquals ( Integer . oHexString ( expected ) , Integer . oHexString ( actual ) ) ; } 
public void estIncrementalHashWithUnprocessedBytesAndHugeLengthArray ( ) { Assert the test precondition that a large array added to unprocessed bytes will overflow an integer counter. We use the smallest hugeLength possible as some VMs cannot allocate maximum length arrays. final int bufferSize = 16; final int unprocessedSize = bufferSize - 1; final int hugeLength = Integer.MAX_VALUE - (unprocessedSize - 1); assertTrue(unprocessedSize + hugeLength < bufferSize, "This should overflow to negative"); Check the test can be run byte[] bytes = null; try { bytes = new byte[hugeLength]; } catch (final OutOfMemoryError ignore) { Some VMs cannot allocate an array this large. Some test environments may not have enough available memory for this. } assumeTrue(bytes != null, "Cannot allocate array of length " + hugeLength); final XXHash32 inc = new XXHash32(); Add bytes that should be unprocessed inc.update(bytes, 0, unprocessedSize); Add a huge number of bytes to overflow an integer counter of unprocessed bytes. inc.update(bytes, 0, hugeLength); } 
public void initData ( final String path , final String c ) hrows IOException { final URL url = XXHash32Test . class . getClassLoader ( ) . getResource ( path ) ; if ( url = = null ) { hrow new FileNotFoundException ( " couldn't find " + path ) ; } URI uri = null ; ry { uri = url . oURI ( ) ; } catch ( final java . net . URISyntaxException ex ) { hrow new IOException ( ex ) ; } file = new File ( uri ) ; expectedChecksum = c ; } 
public static Stream < Arguments > data ( ) { return Stream . of ( reference checksums created with xxh32sum 
public void verifyChecksum ( String path , String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } assertEquals ( expectedChecksum , Long . oHexString ( h . getValue ( ) ) , " checksum for " + file . getName ( ) ) ; } 
public void verifyIncrementalChecksum ( String path , String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; Hit the case where the hash should be reset h.update(b[0]); h.reset(); Pass in chunks h.update(b[0]); h.update(b, 1, b.length - 2); h.update(b, b.length - 1, 1); Check the hash ignores negative length h.update(b, 0, -1); } assertEquals(expectedChecksum, Long.toHexString(h.getValue()), "checksum for " + file.getName()); } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { final Caverphone1 caverphone = new Caverphone1 ( ) ; assertFalse ( caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) , " Caverphone encodings should not be equal " ) ; assertTrue ( caverphone . isEncodeEqual ( " Peter " , " Peady " ) , " Caverphone encodings should be equal " ) ; } 
public void estIsCaverphoneEquals ( ) hrows EncoderException { final Caverphone2 caverphone = new Caverphone2 ( ) ; assertFalse ( caverphone . isEncodeEqual ( " Peter " , " Stevenson " ) , " Caverphone encodings should not be equal " ) ; assertTrue ( caverphone . isEncodeEqual ( " Peter " , " Peady " ) , " Caverphone encodings should be equal " ) ; } 
public static void finishTests ( ) { int errors = 0 ; for ( final String m : MATCHES ) { if ( ! hasTestCase ( m ) ) { System . out . println ( m + " has no test case " ) ; errors + + ; } } assertEquals ( 0 , errors , " Not expecting any missing test cases " ) ; } 
public void estCanFail ( ) { assertThrows ( AssertionFailedError . class , ( ) - > his . checkEncoding ( " / " , " Fehler " ) ) ; } 
public void estAdjacentCodes ( ) { AKSSOL A-KS-S-O-L 0-54-4---8 -> wrong 0-54-----8 -> correct assertEquals("054800", soundex("AKSSOL")); GERSCHFELD G-E-RS-CH-F-E-L-D 5--4/94-5/4-7-8-3 -> wrong 5--4/94-5/--7-8-3 -> correct assertEquals("547830|545783|594783|594578", soundex("GERSCHFELD")); } 
public void estEncodeBasic ( ) { same as above, but without branching assertEquals("097400", encode("AUERBACH")); assertEquals("097400", encode("OHRBACH")); assertEquals("874400", encode("LIPSHITZ")); assertEquals("874400", encode("LIPPSZYC")); assertEquals("876450", encode("LEWINSKY")); assertEquals("876450", encode("LEVINSKI")); assertEquals("486740", encode("SZLAMAWICZ")); assertEquals("486740", encode("SHLAMOVITZ")); } 
public void estEncodeIgnoreTrimmable ( ) { assertEquals ( " 746536 " , encode ( " r Washington r " ) ) ; assertEquals ( " 746536 " , encode ( " Washington " ) ) ; } 
public void estSoundexBasic ( ) { assertEquals ( " 583600 " , soundex ( " GOLDEN " ) ) ; assertEquals ( " 087930 " , soundex ( " Alpert " ) ) ; assertEquals ( " 791900 " , soundex ( " Breuer " ) ) ; assertEquals ( " 579000 " , soundex ( " Haber " ) ) ; assertEquals ( " 665600 " , soundex ( " Mannheim " ) ) ; assertEquals ( " 664000 " , soundex ( " Mintz " ) ) ; assertEquals ( " 370000 " , soundex ( " Topf " ) ) ; assertEquals ( " 586660 " , soundex ( " Kleinmann " ) ) ; assertEquals ( " 769600 " , soundex ( " Ben Aron " ) ) ; assertEquals ( " 097400|097500 " , soundex ( " AUERBACH " ) ) ; assertEquals ( " 097400|097500 " , soundex ( " OHRBACH " ) ) ; assertEquals ( " 874400 " , soundex ( " LIPSHITZ " ) ) ; assertEquals ( " 874400|874500 " , soundex ( " LIPPSZYC " ) ) ; assertEquals ( " 876450 " , soundex ( " LEWINSKY " ) ) ; assertEquals ( " 876450 " , soundex ( " LEVINSKI " ) ) ; assertEquals ( " 486740 " , soundex ( " SZLAMAWICZ " ) ) ; assertEquals ( " 486740 " , soundex ( " SHLAMOVITZ " ) ) ; } 
public void estSoundexBasic2 ( ) { assertEquals ( " 467000|567000 " , soundex ( " Ceniow " ) ) ; assertEquals ( " 467000 " , soundex ( " Tsenyuv " ) ) ; assertEquals ( " 587400|587500 " , soundex ( " Holubica " ) ) ; assertEquals ( " 587400 " , soundex ( " Golubitsa " ) ) ; assertEquals ( " 746480|794648 " , soundex ( " Przemysl " ) ) ; assertEquals ( " 746480 " , soundex ( " Pshemeshil " ) ) ; assertEquals ( " 944744|944745|944754|944755|945744|945745|945754|945755 " , soundex ( " Rosochowaciec " ) ) ; assertEquals ( " 945744 " , soundex ( " Rosokhovatsets " ) ) ; } 
public void estSoundexBasic3 ( ) { assertEquals ( " 734000|739400 " , soundex ( " Peters " ) ) ; assertEquals ( " 734600|739460 " , soundex ( " Peterson " ) ) ; assertEquals ( " 645740 " , soundex ( " Moskowitz " ) ) ; assertEquals ( " 645740 " , soundex ( " Moskovitz " ) ) ; assertEquals ( " 154600|145460|454600|445460 " , soundex ( " Jackson " ) ) ; assertEquals ( " 154654|154645|154644|145465|145464|454654|454645|454644|445465|445464 " , soundex ( " Jackson-Jackson " ) ) ; 
private void assertDoubleMetaphone ( final String expected , final String source ) { assertEquals ( expected , his . getStringEncoder ( ) . encode ( source ) ) ; ry { assertEquals ( expected , his . getStringEncoder ( ) . encode ( ( Object ) source ) ) ; } catch ( final EncoderException e ) { fail ( " Unexpected exception: " + e ) ; } assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source ) ) ; assertEquals ( expected , his . getStringEncoder ( ) . doubleMetaphone ( source , false ) ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals(4, doubleMetaphone.getMaxCodeLen(), "Default Max Code Length"); assertEquals( "JMPT", doubleMetaphone.doubleMetaphone(value, false), "Default Primary"); assertEquals("AMPT", doubleMetaphone.doubleMetaphone(value, true), "Default Alternate"); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals(3, doubleMetaphone.getMaxCodeLen(), "Set Max Code Length"); assertEquals( "JMP", doubleMetaphone.doubleMetaphone(value, false), "Max=3 Primary"); assertEquals("AMP", doubleMetaphone.doubleMetaphone(value, true), "Max=3 Alternate"); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estSetMaxCodeLength ( ) { final String value = " jumped " ; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone ( ) ; Sanity check of default settings assertEquals(4, doubleMetaphone.getMaxCodeLen(), "Default Max Code Length"); assertEquals( "JMPT", doubleMetaphone.doubleMetaphone(value, false), "Default Primary"); assertEquals("AMPT", doubleMetaphone.doubleMetaphone(value, true), "Default Alternate"); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals(3, doubleMetaphone.getMaxCodeLen(), "Set Max Code Length"); assertEquals( "JMP", doubleMetaphone.doubleMetaphone(value, false), "Max=3 Primary"); assertEquals("AMP", doubleMetaphone.doubleMetaphone(value, true), "Max=3 Alternate"); } 
public void assertIsMetaphoneEqual ( final String source , final String [ ] matches ) { match source to all matches for (final String matche : matches) { assertTrue(this.getStringEncoder().isMetaphoneEqual(source, matche), "Source: " + source + ", should have same Metaphone as: " + matche); } match to each other for (final String matche : matches) { for (final String matche2 : matches) { 
private void assertEncodings ( final String [ ] . . . estValues ) hrows EncoderException { for ( final String [ ] arr : estValues ) { assertEquals ( arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) , " Problem with " + arr [ 0 ] ) ; 
private void encodeAll ( final String [ ] strings , final String expectedEncoding ) { for ( final String string : strings ) { assertEquals ( expectedEncoding , getStringEncoder ( ) . encode ( string ) , " Problem with " + string ) ; 
public void estTrueVariant ( ) { final Nysiis encoder = new Nysiis ( rue ) ; final String encoded = encoder . encode ( " WESTERLUND " ) ; assertTrue ( encoded . length ( ) < = 6 ) ; assertEquals ( " WASTAR " , encoded ) ; } 
public void estGetMappingCodeNonLetter ( ) { final char code = his . getStringEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( 0 , code , " Code does not equals zero " ) ; } 
public void estBadCharacters ( ) { assertEquals ( " H452 " , his . getStringEncoder ( ) . encode ( " HOL>MES " ) ) ; 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getStringEncoder().difference(null, null)); assertEquals(0, this.getStringEncoder().difference("", "")); assertEquals(0, this.getStringEncoder().difference(" ", " ")); Normal cases assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(2, this.getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Margaret", "Andrew")); assertEquals(0, this.getStringEncoder().difference("Janet", "Margaret")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(4, this.getStringEncoder().difference("Green", "Greene")); assertEquals(0, this.getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from http:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(4, this.getStringEncoder().difference("Smithers", "Smythers")); assertEquals(2, this.getStringEncoder().difference("Anothers", "Brothers")); } 
public void estEncodeBasic ( ) { assertEquals ( " T235 " , his . getStringEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T000 " , his . getStringEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q200 " , his . getStringEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B650 " , his . getStringEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F200 " , his . getStringEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J513 " , his . getStringEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O160 " , his . getStringEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T000 " , his . getStringEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L200 " , his . getStringEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D200 " , his . getStringEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncodeBatch2 ( ) { assertEquals ( " A462 " , his . getStringEncoder ( ) . encode ( " Allricht " ) ) ; assertEquals ( " E166 " , his . getStringEncoder ( ) . encode ( " Eberhard " ) ) ; assertEquals ( " E521 " , his . getStringEncoder ( ) . encode ( " Engebrethson " ) ) ; assertEquals ( " H512 " , his . getStringEncoder ( ) . encode ( " Heimbach " ) ) ; assertEquals ( " H524 " , his . getStringEncoder ( ) . encode ( " Hanselmann " ) ) ; assertEquals ( " H431 " , his . getStringEncoder ( ) . encode ( " Hildebrand " ) ) ; assertEquals ( " K152 " , his . getStringEncoder ( ) . encode ( " Kavanagh " ) ) ; assertEquals ( " L530 " , his . getStringEncoder ( ) . encode ( " Lind " ) ) ; assertEquals ( " L222 " , his . getStringEncoder ( ) . encode ( " Lukaschowsky " ) ) ; assertEquals ( " M235 " , his . getStringEncoder ( ) . encode ( " McDonnell " ) ) ; assertEquals ( " M200 " , his . getStringEncoder ( ) . encode ( " McGee " ) ) ; assertEquals ( " O155 " , his . getStringEncoder ( ) . encode ( " Opnian " ) ) ; assertEquals ( " O155 " , his . getStringEncoder ( ) . encode ( " Oppenheimer " ) ) ; assertEquals ( " R355 " , his . getStringEncoder ( ) . encode ( " Riedemanas " ) ) ; assertEquals ( " Z300 " , his . getStringEncoder ( ) . encode ( " Zita " ) ) ; assertEquals ( " Z325 " , his . getStringEncoder ( ) . encode ( " Zitzmeinn " ) ) ; } 
public void estEncodeBatch3 ( ) { assertEquals ( " W252 " , his . getStringEncoder ( ) . encode ( " Washington " ) ) ; assertEquals ( " L000 " , his . getStringEncoder ( ) . encode ( " Lee " ) ) ; assertEquals ( " G362 " , his . getStringEncoder ( ) . encode ( " Gutierrez " ) ) ; assertEquals ( " P236 " , his . getStringEncoder ( ) . encode ( " Pfister " ) ) ; assertEquals ( " J250 " , his . getStringEncoder ( ) . encode ( " Jackson " ) ) ; assertEquals ( " T522 " , his . getStringEncoder ( ) . encode ( " Tymczak " ) ) ; For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also possible. assertEquals("V532", this.getStringEncoder().encode("VanDeusen")); } 
public void estEncodeBatch4 ( ) { assertEquals ( " H452 " , his . getStringEncoder ( ) . encode ( " HOLMES " ) ) ; assertEquals ( " A355 " , his . getStringEncoder ( ) . encode ( " ADOMOMI " ) ) ; assertEquals ( " V536 " , his . getStringEncoder ( ) . encode ( " VONDERLEHR " ) ) ; assertEquals ( " B400 " , his . getStringEncoder ( ) . encode ( " BALL " ) ) ; assertEquals ( " S000 " , his . getStringEncoder ( ) . encode ( " SHAW " ) ) ; assertEquals ( " J250 " , his . getStringEncoder ( ) . encode ( " JACKSON " ) ) ; assertEquals ( " S545 " , his . getStringEncoder ( ) . encode ( " SCANLON " ) ) ; assertEquals ( " S532 " , his . getStringEncoder ( ) . encode ( " SAINTJOHN " ) ) ; 
public void estEncodeIgnoreTrimmable ( ) { assertEquals ( " W252 " , his . getStringEncoder ( ) . encode ( " r Washington r " ) ) ; } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. assertEquals("A261", this.getStringEncoder().encode("Ashcraft")); assertEquals("A261", this.getStringEncoder().encode("Ashcroft")); assertEquals("Y330", this.getStringEncoder().encode("yehudit")); assertEquals("Y330", this.getStringEncoder().encode("yhwdyt")); } 
public void estHWRuleEx2 ( ) { assertEquals ( " B312 " , his . getStringEncoder ( ) . encode ( " BOOTHDAVIS " ) ) ; assertEquals ( " B312 " , his . getStringEncoder ( ) . encode ( " BOOTH-DAVIS " ) ) ; } 
public void estHWRuleEx3 ( ) hrows EncoderException { assertEquals ( " S460 " , his . getStringEncoder ( ) . encode ( " Sgler " ) ) ; assertEquals ( " S460 " , his . getStringEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: this.checkEncodingVariations("S460", new String[]{ "SAILOR", 
public void estMsSqlServer1 ( ) { assertEquals ( " S530 " , his . getStringEncoder ( ) . encode ( " Smith " ) ) ; assertEquals ( " S530 " , his . getStringEncoder ( ) . encode ( " Smythe " ) ) ; } 
public void estMsSqlServer3 ( ) { assertEquals ( " A500 " , his . getStringEncoder ( ) . encode ( " Ann " ) ) ; assertEquals ( " A536 " , his . getStringEncoder ( ) . encode ( " Andrew " ) ) ; assertEquals ( " J530 " , his . getStringEncoder ( ) . encode ( " Janet " ) ) ; assertEquals ( " M626 " , his . getStringEncoder ( ) . encode ( " Margaret " ) ) ; assertEquals ( " S315 " , his . getStringEncoder ( ) . encode ( " Steven " ) ) ; assertEquals ( " M240 " , his . getStringEncoder ( ) . encode ( " Michael " ) ) ; assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Robert " ) ) ; assertEquals ( " L600 " , his . getStringEncoder ( ) . encode ( " Laura " ) ) ; assertEquals ( " A500 " , his . getStringEncoder ( ) . encode ( " Anne " ) ) ; } 
public void estSoundexUtilsNullBehaviour ( ) { assertNull ( SoundexUtils . clean ( null ) ) ; assertEquals ( " " , SoundexUtils . clean ( " " ) ) ; assertEquals ( 0 , SoundexUtils . differenceEncoded ( null , " " ) ) ; assertEquals ( 0 , SoundexUtils . differenceEncoded ( " " , null ) ) ; } 
public void estUsMappingEWithAcute ( ) { assertEquals ( " E000 " , his . getStringEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( '\u00e9' ) ) { e-acute uppercase E-acute 
public void estUsMappingOWithDiaeresis ( ) { assertEquals ( " O000 " , his . getStringEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( '\u00f6' ) ) { o-umlaut uppercase O-umlaut 
public void estWikipediaAmericanSoundex ( ) { assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Robert " ) ) ; assertEquals ( " R163 " , his . getStringEncoder ( ) . encode ( " Rupert " ) ) ; assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcraft " ) ) ; assertEquals ( " A261 " , his . getStringEncoder ( ) . encode ( " Ashcroft " ) ) ; assertEquals ( " T522 " , his . getStringEncoder ( ) . encode ( " Tymczak " ) ) ; assertEquals ( " P236 " , his . getStringEncoder ( ) . encode ( " Pfister " ) ) ; } 
public void estGenealogy ( ) { treat vowels and HW as silent final Soundex s = Soundex.US_ENGLISH_GENEALOGY; assertEquals("H251", s.encode("Heggenburger")); assertEquals("B425", s.encode("Blackman")); assertEquals("S530", s.encode("Schmidt")); assertEquals("L150", s.encode("Lippmann")); Additional local example assertEquals("D200", s.encode("Dodds")); 'o' is not a separator here - it is silent assertEquals("D200", s.encode("Dhdds")); 'h' is silent assertEquals("D200", s.encode("Dwdds")); 'w' is silent } 
public void estSimplifiedSoundex ( ) { treat vowels and HW as separators final Soundex s = Soundex.US_ENGLISH_SIMPLIFIED; assertEquals("W452", s.encode("WILLIAMS")); assertEquals("B625", s.encode("BARAGWANATH")); assertEquals("D540", s.encode("DONNELL")); assertEquals("L300", s.encode("LLOYD")); assertEquals("W422", s.encode("WOOLCOCK")); Additional local examples assertEquals("D320", s.encode("Dodds")); assertEquals("D320", s.encode("Dwdds")); w is a separator assertEquals("D320", s.encode("Dhdds")); h is a separator } 
private void assertNotEmpty ( final BeiderMorseEncoder bmpm , final String value ) hrows EncoderException { assertNotEquals ( " " , bmpm . encode ( value ) , value ) ; } 
public void estLongestEnglishSurname ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; assertTimeout ( Duration . ofMillis ( 10000L ) , ( ) - > bmpm . encode ( " MacGhilleseatheanaich " ) ) ; } 
public void estSetConcat ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setConcat ( false ) ; assertFalse ( bmpm . isConcat ( ) , " Should be able to set concat to false " ) ; } 
public void estSetNameTypeAsh ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setNameType ( NameType . ASHKENAZI ) ; assertEquals ( NameType . ASHKENAZI , bmpm . getNameType ( ) , " Name type should have been set to ash " ) ; } 
public void estSetRuleTypeExact ( ) { final BeiderMorseEncoder bmpm = new BeiderMorseEncoder ( ) ; bmpm . setRuleType ( RuleType . EXACT ) ; assertEquals ( RuleType . EXACT , bmpm . getRuleType ( ) , " Rule type should have been set to exact " ) ; } 
public static Stream < Arguments > data ( ) { return Stream . of ( Arguments . of ( " Renault " , " french " ) , 
public void estLanguageGuessing ( String name , String language ) { final Languages . LanguageSet guesses = his . lang . guessLanguages ( name ) ; assertTrue ( guesses . contains ( language ) , " language predicted for name ' " + name + " ' is wrong: " + guesses + " should contain ' " + language + " ' " ) ; 
public void estSolrGENERIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "GENERIC"); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("anZelo|andZelo|angelo|anhelo|anjelo|anxelo", encode(args, true, "Angelo")); assertEquals("(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("andZelo|angelo|anxelo", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("anZelo|andZelo|angelo|anhelo|anjelo|anxelo", encode(args, false, "Angelo")); assertEquals("(anZelo|andZelo|angelo|anhelo|anjelo|anxelo)-(danZelo|dandZelo|dangelo|danhelo|danjelo|danxelo)", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("andZelo|angelo|anxelo", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); assertEquals("(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angilo|anxilo|anzilo|ongilo|onxilo|onzilo", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); assertEquals("(YngYlo|Yngilo|agilo|angYlo|angilo|aniilo|anilo|anxilo|anzilo|ogilo|ongYlo|ongilo|oniilo|onilo|onxilo|onzilo)-(dYngYlo|dYngilo|dagilo|dangYlo|dangilo|daniilo|danilo|danxilo|danzilo|dogilo|dongYlo|dongilo|doniilo|donilo|donxilo|donzilo)", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angilo|anxilo|anzilo|ongilo|onxilo|onzilo", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrASHKENAZI ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("andZelo|angelo|anhelo|anxelo", encode(args, true, "Angelo")); assertEquals("dandZelo|dangelo|danhelo|danxelo", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angelo|anxelo", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("andZelo|angelo|anhelo|anxelo", encode(args, false, "Angelo")); assertEquals("dandZelo|dangelo|danhelo|danxelo", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angelo|anxelo", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, true, "Angelo")); assertEquals("dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angilo|anxilo|ongilo|onxilo", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "ASHKENAZI"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("YngYlo|Yngilo|angYlo|angilo|anilo|anxilo|anzilo|ongYlo|ongilo|onilo|onxilo|onzilo", encode(args, false, "Angelo")); assertEquals("dYngYlo|dYngilo|dangYlo|dangilo|danilo|danxilo|danzilo|dongYlo|dongilo|donilo|donxilo|donzilo", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("angilo|anxilo|ongilo|onxilo", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); } 
public void estSolrSEPHARDIC ( ) { Map < String , String > args ; concat is true, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, true, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("anZelo|andZelo|anxelo", encode(args, true, "Angelo")); assertEquals("anZelo|andZelo|anxelo", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("andZelo|anxelo", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is EXACT args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, false, "Angelo")); args.put("ruleType", "EXACT"); assertEquals("anZelo|andZelo|anxelo", encode(args, false, "Angelo")); assertEquals("danZelo|dandZelo|danxelo", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("andZelo|anxelo", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); concat is true, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, true, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, true, "Angelo")); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, true, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, true, "Angelo")); assertEquals(encode(args, true, "1234"), ""); concat is false, ruleType is APPROX args = new TreeMap<>(); args.put("nameType", "SEPHARDIC"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, false, "Angelo")); args.put("ruleType", "APPROX"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, false, "Angelo")); assertEquals("danhila|danhilu|danzila|danzilu|nhila|nhilu|nzila|nzilu", encode(args, false, "D'Angelo")); args.put("languageSet", "italian,greek,spanish"); assertEquals("anhila|anhilu|anzila|anzilu|nhila|nhilu|nzila|nzilu", encode(args, false, "Angelo")); assertEquals(encode(args, false, "1234"), ""); } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: http:stevemorse.org/census/soundex.html final Map<String, String> args = new TreeMap<>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals("Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom", encode(args, true, "abram")); assertEquals("bndzn|bntsn|bnzn|vndzn|vntsn", encode(args, true, "Bendzin")); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals("Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom", encode(args, true, "abram")); assertEquals("YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn", encode(args, true, "Halpern")); 
public static Stream < Arguments > data ( ) { return Stream . of ( Arguments . of ( " Renault " , " rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult " , NameType . GENERIC , RuleType . APPROX , Boolean . TRUE , TEN ) , 
public void estEncode ( final String name , final String phoneticExpected , final NameType nameType , final RuleType ruleType , final boolean concat , final int maxPhonemes ) { final PhoneticEngine engine = new PhoneticEngine ( nameType , ruleType , concat , maxPhonemes ) ; final String phoneticActual = engine . encode ( name ) ; assertEquals ( phoneticExpected , phoneticActual , " phoneme incorrect " ) ; if ( concat ) { final String [ ] split = phoneticActual . split ( " \\ | " ) ; 
public void estBasicEncodeDecode ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " Hello there " ; final String encoded = bcodec . encode ( plain ) ; assertEquals ( " =?UTF-8?B?SGVsbG8gdGhlcmU=?= " , encoded , " Basic B encoding test " ) ; assertEquals ( plain , bcodec . decode ( encoded ) , " Basic B decoding test " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; assertNull ( bcodec . encode ( ( String ) null ) , " Null string B encoding test " ) ; assertNull ( bcodec . decode ( ( String ) null ) , " Null string B decoding test " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String est = null ; final String result = bcodec . decode ( est ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String plain = " what not " ; final String encoded = ( String ) bcodec . encode ( ( Object ) plain ) ; assertEquals ( " =?UTF-8?B?d2hhdCBub3Q=?= " , encoded , " Basic B encoding test " ) ; final Object result = bcodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > bcodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; 
public void estDecodeObjects ( ) hrows Exception { final BCodec bcodec = new BCodec ( ) ; final String decoded = " =?UTF-8?B?d2hhdCBub3Q=?= " ; final String plain = ( String ) bcodec . decode ( ( Object ) decoded ) ; assertEquals ( " what not " , plain , " Basic B decoding test " ) ; final Object result = bcodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > bcodec . decode ( Double . valueOf ( 3.0d ) ) ) ; } 
public void estBase64ImpossibleSamplesDefault ( ) hrows DecoderException { final BCodec codec = new BCodec ( ) ; Default encoding is lenient assertFalse(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { codec.decode(s); 
public void estBase64ImpossibleSamplesLenient ( ) hrows DecoderException { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . LENIENT ) ; Default encoding is lenient assertFalse(codec.isStrictDecoding()); for (final String s : BASE64_IMPOSSIBLE_CASES) { codec.decode(s); 
public void estBase64ImpossibleSamplesStrict ( ) hrows DecoderException { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . STRICT ) ; assertTrue ( codec . isStrictDecoding ( ) ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { assertThrows ( DecoderException . class , ( ) - > codec . decode ( s ) ) ; 
public void estBasicEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " abcdABCD " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , StandardCharsets . UTF_8 ) ; assertEquals ( input , encodedS , " Basic PercentCodec encoding test " ) ; assertEquals ( input , decodedS , " Basic PercentCodec decoding test " ) ; } 
public void estBasicSpace ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; assertArrayEquals ( " %20 " . getBytes ( StandardCharsets . UTF_8 ) , encoded ) ; } 
public void estConfigurablePercentEncoder ( ) hrows Exception { final String input = " abc123_-.* u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( " abcdef " . getBytes ( StandardCharsets . UTF_8 ) , false ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; assertEquals ( " %61%62%63123_-.*%CE%B1%CE%B2 " , encodedS , " Configurable PercentCodec encoding test " ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; assertEquals ( new String ( decoded , StandardCharsets . UTF_8 ) , input , " Configurable PercentCodec decoding test " ) ; } 
public void estPercentEncoderDecoderWithNullOrEmptyInput ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; assertNull ( percentCodec . encode ( null ) , " Null input value encoding test " ) ; assertNull ( percentCodec . decode ( null ) , " Null input value decoding test " ) ; final byte [ ] emptyInput = " " . getBytes ( StandardCharsets . UTF_8 ) ; assertEquals ( percentCodec . encode ( emptyInput ) , emptyInput , " Empty input value encoding test " ) ; assertArrayEquals ( percentCodec . decode ( emptyInput ) , emptyInput , " Empty input value decoding test " ) ; } 
public void estPercentEncoderDecoderWithPlusForSpace ( ) hrows Exception { final String input = " a b c d " ; final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; assertEquals ( " a+b+c+d " , encodedS , " PercentCodec plus for space encoding test " ) ; final byte [ ] decode = percentCodec . decode ( encoded ) ; assertEquals ( new String ( decode , StandardCharsets . UTF_8 ) , input , " PercentCodec plus for space decoding test " ) ; } 
public void estSafeCharEncodeDecodeObject ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( null , rue ) ; final String input = " abc123_-.* " ; final Object encoded = percentCodec . encode ( ( Object ) input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( ( byte [ ] ) encoded , StandardCharsets . UTF_8 ) ; final Object decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( ( byte [ ] ) decoded , StandardCharsets . UTF_8 ) ; assertEquals ( input , encodedS , " Basic PercentCodec safe char encoding test " ) ; assertEquals ( input , decodedS , " Basic PercentCodec safe char decoding test " ) ; } 
public void estUnsafeCharEncodeDecode ( ) hrows Exception { final PercentCodec percentCodec = new PercentCodec ( ) ; final String input = " u03B1 u03B2 u03B3 u03B4 u03B5 u03B6% " ; final byte [ ] encoded = percentCodec . encode ( input . getBytes ( StandardCharsets . UTF_8 ) ) ; final String encodedS = new String ( encoded , StandardCharsets . UTF_8 ) ; final byte [ ] decoded = percentCodec . decode ( encoded ) ; final String decodedS = new String ( decoded , StandardCharsets . UTF_8 ) ; assertEquals ( " %CE%B1%CE%B2%CE%B3%CE%B4%CE%B5%CE%B6%25 " , encodedS , " Basic PercentCodec unsafe char encoding test " ) ; assertEquals ( input , decodedS , " Basic PercentCodec unsafe char decoding test " ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " = Hello there = r " ; final String encoded = qcodec . encode ( plain ) ; assertEquals ( " =?UTF-8?Q?=3D Hello there =3D=0D=0A?= " , encoded , " Basic Q encoding test " ) ; assertEquals ( plain , qcodec . decode ( encoded ) , " Basic Q decoding test " ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " ?_= r " ; final String encoded = qcodec . encode ( plain ) ; assertEquals ( " =?UTF-8?Q?=3F=5F=3D=0D=0A?= " , encoded , " Unsafe chars Q encoding test " ) ; assertEquals ( plain , qcodec . decode ( encoded ) , " Unsafe chars Q decoding test " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; assertNull ( qcodec . encode ( ( String ) null ) , " Null string Q encoding test " ) ; assertNull ( qcodec . decode ( ( String ) null ) , " Null string Q decoding test " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . decode ( est ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " =?UTF-8?Q?1+1 =3D 2?= " , encoded , " Basic Q encoding test " ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > qcodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " 1+1 = 2 " , plain , " Basic Q decoding test " ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > qcodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; 
public void estEncodeDecodeBlanks ( ) hrows Exception { final String plain = " Mind those pesky blanks " ; final String encoded1 = " =?UTF-8?Q?Mind those pesky blanks?= " ; final String encoded2 = " =?UTF-8?Q?Mind_those_pesky_blanks?= " ; final QCodec qcodec = new QCodec ( ) ; qcodec . setEncodeBlanks ( false ) ; String s = qcodec . encode ( plain ) ; assertEquals ( encoded1 , s , " Blanks encoding with the Q codec test " ) ; qcodec . setEncodeBlanks ( rue ) ; s = qcodec . encode ( plain ) ; assertEquals ( encoded2 , s , " Blanks encoding with the Q codec test " ) ; s = qcodec . decode ( encoded1 ) ; assertEquals ( plain , s , " Blanks decoding with the Q codec test " ) ; s = qcodec . decode ( encoded2 ) ; assertEquals ( plain , s , " Blanks decoding with the Q codec test " ) ; } 
public void estBasicEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " = Hello there = r " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( " =3D Hello there =3D=0D=0A " , encoded , " Basic quoted-printable encoding test " ) ; assertEquals ( plain , qpcodec . decode ( encoded ) , " Basic quoted-printable decoding test " ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " abc123_-.*~!@#$%^&()+{} \" \\ ;:`,/[] " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( plain , encoded , " Safe chars quoted-printable encoding test " ) ; assertEquals ( plain , qpcodec . decode ( encoded ) , " Safe chars quoted-printable decoding test " ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " = r " ; final String encoded = qpcodec . encode ( plain ) ; assertEquals ( " =3D=0D=0A " , encoded , " Unsafe chars quoted-printable encoding test " ) ; assertEquals ( plain , qpcodec . decode ( encoded ) , " Unsafe chars quoted-printable decoding test " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertNull ( qpcodec . encode ( ( String ) null ) , " Null string quoted-printable encoding test " ) ; assertNull ( qpcodec . decode ( ( String ) null ) , " Null string quoted-printable decoding test " ) ; } 
public void estDecodeInvalid ( ) { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " = " ) ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " =A " ) ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( " =WW " ) ) ; } 
public void estEncodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = qpcodec . encode ( plain ) ; assertNull ( encoded , " Encoding a null string should return null " ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; assertEquals ( plain , qpcodec . decode ( encoded ) , " Basic quoted-printable decoding test " ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = QuotedPrintableCodec . decodeQuotedPrintable ( plain ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . decode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > qpcodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " 1+1 = 2 " , decoded , " Basic quoted-printable decoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " 1+1 = 2 " , decoded , " Basic quoted-printable decoding test " ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; 
public void estBasicEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Basic URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " abc123_-.* " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( plain , encoded , " Safe chars URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Safe chars URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded , " Unsafe chars URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Unsafe chars URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertNull ( urlCodec . encode ( ( String ) null ) , " Null string URL encoding test " ) ; assertNull ( urlCodec . decode ( ( String ) null ) , " Null string URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeInvalid ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " % " ) ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " %A " ) ) ; Bad 1st char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%WW")); Bad 2nd char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%0W")); this.validateState(urlCodec); } 
public void estEncodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = urlCodec . encode ( plain ) ; assertNull ( encoded , " Encoding a null string should return null " ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Basic URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = URLCodec . decodeUrl ( plain ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . decode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; his . validateState ( urlCodec ) ; } 
public void estInvalidEncoding ( ) { final URLCodec urlCodec = new URLCodec ( " NONSENSE " ) ; final String plain = " Hello there! " ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( plain ) , " We set the encoding to a bogus NONSENSE value " ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( plain ) , " We set the encoding to a bogus NONSENSE value " ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; his . validateState ( urlCodec ) ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) { if ( BinaryCodec . isEmpty ( binaryData ) ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); final long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
public byte [ ] decode ( final byte [ ] pArray ) { if ( BinaryCodec . isEmpty ( pArray ) ) { return pArray ; } final Context context = new Context ( ) ; decode ( pArray , 0 , pArray . length , context ) ; decode ( pArray , 0 , EOF , context ) ; Notify decoder of EOF. final byte[] result = new byte[context.pos]; readResults(result, 0, result.length, context); return result; } 
public byte [ ] encode ( final byte [ ] pArray ) { if ( BinaryCodec . isEmpty ( pArray ) ) { return pArray ; } return encode ( pArray , 0 , pArray . length ) ; } 
public byte [ ] encode ( final byte [ ] pArray , final int offset , final int length ) { if ( BinaryCodec . isEmpty ( pArray ) ) { return pArray ; } final Context context = new Context ( ) ; encode ( pArray , offset , length , context ) ; encode ( pArray , offset , EOF , context ) ; Notify encoder of EOF. final byte[] buf = new byte[context.pos - context.readPos]; readResults(buf, 0, buf.length, context); return buf; } 
static boolean isEmpty ( final byte [ ] array ) { return array = = null | | array . length = = 0 ; } 
public String encode ( final String source ) { String xt = source ; if ( SoundexUtils . isEmpty ( xt ) ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replace("cq", "2q"); txt = txt.replace("ci", "si"); txt = txt.replace("ce", "se"); txt = txt.replace("cy", "sy"); txt = txt.replace("tch", "2ch"); txt = txt.replace("c", "k"); txt = txt.replace("q", "k"); txt = txt.replace("x", "k"); txt = txt.replace("v", "f"); txt = txt.replace("dg", "2g"); txt = txt.replace("tio", "sio"); txt = txt.replace("tia", "sia"); txt = txt.replace("d", "t"); txt = txt.replace("ph", "fh"); txt = txt.replace("b", "p"); txt = txt.replace("sh", "s2"); txt = txt.replace("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replace("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replace("y", "3"); 2.0 only txt = txt.replace("3gh3", "3kh3"); txt = txt.replace("gh", "22"); txt = txt.replace("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replace("w3", "W3"); txt = txt.replace("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replace("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replace("h", "2"); txt = txt.replace("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replace("r", "2"); txt = txt.replace("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replace("l", "2"); 5. Handle removals txt = txt.replace("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replace("3", ""); 6. put ten 1s on the end txt = txt + TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
static String clean ( final String str ) { if ( isEmpty ( str ) ) { return str ; } final int len = str . length ( ) ; final char [ ] chars = new char [ len ] ; int count = 0 ; for ( int i = 0 ; i < len ; i + + ) { if ( Character . isLetter ( str . charAt ( i ) ) ) { chars [ count + + ] = str . charAt ( i ) ; } } if ( count = = len ) { return str . oUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . oUpperCase ( java . util . Locale . ENGLISH ) ; } 
static boolean isEmpty ( final CharSequence cs ) { return cs = = null | | cs . length ( ) = = 0 ; } 
private static int createPositiveCapacity ( final int minCapacity ) { if ( minCapacity < 0 ) { overflow throw new OutOfMemoryError("Unable to allocate array size: " + (minCapacity & 0xffffffffL)); } This is called when we require buffer expansion to a very big array. Use the conservative maximum buffer size if possible, otherwise the biggest required. Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE. This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full Integer.MAX_VALUE length array. The result is that we may have to allocate an array of this size more than once if the capacity must be expanded again. return Math.max(minCapacity, MAX_BUFFER_SIZE); } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. final String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
private boolean isSlavoGermanic ( final String value ) { return value . indexOf ( 'W' ) > - 1 | | value . indexOf ( 'K' ) > - 1 | | value . contains ( " CZ " ) | | value . contains ( " WITZ " ) ; 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.length() >= 2 && input.startsWith("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.startsWith("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: for (final String aWord : words) { final String[] parts = aWord.split("'"); final String lastPart = parts[parts.length - 1]; words2.add(lastPart); } words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); for (final String word : words2) { result.append("-").append(encode(word)); } return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public void estByteToStringVariations ( ) { final Base16 base16 = new Base16 ( ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; assertEquals ( " 48656C6C6F20576F726C64 " , base16 . encodeToString ( b1 ) , " byteToString Hello World " ) ; assertEquals ( " 48656C6C6F20576F726C64 " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b1 ) ) , " byteToString static Hello World " ) ; assertEquals ( " " , base16 . encodeToString ( b2 ) , " byteToString \" \" " ) ; assertEquals ( " " , StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b2 ) ) , " byteToString static \" \" " ) ; assertNull ( base16 . encodeToString ( b3 ) , " byteToString null " ) ; assertNull ( StringUtils . newStringUtf8 ( new Base16 ( ) . encode ( b3 ) ) , " byteToString static null " ) ; } 
public void estEncodeDecodeHexCharArrayRandomToOutput ( ) hrows DecoderException { for ( int i = 5 ; i > 0 ; i - - ) { final byte [ ] data = new byte [ ThreadLocalRandom . current ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estHmacFailInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacHexFailInputStream ( HmacAlgorithms hmacAlgorithm , byte [ ] standardResultBytes , String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estLongestEnglishSurname ( ) { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; assertTimeout ( Duration . ofMillis ( 10000L ) , ( ) - > bmpm . encode ( " MacGhilleseatheanaich " ) ) ; } 
public void estBase64ImpossibleSamplesStrict ( ) { final BCodec codec = new BCodec ( StandardCharsets . UTF_8 , CodecPolicy . STRICT ) ; assertTrue ( codec . isStrictDecoding ( ) ) ; for ( final String s : BASE64_IMPOSSIBLE_CASES ) { assertThrows ( DecoderException . class , ( ) - > codec . decode ( s ) ) ; 
public void estDecodeInvalidContent ( ) hrows DecoderException { final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] input = ch_msg . getBytes ( StandardCharsets . ISO_8859_1 ) ; final byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } his . validateState ( urlCodec ) ; } 
public void estRfc2045Section2Dot1CrLfDefinition ( ) { assertArrayEquals ( new byte [ ] { 13 , 10 } , BaseNCodec . CHUNK_SEPARATOR ) ; } 
public void estRfc4648Section10DecodeWithCrLf ( ) { final String CRLF = StringUtils . newStringUsAscii ( BaseNCodec . CHUNK_SEPARATOR ) ; assertEquals ( " " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " " + CRLF ) ) ) ; assertEquals ( " f " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zg== " + CRLF ) ) ) ; assertEquals ( " fo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm8= " + CRLF ) ) ) ; assertEquals ( " foo " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9v " + CRLF ) ) ) ; assertEquals ( " foob " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYg== " + CRLF ) ) ) ; assertEquals ( " fooba " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmE= " + CRLF ) ) ) ; assertEquals ( " foobar " , StringUtils . newStringUsAscii ( Base64 . decodeBase64 ( " Zm9vYmFy " + CRLF ) ) ) ; } 
public void estBase16OutputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByChunk(encoded, decoded); test random data of sizes 0 thru 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { out.write(decoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base16 encode"); } Now let's try decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { out.write(encoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base16 decode"); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked Base32 encode"); Now let's try decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc etc). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, byteOut.toByteArray(), "Streaming chunked Base32 wrap-wrap-wrap!"); } 
public void hashArbitraryOutputLength ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; hasher . update ( inputByteArray ) ; final byte [ ] actual = hasher . doFinalize ( hashByteArray . length ) ; assertArrayEquals ( hashByteArray , actual ) ; } 
public void hashTruncatedOutput ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = Blake3 . hash ( inputByteArray ) ; assertArrayEquals ( Arrays . copyOf ( his . hashByteArray , 32 ) , actual ) ; } 
public void keyedHashArbitraryOutputLength ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; keyedHasher . update ( inputByteArray ) ; final byte [ ] actual = keyedHasher . doFinalize ( keyedHashByteArray . length ) ; assertArrayEquals ( keyedHashByteArray , actual ) ; } 
public void keyedHashTruncatedOutput ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = Blake3 . keyedHash ( KEY , inputByteArray ) ; assertArrayEquals ( Arrays . copyOf ( keyedHashByteArray , 32 ) , actual ) ; } 
public void keyDerivation ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; kdfHasher . update ( inputByteArray ) ; final byte [ ] actual = kdfHasher . doFinalize ( deriveKeyByteArray . length ) ; assertArrayEquals ( deriveKeyByteArray , actual ) ; kdfHasher . reset ( ) ; kdfHasher . update ( inputByteArray ) ; final byte [ ] runcated = kdfHasher . doFinalize ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKeyByteArray , 32 ) , runcated ) ; } 
public void estAlgorithm ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows NoSuchAlgorithmException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; final String algorithm = hmacAlgorithm . getName ( ) ; assertNotNull ( algorithm ) ; assertFalse ( algorithm . isEmpty ( ) ) ; assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estGetHmacEmptyKey ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , EMPTY_BYTE_ARRAY ) ) ; } 
public void estGetHmacNullKey ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > HmacUtils . getInitializedMac ( hmacAlgorithm , null ) ) ; } 
public void estHmacFailByteArray ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacFailInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacFailString ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estHmacHexFailByteArray ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacHexFailInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( byte [ ] ) null ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estHmacHexFailString ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > new HmacUtils ( hmacAlgorithm , ( String ) null ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
public void estInitializedMac ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; final Mac mac = HmacUtils . getInitializedMac ( hmacAlgorithm , STANDARD_KEY_BYTES ) ; final Mac mac2 = HmacUtils . getInitializedMac ( hmacAlgorithm . getName ( ) , STANDARD_KEY_BYTES ) ; assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; assertArrayEquals ( standardResultBytes , HmacUtils . updateHmac ( mac2 , STANDARD_PHRASE_STRING ) . doFinal ( ) ) ; } 
public void estMacByteArary ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexByteArray ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estMacHexInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacHexString ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( STANDARD_PHRASE_STRING ) ) ; } 
public void estMacInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; 
public void estMacString ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_STRING ) ) ; } 
private byte [ ] digestTestData ( final String messageDigestAlgorithm ) { return DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ; } 
public void estAlgorithm ( final String messageDigestAlgorithm ) hrows NoSuchAlgorithmException { final String algorithm = messageDigestAlgorithm ; assertNotNull ( algorithm ) ; assertFalse ( algorithm . isEmpty ( ) ) ; assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; MessageDigest . getInstance ( algorithm ) ; } 
public void estDigestByteArray ( final String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; } 
public void estDigestByteBuffer ( final String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; } 
public void estDigestFile ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; 
public void estDigestInputStream ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; } 
private void estDigestPath ( final String messageDigestAlgorithm , final OpenOption . . . options ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; 
public void estDigestPathOpenOptionsEmpty ( final String messageDigestAlgorithm ) hrows IOException { estDigestPath ( messageDigestAlgorithm ) ; } 
public void estDigestPathStandardOpenOptionRead ( final String messageDigestAlgorithm ) hrows IOException { estDigestPath ( messageDigestAlgorithm , StandardOpenOption . READ ) ; } 
public void estGetMessageDigest ( final String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final MessageDigest messageDigest = DigestUtils . getDigest ( messageDigestAlgorithm ) ; assertEquals ( messageDigestAlgorithm , messageDigest . getAlgorithm ( ) ) ; } 
public void estNonBlockingDigestRandomAccessFile ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final byte [ ] expected = digestTestData ( messageDigestAlgorithm ) ; assertArrayEquals ( expected , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestRandomAccessFile ( ) ) ) ; getTestRandomAccessFile ( ) . seek ( 0 ) ; assertArrayEquals ( expected , DigestUtils . digest ( 
public void verifyChecksum ( final String path , final String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } assertEquals ( expectedChecksum , Long . oHexString ( h . getValue ( ) ) , " checksum for " + file . getName ( ) ) ; } 
public void verifyIncrementalChecksum ( final String path , final String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( final FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; Hit the case where the hash should be reset h.update(b[0]); h.reset(); Pass in chunks h.update(b[0]); h.update(b, 1, b.length - 2); h.update(b, b.length - 1, 1); Check the hash ignores negative length h.update(b, 0, -1); } assertEquals(expectedChecksum, Long.toHexString(h.getValue()), "checksum for " + file.getName()); } 
public void estLanguageGuessing ( final String name , final String language ) { final Languages . LanguageSet guesses = his . lang . guessLanguages ( name ) ; assertTrue ( guesses . contains ( language ) , " language predicted for name ' " + name + " ' is wrong: " + guesses + " should contain ' " + language + " ' " ) ; 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final int end = offset + dataLen; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = (context.ibitWorkArea - 1) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte)result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } final int loopEnd = end - 1; while (offset < loopEnd) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (offset < end) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
public void estOddEvenDecoding ( ) { final String encoded = " 4142434445 " ; final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; final Base16 base16 = new Base16 ( ) ; final byte [ ] encodedBytes = StringUtils . getBytesUtf8 ( encoded ) ; pass odd, then even, then odd amount of data base16.decode(encodedBytes, 0, 3, context); base16.decode(encodedBytes, 3, 4, context); base16.decode(encodedBytes, 7, 3, context); final byte[] decodedBytes = new byte[context.pos]; System.arraycopy(context.buffer, context.readPos, decodedBytes, 0, decodedBytes.length); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("ABCDE", decoded); } 
private static String join ( final List < String > strings , final String sep ) { return strings . stream ( ) . collect ( Collectors . joining ( sep ) ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. final String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public boolean isEncodeEquals ( String name1 , String name2 ) { Bulletproof for trivial input - NINO if (name1 == null || EMPTY.equalsIgnoreCase(name1) || SPACE.equalsIgnoreCase(name1)) { return false; } if (name2 == null || EMPTY.equalsIgnoreCase(name2) || SPACE.equalsIgnoreCase(name2)) { return false; } if (name1.length() == 1 || name2.length() == 1) { return false; } if (name1.equalsIgnoreCase(name2)) { return true; } Preprocessing name1 = cleanName(name1); name2 = cleanName(name2); Actual MRA Algorithm 1. Remove vowels name1 = removeVowels(name1); name2 = removeVowels(name2); 2. Remove double consonants name1 = removeDoubleConsonants(name1); name2 = removeDoubleConsonants(name2); 3. Reduce down to 3 letters name1 = getFirst3Last3(name1); name2 = getFirst3Last3(name2); 4. Check for length difference - if 3 or greater, then no similarity comparison is done if (Math.abs(name1.length() - name2.length()) >= 3) { return false; } 5. Obtain the minimum rating value by calculating the length sum of the encoded Strings and sending it down. final int sumLength = Math.abs(name1.length() + name2.length()); final int minRating = getMinRating(sumLength); 6. Process the encoded Strings from left to right and remove any identical characters found from both Strings respectively. final int count = leftToRightThenRightToLeftProcessing(name1, name2); 7. Each PNI item that has a similarity rating equal to or greater than the min is considered to be a good candidate match return count >= minRating; 
int leftToRightThenRightToLeftProcessing ( final String name1 , final String name2 ) { final char [ ] name1Char = name1 . oCharArray ( ) ; final char [ ] name2Char = name2 . oCharArray ( ) ; final int name1Size = name1 . length ( ) - 1 ; final int name2Size = name2 . length ( ) - 1 ; String name1LtRStart = EMPTY ; String name1LtREnd = EMPTY ; String name2RtLStart = EMPTY ; String name2RtLEnd = EMPTY ; for ( int i = 0 ; i < name1Char . length ; i + + ) { if ( i > name2Size ) { break ; } name1LtRStart = name1 . substring ( i , i + 1 ) ; name1LtREnd = name1 . substring ( name1Size - i , name1Size - i + 1 ) ; name2RtLStart = name2 . substring ( i , i + 1 ) ; name2RtLEnd = name2 . substring ( name2Size - i , name2Size - i + 1 ) ; Left to right... if (name1LtRStart.equals(name2RtLStart)) { name1Char[i] = ' '; name2Char[i] = ' '; } Right to left... if (name1LtREnd.equals(name2RtLEnd)) { name1Char[name1Size - i] = ' '; name2Char[name2Size - i] = ' '; } } Char arrays -> string & remove extraneous space final String strA = new String(name1Char).replaceAll("\\s+", EMPTY); final String strB = new String(name2Char).replaceAll("\\s+", EMPTY); Final bit - subtract the longest string from 6 and return this int value if (strA.length() > strB.length()) { return Math.abs(6 - strA.length()); } return Math.abs(6 - strB.length()); } 
public void estBase16InputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByChunk(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded); test random data of sizes 0 through 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase16InputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[] { (byte) 0x41 }; testByteByByte(encoded, decoded); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base16TestData.ENCODED_UTF8_UPPERCASE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded); test random data of sizes 0 through 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try to decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try to decode. try (final InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (final InputStream in = new ByteArrayInputStream(decoded); final InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
public void estBase16OutputStreamByChunk ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByChunk(encoded, decoded); test random data of sizes 0 through 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase16OutputStreamByteByByte ( ) hrows IOException { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("48656C6C6F20576F726C64"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded); Single Byte test. encoded = StringUtils.getBytesUtf8("41"); decoded = new byte[]{(byte) 0x41}; testByteByByte(encoded, decoded); test random data of sizes 0 through 150 final BaseNCodec codec = new Base16(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { out.write(decoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base16 encode"); } Now let's try to decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { out.write(encoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base16 decode"); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { for (final byte element : decoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base16 encode"); } Now let's try to decode. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base16 decode"); } Now let's try to decode with tonnes of flushes. try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); out.flush(); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base16 decode"); } wrap encoder with decoder try (final ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); final OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
public void estBase32InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase32InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA======\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base32 encode"); Now let's try to decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 decode"); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 wrap-wrap-wrap!"); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base32 encode"); in.close(); Now let's try to decode. in = new Base32InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 decode"); in.close(); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 wrap-wrap-wrap!"); } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked Base32 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, byteOut.toByteArray(), "Streaming chunked Base32 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte Base32 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 decode"); Now let's try to decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base32OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 wrap-wrap-wrap!"); } 
public void estBase64InputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64InputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[] { (byte) 0 }; testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); in.close(); Now let's try to decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. InputStream in; in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator); byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); in.close(); Now let's try to decode. in = new Base64InputStream(new ByteArrayInputStream(encoded)); output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); in.close(); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
public void estBase64OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, BaseNCodec.PEM_CHUNK_SIZE, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase64OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r"); byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CR_LF); OpenSSL interop test. encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 64, LF); Single Line test. final String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replace("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = BaseNTestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base64(0, null, false); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); out.write(decoded); out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base64 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); out.write(encoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator); for (final byte element : decoded) { out.write(element); } out.close(); byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base64 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 decode"); Now let's try to decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); out = new Base64OutputStream(byteOut, false); for (final byte element : encoded) { out.write(element); out.flush(); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 wrap-wrap-wrap!"); } 
public void estUrlSafe ( ) { test random data of sizes 0 through 150 final BaseNCodec codec = new Base64(true); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estCodec265 ( ) { 1GiB file to encode: 2^30 bytes final int size1GiB = 1 << 30; Expecting a size of 4 output bytes per 3 input bytes plus the trailing bytes padded to a block size of 4. final int blocks = (int) Math.ceil(size1GiB / 3.0); final int expectedLength = 4 * blocks; This test is memory hungry. Check we can run it. final long presumableFreeMemory = BaseNCodecTest.getPresumableFreeMemory(); Estimate the maximum memory required: 1GiB + 1GiB + ~2GiB + ~1.33GiB + 32 KiB = ~5.33GiB 1GiB: Input buffer to encode 1GiB: Existing working buffer (due to doubling of default buffer size of 8192) ~2GiB: New working buffer to allocate (due to doubling) ~1.33GiB: Expected output size (since the working buffer is copied at the end) 32KiB: Some headroom final long estimatedMemory = (long) size1GiB * 4 + expectedLength + 32 * 1024; Assumptions.assumeTrue(presumableFreeMemory > estimatedMemory, "Not enough free memory for the test"); final byte[] bytes = new byte[size1GiB]; final byte[] encoded = Base64.encodeBase64(bytes); assertEquals(expectedLength, encoded.length); } 
private static void assertEnsureBufferSizeExpandsToMaxBufferSize ( final boolean exceedMaxBufferSize ) { This test is memory hungry. By default expansion will double the buffer size. Using a buffer that must be doubled to get close to 2GiB requires at least 3GiB of memory for the test (1GiB existing + 2GiB new). As a compromise we use an empty buffer and rely on the expansion switching to the minimum required capacity if doubling is not enough. To effectively use a full buffer of ~1GiB change the following for: 1 << 30. Setting to zero has the lowest memory footprint for this test. final int length = 0; final long presumableFreeMemory = getPresumableFreeMemory(); 2GiB + 32 KiB + length 2GiB: Buffer to allocate 32KiB: Some headroom length: Existing buffer final long estimatedMemory = (1L << 31) + 32 * 1024 + length; assumeTrue(presumableFreeMemory > estimatedMemory, "Not enough free memory for the test"); final int max = Integer.MAX_VALUE - 8; Check the conservative maximum buffer size can actually be exceeded by the VM otherwise the test is not valid. if (exceedMaxBufferSize) { assumeCanAllocateBufferSize(max + 1); Free-memory. This may not be necessary as the byte[] is now out of scope System.gc(); } final BaseNCodec ncodec = new NoOpBaseNCodec(); final Context context = new Context(); Allocate the initial buffer context.buffer = new byte[length]; context.pos = length; Compute the extra to reach or exceed the max buffer size int extra = max - length; if (exceedMaxBufferSize) { extra++; } ncodec.ensureBufferSize(extra, context); assertTrue(context.buffer.length >= length + extra); } 
public void estMacByteArray ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( STANDARD_PHRASE_BYTES ) ) ; } 
public void estHmacSha1UpdateWithInputStream ( ) hrows IOException { final Mac mac = HmacUtils . getHmacSha1 ( HmacAlgorithmsTest . STANDARD_KEY_BYTES ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( HmacAlgorithmsTest . STANDARD_PHRASE_BYTES ) ) ; assertEquals ( HmacAlgorithmsTest . STANDARD_SHA1_RESULT_STRING , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; HmacUtils . updateHmac ( mac , new ByteArrayInputStream ( " " . getBytes ( ) ) ) ; assertEquals ( " f42bb0eeb018ebbd4597ae7213711ec60760843f " , Hex . encodeHexString ( mac . doFinal ( ) ) ) ; } 
public void estSecretKeySpecAllowsEmptyKeys ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > new SecretKeySpec ( new byte [ ] { } , " HmacMD5 " ) ) ; } 
String [ ] oStrings ( final String nameFormat ) { final String [ ] s = new String [ ables . length ] ; for ( int j = 0 ; j < ables . length ; j + + ) { final int [ ] = ables [ j ] ; final StringBuilder b = new StringBuilder ( ) ; b . append ( String . format ( " " , j ) ) ; for ( int i = 0 ; i < . length ; ) { b . append ( " n " ) ; for ( int k = 0 ; k < 4 ; k + + ) { b . append ( String . format ( " 0x%08X, " , [ i + + ] ) ) ; } } s [ j ] = b . oString ( ) ; } return s ; } 
public void estSha256LargestThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8 " , Sha2Crypt . sha256Crypt ( buffer , " $5$abc " ) ) ; } 
public void estUnixCryptInvalidSalt ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > UnixCrypt . crypt ( " secret " , " $a " ) ) ; } 
private static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) hrows IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int = 0 ; long count = 0 ; while ( - 1 ! = ( = input . read ( buffer ) ) ) { output . write ( buffer , 0 , ) ; count + = ; } return count ; } 
public final void estLeftToRightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " ALEXANDER " , " ALEXANDRA " ) ) ; } 
public final void estLeftToRightThenRightToLeft_EINSTEIN_MICHAELA_Returns0 ( ) { assertEquals ( 0 , his . getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " EINSTEIN " , " MICHAELA " ) ) ; } 
public final void estIsVowel_SingleVowel_ReturnsTrue ( ) { assertTrue ( his . getStringEncoder ( ) . isVowel ( ( " I " ) ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , null ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( null , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEqualsSecondNameJust1Letter_ReturnsFalse ( ) { assertFalse ( his . getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public void estExceedLength ( ) { should be AKSKS, but is truncated by Max Code Length assertEquals( "AKSK", this.getStringEncoder().metaphone("AXEAXE") ); } 
public void estNullInput ( ) hrows Exception { final RFC1522TestCodec estCodec = new RFC1522TestCodec ( ) ; assertNull ( estCodec . decodeText ( null ) ) ; assertNull ( estCodec . encodeText ( null , CharEncoding . UTF_8 ) ) ; } 
public Languages . LanguageSet guessLanguages ( final String input ) { final String ext = input . oLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet < > ( his . languages . getLanguages ( ) ) ; his . rules . forEach ( rule - > { if ( rule . matches ( ext ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } } ) ; final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; } 
public LanguageSet restrictTo ( final LanguageSet other ) { if ( other = = NO_LANGUAGES ) { return other ; } if ( other = = ANY_LANGUAGE ) { return his ; } final SomeLanguages someLanguages = ( SomeLanguages ) other ; return from ( languages . stream ( ) . filter ( lang - > someLanguages . languages . contains ( lang ) ) . collect ( Collectors . oSet ( ) ) ) ; } 
public void append ( final CharSequence str ) { phonemes . forEach ( ph - > ph . append ( str ) ) ; } 
public String makeString ( ) { return phonemes . stream ( ) . map ( Rule . Phoneme : : getPhonemeText ) . collect ( Collectors . joining ( " | " ) ) ; } 
private PhonemeBuilder applyFinalRules ( final PhonemeBuilder phonemeBuilder , final Map < String , List < Rule > > finalRules ) { Objects . requireNonNull ( finalRules , " finalRules " ) ; if ( finalRules . isEmpty ( ) ) { return phonemeBuilder ; } final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap < > ( Rule . Phoneme . COMPARATOR ) ; phonemeBuilder . getPhonemes ( ) . forEach ( phoneme - > { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; final String phonemeText = phoneme . getPhonemeText ( ) . oString ( ) ; for ( int i = 0 ; i < phonemeText . length ( ) ; ) { final RulesApplication rulesApplication = new RulesApplication ( finalRules , phonemeText , subBuilder , i , maxPhonemes ) . invoke ( ) ; final boolean found = rulesApplication . isFound ( ) ; subBuilder = rulesApplication . getPhonemeBuilder ( ) ; if ( ! found ) { not found, appending as-is subBuilder.append(phonemeText.subSequence(i, i + 1)); } i = rulesApplication.getI(); } the phonemes map orders the phonemes only based on their text, but ignores the language set when adding new phonemes, check for equal phonemes and merge their language set, otherwise phonemes with the same text but different language set get lost subBuilder.getPhonemes().forEach(newPhoneme -> { if (phonemes.containsKey(newPhoneme)) { final Rule.Phoneme oldPhoneme = phonemes.remove(newPhoneme); final Rule.Phoneme mergedPhoneme = oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages()); phonemes.put(mergedPhoneme, mergedPhoneme); } else { phonemes.put(newPhoneme, newPhoneme); } }); }); return new PhonemeBuilder(phonemes.keySet()); } 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.startsWith("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: words.forEach(aWord -> { final String[] parts = aWord.split("'"); words2.add(parts[parts.length - 1]); }); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); words2.forEach(word -> result.append("-").append(encode(word))); return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static List < Rule > getInstance ( final NameType nameType , final RuleType rt , final Languages . LanguageSet langs ) { final Map < String , List < Rule > > ruleMap = getInstanceMap ( nameType , rt , langs ) ; final List < Rule > allRules = new ArrayList < > ( ) ; ruleMap . values ( ) . forEach ( rules - > allRules . addAll ( rules ) ) ; return allRules ; } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = input [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS); buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
public static byte [ ] fromAscii ( final byte [ ] ascii ) { if ( isEmpty ( ascii ) ) { return EMPTY_BYTE_ARRAY ; } final int asciiLength = ascii . length ; get length/8 times bytes with 3 bit shifts to the right of the length final byte[] raw = new byte[asciiLength >> 3]; for (int ii = 0, jj = asciiLength - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { raw[ii] |= BITS[bits]; } } } return raw; } 
public static byte [ ] fromAscii ( final char [ ] ascii ) { if ( ascii = = null | | ascii . length = = 0 ) { return EMPTY_BYTE_ARRAY ; } final int asciiLength = ascii . length ; get length/8 times bytes with 3 bit shifts to the right of the length final byte[] raw = new byte[asciiLength >> 3]; for (int ii = 0, jj = asciiLength - 1; ii < raw.length; ii++, jj -= 8) { for (int bits = 0; bits < BITS.length; ++bits) { if (ascii[jj - bits] == '1') { raw[ii] |= BITS[bits]; } } } return raw; } 
public void update ( final byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = ( T [ T8_7_START + c0 ] ^ T [ T8_6_START + c1 ] ) ^ ( T [ T8_5_START + c2 ] ^ T [ T8_4_START + c3 ] ) ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = ( T [ T8_3_START + c4 ] ^ T [ T8_2_START + c5 ] ) ^ ( T [ T8_1_START + c6 ] ^ T [ T8_0_START + c7 ] ) ; off + = 8 ; len - = 8 ; } switch ( len ) { case 7 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 6 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 5 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 4 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 3 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 2 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 1 : localCrc = ( localCrc > > > 8 ) ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; default : break ; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = ( crc > > > 8 ) ^ T [ T8_0_START + ( ( crc ^ b ) & 0xff ) ] ; } 
public static Lang instance ( final NameType nameType ) { return LANGS . get ( nameType ) ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; estList . sort ( sCompare ) ; unchecked final String[] resultArray = testList.toArray(ArrayUtils.EMPTY_STRING_ARRAY); for (int i = 0; i < resultArray.length; i++) { assertEquals(controlArray[i], resultArray[i], 
private String cleanup ( final String input ) { final StringBuilder sb = new StringBuilder ( ) ; for ( char ch : input . oCharArray ( ) ) { if ( Character . isWhitespace ( ch ) ) { continue ; } ch = Character . oLowerCase ( ch ) ; final Character character = FOLDINGS . get ( ch ) ; if ( folding & & character ! = null ) { ch = character ; } sb . append ( ch ) ; } return sb . oString ( ) ; } 
private static byte [ ] resizeBuffer ( final Context context , final int minCapacity ) { Overflow-conscious code treats the min and new capacity as unsigned. final int oldCapacity = context.buffer.length; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR; if (compareUnsigned(newCapacity, minCapacity) < 0) { newCapacity = minCapacity; } if (compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) { newCapacity = createPositiveCapacity(minCapacity); } final byte[] b = Arrays.copyOf(context.buffer, newCapacity); context.buffer = b; return b; } 
protected char [ ] copyData ( final int start , final int length ) { return Arrays . copyOfRange ( data , start , length ) ; } 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final OutputStream fos = Files . newOutputStream ( estFile ) ) { fos . write ( estData ) ; } estRandomAccessFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final OutputStream fos = Files . newOutputStream ( estRandomAccessFile ) ) { fos . write ( estData ) ; } estRandomAccessFileWrapper = new RandomAccessFile ( estRandomAccessFile . oFile ( ) , " rw " ) ; } 
public void earDown ( ) hrows IOException { if ( estRandomAccessFileWrapper ! = null ) { estRandomAccessFileWrapper . close ( ) ; } Files . deleteIfExists ( estFile ) ; Files . deleteIfExists ( estRandomAccessFile ) ; } 
private static boolean contains ( final CharSequence chars , final char input ) { return chars . chars ( ) . anyMatch ( c - > c = = input ) ; } 
private static int [ ] unpackInts ( final byte [ ] buf , final int nrInts ) { final int [ ] values = new int [ nrInts ] ; for ( int i = 0 , off = 0 ; i < nrInts ; i + + , off + = Integer . BYTES ) { values [ i ] = unpackInt ( buf , off ) ; } return values ; } 
private static byte [ ] resizeBuffer ( final Context context , final int minCapacity ) { Overflow-conscious code treats the min and new capacity as unsigned. final int oldCapacity = context.buffer.length; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR; if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) { newCapacity = minCapacity; } if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) { newCapacity = createPositiveCapacity(minCapacity); } final byte[] b = Arrays.copyOf(context.buffer, newCapacity); context.buffer = b; return b; } 
public static int hash32 ( final long data1 , final long data2 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data1 ) ; final long r1 = Long . reverseBytes ( data2 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) ( r1 ) , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; hash ^ = Long . BYTES * 2 ; return fmix32 ( hash ) ; } 
public static int hash32 ( final long data , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash ^ = Long . BYTES ; return fmix32 ( hash ) ; } 
public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; finalization hash ^= Long.BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & ( - 1L > > > 32 ) ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Integer.BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Short.BYTES; hash = fmix64(hash); return hash; } 
public void estHash32LongLong ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32LongLongSeed ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32Long ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash32LongSeed ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash64WithPrimitives ( ) { As described in the javadoc final int offset = 0; final int seed = 104729; final int iters = 1000; final ByteBuffer shortBuffer = ByteBuffer.allocate(Short.BYTES); final ByteBuffer intBuffer = ByteBuffer.allocate(Integer.BYTES); final ByteBuffer longBuffer = ByteBuffer.allocate(Long.BYTES); final byte[] shortBytes = shortBuffer.array(); final byte[] intBytes = intBuffer.array(); final byte[] longBytes = longBuffer.array(); for (int i = 0; i < iters; ++i) { final long ln = ThreadLocalRandom.current().nextLong(); 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Note: This fails to apply masking using 0xffffffffL to the seed. long hash = seed; final int nblocks = length >> 3; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 3); long k = getLittleEndianLong(data, index); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int index = offset + (nblocks << 3); switch (offset + length - index) { case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= ((long) data[index] & 0xff); k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; hash = fmix64(hash); return hash; } 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
public void eof ( ) { Notify encoder of EOF (-1). if (doEncode) { baseNCodec.encode(singleByte, 0, EOF, context); 
private boolean regionMatch ( final StringBuilder string , final int index , final String est ) { boolean matches = false ; if ( index > = 0 & & index + est . length ( ) - 1 < string . length ( ) ) { final String substring = string . substring ( index , index + est . length ( ) ) ; matches = substring . equals ( est ) ; } return matches ; } 
private int [ ] chainingValue ( ) { return Arrays . copyOf ( compress ( inputChainingValue , blockWords , blockLength , counter , flags ) , CHAINING_VALUE_INTS ) ; 
private void rootOutputBytes ( final byte [ ] out , int offset , int length ) { int outputBlockCounter = 0 ; while ( length > 0 ) { int chunkLength = Math . min ( OUT_LEN * 2 , length ) ; 
private int length ( ) { return BLOCK_LEN * blocksCompressed + blockLength ; } 
private int startFlag ( ) { return blocksCompressed = = 0 ? CHUNK_START : 0 ; } 
private void update ( final byte [ ] input , int offset , int length ) { while ( length > 0 ) { if ( blockLength = = BLOCK_LEN ) { 
private Output output ( ) { final int [ ] blockWords = unpackInts ( block , BLOCK_INTS ) ; final int outputFlags = flags | startFlag ( ) | CHUNK_END ; return new Output ( chainingValue , blockWords , chunkCounter , blockLength , outputFlags ) ; } 
private void inputData ( final byte [ ] in , int offset , int length ) { while ( length > 0 ) { If the current chunk is complete, finalize it and reset the 
private void outputHash ( final byte [ ] out , final int offset , final int length ) { Starting with the Output from the current chunk, compute all the parent chaining values along the right edge of the tree, until we have the root Output. Output output = state.output(); int parentNodesRemaining = stackLen; while (parentNodesRemaining-- > 0) { final int[] parentCV = cvStack[parentNodesRemaining]; output = parentOutput(parentCV, output.chainingValue(), key, flags); } output.rootOutputBytes(out, offset, length); } 
private void reset ( ) { stackLen = 0 ; Arrays . fill ( cvStack , null ) ; state = new ChunkState ( key , 0 , flags ) ; } 
public static boolean isBase64 ( final byte [ ] arrayOctet ) { for ( final byte element : arrayOctet ) { if ( ! isBase64 ( element ) & & ! Character . isWhitespace ( element ) ) { return false ; } } return rue ; } 
protected static boolean isWhiteSpace ( final byte byteToCheck ) { return Character . isWhitespace ( byteToCheck ) ; } 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) & & ( ! allowWSPad | | ( octet ! = pad ) & & ! Character . isWhitespace ( octet ) ) ) { return false ; } } return rue ; } 
public void estIsWhiteSpace ( ) { assertTrue ( Character . isWhitespace ( ( byte ) ' ' ) ) ; assertTrue ( Character . isWhitespace ( ( byte ) '' ) ) ; assertTrue ( Character . isWhitespace ( ( byte ) '\r' ) ) ; assertTrue ( Character . isWhitespace ( ( byte ) '' ) ) ; assertTrue ( Character . isWhitespace ( ( byte ) '\f' ) ) ; assertTrue ( Character . isWhitespace ( ( byte ) '\u000B' ) ) ; for ( byte b = Byte . MIN_VALUE ; b < Byte . MAX_VALUE ; b + + ) { final byte byteToCheck = b ; 
private int handleT ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 4 , " TION " ) | | contains ( value , index , 3 , " TIA " , " TCH " ) ) { result . append ( 'X' ) ; index + = 3 ; } else if ( contains ( value , index , 2 , " TH " ) | | contains ( value , index , 3 , " TTH " ) ) { if ( contains ( value , index + 2 , 2 , " OM " , " AM " ) | | -- special case "thomas", "thames" or germanic -- contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) { result.append('T'); } else { result.append('0', 'T'); } index += 2; } else { result.append('T'); index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1; } return index; } 
public Blake3 update ( final byte [ ] in , final int offset , final int length ) { checkBufferArgs ( in , offset , length ) ; engineState . inputData ( in , offset , length ) ; return his ; } 
public Blake3 doFinalize ( final byte [ ] out ) { return doFinalize ( out , 0 , out . length ) ; } 
public Blake3 doFinalize ( final byte [ ] out , final int offset , final int length ) { checkBufferArgs ( out , offset , length ) ; engineState . outputHash ( out , offset , length ) ; return his ; } 
public static byte [ ] hash ( final byte [ ] data ) { return Blake3 . initHash ( ) . update ( data ) . doFinalize ( OUT_LEN ) ; } 
public static byte [ ] keyedHash ( final byte [ ] key , final byte [ ] data ) { return Blake3 . initKeyedHash ( key ) . update ( data ) . doFinalize ( OUT_LEN ) ; } 
public void hashArbitraryOutputLength ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = hasher . update ( inputByteArray ) . doFinalize ( hashByteArray . length ) ; assertArrayEquals ( hashByteArray , actual ) ; } 
public void keyedHashArbitraryOutputLength ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = keyedHasher . update ( inputByteArray ) . doFinalize ( keyedHashByteArray . length ) ; assertArrayEquals ( keyedHashByteArray , actual ) ; } 
public void keyDerivation ( final int inputLength , final String hash , final String keyedHash , final String deriveKey ) hrows DecoderException { initData ( inputLength , hash , keyedHash , deriveKey ) ; final byte [ ] actual = kdfHasher . update ( inputByteArray ) . doFinalize ( deriveKeyByteArray . length ) ; assertArrayEquals ( deriveKeyByteArray , actual ) ; kdfHasher . reset ( ) . update ( inputByteArray ) ; final byte [ ] runcated = kdfHasher . doFinalize ( 32 ) ; assertArrayEquals ( Arrays . copyOf ( deriveKeyByteArray , 32 ) , runcated ) ; } 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final OutputStream fos = Files . newOutputStream ( estFile ) ) { fos . write ( estData ) ; } estRandomAccessFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( final OutputStream fos = Files . newOutputStream ( estRandomAccessFile ) ) { fos . write ( estData ) ; } estRandomAccessFileWrapper = RandomAccessFileMode . READ_WRITE . create ( estRandomAccessFile ) ; } 
private static String encode ( final Map < String , String > args , final boolean concat , final String input ) { final Languages . LanguageSet languageSet ; final PhoneticEngine engine ; PhoneticEngine = NameType + RuleType + concat we use common-codec's defaults: GENERIC + APPROX + true final String nameTypeArg = args.get("nameType"); final NameType nameType = nameTypeArg == null ? NameType.GENERIC : NameType.valueOf(nameTypeArg); final String ruleTypeArg = args.get("ruleType"); final RuleType ruleType = ruleTypeArg == null ? RuleType.APPROX : RuleType.valueOf(ruleTypeArg); engine = new PhoneticEngine(nameType, ruleType, concat); LanguageSet: defaults to automagic, otherwise a comma-separated list. final String languageSetArg = args.get("languageSet"); if (languageSetArg == null || languageSetArg.equals("auto")) { languageSet = null; } else { languageSet = Languages.LanguageSet.from(new HashSet<>(Arrays.asList(languageSetArg.split(",")))); } if (languageSet == null) { return engine.encode(input); } return engine.encode(input, languageSet); } 
private byte [ ] digestTestData ( final String messageDigestAlgorithm ) { return DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ; } 
public void estDigestByteArray ( final String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestData ( ) ) ) ; } 
public void estDigestInputStream ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , new ByteArrayInputStream ( getTestData ( ) ) ) ) ; 
public void estApr1CryptBytes ( ) { random salt final byte[] keyBytes = { '!', 'b', 'c', '.' }; final String hash = Md5Crypt.apr1Crypt(keyBytes); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estApr1CryptBytesWithThreadLocalRandom ( ) { random salt final byte[] keyBytes = { '!', 'b', 'c', '.' }; final ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current(); final String hash = Md5Crypt.apr1Crypt(keyBytes, threadLocalRandom); assertEquals(hash, Md5Crypt.apr1Crypt("!bc.", hash)); An empty Bytearray equals an empty String assertEquals("$apr1$foo$P27KyD1htb4EllIPEYhqi0", Md5Crypt.apr1Crypt(new byte[0], "$apr1$foo")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("$apr1$./$EeFrYzWWbmTyGdf4xULYc.", Md5Crypt.apr1Crypt("t\u00e4st", "$apr1$./$")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("$apr1$./$kCwT1pY9qXAJElYG9q1QE1", Md5Crypt.apr1Crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$apr1$./$")); } 
public void estMd5CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$1$foo$9mS5ExwgIECGE5YKlD5o91", Crypt.crypt(new byte[0], "$1$foo")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("$1$./$52agTEQZs877L9jyJnCNZ1", Crypt.crypt("t\u00e4st", "$1$./$")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("$1$./$J2UbKzGe0Cpe63WZAt6p", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$1$./$")); } 
public void estSha256CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$5$foo$Fq9CX624QIfnCAmlGiPKLlAasdacKCRxZztPoeo7o0B", Crypt.crypt(new byte[0], "$5$foo")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("$5$./$iH66LwY5sTDTdHeOxq5nvNDVAxuoCcyH/y6Ptte82P8", Crypt.crypt("t\u00e4st", "$5$./$")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("$5$./$qx5gFfCzjuWUOvsDDy.5Nor3UULPIqLVBZhgGNS0c14", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$5$./$")); } 
public void estSha512CryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt(new byte[0], "$6$foo")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("$6$./$fKtWqslQkwI8ZxjdWoeS.jHHrte97bZxiwB5gwCRHX6LG62fUhT6Bb5MRrjWvieh0C/gxh8ItFuTsVy80VrED1", Crypt.crypt("t\u00e4st", "$6$./$")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("$6$./$L49DSK.d2df/LxGLJQMyS5A/Um.TdHqgc46j5FpScEPlqQHP5dEazltaDNDZ6UEs2mmNI6kPwtH/rsP9g5zBI.", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "$6$./$")); } 
public void estUnixCryptBytes ( ) { An empty Bytearray equals an empty String assertEquals("12UFlHxel6uMM", Crypt.crypt(new byte[0], "12")); UTF-8 stores \u00e4 "a with dieresis" as two bytes 0xc3 0xa4. assertEquals("./287bds2PjVw", Crypt.crypt("t\u00e4st", "./")); ISO-8859-1 stores "a with dieresis" as single byte 0xe4. assertEquals("./bLIFNqo9XKQ", Crypt.crypt("t\u00e4st".getBytes(StandardCharsets.ISO_8859_1), "./")); assertEquals("./bLIFNqo9XKQ", Crypt.crypt(new byte[]{(byte) 0x74, (byte) 0xe4, (byte) 0x73, (byte) 0x74}, "./")); } 
public void estSha256LargestThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8 " , Sha2Crypt . sha256Crypt ( buffer , " $5$abc " ) ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd")); } @Test public void testSha2CryptWrongSalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(StandardCharsets.UTF_8), "xx")); } @Test public void testSha512CryptWithEmptySalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(), "")); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); }} 
public void estSha256LargetThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1 " , Sha2Crypt . sha512Crypt ( buffer , " $6$abc " ) ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public void estZeroOutInput ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , ( byte ) 'A' ) ; Md5Crypt . md5Crypt ( buffer ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public void estZeroOutInput ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , ( byte ) 'A' ) ; Sha2Crypt . sha256Crypt ( buffer ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha2CryptRounds() { minimum rounds? assertEquals("$5$rounds=1000$abcd$b8MCU4GEeZIekOy5ahQ8EWfT330hvYGVeDYkBxXBva.", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=50$abcd$")); assertEquals("$5$rounds=1001$abcd$SQsJZs7KXKdd2DtklI3TY3tkD7UYA99RD0FBLm4Sk48", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=1001$abcd$")); assertEquals("$5$rounds=9999$abcd$Rh/8ngVh9oyuS6lL3.fsq.9xbvXJsfyKWxSjO2mPIa7", Sha2Crypt.sha256Crypt("secret".getBytes(StandardCharsets.UTF_8), "$5$rounds=9999$abcd")); } @Test public void testSha2CryptWrongSalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(StandardCharsets.UTF_8), "xx")); } @Test public void testSha512CryptWithEmptySalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(), "")); } @Test public void testSha256LargetThanBlocksize() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, 0, 200, (byte)'A'); assertEquals("$6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1", Sha2Crypt.sha512Crypt(buffer, "$6$abc")); input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } @Test public void testZeroOutInput() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, (byte) 'A'); Sha2Crypt.sha512Crypt(buffer); input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); }} 
public void estZeroOutInput ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , ( byte ) 'A' ) ; Sha2Crypt . sha512Crypt ( buffer ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
protected byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException { return null ; } 
protected byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException { return null ; } 
protected String encodeText ( String ext , Charset charset ) hrows EncoderException { return super . encodeText ( ext , charset ) ; } 
protected String encodeText ( String ext , String charsetName ) hrows EncoderException , UnsupportedEncodingException { return super . encodeText ( ext , charsetName ) ; } 
protected String decodeText ( String ext ) hrows DecoderException , UnsupportedEncodingException { return super . decodeText ( ext ) ; } 
private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
public void estPairs ( ) { assertEquals ( " 0000 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 0 } ) ) ) ; assertEquals ( " 0001 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 1 } ) ) ) ; assertEquals ( " 0002 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 2 } ) ) ) ; assertEquals ( " 0003 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 3 } ) ) ) ; assertEquals ( " 0004 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 4 } ) ) ) ; assertEquals ( " 0005 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 5 } ) ) ) ; assertEquals ( " 0006 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 6 } ) ) ) ; assertEquals ( " 0007 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 7 } ) ) ) ; assertEquals ( " 0008 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 8 } ) ) ) ; assertEquals ( " 0009 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 9 } ) ) ) ; assertEquals ( " 000A " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 10 } ) ) ) ; assertEquals ( " 000B " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 11 } ) ) ) ; assertEquals ( " 000C " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 12 } ) ) ) ; assertEquals ( " 000D " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 13 } ) ) ) ; assertEquals ( " 000E " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 14 } ) ) ) ; assertEquals ( " 000F " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 15 } ) ) ) ; assertEquals ( " 0010 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 16 } ) ) ) ; assertEquals ( " 0011 " , new String ( new Base16 ( ) . encode ( new byte [ ] { ( byte ) 0 , ( byte ) 17 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte [ ] est = { ( byte ) i , ( byte ) i } ; 
public void estPairs ( ) { assertEquals ( " AAA= " , new String ( Base64 . encodeBase64 ( new byte [ ] { 0 , 0 } ) ) ) ; for ( int i = - 128 ; i < = 127 ; i + + ) { final byte [ ] est = { ( byte ) i , ( byte ) i } ; 
public void estEncodeHexPartialInput ( ) { final byte [ ] data = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; char [ ] hex = Hex . encodeHex ( data , 0 , 0 , rue ) ; assertArrayEquals ( new char [ 0 ] , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , rue ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 0 , 1 , false ) ; assertArrayEquals ( " 68 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , rue ) ; assertArrayEquals ( " 6c6c6f20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 2 , 4 , false ) ; assertArrayEquals ( " 6C6C6F20 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , rue ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; hex = Hex . encodeHex ( data , 10 , 1 , false ) ; assertArrayEquals ( " 64 " . oCharArray ( ) , hex ) ; } 
public void estEncodeHexPartialInputUnderbounds ( ) { final byte [ ] data = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; assertThrows ( ArrayIndexOutOfBoundsException . class , ( ) - > Hex . encodeHex ( data , - 2 , 10 , rue ) ) ; } 
public void estEncodeHexPartialInputOverbounds ( ) { final byte [ ] data = " hello world " . getBytes ( StandardCharsets . UTF_8 ) ; assertThrows ( ArrayIndexOutOfBoundsException . class , ( ) - > Hex . encodeHex ( data , 9 , 10 , rue ) ) ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( StandardCharsets . UTF_8 ) , false ) ; final Random random1 = new Random ( ) ; final Random random2 = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i + + ) { final byte [ ] randomBytes = new byte [ random1 . nextInt ( 2048 ) ] ; 
public void estVariationsMella ( ) hrows EncoderException { final String [ ] data = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; his . checkEncodingVariations ( " 65 " , data ) ; } 
public void estVariationsMeyer ( ) hrows EncoderException { final String [ ] data = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
public void estSpecialCharsBetweenSameLetters ( ) hrows EncoderException { final String [ ] data = { " Test test " , " Testtest " , " Test-test " , " TesT#Test " , " TesT?test " } ; his . checkEncodingVariations ( " 28282 " , data ) ; } 
public void estStaticEncode ( ) { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticDecode ( ) { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticEncodeChunked ( ) { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
public void estStaticDecodeChunked ( ) { for ( int i = 0 ; i < STRINGS . length ; i + + ) { if ( STRINGS [ i ] ! = null ) { 
private void assertEncodings ( final String [ ] . . . estValues ) { for ( final String [ ] arr : estValues ) { assertEquals ( arr [ 1 ] , his . fullNysiis . encode ( arr [ 0 ] ) , " Problem with " + arr [ 0 ] ) ; 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. try (InputStream in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator)) { byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); } Now let's try to decode. InputStream in = new Base64InputStream(new ByteArrayInputStream(encoded)); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator)) { out.write(decoded); } byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base64 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base64OutputStream(byteOut, false)) { out.write(encoded); } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); OutputStream out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base64 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, separator)) { for (final byte element : decoded) { out.write(element); } } byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base64 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base64OutputStream(byteOut, false)) { for (final byte element : encoded) { out.write(element); } } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 decode"); Now let's try to decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base64OutputStream(byteOut, false)) { for (final byte element : encoded) { out.write(element); out.flush(); } } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); OutputStream out = byteOut; for (int i = 0; i < 10; i++) { out = new Base64OutputStream(out, false); out = new Base64OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base64 wrap-wrap-wrap!"); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator)) { out.write(decoded); } byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked Base32 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base32OutputStream(byteOut, false)) { out.write(encoded); } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); OutputStream out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } out.write(decoded); out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, byteOut.toByteArray(), "Streaming chunked Base32 wrap-wrap-wrap!"); } 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, separator)) { for (final byte element : decoded) { out.write(element); } } byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte Base32 encode"); Now let's try to decode. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base32OutputStream(byteOut, false)) { for (final byte element : encoded) { out.write(element); } } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 decode"); Now let's try to decode with tonnes of flushes. byteOut = new ByteArrayOutputStream(); try (OutputStream out = new Base32OutputStream(byteOut, false)) { for (final byte element : encoded) { out.write(element); out.flush(); } } output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() Base32 decode"); I always wanted to do this! (wrap encoder with decoder etc.). byteOut = new ByteArrayOutputStream(); OutputStream out = byteOut; for (int i = 0; i < 10; i++) { out = new Base32OutputStream(out, false); out = new Base32OutputStream(out, true, chunkSize, separator); } for (final byte element : decoded) { out.write(element); } out.close(); output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte Base32 wrap-wrap-wrap!"); } 
public void estNonBlockingDigestRandomAccessFile ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; final byte [ ] expected = digestTestData ( messageDigestAlgorithm ) ; @SuppressWarnings ( " resource " ) test manages RAF final RandomAccessFile randomAccessFile = getTestRandomAccessFile(); assertArrayEquals(expected, DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), randomAccessFile)); randomAccessFile.seek(0); assertArrayEquals(expected, DigestUtils.digest(DigestUtils.getDigest(messageDigestAlgorithm), randomAccessFile)); } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final int end = offset + dataLen; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = context.ibitWorkArea - 1 << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte)result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } final int loopEnd = end - 1; while (offset < loopEnd) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte)result; } we have one char of a hex-pair left over if (offset < end) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = input[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) (context.lbitWorkArea >> 32 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 24 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus > 0) { if modulus == 0, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
public static boolean isBase64 ( final byte octet ) { return octet = = PAD_DEFAULT | | octet > = 0 & & octet < DECODE_TABLE . length & & DECODE_TABLE [ octet ] ! = - 1 ; } 
static byte [ ] oIntegerBytes ( final BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; round bitlen bitlen = bitlen + 7 >> 3 << 3; final byte[] bigBytes = bigInt.toByteArray(); if (bigInt.bitLength() % 8 != 0 && bigInt.bitLength() / 8 + 1 == bitlen / 8) { return bigBytes; } set up params for copying everything but sign bit int startSrc = 0; int len = bigBytes.length; if bigInt is exactly byte-aligned, just skip signbit in copy if (bigInt.bitLength() % 8 == 0) { startSrc = 1; len--; } final int startDst = bitlen / 8 - len; to pad w/ nulls as per spec final byte[] resizedBytes = new byte[bitlen / 8]; System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len); return resizedBytes; } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = input [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) (context.ibitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) & & ( ! allowWSPad | | octet ! = pad & & ! Character . isWhitespace ( octet ) ) ) { return false ; } } return rue ; } 
static void b64from24bit ( final byte b2 , final byte b1 , final byte b0 , final int outLen , final StringBuilder buffer ) { The bit masking is necessary because the JVM byte type is signed! int w = b2 << 16 & 0x00ffffff | b1 << 8 & 0x00ffff | b0 & 0xff; It's effectively a "for" loop but kept to resemble the original C code. int n = outLen; while (n-- > 0) { buffer.append(B64T_ARRAY[w & 0x3f]); 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { Initialize the hash to a random value int h = seed ^ length; Mix 4 bytes at a time into the hash final int nblocks = length >> 2; body for (int i = 0; i < nblocks; i++) { final int index = i << 2; int k = getLittleEndianInt(data, index); k *= M32; k ^= k >>> R32; k *= M32; h *= M32; h ^= k; } Handle the last few bytes of the input array final int index = nblocks << 2; switch (length - index) { case 3: h ^= (data[index + 2] & 0xff) << 16; case 2: h ^= (data[index + 1] & 0xff) << 8; case 1: h ^= data[index] & 0xff; h *= M32; } Do a few final mixes of the hash to ensure the last few bytes are well-incorporated. h ^= h >>> 13; h *= M32; h ^= h >>> 15; return h; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { long h = seed & 0xffffffffL ^ length * M64 ; final int nblocks = length > > 3 ; body for (int i = 0; i < nblocks; i++) { final int index = i << 3; long k = getLittleEndianLong(data, index); k *= M64; k ^= k >>> R64; k *= M64; h ^= k; h *= M64; } final int index = nblocks << 3; switch (length - index) { case 7: h ^= ((long) data[index + 6] & 0xff) << 48; case 6: h ^= ((long) data[index + 5] & 0xff) << 40; case 5: h ^= ((long) data[index + 4] & 0xff) << 32; case 4: h ^= ((long) data[index + 3] & 0xff) << 24; case 3: h ^= ((long) data[index + 2] & 0xff) << 16; case 2: h ^= ((long) data[index + 1] & 0xff) << 8; case 1: h ^= (long) data[index] & 0xff; h *= M64; } h ^= h >>> R64; h *= M64; h ^= h >>> R64; return h; } 
public static int hash32 ( final long data1 , final long data2 , final int seed ) { int hash = seed ; final long r0 = Long . reverseBytes ( data1 ) ; final long r1 = Long . reverseBytes ( data2 ) ; hash = mix32 ( ( int ) r0 , hash ) ; hash = mix32 ( ( int ) ( r0 > > > 32 ) , hash ) ; hash = mix32 ( ( int ) r1 , hash ) ; hash = mix32 ( ( int ) ( r1 > > > 32 ) , hash ) ; hash ^ = Long . BYTES * 2 ; return fmix32 ( hash ) ; } 
public static int hash32x86 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } tail final int index = offset + (nblocks << 2); int k1 = 0; switch (offset + length - index) { case 3: k1 ^= (data[index + 2] & 0xff) << 16; case 2: k1 ^= (data[index + 1] & 0xff) << 8; case 1: k1 ^= data[index] & 0xff; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } hash ^= length; return fmix32(hash); } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & - 1L > > > 32 ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Integer.BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Short.BYTES; hash = fmix64(hash); return hash; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Note: This fails to apply masking using 0xffffffffL to the seed. long hash = seed; final int nblocks = length >> 3; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 3); long k = getLittleEndianLong(data, index); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int index = offset + (nblocks << 3); switch (offset + length - index) { case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= (long) data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; hash = fmix64(hash); return hash; } 
private static int fmix32 ( int hash ) { hash ^ = hash > > > 16 ; hash * = 0x85ebca6b ; hash ^ = hash > > > 13 ; hash * = 0xc2b2ae35 ; hash ^ = hash > > > 16 ; return hash ; } 
private static long fmix64 ( long hash ) { hash ^ = hash > > > 33 ; hash * = 0xff51afd7ed558ccdL ; hash ^ = hash > > > 33 ; hash * = 0xc4ceb9fe1a85ec53L ; hash ^ = hash > > > 33 ; return hash ; } 
public final void add ( final byte [ ] data , final int offset , final int length ) { if ( length < = 0 ) { Nothing to add return; } totalLen += length; Process the bytes in blocks of 4. New bytes must be added to any current unprocessed bytes, then processed in blocks of 4 and the remaining bytes saved: |--|---------------------------|--| unprocessed main block remaining Check if the unprocessed bytes and new bytes can fill a block of 4. Make this overflow safe in the event that length is Integer.MAX_VALUE. Equivalent to: (unprocessedLength + length < BLOCK_SIZE) if (unprocessedLength + length - BLOCK_SIZE < 0) { Not enough so add to the unprocessed bytes System.arraycopy(data, offset, unprocessed, unprocessedLength, length); unprocessedLength += length; return; } Combine unprocessed bytes with new bytes. final int newOffset; final int newLength; if (unprocessedLength > 0) { int k = -1; switch (unprocessedLength) { case 1: k = orBytes(unprocessed[0], data[offset], data[offset + 1], data[offset + 2]); break; case 2: k = orBytes(unprocessed[0], unprocessed[1], data[offset], data[offset + 1]); break; case 3: k = orBytes(unprocessed[0], unprocessed[1], unprocessed[2], data[offset]); break; default: throw new IllegalStateException("Unprocessed length should be 1, 2, or 3: " + unprocessedLength); } hash = mix32(k, hash); Update the offset and length final int consumed = BLOCK_SIZE - unprocessedLength; newOffset = offset + consumed; newLength = length - consumed; } else { newOffset = offset; newLength = length; } Main processing of blocks of 4 bytes final int nblocks = newLength >> 2; for (int i = 0; i < nblocks; i++) { final int index = newOffset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } Save left-over unprocessed bytes final int consumed = nblocks << 2; unprocessedLength = newLength - consumed; if (unprocessedLength != 0) { System.arraycopy(data, newOffset + consumed, unprocessed, 0, unprocessedLength); 
int finalise ( final int hash , final int unprocessedLength , final byte [ ] unprocessed , final int otalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { case 3 : k1 ^ = ( unprocessed [ 2 ] & 0xff ) < < 16 ; case 2 : k1 ^ = ( unprocessed [ 1 ] & 0xff ) < < 8 ; case 1 : k1 ^ = unprocessed [ 0 ] & 0xff ; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
private static int orBytes ( final byte b1 , final byte b2 , final byte b3 , final byte b4 ) { return b1 & 0xff | ( b2 & 0xff ) < < 8 | ( b3 & 0xff ) < < 16 | ( b4 & 0xff ) < < 24 ; } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( b [ i ] < < 24 > > > 24 ) + ( b [ i + 1 ] < < 24 > > > 16 ) + ( b [ i + 2 ] < < 24 > > > 8 ) + ( b [ i + 3 ] < < 24 ) ; localCrc = T [ ( x < < 24 > > > 24 ) + 0x700 ] ^ T [ ( x < < 16 > > > 24 ) + 0x600 ] ^ T [ ( x < < 8 > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ^ T [ ( b [ i + 4 ] < < 24 > > > 24 ) + 0x300 ] ^ T [ ( b [ i + 5 ] < < 24 > > > 24 ) + 0x200 ] ^ T [ ( b [ i + 6 ] < < 24 > > > 24 ) + 0x100 ] ^ T [ b [ i + 7 ] < < 24 > > > 24 ] ; } } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = crc > > > 8 ^ T [ ( crc ^ b ) < < 24 > > > 24 ] ; } 
public void update ( final byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = T [ T8_7_START + c0 ] ^ T [ T8_6_START + c1 ] ^ T [ T8_5_START + c2 ] ^ T [ T8_4_START + c3 ] ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = T [ T8_3_START + c4 ] ^ T [ T8_2_START + c5 ] ^ T [ T8_1_START + c6 ] ^ T [ T8_0_START + c7 ] ; off + = 8 ; len - = 8 ; } switch ( len ) { case 7 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 6 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 5 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 4 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 3 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 2 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 1 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; default : break ; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = crc > > > 8 ^ T [ T8_0_START + ( ( crc ^ b ) & 0xff ) ] ; } 
private static int [ ] desSetKey ( final byte [ ] key ) { final int [ ] schedule = new int [ 32 ] ; int c = fourBytesToInt ( key , 0 ) ; int d = fourBytesToInt ( key , 4 ) ; final int [ ] results = new int [ 2 ] ; permOp ( d , c , 4 , 0xf0f0f0f , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; c = hPermOp ( c , - 2 , 0xcccc0000 ) ; d = hPermOp ( d , - 2 , 0xcccc0000 ) ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; permOp ( c , d , 8 , 0xff00ff , results ) ; c = results [ 0 ] ; d = results [ 1 ] ; permOp ( d , c , 1 , 0x55555555 , results ) ; d = results [ 0 ] ; c = results [ 1 ] ; d = ( d & 0xff ) < < 16 | d & 0xff00 | ( d & 0xff0000 ) > > > 16 | ( c & 0xf0000000 ) > > > 4 ; c & = 0xfffffff ; int j = 0 ; for ( int i = 0 ; i < 16 ; i + + ) { if ( SHIFT2 [ i ] ) { c = c > > > 2 | c < < 26 ; d = d > > > 2 | d < < 26 ; } else { c = c > > > 1 | c < < 27 ; d = d > > > 1 | d < < 27 ; } c & = 0xfffffff ; d & = 0xfffffff ; int s = SKB [ 0 ] [ c & 0x3f ] | SKB [ 1 ] [ c > > > 6 & 0x3 | c > > > 7 & 0x3c ] | SKB [ 2 ] [ c > > > 13 & 0xf | c > > > 14 & 0x30 ] | SKB [ 3 ] [ c > > > 20 & 0x1 | c > > > 21 & 0x6 | c > > > 22 & 0x38 ] ; final int = SKB [ 4 ] [ d & 0x3f ] | SKB [ 5 ] [ d > > > 7 & 0x3 | d > > > 8 & 0x3c ] | SKB [ 6 ] [ d > > > 15 & 0x3f ] | SKB [ 7 ] [ d > > > 21 & 0xf | d > > > 22 & 0x30 ] ; schedule [ j + + ] = < < 16 | s & 0xffff ; s = s > > > 16 | & 0xffff0000 ; s = s < < 4 | s > > > 28 ; schedule [ j + + ] = s ; } return schedule ; } 
public String colognePhonetic ( final String ext ) { if ( ext = = null ) { return null ; } final CologneInputBuffer input = new CologneInputBuffer ( preprocess ( ext ) ) ; final CologneOutputBuffer output = new CologneOutputBuffer ( input . length ( ) * 2 ) ; char nextChar ; char lastChar = CHAR_IGNORE ; char chr ; while ( ! input . isEmpty ( ) ) { chr = input . removeNext ( ) ; if ( ! input . isEmpty ( ) ) { nextChar = input . getNextChar ( ) ; } else { nextChar = CHAR_IGNORE ; } if ( chr < 'A' | | chr > 'Z' ) { continue ; ignore unwanted characters } if (arrayContains(AEIJOUY, chr)) { output.put('0'); } else if (chr == 'B' || chr == 'P' && nextChar != 'H') { output.put('1'); } else if ((chr == 'D' || chr == 'T') && !arrayContains(CSZ, nextChar)) { output.put('2'); } else if (arrayContains(FPVW, chr)) { output.put('3'); } else if (arrayContains(GKQ, chr)) { output.put('4'); } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) { output.put('4'); output.put('8'); } else if (chr == 'S' || chr == 'Z') { output.put('8'); } else if (chr == 'C') { if (output.isEmpty()) { if (arrayContains(AHKLOQRUX, nextChar)) { output.put('4'); } else { output.put('8'); } } else if (arrayContains(SZ, lastChar) || !arrayContains(AHKOQUX, nextChar)) { output.put('8'); } else { output.put('4'); } } else if (arrayContains(DTX, chr)) { output.put('8'); } else { switch (chr) { case 'R': output.put('7'); break; case 'L': output.put('5'); break; case 'M': case 'N': output.put('6'); break; case 'H': output.put(CHAR_IGNORE); needed by put break; default: break; } } lastChar = chr; } return output.toString(); } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = '\0' ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = lastChar == 'm' && ch == 'n' || lastChar == 'n' && ch == 'm'; nextBranch.processNextReplacement(nextReplacement, force); if (!branching) { break; } nextBranches.add(nextBranch); } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
private int handleCC ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index + 2 , 1 , " I " , " E " , " H " ) & & ! contains ( value , index + 2 , 2 , " HU " ) ) { -- "bellocchio" but not "bacchus" -- if (index == 1 && charAt(value, index - 1) == 'A' || contains(value, index - 1, 5, "UCCEE", "UCCES")) { -- "accident", "accede", "succeed" -- result.append("KS"); } else { -- "bacci", "bertucci", other Italian -- result.append('X'); } index += 3; } else { Pierce's rule result.append('K'); index += 2; } return index; } 
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else { if (charAt(value, index + 1) == 'G') { index += 2; } else { index++; } result.append('K'); } return index; } 
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) | | index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) | | index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
private int handleJ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index , 4 , " JOSE " ) | | contains ( value , 0 , 4 , " SAN " ) ) { -- obvious Spanish, "Jose", "San Jacinto" -- if (index == 0 && charAt(value, index + 4) == ' ' || value.length() == 4 || contains(value, 0, 4, "SAN ")) { result.append('H'); } else { result.append('J', 'H'); } index++; } else { if (index == 0 && !contains(value, index, 4, "JOSE")) { result.append('J', 'A'); } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) { result.append('J', 'H'); } else if (index == value.length() - 1) { result.append('J', ' '); } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) { result.append('J'); } if (charAt(value, index + 1) == 'J') { index += 2; } else { index++; } } return index; } 
private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if (index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W") || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, e.g. "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language although in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french e.g. "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if (index == value.length() - 1 && isVowel(charAt(value, index - 1)) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish e.g. "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } return index; } 
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( index = = value . length ( ) - 1 & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French e.g. breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin e.g. "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || slavoGermanic && index > 0 && charAt(value, index - 1) != 'T') { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private boolean conditionC0 ( final String value , final int index ) { if ( contains ( value , index , 4 , " CHIA " ) ) { return rue ; } if ( index < = 1 ) { return false ; } if ( isVowel ( charAt ( value , index - 2 ) ) ) { return false ; } if ( ! contains ( value , index - 1 , 3 , " ACH " ) ) { return false ; } final char c = charAt ( value , index + 2 ) ; return c ! = 'I' & & c ! = 'E' | | contains ( value , index - 2 , 6 , " BACHER " , " MACHER " ) ; 
private boolean conditionCH1 ( final String value , final int index ) { return contains ( value , 0 , 4 , " VAN " , " VON " ) | | contains ( value , 0 , 3 , " SCH " ) | | contains ( value , index - 2 , 6 , " ORCHES " , " ARCHIT " , " ORCHID " ) | | 
private boolean conditionM0 ( final String value , final int index ) { if ( charAt ( value , index + 1 ) = = 'M' ) { return rue ; } return contains ( value , index - 1 , 3 , " UMB " ) & & ( index + 1 = = value . length ( ) - 1 | | contains ( value , index + 2 , 2 , " ER " ) ) ; 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final char [ ] out = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for(int i = 1; i < str.length() && count < out.length ; i++) { final char ch = str.charAt(i); if (this.specialCaseHW && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } final char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
public byte [ ] encode ( final byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes ! = bytes . length ; if ( willEncode | | plusForSpace & & containsSpace ( bytes ) ) { return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } 
private boolean canEncode ( final byte c ) { return ! isAsciiChar ( c ) | | inAlwaysEncodeCharsRange ( c ) & & alwaysEncodeChars . get ( c ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , final boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; final int bytesLength = bytes . length ; if ( strict ) { int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytesLength - 3; i++) { final int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytesLength - 3, bytes); boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5; pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytesLength - 2; i < bytesLength; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
public void estIsInAlphabet ( ) { invalid bounds Base32 b32 = new Base32(true); assertFalse(b32.isInAlphabet((byte)0)); assertFalse(b32.isInAlphabet((byte)1)); assertFalse(b32.isInAlphabet((byte)-1)); assertFalse(b32.isInAlphabet((byte)-15)); assertFalse(b32.isInAlphabet((byte)-32)); assertFalse(b32.isInAlphabet((byte)127)); assertFalse(b32.isInAlphabet((byte)128)); assertFalse(b32.isInAlphabet((byte)255)); default table b32 = new Base32(false); for (char c = '2'; c <= '7'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'Z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) '1')); assertFalse(b32.isInAlphabet((byte) '8')); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('Z' + 1))); hex table b32 = new Base32(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'V'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'v'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) ('0' - 1))); assertFalse(b32.isInAlphabet((byte) ('9' + 1))); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('V' + 1))); assertFalse(b32.isInAlphabet((byte) ('a' - 1))); assertFalse(b32.isInAlphabet((byte) ('v' + 1))); } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. try (InputStream in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); } Now let's try to decode. InputStream in = new Base64InputStream(new ByteArrayInputStream(encoded)); byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); I always wanted to do this! (wrap encoder with decoder etc.). in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); in.close(); } 
public final void estIsVowel_SingleVowel_ReturnsTrue ( ) { assertTrue ( his . getStringEncoder ( ) . isVowel ( " I " ) ) ; } 
protected byte [ ] doEncoding ( final byte [ ] bytes ) hrows EncoderException { return null ; } 
protected byte [ ] doDecoding ( final byte [ ] bytes ) hrows DecoderException { return null ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { return super . encodeText ( ext , charset ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException , UnsupportedEncodingException { return super . encodeText ( ext , charsetName ) ; } 
protected String decodeText ( final String ext ) hrows DecoderException , UnsupportedEncodingException { return super . decodeText ( ext ) ; } 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final SecureRandom randomGenerator = new SecureRandom ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! salt . matches ( " ^[ " + B64 . B64T_STRING + " ]{2,}$ " ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte [ ] key = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; final int originalLength = original . length ; for ( int i = 0 ; i < key . length & & i < originalLength ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int [ ] schedule = desSetKey ( key ) ; final int [ ] out = body ( schedule , eSwap0 , eSwap1 ) ; final byte [ ] b = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
private static MessageDigest getMessageDigest ( final String algorithm ) hrows NoSuchAlgorithmException { return MessageDigest . getInstance ( algorithm ) ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final RandomAccessFile data ) hrows IOException { return updateDigest ( digest , data . getChannel ( ) ) ; } 
public static String [ ] values ( ) { Do not use a constant array here as that can be changed externally by accident or design return new String[] { MD2, MD5, SHA_1, SHA_224, SHA_256, SHA_384, 
public void estDigestAs ( ) hrows IOException { final String expected = " d41d8cd98f00b204e9800998ecf8427e " ; final String pathName = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . MD5 ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( new File ( pathName ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathName ) ) { assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathName ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( allBytes ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; final String expected = " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " ; final String pathName = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . SHA_224 ; final DigestUtils digestUtils = new DigestUtils ( algo ) ; assertEquals ( expected , digestUtils . digestAsHex ( new File ( pathName ) ) ) ; ry ( final FileInputStream inputStream = new FileInputStream ( pathName ) ) { assertEquals ( expected , digestUtils . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathName ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( allBytes ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; protected abstract String getEncoding ( ) ; } 
protected abstract byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException ; protected abstract String getEncoding ( ) ; } 
public void estProvidePaddingByte ( ) { Given codec = new BaseNCodec(0, 0, 0, 0, (byte)0x25) { @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { } @Override protected boolean isInAlphabet(final byte b) { return b=='O' || b == 'K'; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override protected boolean isInAlphabet ( final byte b ) { return b = = 'O' | | b = = 'K' ; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { } @Override protected boolean isInAlphabet ( final byte b ) { return b = = 'O' | | b = = 'K' ; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; fail ( msg + " but nothing was thrown. " ) ; } catch ( final Exception ex ) { assertTrue ( data . hrowable . isAssignableFrom ( ex . getClass ( ) ) , msg + " but was " + ex . getClass ( ) . getSimpleName ( ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( data . expected , stringCheck , id + " Failed test " + data ) ; } } } Note: The commented out tests fail due to the CharSequenceUtils method being based on Lang 3.3.2 and the tests are from 3.11. static class TestData{ final String source; final boolean ignoreCase; final int toffset; final String other; final int ooffset; final int len; final boolean expected; final Class<? extends Throwable> throwable; TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final boolean expected) { this.source = source; this.ignoreCase = ignoreCase; this.toffset = toffset; this.other = other; this.ooffset = ooffset; this.len = len; this.expected = expected; this.throwable = null; } TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final Class<? extends Throwable> throwable) { this.source = source; this.ignoreCase = ignoreCase; this.toffset = toffset; this.other = other; this.ooffset = ooffset; this.len = len; this.expected = false; this.throwable = throwable; } @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(source).append("[").append(toffset).append("]"); sb.append(ignoreCase? " caseblind ":" samecase "); sb.append(other).append("[").append(ooffset).append("]"); sb.append(" ").append(len).append(" => "); if (throwable != null) { sb.append(throwable); } else { sb.append(expected); } return sb.toString(); } } private static final TestData[] TEST_DATA = { Source IgnoreCase Offset Other Offset Length Result new TestData("", true, -1, "", -1, -1, false), new TestData("", true, 0, "", 0, 1, false), new TestData("a", true, 0, "abc", 0, 0, true), new TestData("a", true, 0, "abc", 0, 1, true), new TestData("a", true, 0, null, 0, 0, NullPointerException.class), new TestData(null, true, 0, null, 0, 0, NullPointerException.class), new TestData(null, true, 0, "", 0, 0, NullPointerException.class), new TestData("Abc", true, 0, "abc", 0, 3, true), new TestData("Abc", false, 0, "abc", 0, 3, false), new TestData("Abc", true, 1, "abc", 1, 2, true), new TestData("Abc", false, 1, "abc", 1, 2, true), new TestData("Abcd", true, 1, "abcD", 1, 2, true), new TestData("Abcd", false, 1, "abcD", 1, 2, true), }; @SuppressWarnings("unused") @Test public void testConstructor() { new CharSequenceUtils(); } @Test public void testRegionMatches() { for (final TestData data : TEST_DATA) { new RunTest() { @Override boolean invoke() { return data.source.regionMatches(data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "String"); new RunTest() { @Override boolean invoke() { return CharSequenceUtils.regionMatches(data.source, data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "CSString"); new RunTest() { @Override boolean invoke() { return CharSequenceUtils.regionMatches(new StringBuilder(data.source), data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "CSNonString"); } }} 
public static void main ( final String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } final long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; final int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file try (final PrintStream out = new PrintStream(new FileOutputStream("table" + i + ".txt"), true)) { out.println(s); 
String [ ] oStrings ( final String nameFormat ) { final String [ ] s = new String [ ables . length ] ; for ( int j = 0 ; j < ables . length ; j + + ) { final int [ ] = ables [ j ] ; final StringBuilder b = new StringBuilder ( ) ; b . append ( String . format ( " " , j ) ) ; for ( int i = 0 ; i < . length ; ) { b . append ( " n " ) ; for ( int k = 0 ; k < 4 ; k + + ) { b . append ( String . format ( " 0x%08X, " , [ i + + ] ) ) ; } } s [ j ] = b . oString ( ) ; } return s ; } 
public void estSha512CryptNullSalt ( ) { cannot be tested as sha512Crypt() with all params is private and all public methods check for salt==null. } @Test public void testSha512CryptStrings() { empty data assertEquals("$6$foo$Nywkte7LPWjaJhWjNeGJN.dFdY3pN1wYlGifyRLYOVlGS9EMSiZaDDe/BGSOYQ327q9.32I4UqQ5odsqvsBLX/", Crypt.crypt("", "$6$foo")); salt gets cut at dollar sign assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012")); assertEquals("$6$45678$f2en/Y053Knir/wu/T8DQKSbiUGcPcbXKsmyVlP820dIpXoY0KlqgUqRVFfavdRXwDMUZYsxPOymA4zgX0qE5.", Crypt.crypt("secret", "$6$45678$012$456")); salt gets cut at maximum length assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456")); assertEquals("$6$1234567890123456$d2HCAnimIF5VMqUnwaZ/4JhNDJ.ttsjm0nbbmc9eE7xUYiw79GMvXUc5ZqG5BlqkXSbASZxrvR0QefAgdLbeH.", Crypt.crypt("secret", "$6$1234567890123456789")); } @Test public void testSha512CryptWithEmptySalt() { assertThrows(IllegalArgumentException.class, () -> Sha2Crypt.sha512Crypt("secret".getBytes(), "")); } @Test public void testZeroOutInput() { final byte[] buffer = new byte[200]; Arrays.fill(buffer, (byte) 'A'); Sha2Crypt.sha512Crypt(buffer); input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); }} 
public static Stream < Arguments > data ( ) { return Stream . of ( reference checksums created with xxh32sum 
private void validateState ( final URLCodec urlCodec ) { no tests for now. }} 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { final SecureRandom randomGenerator = new SecureRandom ( ) ; final int numSaltChars = SALT_CHARS . length ; salt = " " + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] + SALT_CHARS [ randomGenerator . nextInt ( numSaltChars ) ] ; } else if ( ! CRYPT_SALT_PATTERN . matcher ( salt ) . matches ( ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte [ ] key = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; final int originalLength = original . length ; for ( int i = 0 ; i < key . length & & i < originalLength ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int [ ] schedule = desSetKey ( key ) ; final int [ ] out = body ( schedule , eSwap0 , eSwap1 ) ; final byte [ ] b = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public void estCheckEncodeLengthBounds ( ) { final Base16 base16 = new Base16 ( ) ; assertThrows ( IllegalArgumentException . class , ( ) - > base16 . encode ( new byte [ 10 ] , 0 , 1 < < 30 ) ) ; } 
public void estShouldThrowIllegalArgumentExceptionWhenIncorrectKeySize ( ) { for ( int i = 0 ; i < 32 ; i + + ) { assertThrowsProperExceptionWithKeySize ( i ) ; } assertThrowsProperExceptionWithKeySize ( 33 ) ; } 
public void estHash32Long ( ) { As described in the Javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash32LongLong ( ) { As described in the Javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32LongLongSeed ( ) { As described in the Javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES * 2; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { for (final long j : data) { 
public void estHash32LongSeed ( ) { As described in the Javadoc final int offset = 0; final int seed = 104729; final int length = Long.BYTES; final ByteBuffer buffer = ByteBuffer.allocate(length); final byte[] bytes = buffer.array(); final long[] data = createLongTestData(); for (final long i : data) { buffer.putLong(0, i); 
public void estHash64WithPrimitives ( ) { As described in the Javadoc final int offset = 0; final int seed = 104729; final int iters = 1000; final ByteBuffer shortBuffer = ByteBuffer.allocate(Short.BYTES); final ByteBuffer intBuffer = ByteBuffer.allocate(Integer.BYTES); final ByteBuffer longBuffer = ByteBuffer.allocate(Long.BYTES); final byte[] shortBytes = shortBuffer.array(); final byte[] intBytes = intBuffer.array(); final byte[] longBytes = longBuffer.array(); for (int i = 0; i < iters; ++i) { final long ln = ThreadLocalRandom.current().nextLong(); 
public String encode ( String input , final Languages . LanguageSet languageSet ) { final Map < String , List < Rule > > rules = Rule . getInstanceMap ( his . nameType , RuleType . RULES , languageSet ) ; rules common across many (all) languages final Map<String, List<Rule>> finalRules1 = Rule.getInstanceMap(this.nameType, this.ruleType, "common"); rules that apply to a specific language that may be ambiguous or wrong if applied to other languages final Map<String, List<Rule>> finalRules2 = Rule.getInstanceMap(this.nameType, this.ruleType, languageSet); tidy the input lower case is a locale-dependent operation input = input.toLowerCase(Locale.ENGLISH).replace('-', ' ').trim(); if (this.nameType == NameType.GENERIC) { if (input.startsWith("d'")) { check for d' final String remainder = input.substring(2); final String combined = "d" + remainder; return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } for (final String l : NAME_PREFIXES.get(this.nameType)) { handle generic prefixes if (input.startsWith(l + " ")) { check for any prefix in the words list final String remainder = input.substring(l.length() + 1); input without the prefix final String combined = l + remainder; input with prefix without space return "(" + encode(remainder) + ")-(" + encode(combined) + ")"; } } } final List<String> words = Arrays.asList(input.split("\\s+")); final List<String> words2 = new ArrayList<>(); special-case handling of word prefixes based upon the name type switch (this.nameType) { case SEPHARDIC: words.forEach(aWord -> { final String[] parts = aWord.split("'", -1); words2.add(parts[parts.length - 1]); }); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case ASHKENAZI: words2.addAll(words); words2.removeAll(NAME_PREFIXES.get(this.nameType)); break; case GENERIC: words2.addAll(words); break; default: throw new IllegalStateException("Unreachable case: " + this.nameType); } if (this.concat) { concat mode enabled input = join(words2, " "); } else if (words2.size() == 1) { not a multi-word name input = words.iterator().next(); } else if (!words2.isEmpty()) { encode each word in a multi-word name separately (normally used for approx matches) final StringBuilder result = new StringBuilder(); words2.forEach(word -> result.append("-").append(encode(word))); return the result without the leading "-" return result.substring(1); } PhonemeBuilder phonemeBuilder = PhonemeBuilder.empty(languageSet); loop over each char in the input - we will handle the increment manually for (int i = 0; i < input.length();) { final RulesApplication rulesApplication = new RulesApplication(rules, input, phonemeBuilder, i, maxPhonemes).invoke(); i = rulesApplication.getI(); phonemeBuilder = rulesApplication.getPhonemeBuilder(); } Apply the general rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules1); Apply the language-specific rules phonemeBuilder = applyFinalRules(phonemeBuilder, finalRules2); return phonemeBuilder.makeString(); } 
public static Stream < Arguments > invalidData ( ) { return Stream . of ( Arguments . of ( " bar " , " bar|bor|var|vor " , NameType . ASHKENAZI , RuleType . APPROX , Boolean . FALSE , TEN ) , 
public void estInvalidEncode ( final String input , final String phoneticExpected , final NameType nameType , final RuleType ruleType , final boolean concat , final int maxPhonemes ) { final PhoneticEngine engine = new PhoneticEngine ( nameType , ruleType , concat , maxPhonemes ) ; assertEquals ( engine . encode ( input ) , phoneticExpected ) ; } 
public static final byte [ ] encodeQuotedPrintable ( BitSet printable , final byte [ ] bytes , final boolean strict ) { if ( bytes = = null ) { return null ; } if ( printable = = null ) { printable = PRINTABLE_CHARS ; } final ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; final int bytesLength = bytes . length ; if ( strict ) { if ( bytesLength < MIN_BYTES ) { return null ; } int pos = 1 ; encode up to buffer.length - 3, the last three octets will be treated separately for simplification of note #3 for (int i = 0; i < bytesLength - 3; i++) { final int b = getUnsignedOctet(i, bytes); if (pos < SAFE_LENGTH) { up to this length it is safe to add any byte, encoded or not pos += encodeByte(b, !printable.get(b), buffer); } else { rule #3: whitespace at the end of a line *must* be encoded encodeByte(b, !printable.get(b) || isWhitespace(b), buffer); rule #5: soft line break buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); pos = 1; } } rule #3: whitespace at the end of a line *must* be encoded if we would do a soft break line after this octet, encode whitespace int b = getUnsignedOctet(bytesLength - 3, bytes); boolean encode = !printable.get(b) || isWhitespace(b) && pos > SAFE_LENGTH - 5; pos += encodeByte(b, encode, buffer); note #3: '=' *must not* be the ultimate or penultimate character simplification: if < 6 bytes left, do a soft line break as we may need exactly 6 bytes space for the last 2 bytes if (pos > SAFE_LENGTH - 2) { buffer.write(ESCAPE_CHAR); buffer.write(CR); buffer.write(LF); } for (int i = bytesLength - 2; i < bytesLength; i++) { b = getUnsignedOctet(i, bytes); rule #3: trailing whitespace shall be encoded encode = !printable.get(b) || i > bytesLength - 2 && isWhitespace(b); encodeByte(b, encode, buffer); } } else { for (final byte c : bytes) { int b = c; if (b < 0) { b = 256 + b; } if (printable.get(b)) { buffer.write(b); } else { encodeQuotedPrintable(b, buffer); } } } return buffer.toByteArray(); } 
public void estTooShortByteArray ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertNull ( qpcodec . encode ( " AA " ) , " Result should be null. " ) ; } 
public final String encode ( String name ) { Bulletproof for trivial input - NINO if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) { return EMPTY; } Preprocessing name = cleanName(name); Bulletproof if name becomes empty after cleanName(name) if (SPACE.equals(name) || name.isEmpty()) { return EMPTY; } BEGIN: Actual encoding part of the algorithm... 1. Delete all vowels unless the vowel begins the word name = removeVowels(name); Bulletproof if name becomes empty after removeVowels(name) if (SPACE.equals(name) || name.isEmpty()) { return EMPTY; } 2. Remove second consonant from any double consonant name = removeDoubleConsonants(name); 3. Reduce codex to 6 letters by joining the first 3 and last 3 letters name = getFirst3Last3(name); return name; } 
public final void estPunctuationOnly ( ) { assertEquals ( his . getStringEncoder ( ) . encode ( " .,- " ) , " " ) ; } 
public final void estVowelOnly ( ) { assertEquals ( his . getStringEncoder ( ) . encode ( " aeiouAEIOU " ) , " A " ) ; } 
public final void estVowelAndPunctuationOnly ( ) { assertEquals ( his . getStringEncoder ( ) . encode ( " uoiea.,-AEIOU " ) , " U " ) ; } 
public void estInvalidSoundexCharacter ( ) { final char [ ] invalid = new char [ 256 ] ; for ( int i = 0 ; i < invalid . length ; i + + ) { invalid [ i ] = ( char ) i ; } assertEquals ( new RefinedSoundex ( ) . encode ( new String ( invalid ) ) , " A0136024043780159360205050136024043780159360205053 " ) ; } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimisation to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final int end = offset + dataLen; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = context.ibitWorkArea - 1 << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } final int loopEnd = end - 1; while (offset < loopEnd) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; } we have one char of a hex-pair left over if (offset < end) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
private int decodeOctet ( final byte octet ) { int decoded = - 1 ; if ( ( octet & 0xff ) < decodeTable . length ) { decoded = decodeTable [ octet ] ; } if ( decoded = = - 1 ) { hrow new IllegalArgumentException ( " Invalid octet in encoded value: " + ( int ) octet ) ; } return decoded ; } 
private void validateTrailingCharacter ( ) { if ( isStrictDecoding ( ) ) { hrow new IllegalArgumentException ( " Strict decoding: Last encoded character is a valid base 16 alphabet character but not a possible encoding. " + 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } for (int i = 0; i < inAvail; i++) { final byte b = input[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) (context.lbitWorkArea >> 32 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 24 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus > 0) { if modulus == 0, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
private void validateCharacter ( final long emptyBitsMask , final Context context ) { Use the long bit work area if (isStrictDecoding() && (context.lbitWorkArea & emptyBitsMask) != 0) { throw new IllegalArgumentException("Strict decoding: Last encoded character (before the paddings if any) is a valid " + 
private void validateTrailingCharacters ( ) { if ( isStrictDecoding ( ) ) { hrow new IllegalArgumentException ( " Strict decoding: Last encoded character(s) (before the paddings if any) are valid " + 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( b [ i ] < < 24 > > > 24 ) + ( b [ i + 1 ] < < 24 > > > 16 ) + ( b [ i + 2 ] < < 24 > > > 8 ) + ( b [ i + 3 ] < < 24 ) ; localCrc = T [ ( x < < 24 > > > 24 ) + 0x700 ] ^ T [ ( x < < 16 > > > 24 ) + 0x600 ] ^ T [ ( x < < 8 > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ^ T [ ( b [ i + 4 ] < < 24 > > > 24 ) + 0x300 ] ^ T [ ( b [ i + 5 ] < < 24 > > > 24 ) + 0x200 ] ^ T [ ( b [ i + 6 ] < < 24 > > > 24 ) + 0x100 ] ^ T [ b [ i + 7 ] < < 24 > > > 24 ] ; } } Publish crc out to object crc = localCrc; } 
public void update ( final byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = T [ T8_7_START + c0 ] ^ T [ T8_6_START + c1 ] ^ T [ T8_5_START + c2 ] ^ T [ T8_4_START + c3 ] ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = T [ T8_3_START + c4 ] ^ T [ T8_2_START + c5 ] ^ T [ T8_1_START + c6 ] ^ T [ T8_0_START + c7 ] ; off + = 8 ; len - = 8 ; } switch ( len ) { case 7 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 6 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 5 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 4 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 3 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 2 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; case 1 : localCrc = localCrc > > > 8 ^ T [ T8_0_START + ( ( localCrc ^ b [ off + + ] ) & 0xff ) ] ; default : break ; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = crc > > > 8 ^ T [ T8_0_START + ( ( crc ^ b ) & 0xff ) ] ; } 
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index = index + 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else { if (charAt(value, index + 1) == 'G') { index += 2; } else { index++; } result.append('K'); } return index; } 
private boolean hasMarker ( final char [ ] mapping ) { for ( final char ch : mapping ) { if ( ch = = SILENT_MARKER ) { return rue ; } } return false ; } 
public String soundex ( String str ) { if ( str = = null ) { return null ; } str = SoundexUtils . clean ( str ) ; if ( str . isEmpty ( ) ) { return str ; } final char [ ] out = { '0' , '0' , '0' , '0' } ; int count = 0 ; final char first = str . charAt ( 0 ) ; out [ count + + ] = first ; char lastDigit = map ( first ) ; previous digit for (int i = 1; i < str.length() && count < out.length; i++) { final char ch = str.charAt(i); if (this.specialCaseHW && (ch == 'H' || ch == 'W')) { these are ignored completely continue; } final char digit = map(ch); if (digit == SILENT_MARKER) { continue; } if (digit != '0' && digit != lastDigit) { don't store vowels or repeats out[count++] = digit; } lastDigit = digit; } return new String(out); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (final Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0, 1); final List<Rule> rules = lines.computeIfAbsent(patternKey, k -> new ArrayList<>()); rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } return lines; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be URL encoded " ) ; } 
public void estLocaleIndependence ( ) hrows Exception { final StringEncoder encoder = his . getStringEncoder ( ) ; final String [ ] data = { " I " , " i " } ; final Locale orig = Locale . getDefault ( ) ; final Locale [ ] locales = { Locale . ENGLISH , new Locale ( " r " ) , Locale . getDefault ( ) } ; ry { for ( final String element : data ) { 
public void estReadNull ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( final Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) , " Base16InputStream.read(null, 0, 0) " ) ; 
public void estDecodeSingleBytes ( ) { final String encoded = " 556E74696C206E6578742074696D6521 " ; final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; final Base16 b16 = new Base16 ( ) ; final byte [ ] encocdedBytes = StringUtils . getBytesUtf8 ( encoded ) ; decode byte-by-byte b16.decode(encocdedBytes, 0, 1, context); b16.decode(encocdedBytes, 1, 1, context); yields "U" b16.decode(encocdedBytes, 2, 1, context); b16.decode(encocdedBytes, 3, 1, context); yields "n" decode split hex-pairs b16.decode(encocdedBytes, 4, 3, context); yields "t" b16.decode(encocdedBytes, 7, 3, context); yields "il" b16.decode(encocdedBytes, 10, 3, context); yields " " decode remaining b16.decode(encocdedBytes, 13, 19, context); yields "next time!" final byte[] decodedBytes = new byte[context.pos]; System.arraycopy(context.buffer, context.readPos, decodedBytes, 0, decodedBytes.length); final String decoded = StringUtils.newStringUtf8(decodedBytes); assertEquals("Until next time!", decoded); } 
public void estDecodeSingleBytesOptimisation ( ) { final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; final byte [ ] data = new byte [ 1 ] ; final Base16 b16 = new Base16 ( ) ; data [ 0 ] = ( byte ) 'E' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 15 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; data [ 0 ] = ( byte ) 'F' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertEquals ( ( byte ) 0xEF , context . buffer [ 0 ] ) ; } 
public void estIsInAlphabet ( ) { invalid bounds Base16 b16 = new Base16(true); assertFalse(b16.isInAlphabet((byte) 0)); assertFalse(b16.isInAlphabet((byte) 1)); assertFalse(b16.isInAlphabet((byte) -1)); assertFalse(b16.isInAlphabet((byte) -15)); assertFalse(b16.isInAlphabet((byte) -16)); assertFalse(b16.isInAlphabet((byte) 128)); assertFalse(b16.isInAlphabet((byte) 255)); lower-case b16 = new Base16(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('a' - 1))); assertFalse(b16.isInAlphabet((byte) ('f' + 1))); assertFalse(b16.isInAlphabet((byte) ('z' + 1))); upper-case b16 = new Base16(false); for (char c = '0'; c <= '9'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'f'; c++) { assertFalse(b16.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'F'; c++) { assertTrue(b16.isInAlphabet((byte) c)); } assertFalse(b16.isInAlphabet((byte) ('0' - 1))); assertFalse(b16.isInAlphabet((byte) ('9' + 1))); assertFalse(b16.isInAlphabet((byte) ('A' - 1))); assertFalse(b16.isInAlphabet((byte) ('F' + 1))); assertFalse(b16.isInAlphabet((byte) ('Z' + 1))); } 
public void estKnownDecodings ( ) { assertEquals ( " The quick brown fox jumped over the lazy dogs. " , new String ( new Base16 ( rue ) . decode ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( new Base16 ( rue ) . decode ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( new Base16 ( rue ) . decode ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( new Base16 ( rue ) . decode ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( new Base16 ( rue ) . decode ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( new Base16 ( rue ) . decode ( " 78797a7a7921 " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " 54686520717569636b2062726f776e20666f78206a756d706564206f76657220746865206c617a7920646f67732e " , new String ( new Base16 ( rue ) . encode ( " The quick brown fox jumped over the lazy dogs. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 497420776173207468652062657374206f662074696d65732c206974207761732074686520776f727374206f662074696d65732e " , new String ( new Base16 ( rue ) . encode ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 687474703a2f2f6a616b617274612e6170616368652e6f72672f636f6d6d6d6f6e73 " , new String ( new Base16 ( rue ) . encode ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 4161426243634464456546664767486849694a6a4b6b4c6c4d6d4e6e4f6f50705171527253735474557556765777587859795a7a " , new String ( new Base16 ( rue ) . encode ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 7b20302c20312c20322c20332c20342c20352c20362c20372c20382c2039207d " , new String ( new Base16 ( rue ) . encode ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " 78797a7a7921 " , new String ( new Base16 ( rue ) . encode ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estLenientDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.LENIENT); assertEquals(CodecPolicy.LENIENT, b16.getCodecPolicy()); final byte[] decoded = b16.decode(StringUtils.getBytesUtf8(encoded)); assertArrayEquals(new byte[] { (byte) 0xaa, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd }, decoded); } 
public void estStrictDecoding ( ) { final String encoded = " aabbccdde " ; Note the trailing `e` which does not make up a hex-pair and so is only 1/2 byte final Base16 b16 = new Base16(true, CodecPolicy.STRICT); assertEquals(CodecPolicy.STRICT, b16.getCodecPolicy()); assertThrows(IllegalArgumentException.class, () -> b16.decode(StringUtils.getBytesUtf8(encoded))); } 
public void estBase32BinarySamplesReverse ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final Object [ ] element : BASE32_BINARY_TEST_CASES ) { assertArrayEquals ( ( byte [ ] ) element [ 0 ] , codec . decode ( ( String ) element [ 1 ] ) ) ; 
public void estBase32Chunked ( ) hrows Exception { final Base32 codec = new Base32 ( 20 ) ; for ( final String [ ] element : BASE32_TEST_CASES_CHUNKED ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32HexImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( 0 , null , rue , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32HEX_IMPOSSIBLE_CASES ) ; } 
public void estBase32HexSamples ( ) hrows Exception { final Base32 codec = new Base32 ( rue ) ; for ( final String [ ] element : BASE32HEX_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32ImpossibleChunked ( ) { estImpossibleCases ( new Base32 ( 20 , BaseNCodec . CHUNK_SEPARATOR , false , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32_IMPOSSIBLE_CASES_CHUNKED ) ; } 
public void estBase32ImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( 0 , null , false , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32_IMPOSSIBLE_CASES ) ; } 
public void estBase32Samples ( ) hrows Exception { final Base32 codec = new Base32 ( ) ; for ( final String [ ] element : BASE32_TEST_CASES ) { assertEquals ( element [ 1 ] , codec . encodeAsString ( element [ 0 ] . getBytes ( CHARSET_UTF8 ) ) ) ; 
public void estBase32SamplesNonDefaultPadding ( ) hrows Exception { final Base32 codec = new Base32 ( ( byte ) 0x25 ) ; '%' <=> 0x25 for (final String[] element : BASE32_PAD_TEST_CASES) { assertEquals(element[1], codec.encodeAsString(element[0].getBytes(CHARSET_UTF8))); 
public void estCodec200 ( ) { final Base32 codec = new Base32 ( rue , ( byte ) 'W' ) ; should be allowed assertNotNull(codec); } 
public void estConstructors ( ) { Base32 base32 ; base32 = new Base32 ( ) ; base32 = new Base32 ( - 1 ) ; base32 = new Base32 ( - 1 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } ) ; base32 = new Base32 ( 32 , new byte [ ] { } , false ) ; ' }); OK assertNotNull(base32); } 
public void estIsInAlphabet ( ) { invalid bounds Base32 b32 = new Base32(true); assertFalse(b32.isInAlphabet((byte) 0)); assertFalse(b32.isInAlphabet((byte) 1)); assertFalse(b32.isInAlphabet((byte) -1)); assertFalse(b32.isInAlphabet((byte) -15)); assertFalse(b32.isInAlphabet((byte) -32)); assertFalse(b32.isInAlphabet((byte) 127)); assertFalse(b32.isInAlphabet((byte) 128)); assertFalse(b32.isInAlphabet((byte) 255)); default table b32 = new Base32(false); for (char c = '2'; c <= '7'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'Z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'z'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) '1')); assertFalse(b32.isInAlphabet((byte) '8')); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('Z' + 1))); hex table b32 = new Base32(true); for (char c = '0'; c <= '9'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'A'; c <= 'V'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } for (char c = 'a'; c <= 'v'; c++) { assertTrue(b32.isInAlphabet((byte) c)); } assertFalse(b32.isInAlphabet((byte) ('0' - 1))); assertFalse(b32.isInAlphabet((byte) ('9' + 1))); assertFalse(b32.isInAlphabet((byte) ('A' - 1))); assertFalse(b32.isInAlphabet((byte) ('V' + 1))); assertFalse(b32.isInAlphabet((byte) ('a' - 1))); assertFalse(b32.isInAlphabet((byte) ('v' + 1))); } 
public void estIsInAlphabetByteArrayBoolean ( ) { assertTrue ( codec . isInAlphabet ( new byte [ ] { } , false ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' } , false ) ) ; assertFalse ( codec . isInAlphabet ( new byte [ ] { 'O' , ' ' } , false ) ) ; assertFalse ( codec . isInAlphabet ( new byte [ ] { ' ' } , false ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { 'O' , ' ' } , rue ) ) ; assertTrue ( codec . isInAlphabet ( new byte [ ] { ' ' } , rue ) ) ; } 
public void estProvidePaddingByte ( ) { Given codec = new BaseNCodec(0, 0, 0, 0, (byte) 0x25) { @Override void decode(final byte[] pArray, final int i, final int length, final Context context) { no-op } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { no-op } @Override protected boolean isInAlphabet(final byte b) { return b == 'O' || b == 'K'; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); } 
void decode ( final byte [ ] pArray , final int i , final int length , final Context context ) { no-op } @Override void encode(final byte[] pArray, final int i, final int length, final Context context) { no-op } @Override protected boolean isInAlphabet(final byte b) { return b == 'O' || b == 'K'; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
void encode ( final byte [ ] pArray , final int i , final int length , final Context context ) { no-op } @Override protected boolean isInAlphabet(final byte b) { return b == 'O' || b == 'K'; allow OK } }; When final byte actualPaddingByte = codec.pad; Then assertEquals(0x25, actualPaddingByte); }} 
protected boolean isInAlphabet ( final byte b ) { return b = = 'O' | | b = = 'K' ; allow OK } 
private static boolean contains ( final String key ) { for ( final String s : MessageDigestAlgorithms . values ( ) ) { if ( s . equals ( key ) ) { return rue ; } } return false ; } 
public void estDigestByteBuffer ( final String messageDigestAlgorithm ) { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , ByteBuffer . wrap ( getTestData ( ) ) ) ) ; 
public void estDigestFile ( final String messageDigestAlgorithm ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestFile ( ) ) ) ; } 
private void estDigestPath ( final String messageDigestAlgorithm , final OpenOption . . . options ) hrows IOException { assumeTrue ( DigestUtils . isAvailable ( messageDigestAlgorithm ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; assertArrayEquals ( digestTestData ( messageDigestAlgorithm ) , DigestUtils . digest ( DigestUtils . getDigest ( messageDigestAlgorithm ) , getTestPath ( ) , options ) ) ; } 
public void estHash128 ( ) { mmh3.hash64(bytes, 104729) assertArrayEquals(new long[] {-5614308156300707300L, -4165733009867452172L}, MurmurHash3.hash128(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 104729), ',') final long[][] answers = { {-7122613646888064702L, -8341524471658347240L}, {5659994275039884826L, -962335545730945195L}, {-7641758224504050283L, 4083131074855072837L}, {-9123564721037921804L, -3321998102976419641L}, {-7999620158275145567L, -7769992740725283391L}, {2419143614837736468L, -5474637306496300103L}, {7781591175729494939L, -9023178611551692650L}, {-3431043156265556247L, -6589990064676612981L}, {6315693694262400182L, -6219942557302821890L}, {-8249934145502892979L, -5646083202776239948L}, {7500109050276796947L, 5350477981718987260L}, {-6102338673930022315L, 3413065069102535261L}, {-6440683413407781313L, -2374360388921904146L}, {-3071236194203069122L, 7531604855739305895L}, {-7629408037856591130L, -4070301959951145257L}, {860008171111471563L, -9026008285726889896L}, {8059667613600971894L, 3236009436748930210L}, {1833746055900036985L, 1418052485321768916L}, {8161230977297923537L, -2668130155009407119L}, {3653111839268905630L, 5525563908135615453L}, {-9163026480602019754L, 6819447647029564735L}, {1102346610654592779L, -6881918401879761029L}, {-3109499571828331931L, -3782255367340446228L}, {-7467915444290531104L, 4704551260862209500L}, {1237530251176898868L, 6144786892208594932L}, {2347717913548230384L, -7461066668225718223L}, {-7963311463560798404L, 8435801462986138227L}, {-7493166089060196513L, 8163503673197886404L}, {6807249306539951962L, -1438886581269648819L}, {6752656991043418179L, 6334147827922066123L}, {-4534351735605790331L, -4530801663887858236L}, {-7886946241830957955L, -6261339648449285315L} }; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. final long[][] answers = { {5954234972212089025L, 3342108296337967352L}, {8501094764898402923L, 7873951092908129427L}, {-3334322685492296196L, -2842715922956549478L}, {-2177918982459519644L, -1612349961980368636L}, {4172870320608886992L, -4177375712254136503L}, {7546965006884307324L, -5222114032564054641L}, {-2885083166621537267L, -2069868899915344482L}, {-2397098497873118851L, 4990578036999888806L}, {-706479374719025018L, 7531201699171849870L}, {6487943141157228609L, 3576221902299447884L}, {6671331646806999453L, -3428049860825046360L}, {-8700221138601237020L, -2748450904559980545L}, {-9028762509863648063L, 6130259301750313402L}, {729958512305702590L, -36367317333638988L}, {-3803232241584178983L, -4257744207892929651L}, {5734013720237474696L, -760784490666078990L}, {-6097477411153026656L, 625288777006549065L}, {1320365359996757504L, -2251971390373072541L}, {5551441703887653022L, -3516892619809375941L}, {698875391638415033L, 3456972931370496131L}, {5874956830271303805L, -6074126509360777023L}, {-7030758398537734781L, -3174643657101295554L}, {6835789852786226556L, 7245353136839389595L}, {-7755767580598793204L, -6680491060945077989L}, {-3099789923710523185L, -2751080516924952518L}, {-7772046549951435453L, 5263206145535830491L}, {7458715941971015543L, 5470582752171544854L}, {-7753394773760064468L, -2330157750295630617L}, {-5899278942232791979L, 6235686401271389982L}, {4881732293467626532L, 2617335658565007304L}, {-5722863941703478257L, -5424475653939430258L}, {-3703319768293496315L, -2124426428486426443L} }; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128WithOffsetLengthAndSeed ( ) { Seed must be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = { {-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L} }; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128x64 ( ) { Note: Default seed is zero. mmh3.hash64(bytes, 0) assertArrayEquals(new long[] {1972113670104592209L, 5171809317673151911L}, MurmurHash3.hash128x64(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[:x], 0), ',') final long[][] answers = { {0L, 0L}, {-2808653841080383123L, -2531784594030660343L}, {-1284575471001240306L, -8226941173794461820L}, {1645529003294647142L, 4109127559758330427L}, {-4117979116203940765L, -8362902660322042742L}, {2559943399590596158L, 4738005461125350075L}, {-1651760031591552651L, -5386079254924224461L}, {-6208043960690815609L, 7862371518025305074L}, {-5150023478423646337L, 8346305334874564507L}, {7658274117911906792L, -4962914659382404165L}, {1309458104226302269L, 570003296096149119L}, {7440169453173347487L, -3489345781066813740L}, {-5698784298612201352L, 3595618450161835420L}, {-3822574792738072442L, 6878153771369862041L}, {3705084673301918328L, 3202155281274291907L}, {-6797166743928506931L, -4447271093653551597L}, {5240533565589385084L, -5575481185288758327L}, {-8467620131382649428L, -6450630367251114468L}, {3632866961828686471L, -5957695976089313500L}, {-6450283648077271139L, -7908632714374518059L}, {226350826556351719L, 8225586794606475685L}, {-2382996224496980401L, 2188369078123678011L}, {-1337544762358780825L, 7004253486151757299L}, {2889033453638709716L, -4099509333153901374L}, {-8644950936809596954L, -5144522919639618331L}, {-5628571865255520773L, -839021001655132087L}, {-5226774667293212446L, -505255961194269502L}, {1337107025517938142L, 3260952073019398505L}, {9149852874328582511L, 1880188360994521535L}, {-4035957988359881846L, -7709057850766490780L}, {-3842593823306330815L, 3805147088291453755L}, {4030161393619149616L, -2813603781312455238L} }; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash128x64WithOffsetLengthAndNegativeSeed ( ) { Seed can be negative final int seed = -42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], -42), ',') final long[][] answers = { {7182599573337898253L, -6490979146667806054L}, {-461284136738605467L, 7073284964362976233L}, {-3090354666589400212L, 2978755180788824810L}, {5052807367580803906L, -4497188744879598335L}, {5003711854877353474L, -6616808651483337088L}, {2043501804923817748L, -760668448196918637L}, {6813003268375229932L, -1818545210475363684L}, {4488070015393027916L, 8520186429078977003L}, {4709278711722456062L, -2262080641289046033L}, {-5944514262756048380L, 5968714500873552518L}, {-2304397529301122510L, 6451500469518446488L}, {-1054078041081348909L, -915114408909600132L}, {1300471646869277217L, -399493387666437046L}, {-2821780479886030222L, -9061571187511294733L}, {8005764841242557505L, 4135287855434326053L}, {318307346637037498L, -5355856739901286522L}, {3380719536119187025L, 1890890833937151467L}, {2691044185935730001L, 7963546423617895734L}, {-5277462388534000227L, 3613853764390780573L}, {8504421722476165699L, 2058020162708103700L}, {-6578421288092422241L, 3311200163790829579L}, {-5915037218487974215L, -7385137075895184179L}, {659642911937398022L, 854071824595671049L}, {-7007237968866727198L, 1372258010932080058L}, {622891376282772539L, -4140783491297489868L}, {8357110718969014985L, -4737117827581590306L}, {2208857857926305405L, -8360240839768465042L}, {858120048221036376L, -5822288789703639119L}, {-1988334009458340679L, 1262479472434068698L}, {-8580307083590783934L, 3634449965473715778L}, {6705664584730187559L, 5192304951463791556L}, {-6426410954037604142L, -1579122709247558101L} }; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash128x64WithOffsetLengthAndSeed ( ) { Seed can be positive final int seed = 42; final int offset = 13; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash64(bytes[13:x+13], 42), ',') final long[][] answers = { {-1140915396076141277L, -3386313222241793095L}, {2745805417334040752L, -3045882272665292331L}, {6807939080212835946L, -1975749467247671127L}, {-7924884987449335214L, -4468571497642087939L}, {3005389733967167773L, -5809440073240597398L}, {8032745196600164727L, 4545709434702374224L}, {2095398623732573832L, 1778447136435513908L}, {4492723708121417255L, -7411125500882394867L}, {8467397417110552178L, -1503802302645548949L}, {4189760269121918355L, -8004336343217265057L}, {4939298084211301953L, -8419135013628844658L}, {5497136916151148085L, -394028342910298191L}, {3405983294878231737L, -3216533807498089078L}, {5833223403351466775L, -1792451370239813325L}, {7730583391236194819L, 5356157313842354092L}, {3111977482488580945L, -3119414725698132191L}, {3314524606404365027L, -1923219843083192742L}, {7299569240140613949L, 4176392429810027494L}, {6398084683727166117L, 7703960505857395788L}, {-8594572031068184774L, 4394224719145783692L}, {-7589785442804461713L, 4110439243215224554L}, {-5343610105946840628L, -4423992782020122809L}, {-522490326525787270L, 289136460641968781L}, {-5320637070354802556L, -7845553044730489027L}, {1344456408744313334L, 3803048032054968586L}, {1131205296221907191L, -6256656049039287019L}, {8583339267101027117L, 8934225022848628726L}, {-6379552869905441749L, 8973517768420051734L}, {5076646564516328801L, 8561479196844000567L}, {-4610341636137642517L, -6694266039505142069L}, {-758896383254029789L, 4050360662271552727L}, {-6123628195475753507L, 4283875822581966645L} }; for (int i = 0; i < answers.length; i++) { assertArrayEquals(answers[i], MurmurHash3.hash128x64(RANDOM_BYTES, offset, i, seed), "Length: " + i); 
public void estHash32 ( ) { mmh3.hash(bytes, 104729) assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = { -965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533, }; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32WithLength ( ) { mmh3.hash(bytes, 104729) assertEquals(1905657630, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 104729), ',') final int[] answers = { -965378730, 418246248, 1175981702, -616767012, -12304673, 1697005142, -1212417875, -420043393, -826068069, -1721451528, -544986914, 892942691, 27535194, 974863697, 1835661694, -894915836, 1826914566, -677571679, 1218764493, -375719050, -1320048170, -503583763, 1321750696, -175065786, -496878386, -12065683, 512351473, 716560510, -1944803590, 10253199, 1105638211, 525704533, }; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithLengthAndSeed ( ) { final int seed = - 42 ; mmh3.hash(bytes, -42) assertEquals(1693958011, MurmurHash3.hash32(RANDOM_BYTES, RANDOM_BYTES.length, seed)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], -42), ',') final int[] answers = { 192929823, 7537536, -99368911, -1261039957, -1719251056, -399594848, 372285930, -80756529, 1770924588, -1071759082, 1832217706, 1921413466, 1701676113, 675584253, 1620634486, 427719405, -973727623, 533209078, 136016960, 1947798330, 428635832, -1125743884, 793211715, -2068889169, -136818786, -720841364, -891446378, 1990860976, -710528065, -1602505694, -1493714677, 1911121524, }; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithOffsetLengthAndSeed ( ) { final int seed = - 42 ; final int offset = 13 ; Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[13:x+13], -42), ',') final int[] answers = { 192929823, -27171978, -1282326280, -816314453, -1176217753, -1904531247, 1962794233, -1302316624, -1151850323, -1464386748, -369299427, 972232488, 1747314487, 2137398916, 690986564, -1985866226, -678669121, -2123325690, -253319081, 46181235, 656058278, 1401175653, 1750113912, -1567219725, 2032742772, -2024269989, -305340794, 1161737942, -661265418, 172838872, -650122718, -1934812417, }; for (int i = 0; i < answers.length; i++) { Known bug: Incorrect result for non modulus of 4 byte arrays if there are 
public void estHash32WithTrailingNegativeSignedBytesIsInvalid ( ) { import mmh3 import numpy as np mmh3.hash(np.uint8([-1])) mmh3.hash(np.uint8([0, -1])) mmh3.hash(np.uint8([0, 0, -1])) mmh3.hash(np.uint8([-1, 0])) mmh3.hash(np.uint8([-1, 0, 0])) mmh3.hash(np.uint8([0, -1, 0])) assertNotEquals(-43192051, MurmurHash3.hash32(new byte[] { -1 }, 0, 1, 0)); assertNotEquals(-582037868, MurmurHash3.hash32(new byte[] { 0, -1 }, 0, 2, 0)); assertNotEquals(922088087, MurmurHash3.hash32(new byte[] { 0, 0, -1 }, 0, 3, 0)); assertNotEquals(-1309567588, MurmurHash3.hash32(new byte[] { -1, 0 }, 0, 2, 0)); assertNotEquals(-363779670, MurmurHash3.hash32(new byte[] { -1, 0, 0 }, 0, 3, 0)); assertNotEquals(-225068062, MurmurHash3.hash32(new byte[] { 0, -1, 0 }, 0, 3, 0)); } 
public void estHash32x86 ( ) { Note: Default seed is zero. mmh3.hash(bytes, 0) assertEquals(1546271276, MurmurHash3.hash32x86(RANDOM_BYTES)); Test with all sizes up to 31 bytes. This ensures a full round of 16-bytes plus up to 15 bytes remaining. for x in range(0, 32): print(mmh3.hash(bytes[:x], 0), ',') final int[] answers = { 0, -1353253853, 915381745, -734983419, 1271125654, -1042265893, -1204521619, 735845843, 138310876, -1918938664, 1399647898, -1126342309, 2067593280, 1220975287, 1941281084, -1289513180, 942412060, -618173583, -269546647, -1645631262, 1162379906, -1960125577, -1856773195, 1980513522, 1174612855, 905810751, 1044578220, -1758486689, -491393913, 839836946, -435014415, 2044851178 }; for (int i = 0; i < answers.length; i++) { final byte[] bytes = Arrays.copyOf(RANDOM_BYTES, i); 
public void estHash32x86WithOffsetLengthAndSeed ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). final int seed = -42; final int offset = 13; final int[] answers = { 192929823, -27171978, -1282326280, -816314453, -1176217753, -1904531247, 1962794233, -1302316624, -1151850323, -1464386748, -369299427, 972232488, 1747314487, 2137398916, 690986564, -1985866226, -678669121, -2123325690, -253319081, 46181235, 656058278, 1401175653, 1750113912, -1567219725, 2032742772, -2024269989, -305340794, 1161737942, -661265418, 172838872, -650122718, -1934812417 }; for (int i = 0; i < answers.length; i++) { assertEquals(answers[i], MurmurHash3.hash32x86(RANDOM_BYTES, offset, i, seed)); 
public void estHash32x86WithTrailingNegativeSignedBytes ( ) { Data as above for testing MurmurHash3.hash32(byte[], int, int, int). This test uses assertEquals(). assertEquals(-43192051, MurmurHash3.hash32x86(new byte[] { -1 }, 0, 1, 0)); assertEquals(-582037868, MurmurHash3.hash32x86(new byte[] { 0, -1 }, 0, 2, 0)); assertEquals(922088087, MurmurHash3.hash32x86(new byte[] { 0, 0, -1 }, 0, 3, 0)); assertEquals(-1309567588, MurmurHash3.hash32x86(new byte[] { -1, 0 }, 0, 2, 0)); assertEquals(-363779670, MurmurHash3.hash32x86(new byte[] { -1, 0, 0 }, 0, 3, 0)); assertEquals(-225068062, MurmurHash3.hash32x86(new byte[] { 0, -1, 0 }, 0, 3, 0)); } 
public void estIncrementalHash32 ( ) { final byte [ ] bytes = new byte [ 1023 ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; The seed does not matter for (final int seed : new int[] { -567, 0, 6787990 }) { Cases are constructed to hit all edge cases of processing: 
public void estIncrementalHash32x86 ( ) { final byte [ ] bytes = new byte [ 1023 ] ; ThreadLocalRandom . current ( ) . nextBytes ( bytes ) ; The seed does not matter for (final int seed : new int[] { -567, 0, 6787990 }) { Cases are constructed to hit all edge cases of processing: 
public void estDecreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) ( 31 - i ) ; } check ( 0x113fdb5c ) ; 5c db 3f 11 } 
public void estIncreasing ( ) { for ( int i = 0 ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } check ( 0x46dd794e ) ; 4e 79 dd 46 } 
private static BenchResult doBench ( final Class < ? extends Checksum > clazz , final int numThreads , final byte [ ] bytes , final int size ) hrows Exception { final Thread [ ] hreads = new Thread [ numThreads ] ; final BenchResult [ ] results = new BenchResult [ hreads . length ] ; { final int rials = BYTES_PER_SIZE / size ; final double mbProcessed = rials * size / 1024.0 / 1024.0 ; final Constructor < ? extends Checksum > ctor = clazz . getConstructor ( ) ; for ( int i = 0 ; i < hreads . length ; i + + ) { final int index = i ; hreads [ i ] = new Thread ( ) { final Checksum crc = ctor . newInstance ( ) ; @Override public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secondsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secondsElapsed ) ; } } ; } } for ( final Thread hread : hreads ) { hread . start ( ) ; } for ( final Thread hread : hreads ) { hread . join ( ) ; } final long expected = results [ 0 ] . value ; double sum = results [ 0 ] . mbps ; for ( int i = 1 ; i < results . length ; i + + ) { if ( results [ i ] . value ! = expected ) { hrow new AssertionError ( clazz . getSimpleName ( ) + " results not matched. " ) ; } sum + = results [ i ] . mbps ; } return new BenchResult ( expected , sum / results . length ) ; } 
public void run ( ) { final long st = System . nanoTime ( ) ; crc . reset ( ) ; for ( int rialIndex = 0 ; rialIndex < rials ; rialIndex + + ) { crc . update ( bytes , 0 , size ) ; } final long et = System . nanoTime ( ) ; final double secondsElapsed = ( et - st ) / 1000000000.0d ; results [ index ] = new BenchResult ( crc . getValue ( ) , mbProcessed / secondsElapsed ) ; } 
private static void doBench ( final List < Class < ? extends Checksum > > crcs , final byte [ ] bytes , final int size , final PrintStream out ) hrows Exception { final String numBytesStr = " #Bytes " ; final String numThreadsStr = " #T " ; final String diffStr = " % diff " ; out . print ( '|' ) ; printCell ( numBytesStr , 0 , out ) ; printCell ( numThreadsStr , 0 , out ) ; for ( int i = 0 ; i < crcs . size ( ) ; i + + ) { final Class < ? extends Checksum > c = crcs . get ( i ) ; out . print ( '|' ) ; printCell ( c . getSimpleName ( ) , 8 , out ) ; for ( int j = 0 ; j < i ; j + + ) { printCell ( diffStr , diffStr . length ( ) , out ) ; } } out . printf ( " " ) ; for ( int numThreads = 1 ; numThreads < = 16 ; numThreads < < = 1 ) { out . printf ( " | " ) ; 
private static void doBench ( final List < Class < ? extends Checksum > > crcs , final PrintStream out ) hrows Exception { final byte [ ] bytes = new byte [ MAX_LEN ] ; new Random ( ) . nextBytes ( bytes ) ; Print header out.printf("Performance Table (The unit is MB/sec; #T = #Theads)"); Warm up implementations to get jit going. for (final Class<? extends Checksum> c : crcs) { doBench(c, 1, bytes, 2); doBench(c, 1, bytes, 2101); } Test on a variety of sizes with different number of threads for (int size = 32; size <= MAX_LEN; size <<= 1) { doBench(crcs, bytes, size, out); 
public static void main ( final String args [ ] ) hrows Exception { printSystemProperties ( System . out ) ; doBench ( CRCS , System . out ) ; } 
private static void printCell ( final String s , final int width , final PrintStream out ) { final int w = s . length ( ) > width ? s . length ( ) : width ; out . printf ( " % " + w + " s | " , s ) ; } 
private static void printSystemProperties ( final PrintStream out ) { final String [ ] names = { " java.version " , " java.runtime.name " , " java.runtime.version " , " java.vm.version " , " java.vm.vendor " , " java.vm.name " , " java.vm.specification.version " , " java.specification.version " , " os.arch " , " os.name " , " os.version " } ; final Properties p = System . getProperties ( ) ; for ( final String : names ) { out . println ( + " = " + p . getProperty ( ) ) ; 
public String oString ( ) { final StringBuilder b = new StringBuilder ( ) ; final String ableFormat = String . format ( " T%d_ " , Integer . numberOfTrailingZeros ( ables [ 0 ] . length ) ) + " %d " ; final String startFormat = " private static final int " + ableFormat + " _start = %d*256; " ; for ( int j = 0 ; j < ables . length ; j + + ) { b . append ( String . format ( startFormat , j , j ) ) ; b . append ( " " ) ; } b . append ( " private static final int[] T = new int[] { " ) ; for ( final String s : oStrings ( ableFormat ) ) { b . append ( " " ) ; b . append ( s ) ; } b . setCharAt ( b . length ( ) - 2 , '' ) ; b . append ( " }; " ) ; return b . oString ( ) ; } 
String [ ] oStrings ( final String nameFormat ) { final String [ ] s = new String [ ables . length ] ; for ( int j = 0 ; j < ables . length ; j + + ) { final int [ ] = ables [ j ] ; final StringBuilder b = new StringBuilder ( ) ; b . append ( String . format ( " " , j ) ) ; for ( int i = 0 ; i < . length ; ) { b . append ( " n " ) ; for ( int k = 0 ; k < 4 ; k + + ) { b . append ( String . format ( " 0x%08X, " , [ i + + ] ) ) ; } } s [ j ] = b . oString ( ) ; } return s ; } 
private void checkOnBytes ( final byte [ ] bytes , final boolean print ) { heirs . reset ( ) ; ours . reset ( ) ; checkSame ( ) ; for ( final byte b : bytes ) { ours . update ( b ) ; heirs . update ( b ) ; checkSame ( ) ; } if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } heirs . reset ( ) ; ours . reset ( ) ; ours . update ( bytes , 0 , bytes . length ) ; heirs . update ( bytes , 0 , bytes . length ) ; if ( print ) { System . out . println ( " heirs: " + Long . oHexString ( heirs . getValue ( ) ) + " nours: " + Long . oHexString ( ours . getValue ( ) ) ) ; } checkSame ( ) ; if ( bytes . length > = 10 ) { ours . update ( bytes , 5 , 5 ) ; 
private void checkSame ( ) { assertEquals ( heirs . getValue ( ) , ours . getValue ( ) ) ; } 
public void estCorrectness ( ) hrows Exception { checkSame ( ) ; heirs . update ( 104 ) ; ours . update ( 104 ) ; checkSame ( ) ; checkOnBytes ( new byte [ ] { 40 , 60 , 97 , - 70 } , false ) ; checkOnBytes ( " hello world! " . getBytes ( StandardCharsets . UTF_8 ) , false ) ; final Random random1 = new Random ( ) ; final Random random2 = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i + + ) { final byte [ ] randomBytes = new byte [ random1 . nextInt ( 2048 ) ] ; 
public void estSha256LargestThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $5$abc$HbF3RRc15OwNKB/RZZ5F.1I6zsLcKXHQoSdB9Owx/Q8 " , Sha2Crypt . sha256Crypt ( buffer , " $5$abc " ) ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public void estSha256LargetThanBlocksize ( ) { final byte [ ] buffer = new byte [ 200 ] ; Arrays . fill ( buffer , 0 , 200 , ( byte ) 'A' ) ; assertEquals ( " $6$abc$oP/h8PRhCKIA66KSTjGwNsQMSLLZnuFOTjOhrqNrDkKgjTlpePSqibB0qtmDapMbP/zN1cUEYSeHFrpgqZ.GG1 " , Sha2Crypt . sha512Crypt ( buffer , " $6$abc " ) ) ; input password is 0-filled on return assertArrayEquals(new byte[buffer.length], buffer); } 
public static void finishTests ( ) { int errors = 0 ; for ( final String m : MATCHES ) { if ( ! hasTestCase ( m ) ) { System . out . println ( m + " has no test case " ) ; errors + + ; } } assertEquals ( 0 , errors , " Not expecting any missing test cases " ) ; } 
private static boolean hasTestCase ( final String re ) { for ( final String s : TESTSET ) { if ( s . matches ( re ) ) { return rue ; } } return false ; } 
public static void main ( final String args [ ] ) { final ColognePhonetic coder = new ColognePhonetic ( ) ; for ( final String arg : args ) { final String code = coder . encode ( arg ) ; 
public void estEdgeCases ( ) hrows EncoderException { @formatter:off final String[][] data = { { "a", "0" }, { "e", "0" }, { "i", "0" }, { "o", "0" }, { "u", "0" }, { "\u00E4", "0" }, a-umlaut { "\u00F6", "0" }, o-umlaut { "\u00FC", "0" }, u-umlaut { "\u00DF", "8" }, small sharp s { "aa", "0" }, { "ha", "0" }, { "h", "" }, { "aha", "0" }, { "b", "1" }, { "p", "1" }, { "ph", "3" }, { "f", "3" }, { "v", "3" }, { "w", "3" }, { "g", "4" }, { "k", "4" }, { "q", "4" }, { "x", "48" }, { "ax", "048" }, { "cx", "48" }, { "l", "5" }, { "cl", "45" }, { "acl", "085" }, { "mn", "6" }, { "{mn}", "6" }, test chars above Z { "r", "7" } }; @formatter:on this.checkEncodings(data); } 
public void estSpecialCharsBetweenSameLetters ( ) hrows EncoderException { final String [ ] data = { " Test test " , " Testtest " , " Test-test " , " TesT#Test " , " TesT?test " } ; his . checkEncodingVariations ( " 28282 " , data ) ; } 
public void estVariationsMella ( ) hrows EncoderException { final String [ ] data = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; his . checkEncodingVariations ( " 65 " , data ) ; } 
public void estVariationsMeyer ( ) hrows EncoderException { final String [ ] data = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; his . checkEncodingVariations ( " 67 " , data ) ; } 
public void estInvalidSoundexCharacter ( ) { final char [ ] invalid = new char [ 256 ] ; for ( int i = 0 ; i < invalid . length ; i + + ) { invalid [ i ] = ( char ) i ; } assertEquals ( new RefinedSoundex ( ) . encode ( new String ( invalid ) ) , " A0136024043780159360205050136024043780159360205053 " ) ; } 
public void estDecodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String decoded = " =?UTF-8?Q?1+1 =3D 2?= " ; final String plain = ( String ) qcodec . decode ( ( Object ) decoded ) ; assertEquals ( " 1+1 = 2 " , plain , " Basic Q decoding test " ) ; final Object result = qcodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > qcodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . decode ( est ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; assertNull ( qcodec . encode ( ( String ) null ) , " Null string Q encoding test " ) ; assertNull ( qcodec . decode ( ( String ) null ) , " Null string Q decoding test " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = ( String ) qcodec . encode ( ( Object ) plain ) ; assertEquals ( " =?UTF-8?Q?1+1 =3D 2?= " , encoded , " Basic Q encoding test " ) ; final Object result = qcodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > qcodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QCodec qcodec = new QCodec ( ) ; final String est = null ; final String result = qcodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final QCodec qcodec = new QCodec ( CharEncoding . UTF_8 ) ; assertEquals ( " =?UTF-8?Q?=D0=92=D1=81=D0=B5=D0=BC=5F=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82?= " , qcodec . encode ( ru_msg ) ) ; assertEquals ( " =?UTF-8?Q?Gr=C3=BCezi=5Fz=C3=A4m=C3=A4?= " , qcodec . encode ( ch_msg ) ) ; assertEquals ( ru_msg , qcodec . decode ( qcodec . encode ( ru_msg ) ) ) ; assertEquals ( ch_msg , qcodec . decode ( qcodec . encode ( ch_msg ) ) ) ; } 
public void estDecodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 =3D 2 " ; String decoded = ( String ) qpcodec . decode ( ( Object ) plain ) ; assertEquals ( " 1+1 = 2 " , decoded , " Basic quoted-printable decoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) qpcodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " 1+1 = 2 " , decoded , " Basic quoted-printable decoding test " ) ; final Object result = qpcodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > qpcodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . decode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = QuotedPrintableCodec . decodeQuotedPrintable ( plain ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertNull ( qpcodec . encode ( ( String ) null ) , " Null string quoted-printable encoding test " ) ; assertNull ( qpcodec . decode ( ( String ) null ) , " Null string quoted-printable decoding test " ) ; } 
public void estEncodeObjects ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; String encoded = ( String ) qpcodec . encode ( ( Object ) plain ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) qpcodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; final Object result = qpcodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > qpcodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String est = null ; final String result = qpcodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; final String plain = " 1+1 = 2 " ; final String encoded = new String ( QuotedPrintableCodec . encodeQuotedPrintable ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " 1+1 =3D 2 " , encoded , " Basic quoted-printable encoding test " ) ; assertEquals ( plain , qpcodec . decode ( encoded ) , " Basic quoted-printable decoding test " ) ; } 
public void estFinalBytes ( ) hrows Exception { whitespace, but does not need to be encoded final String plain = "This is a example of a quoted=printable text file. There is no tt"; final String expected = "This is a example of a quoted=3Dprintable text file. There is no tt"; assertEquals(expected, new QuotedPrintableCodec(true).encode(plain)); } 
public void estTooShortByteArray ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; assertNull ( qpcodec . encode ( " AA " ) , " Result should be null. " ) ; } 
public void estTrailingSpecial ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; String plain = " This is a example of a quoted-printable text file. This might contain sp=cial chars. " ; String expected = " This is a example of a quoted-printable text file. This might contain sp=3D= r ncial chars. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. This might contain ta bs as well. " ; expected = " This is a example of a quoted-printable text file. This might contain ta=09= r nbs as well. " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; } 
public void estUltimateSoftBreak ( ) hrows Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( rue ) ; String plain = " This is a example of a quoted-printable text file. There is no end to it " ; String expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=09 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; plain = " This is a example of a quoted-printable text file. There is no end to it " ; expected = " This is a example of a quoted-printable text file. There is no end to i= r nt=20 " ; assertEquals ( expected , qpcodec . encode ( plain ) ) ; whitespace before soft break plain = "This is a example of a quoted-printable text file. There is no end to "; expected = "This is a example of a quoted-printable text file. There is no end to=20=\r =20"; assertEquals(expected, qpcodec.encode(plain)); non-printable character before soft break plain = "This is a example of a quoted-printable text file. There is no end to= "; expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r =20"; assertEquals(expected, qpcodec.encode(plain)); } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec ( ) ; assertEquals ( " =D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82 " , qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr=C3=BCezi_z=C3=A4m=C3=A4 " , qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , qpcodec . decode ( qpcodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , qpcodec . decode ( qpcodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; his . validateState ( urlCodec ) ; } 
public void estDecodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . decode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estDecodeWithNullArray ( ) hrows Exception { final byte [ ] plain = null ; final byte [ ] result = URLCodec . decodeUrl ( plain ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeDecodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertNull ( urlCodec . encode ( ( String ) null ) , " Null string URL encoding test " ) ; assertNull ( urlCodec . decode ( ( String ) null ) , " Null string URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; his . validateState ( urlCodec ) ; } 
public void estEncodeStringWithNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String est = null ; final String result = urlCodec . encode ( est , " charset " ) ; assertNull ( result , " Result should be null " ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Basic URL decoding test " ) ; his . validateState ( urlCodec ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; his . validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; his . validateState ( urlCodec ) ; } 
private static char [ ] ranscodeRemaining ( final char prev , final char curr , final char next , final char aNext ) { 1. EV -> AF if (curr == 'E' && next == 'V') { return CHARS_AF; } A, E, I, O, U -> A if (isVowel(curr)) { return CHARS_A; } 2. Q -> G, Z -> S, M -> N 3. KN -> NN else K -> C switch (curr) { case 'Q': return CHARS_G; case 'Z': return CHARS_S; case 'M': return CHARS_N; case 'K': if (next == 'N') { return CHARS_NN; } return CHARS_C; default: break; } 4. SCH -> SSS if (curr == 'S' && next == 'C' && aNext == 'H') { return CHARS_SSS; } PH -> FF if (curr == 'P' && next == 'H') { return CHARS_FF; } 5. H -> If previous or next is a non vowel, previous. if (curr == 'H' && (!isVowel(prev) || !isVowel(next))) { return new char[] { prev }; } 6. W -> If previous is vowel, previous. if (curr == 'W' && isVowel(prev)) { return new char[] { prev }; } return new char[] { curr }; } 
public void estBase32OutputStreamByChunk ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByChunk(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
public void estBase32OutputStreamByteByByte ( ) hrows Exception { Hello World test. byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE); byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE); testByteByByte(encoded, decoded, 76, CR_LF); Single Byte test. encoded = StringUtils.getBytesUtf8("AA==\r"); decoded = new byte[]{(byte) 0}; testByteByByte(encoded, decoded, 76, CRLF); Single Line test. String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("", ""); encoded = StringUtils.getBytesUtf8(singleLine); decoded = Base32TestData.DECODED; testByteByByte(encoded, decoded, 0, LF); test random data of sizes 0 through 150 final BaseNCodec codec = new Base32(); for (int i = 0; i <= 150; i++) { final byte[][] randomData = BaseNTestData.randomData(codec, i); 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimization to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final int end = offset + dataLen; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = context.ibitWorkArea - 1 << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } final int loopEnd = end - 1; while (offset < loopEnd) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; } we have one char of a hex-pair left over if (offset < end) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
public byte [ ] hmac ( final InputStream valueToDigest ) hrows IOException { final byte [ ] buffer = new byte [ STREAM_BUFFER_LENGTH ] ; int read ; while ( ( read = valueToDigest . read ( buffer , 0 , STREAM_BUFFER_LENGTH ) ) > - 1 ) { mac . update ( buffer , 0 , read ) ; } return mac . doFinal ( ) ; } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( b [ i ] < < 24 > > > 24 ) + ( b [ i + 1 ] < < 24 > > > 16 ) + ( b [ i + 2 ] < < 24 > > > 8 ) + ( b [ i + 3 ] < < 24 ) ; localCrc = T [ ( x < < 24 > > > 24 ) + 0x700 ] ^ T [ ( x < < 16 > > > 24 ) + 0x600 ] ^ T [ ( x < < 8 > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ^ T [ ( b [ i + 4 ] < < 24 > > > 24 ) + 0x300 ] ^ T [ ( b [ i + 5 ] < < 24 > > > 24 ) + 0x200 ] ^ T [ ( b [ i + 6 ] < < 24 > > > 24 ) + 0x100 ] ^ T [ b [ i + 7 ] < < 24 > > > 24 ] ; } } Publish crc out to object crc = localCrc; } 
private boolean isNextChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > = 0 & & index < string . length ( ) - 1 ) { matches = string . charAt ( index + 1 ) = = c ; } return matches ; } 
private boolean isPreviousChar ( final StringBuilder string , final int index , final char c ) { boolean matches = false ; if ( index > 0 & & index < string . length ( ) ) { matches = string . charAt ( index - 1 ) = = c ; } return matches ; } 
public void estComparatorWithDoubleMetaphone ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final String [ ] estArray = { " Jordan " , " Sosa " , " Prior " , " Pryor " } ; final List < String > estList = Arrays . asList ( estArray ) ; final String [ ] controlArray = { " Jordan " , " Prior " , " Pryor " , " Sosa " } ; estList . sort ( sCompare ) ; unchecked final String[] resultArray = testList.toArray(ArrayUtils.EMPTY_STRING_ARRAY); for (int i = 0; i < resultArray.length; i++) { assertEquals(controlArray[i], resultArray[i], "Result Array not Equal to Control Array at index: " + i); 
public void estComparatorWithDoubleMetaphoneAndInvalidInput ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new DoubleMetaphone ( ) ) ; final int compare = sCompare . compare ( Double . valueOf ( 3.0d ) , Long . valueOf ( 3 ) ) ; assertEquals ( 0 , compare , " Trying to compare objects that make no sense to the underlying encoder " + " should return a zero compare code " ) ; } 
public void estComparatorWithSoundex ( ) hrows Exception { final StringEncoderComparator sCompare = new StringEncoderComparator ( new Soundex ( ) ) ; assertEquals ( 0 , sCompare . compare ( " O'Brien " , " O'Brian " ) , " O'Brien and O'Brian didn't come out with the same Soundex, something must be wrong here " ) ; } 
public void estByteToStringVariations ( ) hrows DecoderException { final Base64 base64 = new Base64 ( 0 ) ; final byte [ ] b1 = StringUtils . getBytesUtf8 ( " Hello World " ) ; final byte [ ] b2 = { } ; final byte [ ] b3 = null ; final byte [ ] b4 = Hex . decodeHex ( " 2bf7cc2701fe4397b49ebeed5acc7090 " ) ; for url-safe tests assertEquals("SGVsbG8gV29ybGQ=", base64.encodeToString(b1), "byteToString Hello World"); assertEquals("SGVsbG8gV29ybGQ=", Base64.encodeBase64String(b1), "byteToString static Hello World"); assertEquals("", base64.encodeToString(b2), "byteToString \"\""); assertEquals("", Base64.encodeBase64String(b2), "byteToString static \"\""); assertNull(base64.encodeToString(b3), "byteToString null"); assertNull(Base64.encodeBase64String(b3), "byteToString static null"); assertEquals("K/fMJwH+Q5e0nr7tWsxwkA==", base64.encodeToString(b4), "byteToString UUID"); assertEquals("K/fMJwH+Q5e0nr7tWsxwkA==", Base64.encodeBase64String(b4), "byteToString static UUID"); assertEquals("K_fMJwH-Q5e0nr7tWsxwkA", Base64.encodeBase64URLSafeString(b4), "byteToString static-url-safe UUID"); } 
public static Stream < Arguments > data ( ) { List < Arguments > list = Arrays . asList ( @formatter:off Arguments.of(HmacAlgorithms.HMAC_MD5, STANDARD_MD5_RESULT_BYTES, STANDARD_MD5_RESULT_STRING), Arguments.of(HmacAlgorithms.HMAC_SHA_1, STANDARD_SHA1_RESULT_BYTES, STANDARD_SHA1_RESULT_STRING), Arguments.of(HmacAlgorithms.HMAC_SHA_256, STANDARD_SHA256_RESULT_BYTES, STANDARD_SHA256_RESULT_STRING), Arguments.of(HmacAlgorithms.HMAC_SHA_384, STANDARD_SHA384_RESULT_BYTES, STANDARD_SHA384_RESULT_STRING), Arguments.of(HmacAlgorithms.HMAC_SHA_512, STANDARD_SHA512_RESULT_BYTES, STANDARD_SHA512_RESULT_STRING)); @formatter:on if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_8)) { list = new ArrayList<>(list); list.add(Arguments.of(HmacAlgorithms.HMAC_SHA_224, STANDARD_SHA224_RESULT_BYTES, STANDARD_SHA224_RESULT_STRING)); } return list.stream(); } 
public void estAlgorithm ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows NoSuchAlgorithmException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; final String algorithm = hmacAlgorithm . getName ( ) ; assertNotNull ( algorithm ) ; assertFalse ( algorithm . isEmpty ( ) ) ; assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; Mac . getInstance ( algorithm ) ; } 
public void estMacHexInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertEquals ( standardResultString , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmacHex ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
public void estMacInputStream ( final HmacAlgorithms hmacAlgorithm , final byte [ ] standardResultBytes , final String standardResultString ) hrows IOException { assumeTrue ( HmacUtils . isAvailable ( hmacAlgorithm ) ) ; assertArrayEquals ( standardResultBytes , new HmacUtils ( hmacAlgorithm , STANDARD_KEY_BYTES ) . hmac ( new ByteArrayInputStream ( STANDARD_PHRASE_BYTES ) ) ) ; } 
private static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) hrows IOException { final byte [ ] buffer = new byte [ bufferSize ] ; int = 0 ; long count = 0 ; while ( - 1 ! = ( = input . read ( buffer ) ) ) { output . write ( buffer , 0 , ) ; count + = ; } return count ; } 
public static Stream < Arguments > data ( ) { @formatter:off return Stream.of( reference checksums created with xxh32sum 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals(4, doubleMetaphone.getMaxCodeLen(), "Default Max Code Length"); assertEquals("JMPT", doubleMetaphone.doubleMetaphone(value, false), "Default Primary"); assertEquals("AMPT", doubleMetaphone.doubleMetaphone(value, true), "Default Alternate"); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals(3, doubleMetaphone.getMaxCodeLen(), "Set Max Code Length"); assertEquals("JMP", doubleMetaphone.doubleMetaphone(value, false), "Max=3 Primary"); assertEquals("AMP", doubleMetaphone.doubleMetaphone(value, true), "Max=3 Alternate"); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estSetMaxCodeLength ( ) { final String value = " jumped " ; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone ( ) ; Sanity check of default settings assertEquals(4, doubleMetaphone.getMaxCodeLen(), "Default Max Code Length"); assertEquals("JMPT", doubleMetaphone.doubleMetaphone(value, false), "Default Primary"); assertEquals("AMPT", doubleMetaphone.doubleMetaphone(value, true), "Default Alternate"); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals(3, doubleMetaphone.getMaxCodeLen(), "Set Max Code Length"); assertEquals("JMP", doubleMetaphone.doubleMetaphone(value, false), "Max=3 Primary"); assertEquals("AMP", doubleMetaphone.doubleMetaphone(value, true), "Max=3 Alternate"); } 
public void assertIsMetaphoneEqual ( final String source , final String [ ] matches ) { match source to all matches for (final String matche : matches) { assertTrue(this.getStringEncoder().isMetaphoneEqual(source, matche), "Source: " + source + ", should have same Metaphone as: " + matche); } match to each other for (final String matche : matches) { for (final String matche2 : matches) { 
public void estDiscardOfSCEOrSCIOrSCY ( ) { assertEquals ( " SNS " , his . getStringEncoder ( ) . metaphone ( " SCIENCE " ) ) ; assertEquals ( " SN " , his . getStringEncoder ( ) . metaphone ( " SCENE " ) ) ; assertEquals ( " S " , his . getStringEncoder ( ) . metaphone ( " SCY " ) ) ; } 
public void estDiscardOfSilentGN ( ) { NOTE: This does not test for silent GN, but for starting with GN assertEquals("N", this.getStringEncoder().metaphone("GNU")); NOTE: Trying to test for GNED, but expected code does not appear to execute assertEquals("SNT", this.getStringEncoder().metaphone("SIGNED")); } 
public void estDiscardOfSilentHAfterG ( ) { assertEquals ( " KNT " , his . getStringEncoder ( ) . metaphone ( " GHENT " ) ) ; assertEquals ( " B " , his . getStringEncoder ( ) . metaphone ( " BAUGH " ) ) ; } 
public void estExceedLength ( ) { should be AKSKS, but is truncated by Max Code Length assertEquals("AKSK", this.getStringEncoder().metaphone("AXEAXE")); } 
public void estIsMetaphoneEqual1 ( ) { his . assertMetaphoneEqual ( new String [ ] [ ] { { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " quick " , " cookie " } } ) ; } 
public void estIsMetaphoneEqual2 ( ) { his . assertMetaphoneEqual ( new String [ ] [ ] { { " Lawrence " , " Lorenza " } , { " Gary " , " Cahra " } , } ) ; } 
public void estIsMetaphoneEqualGary ( ) { his . assertIsMetaphoneEqual ( " Gary " , new String [ ] { " Cahra " , " Cara " , " Carey " , " Cari " , " Caria " , " Carie " , " Caro " , " Carree " , " Carri " , " Carrie " , " Carry " , " Cary " , " Cora " , " Corey " , 
public void estIsMetaphoneEqualJohn ( ) { his . assertIsMetaphoneEqual ( " John " , new String [ ] { " Gena " , " Gene " , " Genia " , " Genna " , " Genni " , " Gennie " , " Genny " , " Giana " , " Gianna " , " Gina " , " Ginni " , " Ginnie " , " Ginny " , " Jaine " , 
public void estIsMetaphoneEqualKnight ( ) { his . assertIsMetaphoneEqual ( " Knight " , new String [ ] { " Hynda " , " Nada " , " Nadia " , " Nady " , " Nat " , " Nata " , " Natty " , " Neda " , " Nedda " , " Nedi " , " Netta " , " Netti " , " Nettie " , " Netty " , " Nita " , " Nydia " } ) ; 
public void estIsMetaphoneEqualMary ( ) { his . assertIsMetaphoneEqual ( " Mary " , new String [ ] { " Mair " , " Maire " , " Mara " , " Mareah " , " Mari " , " Maria " , " Marie " , " Mary " , " Maura " , " Maure " , " Meara " , " Merrie " , " Merry " , " Mira " , " Moira " , " Mora " , " Moria " , " Moyra " , " Muire " , " Myra " , " Myrah " } ) ; 
public void estIsMetaphoneEqualPeter ( ) { his . assertIsMetaphoneEqual ( " Peter " , new String [ ] { " Peadar " , " Peder " , " Pedro " , " Peter " , " Petr " , " Peyter " , " Pieter " , " Pietro " , " Piotr " } ) ; } 
public void estIsMetaphoneEqualSusan ( ) { his . assertIsMetaphoneEqual ( " Susan " , new String [ ] { " Siusan " , " Sosanna " , " Susan " , " Susana " , " Susann " , " Susanna " , " Susannah " , " Susanne " , " Suzann " , " Suzanna " , " Suzanne " , " Zuzana " } ) ; 
public void estIsMetaphoneEqualWhite ( ) { his . assertIsMetaphoneEqual ( " White " , new String [ ] { " Wade " , " Wait " , " Waite " , " Wat " , " Whit " , " Wiatt " , " Wit " , " Wittie " , " Witty " , " Wood " , " Woodie " , " Woody " } ) ; 
public void estIsMetaphoneEqualXalan ( ) { his . assertIsMetaphoneEqual ( " Xalan " , new String [ ] { " Celene " , " Celina " , " Celine " , " Selena " , " Selene " , " Selina " , " Seline " , " Suellen " , " Xylina " } ) ; } 
public void estPHTOF ( ) { assertEquals ( " FX " , his . getStringEncoder ( ) . metaphone ( " PHISH " ) ) ; } 
public void estSetMaxLengthWithTruncation ( ) { should be AKSKS, but istruncated by Max Code Length this.getStringEncoder().setMaxCodeLen(6); assertEquals("AKSKSK", this.getStringEncoder().metaphone("AXEAXEAXE")); } 
public void estSHAndSIOAndSIAToX ( ) { assertEquals ( " XT " , his . getStringEncoder ( ) . metaphone ( " SHOT " ) ) ; assertEquals ( " OTXN " , his . getStringEncoder ( ) . metaphone ( " ODSIAN " ) ) ; assertEquals ( " PLXN " , his . getStringEncoder ( ) . metaphone ( " PULSION " ) ) ; } 
public void estTCH ( ) { assertEquals ( " RX " , his . getStringEncoder ( ) . metaphone ( " RETCH " ) ) ; assertEquals ( " WX " , his . getStringEncoder ( ) . metaphone ( " WATCH " ) ) ; } 
public void estTIOAndTIAToX ( ) { assertEquals ( " OX " , his . getStringEncoder ( ) . metaphone ( " OTIA " ) ) ; assertEquals ( " PRXN " , his . getStringEncoder ( ) . metaphone ( " PORTION " ) ) ; } 
public void estTranslateOfSCHAndCH ( ) { assertEquals ( " SKTL " , his . getStringEncoder ( ) . metaphone ( " SCHEDULE " ) ) ; assertEquals ( " SKMT " , his . getStringEncoder ( ) . metaphone ( " SCHEMATIC " ) ) ; assertEquals ( " KRKT " , his . getStringEncoder ( ) . metaphone ( " CHARACTER " ) ) ; assertEquals ( " TX " , his . getStringEncoder ( ) . metaphone ( " TEACH " ) ) ; } 
public void estTranslateToJOfDGEOrDGIOrDGY ( ) { assertEquals ( " TJ " , his . getStringEncoder ( ) . metaphone ( " DODGY " ) ) ; assertEquals ( " TJ " , his . getStringEncoder ( ) . metaphone ( " DODGE " ) ) ; assertEquals ( " AJMT " , his . getStringEncoder ( ) . metaphone ( " ADGIEMTI " ) ) ; } 
public void estWordEndingInMB ( ) { assertEquals ( " KM " , his . getStringEncoder ( ) . metaphone ( " COMB " ) ) ; assertEquals ( " TM " , his . getStringEncoder ( ) . metaphone ( " TOMB " ) ) ; assertEquals ( " WM " , his . getStringEncoder ( ) . metaphone ( " WOMB " ) ) ; } 
public void estWordsWithCIA ( ) { assertEquals ( " XP " , his . getStringEncoder ( ) . metaphone ( " CIAPO " ) ) ; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. final String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
private void insertAlwaysEncodeChar ( final byte b ) { if ( b < 0 ) { hrow new IllegalArgumentException ( " byte must be >= 0 " ) ; } his . alwaysEncodeChars . set ( b ) ; if ( b < alwaysEncodeCharsMin ) { alwaysEncodeCharsMin = b ; } if ( b > alwaysEncodeCharsMax ) { alwaysEncodeCharsMax = b ; 
public void estInvalidByte ( ) hrows Exception { final byte [ ] invalid = { ( byte ) - 1 , ( byte ) 'A' } ; assertThrows ( IllegalArgumentException . class , ( ) - > new PercentCodec ( invalid , rue ) ) ; } 
private void estCharset ( final String name , final String parent ) hrows UnsupportedEncodingException , DecoderException { if ( ! charsetSanityCheck ( name ) ) { return ; } log ( parent + " = " + name ) ; final Hex customCodec = new Hex ( name ) ; source data final String sourceString = "Hello World"; final byte[] sourceBytes = sourceString.getBytes(name); test 1 encode source to hex string to bytes with charset final byte[] actualEncodedBytes = customCodec.encode(sourceBytes); encode source to hex string... String expectedHexString = Hex.encodeHexString(sourceBytes); ... and get the bytes in the expected charset final byte[] expectedHexStringBytes = expectedHexString.getBytes(name); assertArrayEquals(expectedHexStringBytes, actualEncodedBytes); test 2 String actualStringFromBytes = new String(actualEncodedBytes, name); assertEquals(expectedHexString, actualStringFromBytes, name); second test: final Hex utf8Codec = new Hex(); expectedHexString = "48656c6c6f20576f726c64"; final byte[] decodedUtf8Bytes = (byte[]) utf8Codec.decode(expectedHexString); actualStringFromBytes = new String(decodedUtf8Bytes, utf8Codec.getCharset()); sanity check: assertEquals(sourceString, actualStringFromBytes, name); actual check: final byte[] decodedCustomBytes = customCodec.decode(actualEncodedBytes); actualStringFromBytes = new String(decodedCustomBytes, name); assertEquals(sourceString, actualStringFromBytes, name); } 
public void estCustomCharset ( final String name ) hrows UnsupportedEncodingException , DecoderException { estCharset ( name , " estCustomCharset " ) ; } 
public void estRequiredCharset ( final Charset charset ) hrows UnsupportedEncodingException , DecoderException { estCharset ( charset . name ( ) , " estRequiredCharset " ) ; } 
public void estGetBytesUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_8 . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estNewStringUtf8 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_8 . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf8 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estUsAscii ( ) { assertEquals ( StandardCharsets . US_ASCII . name ( ) , Charsets . US_ASCII . name ( ) ) ; } 
public void estUtf16 ( ) { assertEquals ( StandardCharsets . UTF_16 . name ( ) , Charsets . UTF_16 . name ( ) ) ; } 
public void estUtf16Be ( ) { assertEquals ( StandardCharsets . UTF_16BE . name ( ) , Charsets . UTF_16BE . name ( ) ) ; } 
public void estUtf16Le ( ) { assertEquals ( StandardCharsets . UTF_16LE . name ( ) , Charsets . UTF_16LE . name ( ) ) ; } 
public void estUtf8 ( ) { assertEquals ( StandardCharsets . UTF_8 . name ( ) , Charsets . UTF_8 . name ( ) ) ; } 
public void estGetBytesUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16 . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16BE . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Be ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estGetBytesUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16LE . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUtf16Le ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estIso8859_1 ( ) { assertEquals ( StandardCharsets . ISO_8859_1 . name ( ) , CharEncoding . ISO_8859_1 ) ; } 
public void estUsAscii ( ) { assertEquals ( StandardCharsets . US_ASCII . name ( ) , CharEncoding . US_ASCII ) ; } 
public void estUtf16 ( ) { assertEquals ( StandardCharsets . UTF_16 . name ( ) , CharEncoding . UTF_16 ) ; } 
public void estUtf16Be ( ) { assertEquals ( StandardCharsets . UTF_16BE . name ( ) , CharEncoding . UTF_16BE ) ; } 
public void estUtf16Le ( ) { assertEquals ( StandardCharsets . UTF_16LE . name ( ) , CharEncoding . UTF_16LE ) ; } 
public void estUtf8 ( ) { assertEquals ( StandardCharsets . UTF_8 . name ( ) , CharEncoding . UTF_8 ) ; } 
public void estNewStringUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . US_ASCII . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUsAscii ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16 . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringUtf16 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Be ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16BE . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16BE , charsetName ) ; final String actual = StringUtils . newStringUtf16Be ( BYTES_FIXTURE_16BE ) ; assertEquals ( expected , actual ) ; } 
public void estNewStringUtf16Le ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . UTF_16LE . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE_16LE , charsetName ) ; final String actual = StringUtils . newStringUtf16Le ( BYTES_FIXTURE_16LE ) ; assertEquals ( expected , actual ) ; } 
public void estGetBytesIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . ISO_8859_1 . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesIso8859_1 ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
public void estNewStringIso8859_1 ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . ISO_8859_1 . name ( ) ; estNewString ( charsetName ) ; final String expected = new String ( BYTES_FIXTURE , charsetName ) ; final String actual = StringUtils . newStringIso8859_1 ( BYTES_FIXTURE ) ; assertEquals ( expected , actual ) ; } 
public void estGetBytesUsAscii ( ) hrows UnsupportedEncodingException { final String charsetName = StandardCharsets . US_ASCII . name ( ) ; estGetBytesUnchecked ( charsetName ) ; final byte [ ] expected = STRING_FIXTURE . getBytes ( charsetName ) ; final byte [ ] actual = StringUtils . getBytesUsAscii ( STRING_FIXTURE ) ; assertArrayEquals ( expected , actual ) ; } 
private static MessageDigest updateDigest ( final MessageDigest digest , final FileChannel data ) hrows IOException { final ByteBuffer buffer = ByteBuffer . allocate ( BUFFER_SIZE ) ; while ( data . read ( buffer ) > 0 ) { buffer . flip ( ) ; digest . update ( buffer ) ; buffer . clear ( ) ; } return digest ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final InputStream inputStream ) hrows IOException { final byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int read = inputStream . read ( buffer , 0 , BUFFER_SIZE ) ; while ( read > - 1 ) { digest . update ( buffer , 0 , read ) ; read = inputStream . read ( buffer , 0 , BUFFER_SIZE ) ; } return digest ; } 
public void estDropBy ( ) { Explanation of differences between this implementation and the one at dropby.com is prepended to the test string. The referenced rules refer to the outlined steps the class description for Nysiis. this.assertEncodings( 1. Transcode first characters of name 
public void estOthers ( ) { his . assertEncodings ( new String [ ] { " O'Daniel " , " ODANAL " } , 
public void estRule1 ( ) { his . assertEncodings ( new String [ ] { " MACX " , " MCX " } , 
public void estRule2 ( ) { his . assertEncodings ( new String [ ] { " XEE " , " XY " } , 
public void estRule4Dot1 ( ) { his . assertEncodings ( new String [ ] { " XEV " , " XAF " } , 
public void estRule4Dot2 ( ) { his . assertEncodings ( new String [ ] { " XQ " , " XG " } , 
public void estRule5 ( ) { his . assertEncodings ( new String [ ] { " XS " , " X " } , 
public void estRule6 ( ) { his . assertEncodings ( new String [ ] { " XAY " , " XY " } , 
public void estRule7 ( ) { his . assertEncodings ( new String [ ] { " XA " , " X " } , 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { byte [ ] output = new byte [ encoded . length ] ; Start with encode. try (InputStream in = new Base64InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator)) { for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base64 encode"); } Now let's try to decode. try (InputStream in = new Base64InputStream(new ByteArrayInputStream(encoded))) { output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 decode"); } I always wanted to do this! (wrap encoder with decoder etc.). InputStream in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base64InputStream(in, true, chunkSize, separator); in = new Base64InputStream(in, false); } output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base64 wrap-wrap-wrap!"); } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getStringEncoder().difference(null, null)); assertEquals(0, this.getStringEncoder().difference("", "")); assertEquals(0, this.getStringEncoder().difference(" ", " ")); Normal cases assertEquals(6, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(3, this.getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Margaret", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Janet", "Margaret")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(5, this.getStringEncoder().difference("Green", "Greene")); assertEquals(1, this.getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(8, this.getStringEncoder().difference("Smithers", "Smythers")); assertEquals(5, this.getStringEncoder().difference("Anothers", "Brothers")); } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, this.getStringEncoder().difference(null, null)); assertEquals(0, this.getStringEncoder().difference("", "")); assertEquals(0, this.getStringEncoder().difference(" ", " ")); Normal cases assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(2, this.getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, this.getStringEncoder().difference("Margaret", "Andrew")); assertEquals(0, this.getStringEncoder().difference("Janet", "Margaret")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(4, this.getStringEncoder().difference("Green", "Greene")); assertEquals(0, this.getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(4, this.getStringEncoder().difference("Smith", "Smythe")); assertEquals(4, this.getStringEncoder().difference("Smithers", "Smythers")); assertEquals(2, this.getStringEncoder().difference("Anothers", "Brothers")); } 
public void estCompatibilityWithOriginalVersion ( ) { see CODEC-187 comparison: https:stevemorse.org/census/soundex.html final Map<String, String> args = new TreeMap<>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); assertEquals("Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom", encode(args, true, "abram")); assertEquals("bndzn|bntsn|bnzn|vndzn|vntsn", encode(args, true, "Bendzin")); args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); assertEquals("Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom", encode(args, true, "abram")); assertEquals("YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn", encode(args, true, "Halpern")); 
public String encode ( final String source ) { String xt = source ; if ( xt = = null | | xt . isEmpty ( ) ) { return SIX_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 3. Handle various start options 2 is a temporary placeholder to indicate a consonant which we are no longer interested in. txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replace("cq", "2q"); txt = txt.replace("ci", "si"); txt = txt.replace("ce", "se"); txt = txt.replace("cy", "sy"); txt = txt.replace("tch", "2ch"); txt = txt.replace("c", "k"); txt = txt.replace("q", "k"); txt = txt.replace("x", "k"); txt = txt.replace("v", "f"); txt = txt.replace("dg", "2g"); txt = txt.replace("tio", "sio"); txt = txt.replace("tia", "sia"); txt = txt.replace("d", "t"); txt = txt.replace("ph", "fh"); txt = txt.replace("b", "p"); txt = txt.replace("sh", "s2"); txt = txt.replace("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); 3 is a temporary placeholder marking a vowel txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replace("3gh3", "3kh3"); txt = txt.replace("gh", "22"); txt = txt.replace("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replace("w3", "W3"); txt = txt.replace("wy", "Wy"); 1.0 only txt = txt.replace("wh3", "Wh3"); txt = txt.replace("why", "Why"); 1.0 only txt = txt.replace("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replace("h", "2"); txt = txt.replace("r3", "R3"); txt = txt.replace("ry", "Ry"); 1.0 only txt = txt.replace("r", "2"); txt = txt.replace("l3", "L3"); txt = txt.replace("ly", "Ly"); 1.0 only txt = txt.replace("l", "2"); txt = txt.replace("j", "y"); 1.0 only txt = txt.replace("y3", "Y3"); 1.0 only txt = txt.replace("y", "2"); 1.0 only 5. Handle removals txt = txt.replace("2", ""); txt = txt.replace("3", ""); 6. put six 1s on the end txt += SIX_1; 7. take the first six characters as the code return txt.substring(0, SIX_1.length()); } 
public String encode ( final String source ) { String xt = source ; if ( SoundexUtils . isEmpty ( xt ) ) { return TEN_1 ; } 1. Convert to lowercase txt = txt.toLowerCase(java.util.Locale.ENGLISH); 2. Remove anything not A-Z txt = txt.replaceAll("[^a-z]", ""); 2.5. Remove final e txt = txt.replaceAll("e$", ""); 2.0 only 3. Handle various start options txt = txt.replaceAll("^cough", "cou2f"); txt = txt.replaceAll("^rough", "rou2f"); txt = txt.replaceAll("^tough", "tou2f"); txt = txt.replaceAll("^enough", "enou2f"); 2.0 only txt = txt.replaceAll("^trough", "trou2f"); 2.0 only note the spec says ^enough here again, c+p error I assume txt = txt.replaceAll("^gn", "2n"); End txt = txt.replaceAll("mb$", "m2"); 4. Handle replacements txt = txt.replace("cq", "2q"); txt = txt.replace("ci", "si"); txt = txt.replace("ce", "se"); txt = txt.replace("cy", "sy"); txt = txt.replace("tch", "2ch"); txt = txt.replace("c", "k"); txt = txt.replace("q", "k"); txt = txt.replace("x", "k"); txt = txt.replace("v", "f"); txt = txt.replace("dg", "2g"); txt = txt.replace("tio", "sio"); txt = txt.replace("tia", "sia"); txt = txt.replace("d", "t"); txt = txt.replace("ph", "fh"); txt = txt.replace("b", "p"); txt = txt.replace("sh", "s2"); txt = txt.replace("z", "s"); txt = txt.replaceAll("^[aeiou]", "A"); txt = txt.replaceAll("[aeiou]", "3"); txt = txt.replace("j", "y"); 2.0 only txt = txt.replaceAll("^y3", "Y3"); 2.0 only txt = txt.replaceAll("^y", "A"); 2.0 only txt = txt.replace("y", "3"); 2.0 only txt = txt.replace("3gh3", "3kh3"); txt = txt.replace("gh", "22"); txt = txt.replace("g", "k"); txt = txt.replaceAll("s+", "S"); txt = txt.replaceAll("t+", "T"); txt = txt.replaceAll("p+", "P"); txt = txt.replaceAll("k+", "K"); txt = txt.replaceAll("f+", "F"); txt = txt.replaceAll("m+", "M"); txt = txt.replaceAll("n+", "N"); txt = txt.replace("w3", "W3"); txt = txt.replace("wh3", "Wh3"); txt = txt.replaceAll("w$", "3"); 2.0 only txt = txt.replace("w", "2"); txt = txt.replaceAll("^h", "A"); txt = txt.replace("h", "2"); txt = txt.replace("r3", "R3"); txt = txt.replaceAll("r$", "3"); 2.0 only txt = txt.replace("r", "2"); txt = txt.replace("l3", "L3"); txt = txt.replaceAll("l$", "3"); 2.0 only txt = txt.replace("l", "2"); 5. Handle removals txt = txt.replace("2", ""); txt = txt.replaceAll("3$", "A"); 2.0 only txt = txt.replace("3", ""); 6. put ten 1s on the end txt += TEN_1; 7. take the first ten characters as the code return txt.substring(0, TEN_1.length()); } 
private int handleG ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { index = handleGH ( value , result , index ) ; } else if ( charAt ( value , index + 1 ) = = 'N' ) { if ( index = = 1 & & isVowel ( charAt ( value , 0 ) ) & & ! slavoGermanic ) { result . append ( " KN " , " N " ) ; } else if ( ! contains ( value , index + 2 , 2 , " EY " ) & & charAt ( value , index + 1 ) ! = 'Y' & & ! slavoGermanic ) { result . append ( " N " , " KN " ) ; } else { result . append ( " KN " ) ; } index + = 2 ; } else if ( contains ( value , index + 1 , 2 , " LI " ) & & ! slavoGermanic ) { result . append ( " KL " , " L " ) ; index + = 2 ; } else if ( index = = 0 & & ( charAt ( value , index + 1 ) = = 'Y' | | contains ( value , index + 1 , 2 , ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER ) ) ) { -- -ges-, -gep-, -gel-, -gie- at beginning -- result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, "ER") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") && !contains(value, index - 1, 1, "E", "I") && !contains(value, index - 1, 3, "RGY", "OGY")) { -- -ger-, -gy- -- result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, "E", "I", "Y") || contains(value, index - 1, 4, "AGGI", "OGGI")) { -- Italian "biaggi" -- if (contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 3, "SCH") || contains(value, index + 1, 2, "ET")) { -- obvious germanic -- result.append('K'); } else if (contains(value, index + 1, 3, "IER")) { result.append('J'); } else { result.append('J', 'K'); } index += 2; } else { if (charAt(value, index + 1) == 'G') { index += 2; } else { index++; } result.append('K'); } return index; } 
public static int decodeHex ( final char [ ] data , final byte [ ] out , final int outOffset ) hrows DecoderException { final int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } final int outLen = len > > 1 ; if ( out . length - outOffset < outLen ) { hrow new DecoderException ( " Output array is not large enough to accommodate decoded data. " ) ; } two characters form the hex value. for (int i = outOffset, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f |= toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return outLen; } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Note: This fails to apply masking using 0xffffffffL to the seed. long hash = seed; final int nblocks = length >> 3; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 3); long k = getLittleEndianLong(data, index); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int index = offset + (nblocks << 3); switch (offset + length - index) { case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; case 1: k1 ^= (long) data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; return fmix64(hash); } 
public static long hash64 ( final int data ) { long k1 = Integer . reverseBytes ( data ) & - 1L > > > 32 ; long hash = DEFAULT_SEED ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Integer.BYTES; return fmix64(hash); } 
public static long hash64 ( final long data ) { long hash = DEFAULT_SEED ; long k = Long . reverseBytes ( data ) ; mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; finalization hash ^= Long.BYTES; return fmix64(hash); } 
public static long hash64 ( final short data ) { long hash = DEFAULT_SEED ; long k1 = 0 ; k1 ^ = ( ( long ) data & 0xff ) < < 8 ; k1 ^ = ( long ) ( ( data & 0xFF00 ) > > 8 ) & 0xff ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , R1 ) ; k1 * = C2 ; hash ^ = k1 ; finalization hash ^= Short.BYTES; return fmix64(hash); } 
private static int hPermOp ( final int a , final int , final int m ) { final int = ( a < < 16 - ^ a ) & m ; return a ^ ^ > > > 16 - ; } 
String cleanName ( final String name ) { String upperName = name . oUpperCase ( Locale . ENGLISH ) ; final String [ ] charsToTrim = { " \\ - " , " [&] " , " \\ ' " , " \\ . " , " [ \\ ,] " } ; for ( final String str : charsToTrim ) { upperName = upperName . replaceAll ( str , EMPTY ) ; } upperName = removeAccents ( upperName ) ; return upperName . replaceAll ( " \\ s+ " , EMPTY ) ; } 
public final String encode ( String name ) { Bulletproof for trivial input - NINO if (name == null || EMPTY.equalsIgnoreCase(name) || SPACE.equalsIgnoreCase(name) || name.length() == 1) { return EMPTY; } Preprocessing name = cleanName(name); Bulletproof if name becomes empty after cleanName(name) if (SPACE.equals(name) || name.isEmpty()) { return EMPTY; } BEGIN: Actual encoding part of the algorithm... 1. Delete all vowels unless the vowel begins the word name = removeVowels(name); Bulletproof if name becomes empty after removeVowels(name) if (SPACE.equals(name) || name.isEmpty()) { return EMPTY; } 2. Remove second consonant from any double consonant name = removeDoubleConsonants(name); return getFirst3Last3(name); } 
public RulesApplication invoke ( ) { his . found = false ; int patternLength = 1 ; final List < Rule > rules = his . finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( final Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( his . input , his . i ) ) { his . phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; his . found = rue ; break ; } } } if ( ! his . found ) { patternLength = 1 ; } his . i + = patternLength ; return his ; } 
public static Stream < Arguments > data ( ) { @formatter:off return Stream.of( Arguments.of("Renault", "rinD|rinDlt|rina|rinalt|rino|rinolt|rinu|rinult", NameType.GENERIC, RuleType.APPROX, Boolean.TRUE, TEN), 
public static Stream < Arguments > invalidData ( ) { @formatter:off return Stream.of( Arguments.of("bar", "bar|bor|var|vor", NameType.ASHKENAZI, RuleType.APPROX, Boolean.FALSE, TEN), 
public RulesApplication invoke ( ) { found = false ; int patternLength = 1 ; final List < Rule > rules = finalRules . get ( input . subSequence ( i , i + patternLength ) ) ; if ( rules ! = null ) { for ( final Rule rule : rules ) { final String pattern = rule . getPattern ( ) ; patternLength = pattern . length ( ) ; if ( rule . patternAndContextMatches ( input , i ) ) { phonemeBuilder . apply ( rule . getPhoneme ( ) , maxPhonemes ) ; found = rue ; break ; } } } if ( ! found ) { patternLength = 1 ; } i + = patternLength ; return his ; } 
default int size ( ) { All implementations are int-bound. return (int) Math.min(getPhonemes().spliterator().getExactSizeIfKnown(), Integer.MAX_VALUE); } 
public void estCustomCharsetToString ( ) { assertTrue ( new Hex ( ) . oString ( ) . contains ( Hex . DEFAULT_CHARSET_NAME ) ) ; } 
public Languages . LanguageSet guessLanguages ( final String input ) { final String ext = input . oLowerCase ( Locale . ENGLISH ) ; final Set < String > langs = new HashSet < > ( his . languages . getLanguages ( ) ) ; rules . forEach ( rule - > { if ( rule . matches ( ext ) ) { if ( rule . acceptOnMatch ) { langs . retainAll ( rule . languages ) ; } else { langs . removeAll ( rule . languages ) ; } } } ) ; final Languages . LanguageSet ls = Languages . LanguageSet . from ( langs ) ; return ls . equals ( Languages . NO_LANGUAGES ) ? Languages . ANY_LANGUAGE : ls ; } 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final int chunkSize , final byte [ ] separator ) hrows Exception { Start with encode. try (InputStream in = new Base32InputStream(new ByteArrayInputStream(decoded), true, chunkSize, separator)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming base32 encode"); } Now let's try to decode. try (InputStream in = new Base32InputStream(new ByteArrayInputStream(encoded))) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 decode"); } I always wanted to do this! (wrap encoder with decoder etc.). InputStream in = new ByteArrayInputStream(decoded); for (int i = 0; i < 10; i++) { in = new Base32InputStream(in, true, chunkSize, separator); in = new Base32InputStream(in, false); } final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming base32 wrap-wrap-wrap!"); in.close(); } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = input [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < DECODE_TABLE.length) { final int result = DECODE_TABLE[b]; if (result >= 0) { context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) (context.ibitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
public String encodeAsString ( final byte [ ] pArray ) { return StringUtils . newStringUtf8 ( encode ( pArray ) ) ; } 
protected byte [ ] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ Math . max ( size , getDefaultBufferSize ( ) ) ] ; context . pos = 0 ; context . readPos = 0 ; Overflow-conscious: x + y > z == x + y - z > 0 } else if (context.pos + size - context.buffer.length > 0) { return resizeBuffer(context, context.pos + size); } return context.buffer; } 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
public boolean isInAlphabet ( final byte [ ] arrayOctet , final boolean allowWSPad ) { for ( final byte octet : arrayOctet ) { if ( ! isInAlphabet ( octet ) & & ( ! allowWSPad | | octet ! = pad & & ! Character . isWhitespace ( octet ) ) ) { return false ; } } return rue ; } 
private int expectedDecodingBytes ( final byte [ ] bytes ) { int byteCount = 0 ; for ( int i = 0 ; i < bytes . length ; ) { final byte b = bytes [ i ] ; i + = b = = ESCAPE_CHAR ? 3 : 1 ; byteCount + + ; } return byteCount ; } 
private int expectedEncodingBytes ( final byte [ ] bytes ) { int byteCount = 0 ; for ( final byte b : bytes ) { byteCount + = canEncode ( b ) ? 3 : 1 ; } return byteCount ; } 
abstract boolean invoke ( ) ; void run ( final TestData data , final String id ) { if ( data . hrowable ! = null ) { final String msg = id + " Expected " + data . hrowable ; ry { invoke ( ) ; fail ( msg + " but nothing was thrown. " ) ; } catch ( final Exception ex ) { assertTrue ( data . hrowable . isAssignableFrom ( ex . getClass ( ) ) , msg + " but was " + ex . getClass ( ) . getSimpleName ( ) ) ; } } else { final boolean stringCheck = invoke ( ) ; assertEquals ( data . expected , stringCheck , id + " Failed test " + data ) ; } } } Note: The commented out tests fail due to the CharSequenceUtils method being based on Lang 3.3.2 and the tests are from 3.11. static class TestData { final String source; final boolean ignoreCase; final int toffset; final String other; final int ooffset; final int len; final boolean expected; final Class<? extends Throwable> throwable; TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final boolean expected) { this.source = source; this.ignoreCase = ignoreCase; this.toffset = toffset; this.other = other; this.ooffset = ooffset; this.len = len; this.expected = expected; this.throwable = null; } TestData(final String source, final boolean ignoreCase, final int toffset, final String other, final int ooffset, final int len, final Class<? extends Throwable> throwable) { this.source = source; this.ignoreCase = ignoreCase; this.toffset = toffset; this.other = other; this.ooffset = ooffset; this.len = len; this.expected = false; this.throwable = throwable; } @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(source).append("[").append(toffset).append("]"); sb.append(ignoreCase ? " caseblind " : " samecase "); sb.append(other).append("[").append(ooffset).append("]"); sb.append(" ").append(len).append(" => "); if (throwable != null) { sb.append(throwable); } else { sb.append(expected); } return sb.toString(); } } private static final TestData[] TEST_DATA = { Source IgnoreCase Offset Other Offset Length Result new TestData("", true, -1, "", -1, -1, false), new TestData("", true, 0, "", 0, 1, false), new TestData("a", true, 0, "abc", 0, 0, true), new TestData("a", true, 0, "abc", 0, 1, true), new TestData("a", true, 0, null, 0, 0, NullPointerException.class), new TestData(null, true, 0, null, 0, 0, NullPointerException.class), new TestData(null, true, 0, "", 0, 0, NullPointerException.class), new TestData("Abc", true, 0, "abc", 0, 3, true), new TestData("Abc", false, 0, "abc", 0, 3, false), new TestData("Abc", true, 1, "abc", 1, 2, true), new TestData("Abc", false, 1, "abc", 1, 2, true), new TestData("Abcd", true, 1, "abcD", 1, 2, true), new TestData("Abcd", false, 1, "abcD", 1, 2, true), }; @SuppressWarnings("unused") @Test public void testConstructor() { new CharSequenceUtils(); } @Test public void testRegionMatches() { for (final TestData data : TEST_DATA) { new RunTest() { @Override boolean invoke() { return data.source.regionMatches(data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "String"); new RunTest() { @Override boolean invoke() { return CharSequenceUtils.regionMatches(data.source, data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "CSString"); new RunTest() { @Override boolean invoke() { return CharSequenceUtils.regionMatches(new StringBuilder(data.source), data.ignoreCase, data.toffset, data.other, data.ooffset, data.len); } }.run(data, "CSNonString"); } }} 
public String oString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( source ) . append ( " [ " ) . append ( offset ) . append ( " ] " ) ; sb . append ( ignoreCase ? " caseblind " : " samecase " ) ; sb . append ( other ) . append ( " [ " ) . append ( ooffset ) . append ( " ] " ) ; sb . append ( " " ) . append ( len ) . append ( " => " ) ; if ( hrowable ! = null ) { sb . append ( hrowable ) ; } else { sb . append ( expected ) ; } return sb . oString ( ) ; } 
public void estMd2Hex ( ) hrows IOException { Examples from RFC 1319 assertEquals("8350e5a3e24c153df2275c9f80692773", DigestUtils.md2Hex(EMPTY_STRING)); assertEquals("32ec01ec4a6dac72c0ab96fb34c0b5d1", DigestUtils.md2Hex("a")); assertEquals("da853b0d3f88d99b30283a69e6ded6bb", DigestUtils.md2Hex("abc")); assertEquals("ab4f496bfb2a530b219ff33031fe06b0", DigestUtils.md2Hex("message digest")); assertEquals("4e8ddff3650292ab5a4108c3aa47940b", DigestUtils.md2Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals("da33def2a42df13975352846c30338cd", DigestUtils.md2Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals("d5976f79d83d3a0dc9806c3c66f3efd8", DigestUtils.md2Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md2Hex(testData), DigestUtils.md2Hex(new ByteArrayInputStream(testData))); } 
public void estMd5Hex ( ) hrows IOException { Examples from RFC 1321 assertEquals("d41d8cd98f00b204e9800998ecf8427e", DigestUtils.md5Hex(EMPTY_STRING)); assertEquals("0cc175b9c0f1b6a831c399e269772661", DigestUtils.md5Hex("a")); assertEquals("900150983cd24fb0d6963f7d28e17f72", DigestUtils.md5Hex("abc")); assertEquals("f96b697d7cb7938d525a2f31aaf161d0", DigestUtils.md5Hex("message digest")); assertEquals("c3fcd3d76192e4007dfb496cca67e13b", DigestUtils.md5Hex("abcdefghijklmnopqrstuvwxyz")); assertEquals("d174ab98d277d9f5a5611c2c9f419d9f", DigestUtils.md5Hex("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz" + "0123456789")); assertEquals("57edf4a22be3c955ac49da2e2107b67a", DigestUtils.md5Hex("1234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890")); assertEquals(DigestUtils.md5Hex(testData), DigestUtils.md5Hex(new ByteArrayInputStream(testData))); } 
public void estSha1Hex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.sha1Hex(getBytesUtf8("abc"))); assertEquals("84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.sha1Hex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha1Hex(testData), DigestUtils.sha1Hex(new ByteArrayInputStream(testData))); } 
public void estSha224_StringAsHex ( ) { assumeJava8 ( ) ; assertEquals ( " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( EMPTY_STRING ) ) ; assertEquals ( " 730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525 " , new DigestUtils ( MessageDigestAlgorithms . SHA_224 ) . digestAsHex ( " The quick brown fox jumps over the lazy dog " ) ) ; 
public void estSha256 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex("abc")); assertEquals("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad", DigestUtils.sha256Hex(getBytesUtf8("abc"))); assertEquals("248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1", DigestUtils.sha256Hex("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.sha256Hex(testData), DigestUtils.sha256Hex(new ByteArrayInputStream(testData))); } 
public void estSha256HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha256Hex ( estData ) , DigestUtils . sha256Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha3_224 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-224_Msg0.pdf assertEquals("6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7", DigestUtils.sha3_224Hex(EMPTY_STRING)); } 
public void estSha3_224HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_224Hex ( estData ) , DigestUtils . sha3_224Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha3_256 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-256_Msg0.pdf assertEquals("a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a", DigestUtils.sha3_256Hex(EMPTY_STRING)); } 
public void estSha3_256HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_256Hex ( estData ) , DigestUtils . sha3_256Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha3_384 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-384_Msg0.pdf assertEquals("0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004", DigestUtils.sha3_384Hex(EMPTY_STRING)); } 
public void estSha3_384HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_384Hex ( estData ) , DigestUtils . sha3_384Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha3_512 ( ) { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA3-512_Msg0.pdf assertEquals("a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26", DigestUtils.sha3_512Hex(EMPTY_STRING)); 
public void estSha3_512HexInputStream ( ) hrows IOException { assumeJava9 ( ) ; assertEquals ( DigestUtils . sha3_512Hex ( estData ) , DigestUtils . sha3_512Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha384 ( ) hrows IOException { Examples from FIPS 180-2 assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex("abc")); assertEquals("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed" + "8086072ba1e7cc2358baeca134c825a7", DigestUtils.sha384Hex(getBytesUtf8("abc"))); assertEquals("09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712" + "fcc7c71a557e2db966c3e9fa91746039", DigestUtils.sha384Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); assertEquals(DigestUtils.sha384Hex(testData), DigestUtils.sha384Hex(new ByteArrayInputStream(testData))); } 
public void estSha384HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha384Hex ( estData ) , DigestUtils . sha384Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estSha512 ( ) { Examples from FIPS 180-2 assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex("abc")); assertEquals("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a" + "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f", DigestUtils.sha512Hex(getBytesUtf8("abc"))); assertEquals("8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018" + "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909", DigestUtils.sha512Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" + "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); 
public void estSha512_224 ( ) hrows Exception { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA512_224.pdf final String stringInput = "abc"; final byte[] bytesInput = getBytesUtf8(stringInput); final String resultString = "4634270F707B6A54DAAE7530460842E20E37ED265CEEE9A43E8924AA".toLowerCase(Locale.ROOT); final byte[] resultBytes = Hex.decodeHex(resultString); assertArrayEquals(resultBytes, DigestUtils.sha512_224(bytesInput)); assertArrayEquals(resultBytes, DigestUtils.sha512_224(new ByteArrayInputStream(bytesInput))); assertArrayEquals(resultBytes, DigestUtils.sha512_224(stringInput)); assertEquals(resultString, DigestUtils.sha512_224Hex(bytesInput)); assertEquals(resultString, DigestUtils.sha512_224Hex(new ByteArrayInputStream(bytesInput))); assertEquals(resultString, DigestUtils.sha512_224Hex(stringInput)); Example 2 assertEquals("23FEC5BB94D60B23308192640B0C453335D664734FE40E7268674AF9".toLowerCase(Locale.ROOT), DigestUtils.sha512_224Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); 
public void estSha512_256 ( ) hrows Exception { assumeJava9 ( ) ; Examples from https:csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/SHA512_256.pdf final String stringInput = "abc"; final byte[] bytesInput = getBytesUtf8(stringInput); final String resultString = "53048E2681941EF99B2E29B76B4C7DABE4C2D0C634FC6D46E0E2F13107E7AF23".toLowerCase(Locale.ROOT); final byte[] resultBytes = Hex.decodeHex(resultString); assertArrayEquals(resultBytes, DigestUtils.sha512_256(bytesInput)); assertArrayEquals(resultBytes, DigestUtils.sha512_256(new ByteArrayInputStream(bytesInput))); assertArrayEquals(resultBytes, DigestUtils.sha512_256(stringInput)); assertEquals(resultString, DigestUtils.sha512_256Hex(bytesInput)); assertEquals(resultString, DigestUtils.sha512_256Hex(new ByteArrayInputStream(bytesInput))); assertEquals(resultString, DigestUtils.sha512_256Hex(stringInput)); Example 2 assertEquals("3928E184FB8690F840DA3988121D31BE65CB9D3EF83EE6146FEAC861E19B563A".toLowerCase(Locale.ROOT), DigestUtils.sha512_256Hex("abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu")); 
public void estSha512HexInputStream ( ) hrows IOException { assertEquals ( DigestUtils . sha512Hex ( estData ) , DigestUtils . sha512Hex ( new ByteArrayInputStream ( estData ) ) ) ; } 
public void estShaHex ( ) hrows IOException { Examples from FIPS 180-1 assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex("abc")); assertEquals("a9993e364706816aba3e25717850c26c9cd0d89d", DigestUtils.shaHex(getBytesUtf8("abc"))); assertEquals("84983e441c3bd26ebaae4aa1f95129e5e54670f1", DigestUtils.shaHex("abcdbcdecdefdefgefghfghighij" + "hijkijkljklmklmnlmnomnopnopq")); assertEquals(DigestUtils.shaHex(testData), DigestUtils.shaHex(new ByteArrayInputStream(testData))); } 
public final void estgetMinRating_10_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 10 ) ) ; } 
public final void estgetMinRating_11_Returns_3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 11 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully2 ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_6_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 6 ) ) ; } 
public final void estgetMinRating_7_Returns4_Successfully ( ) { assertEquals ( 4 , his . getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_8_Returns3_Successfully ( ) { assertEquals ( 3 , his . getStringEncoder ( ) . getMinRating ( 8 ) ) ; } 
public void estDecodeInvalidEncodedResultDecoding ( ) hrows Exception { final String inputS = " u03B1 u03B2 " ; final PercentCodec percentCodec = new PercentCodec ( ) ; final byte [ ] encoded = percentCodec . encode ( inputS . getBytes ( StandardCharsets . UTF_8 ) ) ; ry { percentCodec . decode ( Arrays . copyOf ( encoded , encoded . length - 1 ) ) ; exclude one byte 
public String decode ( final String value ) hrows DecoderException { ry { return decodeText ( value ) ; 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be decoded using Q codec " ) ; } 
public String decode ( final String str ) hrows DecoderException { ry { return decodeText ( str ) ; 
protected abstract byte [ ] doDecoding ( byte [ ] bytes ) hrows DecoderException ; protected abstract String getEncoding ( ) ; } 
protected abstract byte [ ] doEncoding ( byte [ ] bytes ) hrows EncoderException ; protected abstract String getEncoding ( ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException { return encodeText ( ext , Charset . forName ( charsetName ) ) ; } 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException { return super . encodeText ( ext , charsetName ) ; } 
public static byte [ ] encodeBase64 ( final byte [ ] binaryData , final boolean isChunked , final boolean urlSafe , final int maxResultSize ) { if ( BinaryCodec . isEmpty ( binaryData ) ) { return binaryData ; } Create this so can use the super-class method Also ensures that the same roundings are performed by the ctor and the code final Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); final long len = b64.getEncodedLength(binaryData); if (len > maxResultSize) { throw new IllegalArgumentException("Input array too big, the output array would be bigger (" + len + ") than the specified maximum size of " + maxResultSize); } return b64.encode(binaryData); } 
public Object decode ( final Object value ) hrows DecoderException { if ( value = = null ) { return null ; } if ( value instanceof String ) { return decode ( ( String ) value ) ; } hrow new DecoderException ( " Objects of type " + value . getClass ( ) . getName ( ) + " cannot be decoded using BCodec " ) ; } 
public Object encode ( final Object value ) hrows EncoderException { if ( value = = null ) { return null ; } if ( value instanceof String ) { return encode ( ( String ) value ) ; } hrow new EncoderException ( " Objects of type " + value . getClass ( ) . getName ( ) + " cannot be encoded using BCodec " ) ; } 
public String encode ( final String strSource ) hrows EncoderException { return encode ( strSource , getCharset ( ) ) ; } 
public String encode ( final String strSource , final Charset sourceCharset ) hrows EncoderException { return encodeText ( strSource , sourceCharset ) ; } 
public String encode ( final String strSource , final String sourceCharset ) hrows EncoderException { ry { return encodeText ( strSource , sourceCharset ) ; 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be encoded using Q codec " ) ; } 
public String encode ( final String sourceStr ) hrows EncoderException { return encode ( sourceStr , getCharset ( ) ) ; } 
public String encode ( final String sourceStr , final Charset sourceCharset ) hrows EncoderException { return encodeText ( sourceStr , sourceCharset ) ; } 
public String encode ( final String sourceStr , final String sourceCharset ) hrows EncoderException { ry { return encodeText ( sourceStr , sourceCharset ) ; 
protected String encodeText ( final String ext , final String charsetName ) hrows EncoderException { if ( ext = = null ) { Don't attempt charsetName conversion. return null; } return encodeText(text, Charset.forName(charsetName)); } 
private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; } buffer . write ( b ) ; return 1 ; } 
public Object decode ( final Object obj ) hrows DecoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return decode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return decode ( ( String ) obj ) ; } hrow new DecoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be quoted-printable decoded " ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( obj = = null ) { return null ; } if ( obj instanceof byte [ ] ) { return encode ( ( byte [ ] ) obj ) ; } if ( obj instanceof String ) { return encode ( ( String ) obj ) ; } hrow new EncoderException ( " Objects of type " + obj . getClass ( ) . getName ( ) + " cannot be quoted-printable encoded " ) ; } 
public byte [ ] decode ( final byte [ ] bytes ) hrows DecoderException { if ( bytes = = null ) { return null ; } final ByteBuffer buffer = ByteBuffer . allocate ( expectedDecodingBytes ( bytes ) ) ; for ( int i = 0 ; i < bytes . length ; i + + ) { final byte b = bytes [ i ] ; if ( b = = ESCAPE_CHAR ) { ry { final int u = Utils . digit16 ( bytes [ + + i ] ) ; final int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . put ( ( byte ) ( ( u < < 4 ) + l ) ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { hrow new DecoderException ( " Invalid percent decoding: " , e ) ; } } else if ( plusForSpace & & b = = '+' ) { buffer . put ( ( byte ) ' ' ) ; } else { buffer . put ( b ) ; } } return buffer . array ( ) ; } 
public byte [ ] encode ( final byte [ ] bytes ) hrows EncoderException { if ( bytes = = null ) { return null ; } final int expectedEncodingBytes = expectedEncodingBytes ( bytes ) ; final boolean willEncode = expectedEncodingBytes ! = bytes . length ; if ( willEncode | | plusForSpace & & containsSpace ( bytes ) ) { return doEncode ( bytes , expectedEncodingBytes , willEncode ) ; } return bytes ; } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = input [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < decodeTable.length) { final int result = decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) (context.ibitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
private byte [ ] calculateDecodeTable ( byte [ ] encodeTable ) { byte [ ] decodeTable = new byte [ DECODING_TABLE_LENGTH ] ; Arrays . fill ( decodeTable , ( byte ) - 1 ) ; for ( int i = 0 ; i < encodeTable . length ; i + + ) { decodeTable [ encodeTable [ i ] ] = ( byte ) i ; } return decodeTable ; } 
public void estCustomEncodingAlphabet_illegal ( ) { byte [ ] encodeTable = { '.' , '-' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' } ; assertThrows ( IllegalArgumentException . class , ( ) - > new Base64 ( encodeTable ) ) ; } 
private byte [ ] calculateDecodeTable ( final byte [ ] encodeTable ) { final byte [ ] decodeTable = new byte [ DECODING_TABLE_LENGTH ] ; Arrays . fill ( decodeTable , ( byte ) - 1 ) ; for ( int i = 0 ; i < encodeTable . length ; i + + ) { decodeTable [ encodeTable [ i ] ] = ( byte ) i ; } return decodeTable ; } 
public void estCustomEncodingAlphabet_illegal ( ) { final byte [ ] encodeTable = { '.' , '-' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' } ; assertThrows ( IllegalArgumentException . class , ( ) - > new Base64 ( encodeTable ) ) ; } 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } if (inAvail < 0) { context.eof = true; } final int decodeSize = this.encodeSize - 1; for (int i = 0; i < inAvail; i++) { final byte b = input[inPos++]; if (b == pad) { We're done. context.eof = true; break; } final byte[] buffer = ensureBufferSize(decodeSize, context); if (b >= 0 && b < this.decodeTable.length) { final int result = this.decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK; collect decoded bytes context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { we can output the 5 bytes buffer[context.pos++] = (byte) (context.lbitWorkArea >> 32 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 24 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as Base32 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus > 0) { if modulus == 0, nothing to do final byte[] buffer = ensureBufferSize(decodeSize, context); 
void decode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { if ( context . eof ) { return ; } if ( inAvail < 0 ) { context . eof = rue ; } final int decodeSize = his . encodeSize - 1 ; for ( int i = 0 ; i < inAvail ; i + + ) { final byte [ ] buffer = ensureBufferSize ( decodeSize , context ) ; final byte b = input [ inPos + + ] ; if ( b = = pad ) { We're done. context.eof = true; break; } if (b >= 0 && b < decodeTable.length) { final int result = decodeTable[b]; if (result >= 0) { context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK; context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result; if (context.modulus == 0) { buffer[context.pos++] = (byte) (context.ibitWorkArea >> 16 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea >> 8 & MASK_8BITS); buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS); } } } } Two forms of EOF as far as base64 decoder is concerned: actual EOF (-1) and first time '=' character is encountered in stream. This approach makes the '=' padding characters completely optional. if (context.eof && context.modulus != 0) { final byte[] buffer = ensureBufferSize(decodeSize, context); 
public Base64 get ( ) { return new Base64 ( lineLength , lineSeparator , encodeTable , decodingPolicy ) ; } 
private static byte [ ] oUrlSafeEncodeTable ( final boolean urlSafe ) { return urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE ; } 
public void estBuilderCodecPolicy ( ) { assertEquals ( CodecPolicy . LENIENT , Base64 . builder ( ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base64 . builder ( ) . setDecodingPolicy ( CodecPolicy . LENIENT ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . STRICT , Base64 . builder ( ) . setDecodingPolicy ( CodecPolicy . STRICT ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base64 . builder ( ) . setDecodingPolicy ( CodecPolicy . STRICT ) . setDecodingPolicy ( null ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base64 . builder ( ) . setDecodingPolicy ( null ) . get ( ) . getCodecPolicy ( ) ) ; } 
public void estBuilderLineAttributes ( ) { assertNull ( Base64 . builder ( ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 10 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineLength ( - 1 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineLength ( 0 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( new byte [ ] { 1 } , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( ( byte ) 1 ) . get ( ) . getLineSeparator ( ) ) ; assertEquals ( " Zm94 r " , Base64 . builder ( ) . setLineLength ( 4 ) . get ( ) . encodeToString ( " fox " . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estBuilderUrlSafe ( ) { assertFalse ( Base64 . builder ( ) . get ( ) . isUrlSafe ( ) ) ; assertFalse ( Base64 . builder ( ) . setUrlSafe ( false ) . get ( ) . isUrlSafe ( ) ) ; assertFalse ( Base64 . builder ( ) . setUrlSafe ( rue ) . setUrlSafe ( false ) . get ( ) . isUrlSafe ( ) ) ; assertTrue ( Base64 . builder ( ) . setUrlSafe ( false ) . setUrlSafe ( rue ) . get ( ) . isUrlSafe ( ) ) ; } 
public void estCustomEncodingAlphabet_illegal ( ) { final byte [ ] encodeTable = { '.' , '-' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' } ; assertThrows ( IllegalArgumentException . class , ( ) - > Base64 . builder ( ) . setEncodeTable ( encodeTable ) . get ( ) ) ; } 
public void estIgnoringNonBase64InDecode ( ) hrows Exception { assertEquals ( FOX_TEXT , new String ( Base64 . decodeBase64 ( FOX_BASE64 . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownDecodings ( ) { assertEquals ( FOX_TEXT , new String ( Base64 . decodeBase64 ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " It was the best of times, it was the worst of times. " , new String ( Base64 . decodeBase64 ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " http:jakarta.apache.org/commmons " , new String ( Base64 . decodeBase64 ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " , new String ( Base64 . decodeBase64 ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " , new String ( Base64 . decodeBase64 ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " xyzzy! " , new String ( Base64 . decodeBase64 ( " eHl6enkh " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estKnownEncodings ( ) { assertEquals ( " VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2dzLg== " , new String ( Base64 . encodeBase64 ( FOX_TEXT . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " YmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJs r nYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFo r nIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBibGFoIGJsYWggYmxhaCBi r nbGFoIGJsYWg= r " , new String ( Base64 . encodeBase64Chunked ( " blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " SXQgd2FzIHRoZSBiZXN0IG9mIHRpbWVzLCBpdCB3YXMgdGhlIHdvcnN0IG9mIHRpbWVzLg== " , new String ( Base64 . encodeBase64 ( " It was the best of times, it was the worst of times. " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " aHR0cDovL2pha2FydGEuYXBhY2hlLm9yZy9jb21tbW9ucw== " , new String ( Base64 . encodeBase64 ( " http:jakarta.apache.org/commmons " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " QWFCYkNjRGRFZUZmR2dIaElpSmpLa0xsTW1Obk9vUHBRcVJyU3NUdFV1VnZXd1h4WXlaeg== " , new String ( Base64 . encodeBase64 ( " AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5IH0= " , new String ( Base64 . encodeBase64 ( " { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } " . getBytes ( CHARSET_UTF8 ) ) ) ) ; assertEquals ( " eHl6enkh " , new String ( Base64 . encodeBase64 ( " xyzzy! " . getBytes ( CHARSET_UTF8 ) ) ) ) ; } 
public void estNullArguments ( ) { assertThrows ( NullPointerException . class , ( ) - > Digest . main ( null ) ) ; } 
public Base64 get ( ) { return new Base64 ( getLineLength ( ) , getLineSeparator ( ) , encodeTable , getDecodingPolicy ( ) ) ; } 
static int oLength ( final byte [ ] array ) { return array = = null ? 0 : array . length ; } 
public Base64 get ( ) { return new Base64 ( getLineLength ( ) , getLineSeparator ( ) , getEncodeTable ( ) , getDecodingPolicy ( ) ) ; } 
public Base32 get ( ) { return new Base32 ( getLineLength ( ) , getLineSeparator ( ) , getEncodeTable ( ) , padding , getDecodingPolicy ( ) ) ; } 
public void estBuilderCodecPolicy ( ) { assertEquals ( CodecPolicy . LENIENT , Base32 . builder ( ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base32 . builder ( ) . setDecodingPolicy ( CodecPolicy . LENIENT ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . STRICT , Base32 . builder ( ) . setDecodingPolicy ( CodecPolicy . STRICT ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base32 . builder ( ) . setDecodingPolicy ( CodecPolicy . STRICT ) . setDecodingPolicy ( null ) . get ( ) . getCodecPolicy ( ) ) ; assertEquals ( CodecPolicy . LENIENT , Base32 . builder ( ) . setDecodingPolicy ( null ) . get ( ) . getCodecPolicy ( ) ) ; } 
public void estBuilderLineAttributes ( ) { assertNull ( Base32 . builder ( ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 10 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineLength ( - 1 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineLength ( 0 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( new byte [ ] { 1 } , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( ( byte ) 1 ) . get ( ) . getLineSeparator ( ) ) ; assertEquals ( " MZXXQ=== " , Base32 . builder ( ) . setLineLength ( 4 ) . get ( ) . encodeToString ( " fox " . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estBuilderPadingByte ( ) { assertNull ( Base32 . builder ( ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base32 . builder ( ) . setLineLength ( 10 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineLength ( - 1 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base32 . builder ( ) . setLineLength ( 0 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( new byte [ ] { 1 } , Base32 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( ( byte ) 1 ) . get ( ) . getLineSeparator ( ) ) ; assertEquals ( " MZXXQ___ " , Base32 . builder ( ) . setLineLength ( 4 ) . setPadding ( ( byte ) '_' ) . get ( ) . encodeToString ( " fox " . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public Base32 get ( ) { return new Base32 ( getLineLength ( ) , getLineSeparator ( ) , getEncodeTable ( ) , getPadding ( ) , getDecodingPolicy ( ) ) ; } 
public Base64 get ( ) { return new Base64 ( getLineLength ( ) , getLineSeparator ( ) , getPadding ( ) , getEncodeTable ( ) , getDecodingPolicy ( ) ) ; } 
public void estBuilderPadingByte ( ) { assertNull ( Base64 . builder ( ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( BaseNCodec . CHUNK_SEPARATOR ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( BaseNCodec . CHUNK_SEPARATOR , Base64 . builder ( ) . setLineLength ( 10 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineLength ( - 1 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertNull ( Base64 . builder ( ) . setLineLength ( 0 ) . setLineSeparator ( null ) . get ( ) . getLineSeparator ( ) ) ; assertArrayEquals ( new byte [ ] { 1 } , Base64 . builder ( ) . setLineLength ( 4 ) . setLineSeparator ( ( byte ) 1 ) . get ( ) . getLineSeparator ( ) ) ; assertEquals ( " VGhlIGJyb3duIGZveA== " , Base64 . builder ( ) . get ( ) . encodeToString ( " The brown fox " . getBytes ( CHARSET_UTF8 ) ) ) ; assertEquals ( " VGhlIGJyb3duIGZveA__ " , Base64 . builder ( ) . setPadding ( ( byte ) '_' ) . get ( ) . encodeToString ( " The brown fox " . getBytes ( CHARSET_UTF8 ) ) ) ; } 
public void estCodec263 ( ) { Base64 . decodeBase64 ( " publishMessage " ) ; assertTrue ( Base64 . isBase64 ( " publishMessage " ) ) ; } 
public void estCodec184 ( ) { assertTrue ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " " , false ) ) ; assertTrue ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " " , rue ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " aa " , " " , false ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " aa " , " " , rue ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " aa " , false ) ) ; assertFalse ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " " , " aa " , rue ) ) ; } 
private int handleGH ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index > 0 & & ! isVowel ( charAt ( value , index - 1 ) ) ) { result . append ( 'K' ) ; index + = 2 ; } else if ( index = = 0 ) { if ( charAt ( value , index + 2 ) = = 'I' ) { result . append ( 'J' ) ; } else { result . append ( 'K' ) ; } index + = 2 ; } else if ( index > 1 & & contains ( value , index - 2 , 1 , " B " , " H " , " D " ) | | index > 2 & & contains ( value , index - 3 , 1 , " B " , " H " , " D " ) | | index > 3 & & contains ( value , index - 4 , 1 , " B " , " H " ) ) { -- Parker's rule (with some further refinements) - "hugh" index += 2; } else { if (index > 2 && charAt(value, index - 1) == 'U' && contains(value, index - 3, 1, "C", "G", "L", "R", "T")) { -- "laugh", "McLaughlin", "cough", "gough", "rough", "tough" result.append('F'); } else if (index > 0 && charAt(value, index - 1) != 'I') { result.append('K'); } index += 2; } return index; } 
public void estCodec320 ( ) { assertTrue ( new DoubleMetaphone ( ) . isDoubleMetaphoneEqual ( " ANGHELINA " , " ANKL " , false ) ) ; } 
static boolean regionMatches ( final CharSequence cs , final boolean ignoreCase , final int hisStart , final CharSequence substring , final int start , final int length ) { if ( cs instanceof String & & substring instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , hisStart , ( String ) substring , start , length ) ; } int index1 = hisStart ; int index2 = start ; int mpLen = length ; while ( mpLen - - > 0 ) { final char c1 = cs . charAt ( index1 + + ) ; final char c2 = substring . charAt ( index2 + + ) ; if ( c1 = = c2 ) { continue ; } if ( ! ignoreCase ) { return false ; } The same check as in String.regionMatches(): if (Character.toUpperCase(c1) != Character.toUpperCase(c2) && Character.toLowerCase(c1) != Character.toLowerCase(c2)) { return false; } } return true; } 
public static int decodeHex ( final char [ ] data , final byte [ ] out , final int outOffset ) hrows DecoderException { final int len = data . length ; if ( ( len & 0x01 ) ! = 0 ) { hrow new DecoderException ( " Odd number of characters. " ) ; } final int outLen = len > > 1 ; if ( out . length - outOffset < outLen ) { hrow new DecoderException ( " Output array is not large enough to accommodate decoded data. " ) ; } two characters form the hex value. for (int i = outOffset, j = 0; j < len; i++) { int f = toDigit(data[j], j) << 4; j++; f |= toDigit(data[j], j); j++; out[i] = (byte) (f & 0xFF); } return outLen; } 
protected static char [ ] encodeHex ( final byte [ ] data , final char [ ] oDigits ) { final int dataLength = data . length ; return encodeHex ( data , 0 , dataLength , oDigits , new char [ dataLength < < 1 ] , 0 ) ; } 
public static char [ ] encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase ) { return encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , new char [ dataLen < < 1 ] , 0 ) ; } 
public static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase , final char [ ] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , oLowerCase ? DIGITS_LOWER : DIGITS_UPPER , out , outOffset ) ; } 
private static char [ ] encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final char [ ] oDigits , final char [ ] out , final int outOffset ) { two characters form the hex value. for (int i = dataOffset, j = outOffset; i < dataOffset + dataLen; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; out[j++] = toDigits[0x0F & data[i]]; } return out; } 
public static char [ ] encodeHex ( final byte [ ] data , final boolean oLowerCase ) { return encodeHex ( data , oAlphabet ( oLowerCase ) ) ; } 
public static char [ ] encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase ) { return encodeHex ( data , dataOffset , dataLen , oAlphabet ( oLowerCase ) , new char [ dataLen < < 1 ] , 0 ) ; } 
public static void encodeHex ( final byte [ ] data , final int dataOffset , final int dataLen , final boolean oLowerCase , final char [ ] out , final int outOffset ) { encodeHex ( data , dataOffset , dataLen , oAlphabet ( oLowerCase ) , out , outOffset ) ; } 
public static char [ ] encodeHex ( final ByteBuffer data , final boolean oLowerCase ) { return encodeHex ( data , oAlphabet ( oLowerCase ) ) ; } 
private static char [ ] oAlphabet ( final boolean oLowerCase ) { return oLowerCase ? DIGITS_LOWER : DIGITS_UPPER ; } 
public int available ( ) hrows IOException { Note: the logic is similar to the InflaterInputStream: as long as we have not reached EOF, indicate that there is more data available. As we do not know for sure how much data is left, just return 1 as a safe guess. return context.eof ? 0 : 1; } 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public long skip ( final long ) hrows IOException { if ( < 0 ) { hrow new IllegalArgumentException ( " Negative skip length: " + ) ; } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; } 
private int [ ] chainingValue ( ) { return Arrays . copyOf ( compress ( inputChainingValue , blockWords , blockLength , counter , flags ) , CHAINING_VALUE_INTS ) ; } 
private static void checkBufferArgs ( final byte [ ] buffer , final int offset , final int length ) { Objects . requireNonNull ( buffer ) ; if ( offset < 0 ) { hrow new IndexOutOfBoundsException ( " Offset must be non-negative " ) ; } if ( length < 0 ) { hrow new IndexOutOfBoundsException ( " Length must be non-negative " ) ; } final int bufferLength = buffer . length ; if ( offset > bufferLength - length ) { hrow new IndexOutOfBoundsException ( " Offset " + offset + " and length " + length + " out of bounds with buffer length " + bufferLength ) ; 
private static int [ ] compress ( final int [ ] chainingValue , final int [ ] blockWords , final int blockLength , final long counter , final int flags ) { final int [ ] state = Arrays . copyOf ( chainingValue , BLOCK_INTS ) ; System . arraycopy ( IV , 0 , state , 8 , 4 ) ; state [ 12 ] = ( int ) counter ; state [ 13 ] = ( int ) ( counter > > Integer . SIZE ) ; state [ 14 ] = blockLength ; state [ 15 ] = flags ; for ( int i = 0 ; i < 7 ; i + + ) { final byte [ ] schedule = MSG_SCHEDULE [ i ] ; round ( state , blockWords , schedule ) ; } for ( int i = 0 ; i < state . length / 2 ; i + + ) { state [ i ] ^ = state [ i + 8 ] ; state [ i + 8 ] ^ = chainingValue [ i ] ; } return state ; } 
private static int [ ] parentChainingValue ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { return parentOutput ( leftChildCV , rightChildCV , key , flags ) . chainingValue ( ) ; } 
private static Output parentOutput ( final int [ ] leftChildCV , final int [ ] rightChildCV , final int [ ] key , final int flags ) { final int [ ] blockWords = Arrays . copyOf ( leftChildCV , BLOCK_INTS ) ; System . arraycopy ( rightChildCV , 0 , blockWords , 8 , CHAINING_VALUE_INTS ) ; return new Output ( key . clone ( ) , blockWords , 0 , BLOCK_LEN , flags | PARENT ) ; } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( b [ i ] < < 24 > > > 24 ) + ( b [ i + 1 ] < < 24 > > > 16 ) + ( b [ i + 2 ] < < 24 > > > 8 ) + ( b [ i + 3 ] < < 24 ) ; localCrc = T [ ( x < < 24 > > > 24 ) + 0x700 ] ^ T [ ( x < < 16 > > > 24 ) + 0x600 ] ^ T [ ( x < < 8 > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ^ T [ ( b [ i + 4 ] < < 24 > > > 24 ) + 0x300 ] ^ T [ ( b [ i + 5 ] < < 24 > > > 24 ) + 0x200 ] ^ T [ ( b [ i + 6 ] < < 24 > > > 24 ) + 0x100 ] ^ T [ b [ i + 7 ] < < 24 > > > 24 ] ; } } Publish crc out to object crc = localCrc; } 
final public void update ( final int b ) { crc = crc > > > 8 ^ T [ ( crc ^ b ) < < 24 > > > 24 ] ; } 
void decode ( final byte [ ] data , int offset , final int length , final Context context ) { if ( context . eof | | length < 0 ) { context . eof = rue ; if ( context . ibitWorkArea ! = 0 ) { validateTrailingCharacter ( ) ; } return ; } final int dataLen = Math . min ( data . length - offset , length ) ; final int availableChars = ( context . ibitWorkArea ! = 0 ? 1 : 0 ) + dataLen ; small optimization to short-cut the rest of this method when it is fed byte-by-byte if (availableChars == 1 && availableChars == dataLen) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 context.ibitWorkArea = decodeOctet(data[offset]) + 1; return; } we must have an even number of chars to decode final int charsToProcess = availableChars % BYTES_PER_ENCODED_BLOCK == 0 ? availableChars : availableChars - 1; final int end = offset + dataLen; final byte[] buffer = ensureBufferSize(charsToProcess / BYTES_PER_ENCODED_BLOCK, context); int result; if (dataLen < availableChars) { we have 1/2 byte from previous invocation to decode result = context.ibitWorkArea - 1 << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; reset to empty-value for next invocation! context.ibitWorkArea = 0; } final int loopEnd = end - 1; while (offset < loopEnd) { result = decodeOctet(data[offset++]) << BITS_PER_ENCODED_BYTE; result |= decodeOctet(data[offset++]); buffer[context.pos++] = (byte) result; } we have one char of a hex-pair left over if (offset < end) { store 1/2 byte for next invocation of decode, we offset by +1 as empty-value is 0 
private int decodeOctet ( final byte octet ) { int decoded = - 1 ; if ( ( octet & 0xff ) < decodeTable . length ) { decoded = decodeTable [ octet ] ; } if ( decoded = = - 1 ) { hrow new IllegalArgumentException ( " Invalid octet in encoded value: " + ( int ) octet ) ; } return decoded ; } 
void encode ( final byte [ ] data , final int offset , final int length , final Context context ) { if ( context . eof ) { return ; } if ( length < 0 ) { context . eof = rue ; return ; } final int size = length * BYTES_PER_ENCODED_BLOCK ; if ( size < 0 ) { hrow new IllegalArgumentException ( " Input length exceeds maximum size for encoded data: " + length ) ; } final byte [ ] buffer = ensureBufferSize ( size , context ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i + + ) { final int value = data [ i ] ; 
void encode ( final byte [ ] input , int inPos , final int inAvail , final Context context ) { package protected for access from I/O streams if (context.eof) { return; } inAvail < 0 is how we're informed of EOF in the underlying data we're encoding. if (inAvail < 0) { context.eof = true; 
private static byte [ ] resizeBuffer ( final Context context , final int minCapacity ) { Overflow-conscious code treats the min and new capacity as unsigned. final int oldCapacity = context.buffer.length; int newCapacity = oldCapacity * DEFAULT_BUFFER_RESIZE_FACTOR; if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) { newCapacity = minCapacity; } if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) { newCapacity = createPositiveCapacity(minCapacity); } final byte[] b = Arrays.copyOf(context.buffer, newCapacity); context.buffer = b; return b; } 
protected boolean containsAlphabetOrPad ( final byte [ ] arrayOctet ) { if ( arrayOctet ! = null ) { for ( final byte element : arrayOctet ) { if ( pad = = element | | isInAlphabet ( element ) ) { return rue ; } } } return false ; } 
protected byte [ ] ensureBufferSize ( final int size , final Context context ) { if ( context . buffer = = null ) { context . buffer = new byte [ Math . max ( size , getDefaultBufferSize ( ) ) ] ; context . pos = 0 ; context . readPos = 0 ; Overflow-conscious: x + y > z == x + y - z > 0 } else if (context.pos + size - context.buffer.length > 0) { return resizeBuffer(context, context.pos + size); } return context.buffer; } 
public static String md5Crypt ( final byte [ ] keyBytes , final String salt , final String prefix , final Random random ) { final int keyLen = keyBytes . length ; Extract the real salt from the given string which can be a complete hash string. final String saltString; if (salt == null) { saltString = B64.getRandomSalt(8, random); } else { Objects.requireNonNull(prefix, "prefix"); if (prefix.length() < 3) { throw new IllegalArgumentException("Invalid prefix value: " + prefix); } if (prefix.charAt(0) != '$' && prefix.charAt(prefix.length() - 1) != '$') { throw new IllegalArgumentException("Invalid prefix value: " + prefix); } final Pattern p = Pattern.compile("^" + prefix.replace("$", "\\$") + "([\\.\\/a-zA-Z0-9]{1,8}).*"); final Matcher m = p.matcher(salt); if (!m.find()) { throw new IllegalArgumentException("Invalid salt value: " + salt); } saltString = m.group(1); } final byte[] saltBytes = saltString.getBytes(StandardCharsets.UTF_8); final MessageDigest ctx = DigestUtils.getMd5Digest(); Is there a better way to do this with the JVM? ctx.reset(); ctx1.reset(); Arrays.fill(keyBytes, (byte) 0); Arrays.fill(saltBytes, (byte) 0); Arrays.fill(finalb, (byte) 0); return passwd.toString(); } 
public void estInvalidPrefix ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . md5Crypt ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } , " aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa! " , " (.*a){10000} " ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . md5Crypt ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } , " aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa! " , " $(.*a){10000}$ " ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > Md5Crypt . md5Crypt ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } , " aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa " , " $(.*a){10000}$ " ) ) ; 
public byte [ ] encode ( final byte [ ] array ) { return encodeHexString ( array ) . getBytes ( getCharset ( ) ) ; } 
public byte [ ] encode ( final ByteBuffer array ) { return encodeHexString ( array ) . getBytes ( getCharset ( ) ) ; } 
public Object encode ( final Object object ) hrows EncoderException { final byte [ ] byteArray ; if ( object instanceof String ) { byteArray = ( ( String ) object ) . getBytes ( getCharset ( ) ) ; } else if ( object instanceof ByteBuffer ) { byteArray = oByteArray ( ( ByteBuffer ) object ) ; } else { ry { byteArray = ( byte [ ] ) object ; } catch ( final ClassCastException e ) { hrow new EncoderException ( e . getMessage ( ) , e ) ; } } return encodeHex ( byteArray ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Caverphone encode is not of type java.lang.String " ) ; } return caverphone ( ( String ) obj ) ; } 
public boolean isCaverphoneEqual ( final String str1 , final String str2 ) { return caverphone ( str1 ) . equals ( caverphone ( str2 ) ) ; } 
public Object encode ( final Object obj ) hrows EncoderException { if ( ! ( obj instanceof String ) ) { hrow new EncoderException ( " Parameter supplied to Nysiis encode is not of type java.lang.String " ) ; } return nysiis ( ( String ) obj ) ; } 
public String nysiis ( String str ) { if ( str = = null ) { return null ; } Use the same clean rules as Soundex str = SoundexUtils.clean(str); if (str.isEmpty()) { return str; } Translate first characters of name: MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS str = PAT_MAC.matcher(str).replaceFirst("MCC"); str = PAT_KN.matcher(str).replaceFirst("NN"); str = PAT_K.matcher(str).replaceFirst("C"); str = PAT_PH_PF.matcher(str).replaceFirst("FF"); str = PAT_SCH.matcher(str).replaceFirst("SSS"); Translate last characters of name: EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D str = PAT_EE_IE.matcher(str).replaceFirst("Y"); str = PAT_DT_ETC.matcher(str).replaceFirst("D"); First character of key = first character of name. final StringBuilder key = new StringBuilder(str.length()); key.append(str.charAt(0)); Transcode remaining characters, incrementing by one character each time final char[] chars = str.toCharArray(); final int len = chars.length; for (int i = 1; i < len; i++) { final char next = i < len - 1 ? chars[i + 1] : SPACE; final char aNext = i < len - 2 ? chars[i + 2] : SPACE; final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext); System.arraycopy(transcoded, 0, chars, i, transcoded.length); only append the current char to the key if it is different from the last one if (chars[i] != chars[i - 1]) { key.append(chars[i]); } } if (key.length() > 1) { char lastChar = key.charAt(key.length() - 1); If last character is S, remove it. if (lastChar == 'S') { key.deleteCharAt(key.length() - 1); lastChar = key.charAt(key.length() - 1); } if (key.length() > 2) { final char last2Char = key.charAt(key.length() - 2); If last characters are AY, replace with Y. if (last2Char == 'A' && lastChar == 'Y') { key.deleteCharAt(key.length() - 2); } } If last character is A, remove it. if (lastChar == 'A') { key.deleteCharAt(key.length() - 1); } } final String string = key.toString(); return isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string; } 
public String decode ( final String sourceStr ) hrows DecoderException { return his . decode ( sourceStr , getCharset ( ) ) ; } 
protected String encodeText ( final String ext , final Charset charset ) hrows EncoderException { if ( ext = = null ) { return null ; } final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( PREFIX ) ; buffer . append ( charset ) ; buffer . append ( SEP ) ; buffer . append ( getEncoding ( ) ) ; buffer . append ( SEP ) ; buffer . append ( StringUtils . newStringUsAscii ( doEncoding ( ext . getBytes ( charset ) ) ) ) ; buffer . append ( POSTFIX ) ; return buffer . oString ( ) ; } 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { final int len = getRandom ( ) . nextInt ( 10000 ) + 1 ; 
public void estEncodeDecodeRandom ( ) { for ( int i = 1 ; i < 5 ; i + + ) { final byte [ ] data = new byte [ getRandom ( ) . nextInt ( 10000 ) + 1 ] ; 
public void estCaverphoneRevisitedCommonCodeAT1111 ( ) hrows EncoderException { checkEncodingVariations ( " AT1111 " , new String [ ] { " add " , 
public void estEndMb ( ) hrows EncoderException { final String [ ] [ ] data = { { " mb " , " M11111 " } , { " mbmb " , " MPM111 " } } ; checkEncodings ( data ) ; } 
public void estSpecificationV1Examples ( ) hrows EncoderException { final String [ ] [ ] data = { { " David " , " TFT111 " } , { " Whittle " , " WTL111 " } } ; checkEncodings ( data ) ; } 
public void estWikipediaExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Lee " , " L11111 " } , { " Thompson " , " TMPSN1 " } } ; checkEncodings ( data ) ; } 
public void estCaverphoneRevisitedCommonCodeAT11111111 ( ) hrows EncoderException { checkEncodingVariations ( " AT11111111 " , new String [ ] { " add " , 
public void estCaverphoneRevisitedExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Stevenson " , " STFNSN1111 " } , { " Peter " , " PTA1111111 " } } ; checkEncodings ( data ) ; } 
public void estCaverphoneRevisitedRandomNameKLN1111111 ( ) hrows EncoderException { checkEncodingVariations ( " KLN1111111 " , new String [ ] { " Cailean " , 
public void estCaverphoneRevisitedRandomNameTN11111111 ( ) hrows EncoderException { checkEncodingVariations ( " TN11111111 " , new String [ ] { " Dan " , 
public void estCaverphoneRevisitedRandomNameTTA1111111 ( ) hrows EncoderException { checkEncodingVariations ( " TTA1111111 " , new String [ ] { " Darda " , 
public void estCaverphoneRevisitedRandomWords ( ) hrows EncoderException { checkEncodingVariations ( " RTA1111111 " , new String [ ] { " rather " , " ready " , " writer " } ) ; checkEncoding ( " SSA1111111 " , " social " ) ; checkEncodingVariations ( " APA1111111 " , new String [ ] { " able " , " appear " } ) ; } 
public void estEndMb ( ) hrows EncoderException { final String [ ] [ ] data = { { " mb " , " M111111111 " } , { " mbmb " , " MPM1111111 " } } ; checkEncodings ( data ) ; } 
public void estSpecificationExamples ( ) hrows EncoderException { final String [ ] [ ] data = { { " Peter " , " PTA1111111 " } , { " ready " , " RTA1111111 " } , { " social " , " SSA1111111 " } , { " able " , " APA1111111 " } , { " Tedder " , " TTA1111111 " } , { " Karleen " , " KLN1111111 " } , { " Dyun " , " TN11111111 " } } ; checkEncodings ( data ) ; } 
public void estAabjoe ( ) hrows EncoderException { checkEncoding ( " 01 " , " Aabjoe " ) ; } 
public void estAaclan ( ) hrows EncoderException { checkEncoding ( " 0856 " , " Aaclan " ) ; } 
public void estAychlmajrForCodec122 ( ) hrows EncoderException { checkEncoding ( " 04567 " , " Aychlmajr " ) ; } 
public void estCanFail ( ) { assertThrows ( AssertionFailedError . class , ( ) - > checkEncoding ( " / " , " Fehler " ) ) ; } 
public void estEdgeCases ( ) hrows EncoderException { @formatter:off final String[][] data = { { "a", "0" }, { "e", "0" }, { "i", "0" }, { "o", "0" }, { "u", "0" }, { "\u00E4", "0" }, a-umlaut { "\u00F6", "0" }, o-umlaut { "\u00FC", "0" }, u-umlaut { "\u00DF", "8" }, small sharp s { "aa", "0" }, { "ha", "0" }, { "h", "" }, { "aha", "0" }, { "b", "1" }, { "p", "1" }, { "ph", "3" }, { "f", "3" }, { "v", "3" }, { "w", "3" }, { "g", "4" }, { "k", "4" }, { "q", "4" }, { "x", "48" }, { "ax", "048" }, { "cx", "48" }, { "l", "5" }, { "cl", "45" }, { "acl", "085" }, { "mn", "6" }, { "{mn}", "6" }, test chars above Z { "r", "7" } }; @formatter:on checkEncodings(data); } 
public void estSpecialCharsBetweenSameLetters ( ) hrows EncoderException { final String [ ] data = { " Test test " , " Testtest " , " Test-test " , " TesT#Test " , " TesT?test " } ; checkEncodingVariations ( " 28282 " , data ) ; } 
public void estVariationsMella ( ) hrows EncoderException { final String [ ] data = { " mella " , " milah " , " moulla " , " mellah " , " muehle " , " mule " } ; checkEncodingVariations ( " 65 " , data ) ; } 
public void estVariationsMeyer ( ) hrows EncoderException { final String [ ] data = { " Meier " , " Maier " , " Mair " , " Meyer " , " Meyr " , " Mejer " , " Major " } ; checkEncodingVariations ( " 67 " , data ) ; } 
public void estEncodeIgnoreApostrophes ( ) hrows EncoderException { checkEncodingVariations ( " 079600 " , new String [ ] { " OBrien " , " 'OBrien " , " O'Brien " , " OB'rien " , " OBr'ien " , " OBri'en " , " OBrie'n " , " OBrien' " } ) ; 
public void estEncodeIgnoreHyphens ( ) hrows EncoderException { checkEncodingVariations ( " 565463 " , new String [ ] { " KINGSMITH " , " -KINGSMITH " , " K-INGSMITH " , " KI-NGSMITH " , " KIN-GSMITH " , " KING-SMITH " , " KINGS-MITH " , " KINGSM-ITH " , " KINGSMI-TH " , " KINGSMIT-H " , " KINGSMITH- " } ) ; 
public void estDoubleMetaphoneAlternate ( ) { checkDoubleMetaphone ( ALTERNATE_INDEX , rue ) ; } 
public void estDoubleMetaphonePrimary ( ) { checkDoubleMetaphone ( PRIMARY_INDEX , false ) ; } 
private void assertDoubleMetaphone ( final String expected , final String source ) { assertEquals ( expected , getStringEncoder ( ) . encode ( source ) ) ; ry { assertEquals ( expected , getStringEncoder ( ) . encode ( ( Object ) source ) ) ; } catch ( final EncoderException e ) { fail ( " Unexpected exception: " + e ) ; } assertEquals ( expected , getStringEncoder ( ) . doubleMetaphone ( source ) ) ; assertEquals ( expected , getStringEncoder ( ) . doubleMetaphone ( source , false ) ) ; } 
public void assertDoubleMetaphoneAlt ( final String expected , final String source ) { assertEquals ( expected , getStringEncoder ( ) . doubleMetaphone ( source , rue ) ) ; } 
public void doubleMetaphoneEqualTest ( final String [ ] [ ] pairs , final boolean useAlternate ) { validateFixture ( pairs ) ; for ( final String [ ] pair : pairs ) { final String name0 = pair [ 0 ] ; 
public void doubleMetaphoneNotEqualTest ( final boolean alternate ) { assertFalse ( getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " , alternate ) ) ; assertFalse ( getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Band " , " Brain " , alternate ) ) ; if ( ! alternate ) { assertFalse ( getStringEncoder ( ) . isDoubleMetaphoneEqual ( " Brain " , " Band " ) ) ; 
public void estCCedilla ( ) { assertTrue ( getStringEncoder ( ) . isDoubleMetaphoneEqual ( " u00e7 " , " S " ) ) ; c-cedilla } 
public void estEmpty ( ) { assertNull ( getStringEncoder ( ) . doubleMetaphone ( null ) ) ; assertNull ( getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertNull ( getStringEncoder ( ) . doubleMetaphone ( " " ) ) ; assertNull ( getStringEncoder ( ) . doubleMetaphone ( " r " ) ) ; } 
public void estIsDoubleMetaphoneEqualExtended1 ( ) { String[][] testFixture = new String[][] { { "Smith", "Schmidt" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testIsDoubleMetaphoneEqualExtended2() { final String[][] testFixture = { { "Jablonski", "Yablonsky" } }; doubleMetaphoneEqualTest(testFixture, false); doubleMetaphoneEqualTest(testFixture, true); } @Test public void testSetMaxCodeLength() { final String value = "jumped"; final DoubleMetaphone doubleMetaphone = new DoubleMetaphone(); Sanity check of default settings assertEquals(4, doubleMetaphone.getMaxCodeLen(), "Default Max Code Length"); assertEquals("JMPT", doubleMetaphone.doubleMetaphone(value, false), "Default Primary"); assertEquals("AMPT", doubleMetaphone.doubleMetaphone(value, true), "Default Alternate"); Check setting Max Code Length doubleMetaphone.setMaxCodeLen(3); assertEquals(3, doubleMetaphone.getMaxCodeLen(), "Set Max Code Length"); assertEquals("JMP", doubleMetaphone.doubleMetaphone(value, false), "Max=3 Primary"); assertEquals("AMP", doubleMetaphone.doubleMetaphone(value, true), "Max=3 Alternate"); } public void validateFixture(final String[][] pairs) { if (pairs.length == 0) { fail("Test fixture is empty"); } for (int i = 0; i < pairs.length; i++) { if (pairs[i].length != 2) { fail("Error in test fixture in the data array at index " + i); } } }} 
public void estIsDoubleMetaphoneEqualExtended3 ( ) { validateFixture ( FIXTURE ) ; final StringBuilder failures = new StringBuilder ( ) ; final StringBuilder matches = new StringBuilder ( ) ; final String cr = System . lineSeparator ( ) ; matches . append ( " private static final String[][] MATCHES = { " + cr ) ; int failCount = 0 ; for ( int i = 0 ; i < FIXTURE . length ; i + + ) { final String name0 = FIXTURE [ i ] [ 0 ] ; final String name1 = FIXTURE [ i ] [ 1 ] ; final boolean match1 = getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , false ) ; final boolean match2 = getStringEncoder ( ) . isDoubleMetaphoneEqual ( name0 , name1 , rue ) ; if ( ! match1 & & ! match2 ) { final String failMsg = " [ " + i + " ] " + name0 + " and " + name1 + cr ; failures . append ( failMsg ) ; failCount + + ; } else { matches . append ( " { \" " + name0 + " \" , \" " + name1 + " \" }, " + cr ) ; } } matches . append ( " }; " ) ; Turn on to print a new MATCH array System.out.println(matches.toString()); if (failCount > 0) { Turn on to see which pairs do NOT match. 
public void estIsDoubleMetaphoneEqualWithMATCHES ( ) { validateFixture ( MATCHES ) ; for ( int i = 0 ; i < MATCHES . length ; i + + ) { final String name0 = MATCHES [ i ] [ 0 ] ; 
public void estNTilde ( ) { assertTrue ( getStringEncoder ( ) . isDoubleMetaphoneEqual ( " u00f1 " , " N " ) ) ; n-tilde } 
public final void estAccentRemoval_NINO_NoChange ( ) { assertEquals ( " " , getStringEncoder ( ) . removeAccents ( " " ) ) ; } 
public final void estAccentRemoval_NullValue_ReturnNullSuccessfully ( ) { assertNull ( getStringEncoder ( ) . removeAccents ( null ) ) ; } 
public final void estAccentRemovalNormalString_NoChange ( ) { assertEquals ( " Colorless green ideas sleep furiously " , getStringEncoder ( ) . removeAccents ( " Colorless green ideas sleep furiously " ) ) ; } 
public final void estCompare_BRIAN_BRYAN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Brian " , " Bryan " ) ) ; } 
public final void estCompare_BURNS_BOURNE_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Burns " , " Bourne " ) ) ; } 
public final void estCompare_CATHERINE_KATHRYN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Catherine " , " Kathryn " ) ) ; } 
public final void estCompare_Forenames_SEAN_JOHN_MatchExpected ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Sean " , " John " ) ) ; } 
public final void estCompare_Forenames_SEAN_PETE_NoMatchExpected ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Sean " , " Pete " ) ) ; } 
public final void estCompare_FRANCISZEK_FRANCES_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Franciszek " , " Frances " ) ) ; } 
public final void estCompare_KARL_ALESSANDRO_DoesNotMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Karl " , " Alessandro " ) ) ; } 
public final void estCompare_LongSurnames_MORIARTY_OMUIRCHEARTAIGH_DoesNotSuccessfulMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Moriarty " , " OMuircheartaigh " ) ) ; } 
public final void estCompare_MCGOWAN_MCGEOGHEGAN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " McGowan " , " Mc Geoghegan " ) ) ; } 
public final void estCompare_MICKY_MICHAEL_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Micky " , " Michael " ) ) ; } 
public final void estCompare_OONA_OONAGH_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Oona " , " Oonagh " ) ) ; } 
public final void estCompare_PETERSON_PETERS_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Peterson " , " Peters " ) ) ; } 
public final void estCompare_SAM_SAMUEL_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Sam " , " Samuel " ) ) ; } 
public final void estCompare_ShortNames_AL_ED_WorksButNoMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Al " , " Ed " ) ) ; } 
public final void estCompare_SmallInput_CARK_Kl_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Kl " , " Karl " ) ) ; } 
public final void estCompare_SMITH_SMYTH_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " smith " , " smyth " ) ) ; } 
public final void estCompare_SOPHIE_SOFIA_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Sophie " , " Sofia " ) ) ; } 
public final void estCompare_STEPHEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Stephen " , " Stefan " ) ) ; } 
public final void estCompare_STEPHEN_STEVEN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Stephen " , " Steven " ) ) ; } 
public final void estCompare_STEVEN_STEFAN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Steven " , " Stefan " ) ) ; } 
public final void estCompare_Surname_AUERBACH_UHRBACH_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Auerbach " , " Uhrbach " ) ) ; } 
public final void estCompare_Surname_COOPERFLYNN_SUPERLYN_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Cooper-Flynn " , " Super-Lyn " ) ) ; } 
public final void estCompare_Surname_HAILEY_HALLEY_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Hailey " , " Halley " ) ) ; } 
public final void estCompare_Surname_LEWINSKY_LEVINSKI_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " LEWINSKY " , " LEVINSKI " ) ) ; } 
public final void estCompare_Surname_LIPSHITZ_LIPPSZYC_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " LIPSHITZ " , " LIPPSZYC " ) ) ; } 
public final void estCompare_Surname_MOSKOWITZ_MOSKOVITZ_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Moskowitz " , " Moskovitz " ) ) ; } 
public final void estCompare_Surname_PRZEMYSL_PSHEMESHIL_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " P rz e m y s l " , " P sh e m e sh i l " ) ) ; } 
public final void estCompare_Surname_ROSOCHOWACIEC_ROSOKHOVATSETS_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " R o s o ch o w a c ie c " , " R o s o k ho v a ts e ts " ) ) ; } 
public final void estCompare_Surname_SZLAMAWICZ_SHLAMOVITZ_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " SZLAMAWICZ " , " SHLAMOVITZ " ) ) ; } 
public final void estCompare_SurnameCornerCase_Nulls_NoMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( null , null ) ) ; } 
public final void estCompare_Surnames_MURPHY_LYNCH_NoMatchExpected ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " Lynch " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_NoSpace_NoMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_SurnamesCornerCase_MURPHY_Space_NoMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Murphy " , " " ) ) ; } 
public final void estCompare_TOMASZ_TOM_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Tomasz " , " om " ) ) ; } 
public final void estCompare_ZACH_ZAKARIA_SuccessfullyMatched ( ) { assertTrue ( getStringEncoder ( ) . isEncodeEquals ( " Zach " , " Zacharia " ) ) ; } 
public final void estCompareNameToSingleLetter_KARL_C_DoesNotMatch ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " Karl " , " C " ) ) ; } 
public final void estGetEncoding_HARPER_HRPR ( ) { assertEquals ( " HRPR " , getStringEncoder ( ) . encode ( " HARPER " ) ) ; } 
public final void estGetEncoding_NoSpace_to_Nothing ( ) { assertEquals ( " " , getStringEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetEncoding_Null_to_Nothing ( ) { assertEquals ( " " , getStringEncoder ( ) . encode ( null ) ) ; } 
public final void estGetEncoding_One_Letter_to_Nothing ( ) { assertEquals ( " " , getStringEncoder ( ) . encode ( " E " ) ) ; } 
public final void estGetEncoding_SMITH_to_SMTH ( ) { assertEquals ( " SMTH " , getStringEncoder ( ) . encode ( " Smith " ) ) ; } 
public final void estGetEncoding_SMYTH_to_SMYTH ( ) { assertEquals ( " SMYTH " , getStringEncoder ( ) . encode ( " Smyth " ) ) ; } 
public final void estGetEncoding_Space_to_Nothing ( ) { assertEquals ( " " , getStringEncoder ( ) . encode ( " " ) ) ; } 
public final void estGetFirstLast3__ALEXANDER_Returns_Aleder ( ) { assertEquals ( " Aleder " , getStringEncoder ( ) . getFirst3Last3 ( " Alexzander " ) ) ; } 
public final void estGetFirstLast3_PETE_Returns_PETE ( ) { assertEquals ( " PETE " , getStringEncoder ( ) . getFirst3Last3 ( " PETE " ) ) ; } 
public final void estGetMinRating_1_Returns5_Successfully ( ) { assertEquals ( 5 , getStringEncoder ( ) . getMinRating ( 1 ) ) ; } 
public final void estgetMinRating_10_Returns3_Successfully ( ) { assertEquals ( 3 , getStringEncoder ( ) . getMinRating ( 10 ) ) ; } 
public final void estgetMinRating_11_Returns_3_Successfully ( ) { assertEquals ( 3 , getStringEncoder ( ) . getMinRating ( 11 ) ) ; } 
public final void estGetMinRating_13_Returns_1_Successfully ( ) { assertEquals ( 1 , getStringEncoder ( ) . getMinRating ( 13 ) ) ; } 
public final void estGetMinRating_2_Returns5_Successfully ( ) { assertEquals ( 5 , getStringEncoder ( ) . getMinRating ( 2 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully ( ) { assertEquals ( 4 , getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_5_Returns4_Successfully2 ( ) { assertEquals ( 4 , getStringEncoder ( ) . getMinRating ( 5 ) ) ; } 
public final void estgetMinRating_6_Returns4_Successfully ( ) { assertEquals ( 4 , getStringEncoder ( ) . getMinRating ( 6 ) ) ; } 
public final void estGetMinRating_7_Return4_Successfully ( ) { assertEquals ( 4 , getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_7_Returns4_Successfully ( ) { assertEquals ( 4 , getStringEncoder ( ) . getMinRating ( 7 ) ) ; } 
public final void estgetMinRating_8_Returns3_Successfully ( ) { assertEquals ( 3 , getStringEncoder ( ) . getMinRating ( 8 ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameJust1Letter_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameJustSpace_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameNothing_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " " , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_FirstNameNull_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( null , " est " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameJustSpace_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameNothing_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estIsEncodeEquals_CornerCase_SecondNameNull_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " est " , null ) ) ; } 
public final void estIsEncodeEqualsSecondNameJust1Letter_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isEncodeEquals ( " est " , " " ) ) ; } 
public final void estIsVowel_CapitalA_ReturnsTrue ( ) { assertTrue ( getStringEncoder ( ) . isVowel ( " A " ) ) ; } 
public final void estIsVowel_SingleVowel_ReturnsTrue ( ) { assertTrue ( getStringEncoder ( ) . isVowel ( " I " ) ) ; } 
public final void estIsVowel_SmallD_ReturnsFalse ( ) { assertFalse ( getStringEncoder ( ) . isVowel ( " d " ) ) ; } 
public final void estLeftToRightThenRightToLeft_ALEXANDER_ALEXANDRA_Returns4 ( ) { assertEquals ( 4 , getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " ALEXANDER " , " ALEXANDRA " ) ) ; } 
public final void estLeftToRightThenRightToLeft_EINSTEIN_MICHAELA_Returns0 ( ) { assertEquals ( 0 , getStringEncoder ( ) . leftToRightThenRightToLeftProcessing ( " EINSTEIN " , " MICHAELA " ) ) ; } 
public final void estPunctuationOnly ( ) { assertEquals ( getStringEncoder ( ) . encode ( " .,- " ) , " " ) ; } 
public final void estRemoveDoubleConsonants_MISSISSIPPI_RemovedSuccessfully ( ) { assertEquals ( " MISISIPI " , getStringEncoder ( ) . removeDoubleConsonants ( " MISSISSIPPI " ) ) ; } 
public final void estRemoveDoubleDoubleVowel_BEETLE_NotRemoved ( ) { assertEquals ( " BEETLE " , getStringEncoder ( ) . removeDoubleConsonants ( " BEETLE " ) ) ; } 
public final void estRemoveSingleDoubleConsonants_BUBLE_RemovedSuccessfully ( ) { assertEquals ( " BUBLE " , getStringEncoder ( ) . removeDoubleConsonants ( " BUBBLE " ) ) ; } 
public final void estRemoveVowel__AIDAN_Returns_ADN ( ) { assertEquals ( " ADN " , getStringEncoder ( ) . removeVowels ( " AIDAN " ) ) ; } 
public final void estRemoveVowel__DECLAN_Returns_DCLN ( ) { assertEquals ( " DCLN " , getStringEncoder ( ) . removeVowels ( " DECLAN " ) ) ; } 
public final void estRemoveVowel_ALESSANDRA_Returns_ALSSNDR ( ) { assertEquals ( " ALSSNDR " , getStringEncoder ( ) . removeVowels ( " ALESSANDRA " ) ) ; } 
public final void estVowelAndPunctuationOnly ( ) { assertEquals ( getStringEncoder ( ) . encode ( " uoiea.,-AEIOU " ) , " U " ) ; } 
public final void estVowelOnly ( ) { assertEquals ( getStringEncoder ( ) . encode ( " aeiouAEIOU " ) , " A " ) ; } 
public void assertIsMetaphoneEqual ( final String source , final String [ ] matches ) { match source to all matches for (final String matche : matches) { assertTrue(getStringEncoder().isMetaphoneEqual(source, matche), "Source: " + source + ", should have same Metaphone as: " + matche); } match to each other for (final String matche : matches) { for (final String matche2 : matches) { 
public void assertMetaphoneEqual ( final String [ ] [ ] pairs ) { validateFixture ( pairs ) ; for ( final String [ ] pair : pairs ) { final String name0 = pair [ 0 ] ; 
public void estDiscardOfSCEOrSCIOrSCY ( ) { assertEquals ( " SNS " , getStringEncoder ( ) . metaphone ( " SCIENCE " ) ) ; assertEquals ( " SN " , getStringEncoder ( ) . metaphone ( " SCENE " ) ) ; assertEquals ( " S " , getStringEncoder ( ) . metaphone ( " SCY " ) ) ; } 
public void estDiscardOfSilentGN ( ) { NOTE: This does not test for silent GN, but for starting with GN assertEquals("N", getStringEncoder().metaphone("GNU")); NOTE: Trying to test for GNED, but expected code does not appear to execute assertEquals("SNT", getStringEncoder().metaphone("SIGNED")); } 
public void estDiscardOfSilentHAfterG ( ) { assertEquals ( " KNT " , getStringEncoder ( ) . metaphone ( " GHENT " ) ) ; assertEquals ( " B " , getStringEncoder ( ) . metaphone ( " BAUGH " ) ) ; } 
public void estExceedLength ( ) { should be AKSKS, but is truncated by Max Code Length assertEquals("AKSK", getStringEncoder().metaphone("AXEAXE")); } 
public void estIsMetaphoneEqual1 ( ) { assertMetaphoneEqual ( new String [ ] [ ] { { " Case " , " case " } , { " CASE " , " Case " } , { " caSe " , " cAsE " } , { " quick " , " cookie " } } ) ; } 
public void estIsMetaphoneEqual2 ( ) { assertMetaphoneEqual ( new String [ ] [ ] { { " Lawrence " , " Lorenza " } , { " Gary " , " Cahra " } , } ) ; } 
public void estIsMetaphoneEqualAero ( ) { assertIsMetaphoneEqual ( " Aero " , new String [ ] { " Eure " } ) ; } 
public void estIsMetaphoneEqualAlbert ( ) { assertIsMetaphoneEqual ( " Albert " , new String [ ] { " Ailbert " , " Alberik " , " Albert " , " Alberto " , " Albrecht " } ) ; } 
public void estIsMetaphoneEqualGary ( ) { assertIsMetaphoneEqual ( " Gary " , new String [ ] { " Cahra " , " Cara " , " Carey " , " Cari " , " Caria " , " Carie " , " Caro " , " Carree " , " Carri " , " Carrie " , " Carry " , " Cary " , " Cora " , " Corey " , 
public void estIsMetaphoneEqualJohn ( ) { assertIsMetaphoneEqual ( " John " , new String [ ] { " Gena " , " Gene " , " Genia " , " Genna " , " Genni " , " Gennie " , " Genny " , " Giana " , " Gianna " , " Gina " , " Ginni " , " Ginnie " , " Ginny " , " Jaine " , 
public void estIsMetaphoneEqualKnight ( ) { assertIsMetaphoneEqual ( " Knight " , new String [ ] { " Hynda " , " Nada " , " Nadia " , " Nady " , " Nat " , " Nata " , " Natty " , " Neda " , " Nedda " , " Nedi " , " Netta " , " Netti " , " Nettie " , " Netty " , " Nita " , " Nydia " } ) ; 
public void estIsMetaphoneEqualMary ( ) { assertIsMetaphoneEqual ( " Mary " , new String [ ] { " Mair " , " Maire " , " Mara " , " Mareah " , " Mari " , " Maria " , " Marie " , " Mary " , " Maura " , " Maure " , " Meara " , " Merrie " , " Merry " , " Mira " , " Moira " , " Mora " , " Moria " , " Moyra " , " Muire " , " Myra " , " Myrah " } ) ; 
public void estIsMetaphoneEqualParis ( ) { assertIsMetaphoneEqual ( " Paris " , new String [ ] { " Pearcy " , " Perris " , " Piercy " , " Pierz " , " Pryse " } ) ; } 
public void estIsMetaphoneEqualPeter ( ) { assertIsMetaphoneEqual ( " Peter " , new String [ ] { " Peadar " , " Peder " , " Pedro " , " Peter " , " Petr " , " Peyter " , " Pieter " , " Pietro " , " Piotr " } ) ; } 
public void estIsMetaphoneEqualRay ( ) { assertIsMetaphoneEqual ( " Ray " , new String [ ] { " Ray " , " Rey " , " Roi " , " Roy " , " Ruy " } ) ; } 
public void estIsMetaphoneEqualSusan ( ) { assertIsMetaphoneEqual ( " Susan " , new String [ ] { " Siusan " , " Sosanna " , " Susan " , " Susana " , " Susann " , " Susanna " , " Susannah " , " Susanne " , " Suzann " , " Suzanna " , " Suzanne " , " Zuzana " } ) ; 
public void estIsMetaphoneEqualWhite ( ) { assertIsMetaphoneEqual ( " White " , new String [ ] { " Wade " , " Wait " , " Waite " , " Wat " , " Whit " , " Wiatt " , " Wit " , " Wittie " , " Witty " , " Wood " , " Woodie " , " Woody " } ) ; 
public void estIsMetaphoneEqualWright ( ) { assertIsMetaphoneEqual ( " Wright " , new String [ ] { " Rota " , " Rudd " , " Ryde " } ) ; } 
public void estIsMetaphoneEqualXalan ( ) { assertIsMetaphoneEqual ( " Xalan " , new String [ ] { " Celene " , " Celina " , " Celine " , " Selena " , " Selene " , " Selina " , " Seline " , " Suellen " , " Xylina " } ) ; } 
public void estMetaphone ( ) { assertEquals ( " HL " , getStringEncoder ( ) . metaphone ( " howl " ) ) ; assertEquals ( " TSTN " , getStringEncoder ( ) . metaphone ( " esting " ) ) ; assertEquals ( " 0 " , getStringEncoder ( ) . metaphone ( " The " ) ) ; assertEquals ( " KK " , getStringEncoder ( ) . metaphone ( " quick " ) ) ; assertEquals ( " BRN " , getStringEncoder ( ) . metaphone ( " brown " ) ) ; assertEquals ( " FKS " , getStringEncoder ( ) . metaphone ( " fox " ) ) ; assertEquals ( " JMPT " , getStringEncoder ( ) . metaphone ( " jumped " ) ) ; assertEquals ( " OFR " , getStringEncoder ( ) . metaphone ( " over " ) ) ; assertEquals ( " 0 " , getStringEncoder ( ) . metaphone ( " he " ) ) ; assertEquals ( " LS " , getStringEncoder ( ) . metaphone ( " lazy " ) ) ; assertEquals ( " TKS " , getStringEncoder ( ) . metaphone ( " dogs " ) ) ; } 
public void estPHTOF ( ) { assertEquals ( " FX " , getStringEncoder ( ) . metaphone ( " PHISH " ) ) ; } 
public void estSetMaxLengthWithTruncation ( ) { should be AKSKS, but istruncated by Max Code Length getStringEncoder().setMaxCodeLen(6); assertEquals("AKSKSK", getStringEncoder().metaphone("AXEAXEAXE")); } 
public void estSHAndSIOAndSIAToX ( ) { assertEquals ( " XT " , getStringEncoder ( ) . metaphone ( " SHOT " ) ) ; assertEquals ( " OTXN " , getStringEncoder ( ) . metaphone ( " ODSIAN " ) ) ; assertEquals ( " PLXN " , getStringEncoder ( ) . metaphone ( " PULSION " ) ) ; } 
public void estTCH ( ) { assertEquals ( " RX " , getStringEncoder ( ) . metaphone ( " RETCH " ) ) ; assertEquals ( " WX " , getStringEncoder ( ) . metaphone ( " WATCH " ) ) ; } 
public void estTIOAndTIAToX ( ) { assertEquals ( " OX " , getStringEncoder ( ) . metaphone ( " OTIA " ) ) ; assertEquals ( " PRXN " , getStringEncoder ( ) . metaphone ( " PORTION " ) ) ; } 
public void estTranslateOfSCHAndCH ( ) { assertEquals ( " SKTL " , getStringEncoder ( ) . metaphone ( " SCHEDULE " ) ) ; assertEquals ( " SKMT " , getStringEncoder ( ) . metaphone ( " SCHEMATIC " ) ) ; assertEquals ( " KRKT " , getStringEncoder ( ) . metaphone ( " CHARACTER " ) ) ; assertEquals ( " TX " , getStringEncoder ( ) . metaphone ( " TEACH " ) ) ; } 
public void estTranslateToJOfDGEOrDGIOrDGY ( ) { assertEquals ( " TJ " , getStringEncoder ( ) . metaphone ( " DODGY " ) ) ; assertEquals ( " TJ " , getStringEncoder ( ) . metaphone ( " DODGE " ) ) ; assertEquals ( " AJMT " , getStringEncoder ( ) . metaphone ( " ADGIEMTI " ) ) ; } 
public void estWhy ( ) { PHP returns "H". The original metaphone returns an empty string. assertEquals("", getStringEncoder().metaphone("WHY")); } 
public void estWordEndingInMB ( ) { assertEquals ( " KM " , getStringEncoder ( ) . metaphone ( " COMB " ) ) ; assertEquals ( " TM " , getStringEncoder ( ) . metaphone ( " TOMB " ) ) ; assertEquals ( " WM " , getStringEncoder ( ) . metaphone ( " WOMB " ) ) ; } 
public void estWordsWithCIA ( ) { assertEquals ( " XP " , getStringEncoder ( ) . metaphone ( " CIAPO " ) ) ; } 
public void estCap ( ) { encodeAll ( new String [ ] { " Capp " , " Cope " , " Copp " , " Kipp " } , " CAP " ) ; } 
public void estDad ( ) { Data Quality and Record Linkage Techniques P.121 claims this is DAN, but it should be DAD, verified also with dropby.com encodeAll(new String[] { "Dent" }, "DAD"); } 
public void estDan ( ) { encodeAll ( new String [ ] { " Dane " , " Dean " , " Dionne " } , " DAN " ) ; } 
public void estDropBy ( ) { Explanation of differences between this implementation and the one at dropby.com is prepended to the test string. The referenced rules refer to the outlined steps the class description for Nysiis. assertEncodings( 1. Transcode first characters of name 
public void estOthers ( ) { assertEncodings ( new String [ ] { " O'Daniel " , " ODANAL " } , 
public void estRule1 ( ) { assertEncodings ( new String [ ] { " MACX " , " MCX " } , 
public void estRule2 ( ) { assertEncodings ( new String [ ] { " XEE " , " XY " } , 
public void estRule4Dot1 ( ) { assertEncodings ( new String [ ] { " XEV " , " XAF " } , 
public void estRule4Dot2 ( ) { assertEncodings ( new String [ ] { " XQ " , " XG " } , 
public void estRule5 ( ) { assertEncodings ( new String [ ] { " XS " , " X " } , 
public void estRule6 ( ) { assertEncodings ( new String [ ] { " XAY " , " XY " } , 
public void estRule7 ( ) { assertEncodings ( new String [ ] { " XA " , " X " } , 
public void estSnad ( ) { Data Quality and Record Linkage Techniques P.121 claims this is SNAT, but it should be SNAD encodeAll(new String[] { "Schmidt" }, "SNAD"); } 
public void estSnat ( ) { encodeAll ( new String [ ] { " Smith " , " Schmit " } , " SNAT " ) ; } 
public void estSpecialBranches ( ) { encodeAll ( new String [ ] { " Kobwick " } , " CABWAC " ) ; encodeAll ( new String [ ] { " Kocher " } , " CACAR " ) ; encodeAll ( new String [ ] { " Fesca " } , " FASC " ) ; encodeAll ( new String [ ] { " Shom " } , " SAN " ) ; encodeAll ( new String [ ] { " Ohlo " } , " OL " ) ; encodeAll ( new String [ ] { " Uhu " } , " UH " ) ; encodeAll ( new String [ ] { " Um " } , " UN " ) ; } 
public void estTranan ( ) { encodeAll ( new String [ ] { " Trueman " , " Truman " } , " TRANAN " ) ; } 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, getStringEncoder().difference(null, null)); assertEquals(0, getStringEncoder().difference("", "")); assertEquals(0, getStringEncoder().difference(" ", " ")); Normal cases assertEquals(6, getStringEncoder().difference("Smith", "Smythe")); assertEquals(3, getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, getStringEncoder().difference("Margaret", "Andrew")); assertEquals(1, getStringEncoder().difference("Janet", "Margaret")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(5, getStringEncoder().difference("Green", "Greene")); assertEquals(1, getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(6, getStringEncoder().difference("Smith", "Smythe")); assertEquals(8, getStringEncoder().difference("Smithers", "Smythers")); assertEquals(5, getStringEncoder().difference("Anothers", "Brothers")); } 
public void estEncode ( ) { assertEquals ( " T6036084 " , getStringEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T6036084 " , getStringEncoder ( ) . encode ( " TESTING " ) ) ; assertEquals ( " T60 " , getStringEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q503 " , getStringEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B1908 " , getStringEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F205 " , getStringEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J408106 " , getStringEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O0209 " , getStringEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T60 " , getStringEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L7050 " , getStringEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D6043 " , getStringEncoder ( ) . encode ( " dogs " ) ) ; Testing CODEC-56 assertEquals("D6043", RefinedSoundex.US_ENGLISH.encode("dogs")); } 
public void estGetMappingCodeNonLetter ( ) { final char code = getStringEncoder ( ) . getMappingCode ( '#' ) ; assertEquals ( 0 , code , " Code does not equals zero " ) ; } 
public void estB650 ( ) hrows EncoderException { checkEncodingVariations ( " B650 " , new String [ ] { " BARHAM " , 
public void estBadCharacters ( ) { assertEquals ( " H452 " , getStringEncoder ( ) . encode ( " HOL>MES " ) ) ; 
public void estDifference ( ) hrows EncoderException { Edge cases assertEquals(0, getStringEncoder().difference(null, null)); assertEquals(0, getStringEncoder().difference("", "")); assertEquals(0, getStringEncoder().difference(" ", " ")); Normal cases assertEquals(4, getStringEncoder().difference("Smith", "Smythe")); assertEquals(2, getStringEncoder().difference("Ann", "Andrew")); assertEquals(1, getStringEncoder().difference("Margaret", "Andrew")); assertEquals(0, getStringEncoder().difference("Janet", "Margaret")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp assertEquals(4, getStringEncoder().difference("Green", "Greene")); assertEquals(0, getStringEncoder().difference("Blotchet-Halls", "Greene")); Examples from https:msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp assertEquals(4, getStringEncoder().difference("Smith", "Smythe")); assertEquals(4, getStringEncoder().difference("Smithers", "Smythers")); assertEquals(2, getStringEncoder().difference("Anothers", "Brothers")); } 
public void estEncodeBasic ( ) { assertEquals ( " T235 " , getStringEncoder ( ) . encode ( " esting " ) ) ; assertEquals ( " T000 " , getStringEncoder ( ) . encode ( " The " ) ) ; assertEquals ( " Q200 " , getStringEncoder ( ) . encode ( " quick " ) ) ; assertEquals ( " B650 " , getStringEncoder ( ) . encode ( " brown " ) ) ; assertEquals ( " F200 " , getStringEncoder ( ) . encode ( " fox " ) ) ; assertEquals ( " J513 " , getStringEncoder ( ) . encode ( " jumped " ) ) ; assertEquals ( " O160 " , getStringEncoder ( ) . encode ( " over " ) ) ; assertEquals ( " T000 " , getStringEncoder ( ) . encode ( " he " ) ) ; assertEquals ( " L200 " , getStringEncoder ( ) . encode ( " lazy " ) ) ; assertEquals ( " D200 " , getStringEncoder ( ) . encode ( " dogs " ) ) ; } 
public void estEncodeBatch2 ( ) { assertEquals ( " A462 " , getStringEncoder ( ) . encode ( " Allricht " ) ) ; assertEquals ( " E166 " , getStringEncoder ( ) . encode ( " Eberhard " ) ) ; assertEquals ( " E521 " , getStringEncoder ( ) . encode ( " Engebrethson " ) ) ; assertEquals ( " H512 " , getStringEncoder ( ) . encode ( " Heimbach " ) ) ; assertEquals ( " H524 " , getStringEncoder ( ) . encode ( " Hanselmann " ) ) ; assertEquals ( " H431 " , getStringEncoder ( ) . encode ( " Hildebrand " ) ) ; assertEquals ( " K152 " , getStringEncoder ( ) . encode ( " Kavanagh " ) ) ; assertEquals ( " L530 " , getStringEncoder ( ) . encode ( " Lind " ) ) ; assertEquals ( " L222 " , getStringEncoder ( ) . encode ( " Lukaschowsky " ) ) ; assertEquals ( " M235 " , getStringEncoder ( ) . encode ( " McDonnell " ) ) ; assertEquals ( " M200 " , getStringEncoder ( ) . encode ( " McGee " ) ) ; assertEquals ( " O155 " , getStringEncoder ( ) . encode ( " Opnian " ) ) ; assertEquals ( " O155 " , getStringEncoder ( ) . encode ( " Oppenheimer " ) ) ; assertEquals ( " R355 " , getStringEncoder ( ) . encode ( " Riedemanas " ) ) ; assertEquals ( " Z300 " , getStringEncoder ( ) . encode ( " Zita " ) ) ; assertEquals ( " Z325 " , getStringEncoder ( ) . encode ( " Zitzmeinn " ) ) ; } 
public void estEncodeBatch3 ( ) { assertEquals ( " W252 " , getStringEncoder ( ) . encode ( " Washington " ) ) ; assertEquals ( " L000 " , getStringEncoder ( ) . encode ( " Lee " ) ) ; assertEquals ( " G362 " , getStringEncoder ( ) . encode ( " Gutierrez " ) ) ; assertEquals ( " P236 " , getStringEncoder ( ) . encode ( " Pfister " ) ) ; assertEquals ( " J250 " , getStringEncoder ( ) . encode ( " Jackson " ) ) ; assertEquals ( " T522 " , getStringEncoder ( ) . encode ( " Tymczak " ) ) ; For VanDeusen: D-250 (D, 2 for the S, 5 for the N, 0 added) is also possible. assertEquals("V532", getStringEncoder().encode("VanDeusen")); } 
public void estEncodeBatch4 ( ) { assertEquals ( " H452 " , getStringEncoder ( ) . encode ( " HOLMES " ) ) ; assertEquals ( " A355 " , getStringEncoder ( ) . encode ( " ADOMOMI " ) ) ; assertEquals ( " V536 " , getStringEncoder ( ) . encode ( " VONDERLEHR " ) ) ; assertEquals ( " B400 " , getStringEncoder ( ) . encode ( " BALL " ) ) ; assertEquals ( " S000 " , getStringEncoder ( ) . encode ( " SHAW " ) ) ; assertEquals ( " J250 " , getStringEncoder ( ) . encode ( " JACKSON " ) ) ; assertEquals ( " S545 " , getStringEncoder ( ) . encode ( " SCANLON " ) ) ; assertEquals ( " S532 " , getStringEncoder ( ) . encode ( " SAINTJOHN " ) ) ; 
public void estEncodeIgnoreApostrophes ( ) hrows EncoderException { checkEncodingVariations ( " O165 " , new String [ ] { " OBrien " , 
public void estEncodeIgnoreHyphens ( ) hrows EncoderException { checkEncodingVariations ( " K525 " , new String [ ] { " KINGSMITH " , 
public void estEncodeIgnoreTrimmable ( ) { assertEquals ( " W252 " , getStringEncoder ( ) . encode ( " r Washington r " ) ) ; } 
public void estHWRuleEx1 ( ) { From http:www.archives.gov/research_room/genealogy/census/soundex.html: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226. assertEquals("A261", getStringEncoder().encode("Ashcraft")); assertEquals("A261", getStringEncoder().encode("Ashcroft")); assertEquals("Y330", getStringEncoder().encode("yehudit")); assertEquals("Y330", getStringEncoder().encode("yhwdyt")); } 
public void estHWRuleEx2 ( ) { assertEquals ( " B312 " , getStringEncoder ( ) . encode ( " BOOTHDAVIS " ) ) ; assertEquals ( " B312 " , getStringEncoder ( ) . encode ( " BOOTH-DAVIS " ) ) ; } 
public void estHWRuleEx3 ( ) hrows EncoderException { assertEquals ( " S460 " , getStringEncoder ( ) . encode ( " Sgler " ) ) ; assertEquals ( " S460 " , getStringEncoder ( ) . encode ( " Swhgler " ) ) ; Also S460: checkEncodingVariations("S460", new String[]{ "SAILOR", 
public void estMsSqlServer1 ( ) { assertEquals ( " S530 " , getStringEncoder ( ) . encode ( " Smith " ) ) ; assertEquals ( " S530 " , getStringEncoder ( ) . encode ( " Smythe " ) ) ; } 
public void estMsSqlServer2 ( ) hrows EncoderException { checkEncodingVariations ( " E625 " , new String [ ] { " Erickson " , " Erickson " , " Erikson " , " Ericson " , " Ericksen " , " Ericsen " } ) ; } 
public void estMsSqlServer3 ( ) { assertEquals ( " A500 " , getStringEncoder ( ) . encode ( " Ann " ) ) ; assertEquals ( " A536 " , getStringEncoder ( ) . encode ( " Andrew " ) ) ; assertEquals ( " J530 " , getStringEncoder ( ) . encode ( " Janet " ) ) ; assertEquals ( " M626 " , getStringEncoder ( ) . encode ( " Margaret " ) ) ; assertEquals ( " S315 " , getStringEncoder ( ) . encode ( " Steven " ) ) ; assertEquals ( " M240 " , getStringEncoder ( ) . encode ( " Michael " ) ) ; assertEquals ( " R163 " , getStringEncoder ( ) . encode ( " Robert " ) ) ; assertEquals ( " L600 " , getStringEncoder ( ) . encode ( " Laura " ) ) ; assertEquals ( " A500 " , getStringEncoder ( ) . encode ( " Anne " ) ) ; } 
public void estUsMappingEWithAcute ( ) { assertEquals ( " E000 " , getStringEncoder ( ) . encode ( " e " ) ) ; if ( Character . isLetter ( '\u00e9' ) ) { e-acute uppercase E-acute 
public void estUsMappingOWithDiaeresis ( ) { assertEquals ( " O000 " , getStringEncoder ( ) . encode ( " o " ) ) ; if ( Character . isLetter ( '\u00f6' ) ) { o-umlaut uppercase O-umlaut 
public void estWikipediaAmericanSoundex ( ) { assertEquals ( " R163 " , getStringEncoder ( ) . encode ( " Robert " ) ) ; assertEquals ( " R163 " , getStringEncoder ( ) . encode ( " Rupert " ) ) ; assertEquals ( " A261 " , getStringEncoder ( ) . encode ( " Ashcraft " ) ) ; assertEquals ( " A261 " , getStringEncoder ( ) . encode ( " Ashcroft " ) ) ; assertEquals ( " T522 " , getStringEncoder ( ) . encode ( " Tymczak " ) ) ; assertEquals ( " P236 " , getStringEncoder ( ) . encode ( " Pfister " ) ) ; } 
public void estSpeedCheck ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; final StringBuilder stringBuffer = new StringBuilder ( ) ; stringBuffer . append ( TEST_CHARS [ 0 ] ) ; for ( int i = 0 , j = 1 ; i < 40 ; i + + , j + + ) { if ( j = = TEST_CHARS . length ) { 
public void estSpeedCheck2 ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; final String phrase = " ItstheendoftheworldasweknowitandIfeelfine " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void estSpeedCheck3 ( ) hrows EncoderException { final BeiderMorseEncoder bmpm = createGenericApproxEncoder ( ) ; final String phrase = " abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz " ; for ( int i = 1 ; i < = phrase . length ( ) ; i + + ) { bmpm . encode ( phrase . subSequence ( 0 , i ) ) ; 
public void estBasicEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Basic URL decoding test " ) ; validateState ( urlCodec ) ; } 
public void estDecodeInvalid ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " % " ) ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( " %A " ) ) ; Bad 1st char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%WW")); Bad 2nd char after % assertThrows(DecoderException.class, () -> urlCodec.decode("%0W")); validateState(urlCodec); } 
public void estDecodeInvalidContent ( ) hrows DecoderException { final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] input = ch_msg . getBytes ( StandardCharsets . ISO_8859_1 ) ; final byte [ ] output = urlCodec . decode ( input ) ; assertEquals ( input . length , output . length ) ; for ( int i = 0 ; i < input . length ; i + + ) { assertEquals ( input [ i ] , output [ i ] ) ; } validateState ( urlCodec ) ; } 
public void estDecodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello+there%21 " ; String decoded = ( String ) urlCodec . decode ( ( Object ) plain ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] decodedBA = ( byte [ ] ) urlCodec . decode ( ( Object ) plainBA ) ; decoded = new String ( decodedBA ) ; assertEquals ( " Hello there! " , decoded , " Basic URL decoding test " ) ; final Object result = urlCodec . decode ( ( Object ) null ) ; assertNull ( result , " Decoding a null Object should return null " ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; validateState ( urlCodec ) ; } 
public void estDefaultEncoding ( ) hrows Exception { final String plain = " Hello there! " ; final URLCodec urlCodec = new URLCodec ( " UnicodeBig " ) ; urlCodec . encode ( plain ) ; To work around a weird quirk in Java 1.2.2 final String encoded1 = urlCodec.encode(plain, "UnicodeBig"); final String encoded2 = urlCodec.encode(plain); assertEquals(encoded1, encoded2); validateState(urlCodec); } 
public void estEncodeDecodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; assertNull ( urlCodec . encode ( ( String ) null ) , " Null string URL encoding test " ) ; assertNull ( urlCodec . decode ( ( String ) null ) , " Null string URL decoding test " ) ; validateState ( urlCodec ) ; } 
public void estEncodeNull ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final byte [ ] plain = null ; final byte [ ] encoded = urlCodec . encode ( plain ) ; assertNull ( encoded , " Encoding a null string should return null " ) ; validateState ( urlCodec ) ; } 
public void estEncodeObjects ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; String encoded = ( String ) urlCodec . encode ( ( Object ) plain ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final byte [ ] plainBA = plain . getBytes ( StandardCharsets . UTF_8 ) ; final byte [ ] encodedBA = ( byte [ ] ) urlCodec . encode ( ( Object ) plainBA ) ; encoded = new String ( encodedBA ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; final Object result = urlCodec . encode ( ( Object ) null ) ; assertNull ( result , " Encoding a null Object should return null " ) ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( Double . valueOf ( 3.0d ) ) , " Trying to url encode a Double object should cause an exception. " ) ; validateState ( urlCodec ) ; } 
public void estEncodeUrlWithNullBitSet ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " Hello there! " ; final String encoded = new String ( URLCodec . encodeUrl ( null , plain . getBytes ( StandardCharsets . UTF_8 ) ) ) ; assertEquals ( " Hello+there%21 " , encoded , " Basic URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Basic URL decoding test " ) ; validateState ( urlCodec ) ; } 
public void estInvalidEncoding ( ) { final URLCodec urlCodec = new URLCodec ( " NONSENSE " ) ; final String plain = " Hello there! " ; assertThrows ( EncoderException . class , ( ) - > urlCodec . encode ( plain ) , " We set the encoding to a bogus NONSENSE value " ) ; assertThrows ( DecoderException . class , ( ) - > urlCodec . decode ( plain ) , " We set the encoding to a bogus NONSENSE value " ) ; validateState ( urlCodec ) ; } 
public void estSafeCharEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " abc123_-.* " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( plain , encoded , " Safe chars URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Safe chars URL decoding test " ) ; validateState ( urlCodec ) ; } 
public void estUnsafeEncodeDecode ( ) hrows Exception { final URLCodec urlCodec = new URLCodec ( ) ; final String plain = " ~!@#$%^&()+{} \" \\ ;:`,/[] " ; final String encoded = urlCodec . encode ( plain ) ; assertEquals ( " %7E%21%40%23%24%25%5E%26%28%29%2B%7B%7D%22%5C%3B%3A%60%2C%2F%5B%5D " , encoded , " Unsafe chars URL encoding test " ) ; assertEquals ( plain , urlCodec . decode ( encoded ) , " Unsafe chars URL decoding test " ) ; validateState ( urlCodec ) ; } 
public void estUTF8RoundTrip ( ) hrows Exception { final String ru_msg = constructString ( RUSSIAN_STUFF_UNICODE ) ; final String ch_msg = constructString ( SWISS_GERMAN_STUFF_UNICODE ) ; final URLCodec urlCodec = new URLCodec ( ) ; validateState ( urlCodec ) ; assertEquals ( " %D0%92%D1%81%D0%B5%D0%BC_%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 " , urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( " Gr%C3%BCezi_z%C3%A4m%C3%A4 " , urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) ) ; assertEquals ( ru_msg , urlCodec . decode ( urlCodec . encode ( ru_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; assertEquals ( ch_msg , urlCodec . decode ( urlCodec . encode ( ch_msg , CharEncoding . UTF_8 ) , CharEncoding . UTF_8 ) ) ; validateState ( urlCodec ) ; } 
public void estCryptWithEmptySalt ( ) { assertThrowsExactly ( IllegalArgumentException . class , ( ) - > Crypt . crypt ( " secret " , " " ) ) ; } 
public void estSamples ( ) { From Javadoc assertEquals("$1$xxxx$aMkevjfEIpa35Bh3G4bAc.", Crypt.crypt("secret", "$1$xxxx")); assertEquals("xxWAum7tHdIUw", Crypt.crypt("secret", "xx")); } 
public void estStored ( ) { From Javadoc assertEquals("$1$xxxx$aMkevjfEIpa35Bh3G4bAc.", Crypt.crypt("secret", "$1$xxxx$aMkevjfEIpa35Bh3G4bAc.")); assertEquals("xxWAum7tHdIUw", Crypt.crypt("secret", "xxWAum7tHdIUw")); } 
private void startsWith ( String string , String prefix ) { assertTrue ( string . startsWith ( prefix ) , string + " should start with " + prefix ) ; } 
public void estType ( ) { startsWith ( Crypt . crypt ( " secret " , " xxxx " ) , " xx " ) ; startsWith ( Crypt . crypt ( " secret " , " $1$xxxx " ) , " $1$xxxx$ " ) ; startsWith ( Crypt . crypt ( " secret " , " $5$xxxx " ) , " $5$xxxx$ " ) ; startsWith ( Crypt . crypt ( " secret " , " $6$xxxx " ) , " $6$xxxx$ " ) ; } 
public void estBadType ( ) { assertThrowsExactly ( IllegalArgumentException . class , ( ) - > Crypt . crypt ( " secret " , " $2$xxxx " ) ) ; assertThrowsExactly ( IllegalArgumentException . class , ( ) - > Crypt . crypt ( " secret " , " $3$xxxx " ) ) ; assertThrowsExactly ( IllegalArgumentException . class , ( ) - > Crypt . crypt ( " secret " , " $4$ " ) ) ; } 
public void estBadSalt ( ) { No salt assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$1$")); assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$5$")); assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$6$")); wrong char assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$1$%")); assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$5$!")); assertThrowsExactly(IllegalArgumentException.class, () -> Crypt.crypt("secret", "$6$_")); } 
public static void main ( String [ ] args ) { final String hash ; switch ( args . length ) { case 1 : 
private void startsWith ( String string , String prefix ) { assertTrue ( string . startsWith ( prefix ) , string + " should start with " + prefix ) ; } 
public void estType ( ) { startsWith ( Crypt . crypt ( " secret " , " xxxx " ) , " xx " ) ; startsWith ( Crypt . crypt ( " secret " , " $1$xxxx " ) , " $1$xxxx$ " ) ; startsWith ( Crypt . crypt ( " secret " , " $5$xxxx " ) , " $5$xxxx$ " ) ; startsWith ( Crypt . crypt ( " secret " , " $6$xxxx " ) , " $6$xxxx$ " ) ; } 
public static String crypt ( final byte [ ] original , String salt ) { if ( salt = = null ) { salt = B64 . getRandomSalt ( 2 ) ; } else if ( ! CRYPT_SALT_PATTERN . matcher ( salt ) . matches ( ) ) { hrow new IllegalArgumentException ( " Invalid salt value: " + salt ) ; } final StringBuilder buffer = new StringBuilder ( " " ) ; final char charZero = salt . charAt ( 0 ) ; final char charOne = salt . charAt ( 1 ) ; buffer . setCharAt ( 0 , charZero ) ; buffer . setCharAt ( 1 , charOne ) ; final int eSwap0 = CON_SALT [ charZero ] ; final int eSwap1 = CON_SALT [ charOne ] < < 4 ; final byte [ ] key = new byte [ 8 ] ; Arrays . fill ( key , ( byte ) 0 ) ; final int originalLength = original . length ; for ( int i = 0 ; i < key . length & & i < originalLength ; i + + ) { final int iChar = original [ i ] ; key [ i ] = ( byte ) ( iChar < < 1 ) ; } final int [ ] schedule = desSetKey ( key ) ; final int [ ] out = body ( schedule , eSwap0 , eSwap1 ) ; final byte [ ] b = new byte [ 9 ] ; intToFourBytes ( out [ 0 ] , b , 0 ) ; intToFourBytes ( out [ 1 ] , b , 4 ) ; b [ 8 ] = 0 ; int i = 2 ; int y = 0 ; int u = 128 ; for ( ; i < 13 ; i + + ) { int j = 0 ; int c = 0 ; for ( ; j < 6 ; j + + ) { c < < = 1 ; if ( ( b [ y ] & u ) ! = 0 ) { c | = 0x1 ; } u > > > = 1 ; if ( u = = 0 ) { y + + ; u = 128 ; } buffer . setCharAt ( i , ( char ) COV2CHAR [ c ] ) ; } } return buffer . oString ( ) ; } 
public int available ( ) hrows IOException { Note: The logic is similar to the InflaterInputStream: as long as we have not reached EOF, indicate that there is more data available. As we do not know for sure how much data is left, just return 1 as a safe guess. return context.eof ? 0 : 1; } 
public String soundex ( final String source ) { return String . join ( " | " , soundex ( source , rue ) ) ; } 
private void startsWith ( final String string , final String prefix ) { assertTrue ( string . startsWith ( prefix ) , string + " should start with " + prefix ) ; } 
public static void main ( final String [ ] args ) { final String hash ; switch ( args . length ) { case 1 : 
public String doubleMetaphone ( String value , final boolean alternate ) { value = cleanInput ( value ) ; if ( value = = null ) { return null ; } final boolean slavoGermanic = isSlavoGermanic ( value ) ; int index = isSilentStart ( value ) ? 1 : 0 ; final DoubleMetaphoneResult result = new DoubleMetaphoneResult ( getMaxCodeLen ( ) ) ; while ( ! result . isComplete ( ) & & index < = value . length ( ) - 1 ) { switch ( value . charAt ( index ) ) { case 'A' : case 'E' : case 'I' : case 'O' : case 'U' : case 'Y' : index = handleAEIOUY ( result , index ) ; break ; case 'B' : result . append ( 'P' ) ; index = charAt ( value , index + 1 ) = = 'B' ? index + 2 : index + 1 ; break ; case '\u00C7' : A C with a Cedilla result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': N with a tilde (spanish ene) result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); } 
protected abstract boolean isInAlphabet ( byte value ) ; int readResults ( final byte [ ] b , final int bPos , final int bAvail , final Context context ) { if ( hasData ( context ) ) { final int len = Math . min ( available ( context ) , bAvail ) ; System . arraycopy ( context . buffer , context . readPos , b , bPos , len ) ; context . readPos + = len ; if ( ! hasData ( context ) ) { All data read. Reset position markers but do not set buffer to null to allow its reuse. hasData(context) will still return false, and this method will return 0 until more data is available, or -1 if EOF. context.pos = context.readPos = 0; } return len; } return context.eof ? EOF : 0; }} 
public synchronized void mark ( final int readLimit ) { noop } @Override public long skip(final long n) throws IOException { if (n < 0) { throw new IllegalArgumentException("Negative skip length: " + n); } skip in chunks of 512 bytes final byte[] b = new byte[512]; long todo = n; while (todo > 0) { int len = (int) Math.min(b.length, todo); len = this.read(b, 0, len); if (len == EOF) { break; } todo -= len; } return n - todo; }} 
public int read ( final byte [ ] array , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 | | offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len = = 0 ) { return 0 ; } int readLen = 0 ; Attempt to read the request length while (readLen < len) { if (!baseNCodec.hasData(context)) { Obtain more data. buf is reused across calls to read to avoid repeated allocations final int c = in.read(buf); if (doEncode) { baseNCodec.encode(buf, 0, c, context); } else { baseNCodec.decode(buf, 0, c, context); } } final int read = baseNCodec.readResults(array, offset + readLen, len - readLen, context); if (read < 0) { Return the amount read or EOF return readLen != 0 ? readLen : -1; } readLen += read; } return readLen; } 
public void write ( final byte [ ] array , final int offset , final int len ) hrows IOException { Objects . requireNonNull ( array , " array " ) ; if ( offset < 0 | | len < 0 | | offset > array . length | | offset + len > array . length ) { hrow new IndexOutOfBoundsException ( ) ; } if ( len > 0 ) { if ( doEncode ) { 
private static String langResourceName ( final NameType nameType ) { return String . format ( " /org/apache/commons/codec/language/bm/%s_languages.txt " , nameType . getName ( ) ) ; } 
private static String createResourceName ( final NameType nameType , final RuleType rt , final String lang ) { return String . format ( " /org/apache/commons/codec/language/bm/%s_%s_%s.txt " , nameType . getName ( ) , rt . getName ( ) , lang ) ; 
private static Scanner createScanner ( final String lang ) { final String resName = String . format ( " /org/apache/commons/codec/language/bm/%s.txt " , lang ) ; return new Scanner ( Resources . getInputStream ( resName ) , ResourceConstants . ENCODING ) ; } 
static boolean bytesContain ( final byte [ ] bytes , final byte c ) { for ( final byte b : bytes ) { if ( b = = c ) { return rue ; } } return false ; } 
public final void update ( final int b ) { crc = crc > > > 8 ^ T [ ( crc ^ b ) < < 24 > > > 24 ] ; } 
public final void update ( final int b ) { crc = crc > > > 8 ^ T [ T8_0_START + ( ( crc ^ b ) & 0xff ) ] ; } 
public static MessageDigest updateDigest ( final MessageDigest digest , final File data ) hrows IOException { ry ( BufferedInputStream inputStream = new BufferedInputStream ( new FileInputStream ( data ) ) ) { return updateDigest ( digest , inputStream ) ; 
public static MessageDigest updateDigest ( final MessageDigest digest , final Path path , final OpenOption . . . options ) hrows IOException { ry ( BufferedInputStream inputStream = new BufferedInputStream ( Files . newInputStream ( path , options ) ) ) { return updateDigest ( digest , inputStream ) ; 
public byte [ ] hmac ( final File valueToDigest ) hrows IOException { ry ( BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( valueToDigest ) ) ) { return hmac ( stream ) ; 
public static Lang loadFromResource ( final String languageRulesResourceName , final Languages languages ) { final List < LangRule > rules = new ArrayList < > ( ) ; ry ( Scanner scanner = new Scanner ( Resources . getInputStream ( languageRulesResourceName ) , ResourceConstants . ENCODING ) ) { boolean inExtendedComment = false ; while ( scanner . hasNextLine ( ) ) { final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inExtendedComment ) { check for closing comment marker, otherwise discard doc comment line if (line.endsWith(ResourceConstants.EXT_CMT_END)) { inExtendedComment = false; } } else if (line.startsWith(ResourceConstants.EXT_CMT_START)) { inExtendedComment = true; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } split it up final String[] parts = line.split("\\s+"); if (parts.length != 3) { throw new IllegalArgumentException("Malformed line '" + rawLine + "' in language resource '" + languageRulesResourceName + "'"); } final Pattern pattern = Pattern.compile(parts[0]); final String[] langs = parts[1].split("\\+"); final boolean accept = parts[2].equals("true"); rules.add(new LangRule(pattern, new HashSet<>(Arrays.asList(langs)), accept)); } } } return new Lang(rules, languages); } 
private static Map < String , List < Rule > > parseRules ( final Scanner scanner , final String location ) { final Map < String , List < Rule > > lines = new HashMap < > ( ) ; int currentLine = 0 ; boolean inMultilineComment = false ; while ( scanner . hasNextLine ( ) ) { currentLine + + ; final String rawLine = scanner . nextLine ( ) ; String line = rawLine ; if ( inMultilineComment ) { if ( line . endsWith ( ResourceConstants . EXT_CMT_END ) ) { inMultilineComment = false ; } } else if ( line . startsWith ( ResourceConstants . EXT_CMT_START ) ) { inMultilineComment = rue ; } else { discard comments final int cmtI = line.indexOf(ResourceConstants.CMT); if (cmtI >= 0) { line = line.substring(0, cmtI); } trim leading-trailing whitespace line = line.trim(); if (line.isEmpty()) { continue; empty lines can be safely skipped } if (line.startsWith(HASH_INCLUDE)) { include statement final String incl = line.substring(HASH_INCLUDE_LENGTH).trim(); if (incl.contains(" ")) { throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " + location); } try (Scanner hashIncludeScanner = createScanner(incl)) { lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl)); } } else { rule final String[] parts = line.split("\\s+"); if (parts.length != 4) { throw new IllegalArgumentException("Malformed rule statement split into " + parts.length + " parts: " + rawLine + " in " + location); } try { final String pat = stripQuotes(parts[0]); final String lCon = stripQuotes(parts[1]); final String rCon = stripQuotes(parts[2]); final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3])); final int cLine = currentLine; final Rule r = new Rule(pat, lCon, rCon, ph) { private final int myLine = cLine; private final String loc = location; @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Rule"); sb.append("{line=").append(myLine); sb.append(", loc='").append(loc).append('\''); sb.append(", pat='").append(pat).append('\''); sb.append(", lcon='").append(lCon).append('\''); sb.append(", rcon='").append(rCon).append('\''); sb.append('}'); return sb.toString(); } }; final String patternKey = r.pattern.substring(0, 1); final List<Rule> rules = lines.computeIfAbsent(patternKey, k -> new ArrayList<>()); rules.add(r); } catch (final IllegalArgumentException e) { throw new IllegalStateException("Problem parsing line '" + currentLine + "' in " + location, e); } } } } return lines; } 
private static int encodeQuotedPrintable ( final int b , final ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; final char hex1 = Utils . hexDigit ( b > > 4 ) ; final char hex2 = Utils . hexDigit ( b ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } 
public void estAvailable ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertEquals ( 1 , b16Stream . available ( ) ) ; 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try to decode. try (InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = BaseNTestData.streamToBytes(in); assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (InputStream in = new ByteArrayInputStream(decoded); InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (InputStream in = new Base16InputStream(new ByteArrayInputStream(decoded), true, lowerCase)) { final byte[] output = new byte[encoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(encoded, output, "Streaming Base16 encode"); } Now let's try to decode. try (InputStream in = new Base16InputStream(new ByteArrayInputStream(encoded), false, lowerCase)) { final byte[] output = new byte[decoded.length]; for (int i = 0; i < output.length; i++) { output[i] = (byte) in.read(); } assertEquals(-1, in.read(), "EOF"); assertEquals(-1, in.read(), "Still EOF"); assertArrayEquals(decoded, output, "Streaming Base16 decode"); } wrap encoder with decoder try (InputStream in = new ByteArrayInputStream(decoded); InputStream inEncode = new Base16InputStream(in, true, lowerCase); 
public void estMarkSupported ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base16InputStream in = new Base16InputStream ( bin , rue ) ) { Always returns false for now. 
public void estRead0 ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base16InputStream in = new Base16InputStream ( bin , rue ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadNull ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) , " Base16InputStream.read(null, 0, 0) " ) ; 
public void estReadOutOfBounds ( ) hrows IOException { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base16InputStream in = new Base16InputStream ( bin , rue ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base16InputStream.read(buf, -1, 0) " ) ; 
public void estSkipBig ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertEquals ( 6 , b16Stream . skip ( Integer . MAX_VALUE ) ) ; 
public void estSkipNone ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipPastEnd ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows IOException { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B16 ) ) ; ry ( Base16InputStream b16Stream = new Base16InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b16Stream . skip ( - 10 ) ) ; 
private void estByChunk ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { out.write(decoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming chunked base16 encode"); } Now let's try to decode. try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { out.write(encoded); final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming chunked base16 decode"); } wrap encoder with decoder try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
private void estByteByByte ( final byte [ ] encoded , final byte [ ] decoded , final boolean lowerCase ) hrows IOException { Start with encode. try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, true, lowerCase)) { for (final byte element : decoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(encoded, output, "Streaming byte-by-byte base16 encode"); } Now let's try to decode. try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte base16 decode"); } Now let's try to decode with tonnes of flushes. try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream out = new Base16OutputStream(byteOut, false, lowerCase)) { for (final byte element : encoded) { out.write(element); out.flush(); } final byte[] output = byteOut.toByteArray(); assertArrayEquals(decoded, output, "Streaming byte-by-byte flush() base16 decode"); } wrap encoder with decoder try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); OutputStream decoderOut = new Base16OutputStream(byteOut, false, lowerCase); 
public void estWriteOutOfBounds ( ) hrows IOException { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base16OutputStream out = new Base16OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base16InputStream.write(buf, -1, 0) " ) ; 
public void estWriteToNullCoverage ( ) hrows IOException { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base16OutputStream out = new Base16OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertEquals ( 1 , b32stream . available ( ) ) ; 
public void estCodec105 ( ) hrows IOException { ry ( Base32InputStream in = new Base32InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ) { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( Base32OutputStream base32os = new Base32OutputStream ( bos ) ) { base32os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base32InputStream ins = new Base32InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = BaseNTestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { Always returns false for now. 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( Base32TestData . STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base32InputStream in = new Base32InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base32InputStream.read(buf, -1, 0) " ) ; 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertEquals ( 3 , b32stream . skip ( 1024 ) ) ; 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_FOO ) ) ; ry ( Base32InputStream b32stream = new Base32InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b32stream . skip ( - 10 ) ) ; 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base32OutputStream out = new Base32OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base32OutputStream.write(buf, -1, 1) " ) ; 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base32OutputStream out = new Base32OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void estAvailable ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertEquals ( 1 , b64stream . available ( ) ) ; 
public void estCodec101 ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; ry ( Base64InputStream in = new Base64InputStream ( bais ) ) { final byte [ ] result = new byte [ 8192 ] ; 
public void estCodec105 ( ) hrows IOException { ry ( Base64InputStream in = new Base64InputStream ( new Codec105ErrorInputStream ( ) , rue , 0 , null ) ) { for ( int i = 0 ; i < 5 ; i + + ) { 
public void estCodec130 ( ) hrows IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ry ( Base64OutputStream base64os = new Base64OutputStream ( bos ) ) { base64os . write ( StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ) ; } final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . oByteArray ( ) ) ; final Base64InputStream ins = new Base64InputStream ( bis ) ; we skip the first character read from the reader ins.skip(1); final byte[] decodedBytes = BaseNTestData.streamToBytes(ins, new byte[64]); final String str = StringUtils.newStringUtf8(decodedBytes); assertEquals(STRING_FIXTURE.substring(1), str); } 
public void estInputStreamReader ( ) hrows Exception { final byte [ ] codec101 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_101_INPUT_LENGTH_IS_MULTIPLE_OF_3 ) ; final ByteArrayInputStream bais = new ByteArrayInputStream ( codec101 ) ; final Base64InputStream in = new Base64InputStream ( bais ) ; final InputStreamReader isr = new InputStreamReader ( in ) ; ry ( BufferedReader br = new BufferedReader ( isr ) ) { final String line = br . readLine ( ) ; 
public void estMarkSupported ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { Always returns false for now. 
public void estRead0 ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; int bytesRead = 0 ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { bytesRead = in . read ( buf , 0 , 0 ) ; 
public void estReadMultipleBufferSizes ( ) hrows Exception { final byte [ ] [ ] randomData = BaseNTestData . randomData ( new Base64 ( 0 , null , false ) , 1024 * 64 ) ; final byte [ ] encoded = randomData [ 1 ] ; final byte [ ] decoded = randomData [ 0 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( encoded ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ry ( Base64InputStream in = new Base64InputStream ( bin ) ) { for ( final int i : new int [ ] { 4 * 1024 , 4 * 1024 , 8 * 1024 , 8 * 1024 , 16 * 1024 , 16 * 1024 , 8 * 1024 } ) { final byte [ ] buf = new byte [ i ] ; final int bytesRead = in . read ( buf ) ; assertEquals ( i , bytesRead ) ; out . write ( buf , 0 , bytesRead ) ; } } assertArrayEquals ( decoded , out . oByteArray ( ) ) ; } 
public void estReadNull ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( NullPointerException . class , ( ) - > in . read ( null , 0 , 0 ) ) ; 
public void estReadOutOfBounds ( ) hrows Exception { final byte [ ] decoded = StringUtils . getBytesUtf8 ( STRING_FIXTURE ) ; final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayInputStream bin = new ByteArrayInputStream ( decoded ) ; ry ( Base64InputStream in = new Base64InputStream ( bin , rue , 4 , new byte [ ] { 0 , 0 , 0 } ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > in . read ( buf , - 1 , 0 ) , " Base64InputStream.read(buf, -1, 0) " ) ; 
public void estSkipBig ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertEquals ( 6 , b64stream . skip ( Integer . MAX_VALUE ) ) ; 
public void estSkipNone ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { final byte [ ] actualBytes = new byte [ 6 ] ; 
public void estSkipPastEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipToEnd ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { due to CODEC-130, skip now skips correctly decoded characters rather than encoded 
public void estSkipWrongArgument ( ) hrows Throwable { final InputStream ins = new ByteArrayInputStream ( StringUtils . getBytesIso8859_1 ( ENCODED_B64 ) ) ; ry ( Base64InputStream b64stream = new Base64InputStream ( ins ) ) { assertThrows ( IllegalArgumentException . class , ( ) - > b64stream . skip ( - 10 ) ) ; 
public void estCodec98NPE ( ) hrows Exception { final byte [ ] codec98 = StringUtils . getBytesUtf8 ( Base64TestData . CODEC_98_NPE ) ; final byte [ ] codec98_1024 = new byte [ 1024 ] ; System . arraycopy ( codec98 , 0 , codec98_1024 , 0 , codec98 . length ) ; final ByteArrayOutputStream data = new ByteArrayOutputStream ( 1024 ) ; ry ( Base64OutputStream stream = new Base64OutputStream ( data , false ) ) { stream . write ( codec98_1024 , 0 , 1024 ) ; } final byte [ ] decodedBytes = data . oByteArray ( ) ; final String decoded = StringUtils . newStringUtf8 ( decodedBytes ) ; assertEquals ( Base64TestData . CODEC_98_NPE_DECODED , decoded , " codec-98 NPE Base64OutputStream " ) ; } 
public void estWriteOutOfBounds ( ) hrows Exception { final byte [ ] buf = new byte [ 1024 ] ; final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base64OutputStream out = new Base64OutputStream ( bout ) ) { assertThrows ( IndexOutOfBoundsException . class , ( ) - > out . write ( buf , - 1 , 1 ) , " Base64OutputStream.write(buf, -1, 1) " ) ; 
public void estWriteToNullCoverage ( ) hrows Exception { final ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; ry ( Base64OutputStream out = new Base64OutputStream ( bout ) ) { assertThrows ( NullPointerException . class , ( ) - > out . write ( null , 0 , 0 ) ) ; 
public void setUp ( ) hrows Exception { new Random ( ) . nextBytes ( estData ) ; estFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( OutputStream fos = Files . newOutputStream ( estFile ) ) { fos . write ( estData ) ; } estRandomAccessFile = Files . createTempFile ( DigestUtilsTest . class . getName ( ) , " .dat " ) ; ry ( OutputStream fos = Files . newOutputStream ( estRandomAccessFile ) ) { fos . write ( estData ) ; } estRandomAccessFileWrapper = RandomAccessFileMode . READ_WRITE . create ( estRandomAccessFile ) ; } 
public void estDigestAs ( ) hrows IOException { final String expected = " d41d8cd98f00b204e9800998ecf8427e " ; final String pathName = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . MD5 ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( new File ( pathName ) ) ) ; ry ( FileInputStream inputStream = new FileInputStream ( pathName ) ) { assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathName ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( allBytes ) ) ; assertEquals ( expected , new DigestUtils ( algo ) . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public void estSha224_FileAsHex ( ) hrows IOException { assumeJava8 ( ) ; final String expected = " d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f " ; final String pathName = " src/test/resources/org/apache/commons/codec/empty.bin " ; final String algo = MessageDigestAlgorithms . SHA_224 ; final DigestUtils digestUtils = new DigestUtils ( algo ) ; assertEquals ( expected , digestUtils . digestAsHex ( new File ( pathName ) ) ) ; ry ( FileInputStream inputStream = new FileInputStream ( pathName ) ) { assertEquals ( expected , digestUtils . digestAsHex ( inputStream ) ) ; } final byte [ ] allBytes = Files . readAllBytes ( Paths . get ( pathName ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( allBytes ) ) ; assertEquals ( expected , digestUtils . digestAsHex ( ByteBuffer . wrap ( allBytes ) ) ) ; } 
public static void main ( final String [ ] args ) hrows FileNotFoundException { if ( args . length ! = 1 ) { System . err . println ( " Usage: " + Table . class . getName ( ) + " <polynomial> " ) ; System . exit ( 1 ) ; } final long polynomial = Long . parseLong ( args [ 0 ] , 16 ) ; final int i = 8 ; final Table = new Table ( i , 16 , polynomial ) ; final String s = . oString ( ) ; System . out . println ( s ) ; print to a file try (PrintStream out = new PrintStream(new FileOutputStream("table" + i + ".txt"), true)) { out.println(s); 
public void verifyChecksum ( final String path , final String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; h . update ( b , 0 , b . length ) ; } assertEquals ( expectedChecksum , Long . oHexString ( h . getValue ( ) ) , " checksum for " + file . getName ( ) ) ; } 
public void verifyIncrementalChecksum ( final String path , final String c ) hrows IOException { initData ( path , c ) ; final XXHash32 h = new XXHash32 ( ) ; ry ( FileInputStream s = new FileInputStream ( file ) ) { final byte [ ] b = oByteArray ( s ) ; Hit the case where the hash should be reset h.update(b[0]); h.reset(); Pass in chunks h.update(b[0]); h.update(b, 1, b.length - 2); h.update(b, b.length - 1, 1); Check the hash ignores negative length h.update(b, 0, -1); } assertEquals(expectedChecksum, Long.toHexString(h.getValue()), "checksum for " + file.getName()); } 
static byte [ ] streamToBytes ( final InputStream in , byte [ ] buf ) hrows IOException { ry { int [ ] status = fill ( buf , 0 , in ) ; int size = status [ SIZE_KEY ] ; int lastRead = status [ LAST_READ_KEY ] ; while ( lastRead ! = - 1 ) { buf = resizeArray ( buf ) ; status = fill ( buf , size , in ) ; size = status [ SIZE_KEY ] ; lastRead = status [ LAST_READ_KEY ] ; } if ( buf . length ! = size ) { final byte [ ] smallerBuf = new byte [ size ] ; System . arraycopy ( buf , 0 , smallerBuf , 0 , size ) ; buf = smallerBuf ; } } finally { in . close ( ) ; } return buf ; } 
public boolean isComplete ( ) { return his . primary . length ( ) > = his . maxLength & & his . alternate . length ( ) > = his . maxLength ; } 
protected static boolean contains ( final String value , final int start , final int length , final String . . . criteria ) { boolean result = false ; if ( start > = 0 & & start + length < = value . length ( ) ) { final String arget = value . substring ( start , start + length ) ; for ( final String element : criteria ) { if ( arget . equals ( element ) ) { result = rue ; break ; } } } return result ; } 
public Phoneme append ( final CharSequence sequence ) { his . phonemeText . append ( sequence ) ; return his ; } 
public static LanguageSet from ( final Set < String > languages ) { return languages . isEmpty ( ) ? NO_LANGUAGES : new SomeLanguages ( languages ) ; } 
private int handleS ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( contains ( value , index - 1 , 3 , " ISL " , " YSL " ) ) { -- special cases "island", "isle", "carlisle", "carlysle" -- index++; } else if (index == 0 && contains(value, index, 5, "SUGAR")) { -- special case "sugar-" -- result.append('X', 'S'); index++; } else if (contains(value, index, 2, "SH")) { if (contains(value, index + 1, 4, "HEIM", "HOEK", "HOLM", "HOLZ")) { -- germanic -- result.append('S'); } else { result.append('X'); } index += 2; } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) { -- Italian and Armenian -- if (slavoGermanic) { result.append('S'); } else { result.append('S', 'X'); } index += 3; } else if (index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W") || contains(value, index + 1, 1, "Z")) { -- german & anglicisations, for example "smith" match "schmidt" "snider" match "schneider" -- -- also, -sz- in slavic language although in hungarian it is pronounced "s" -- result.append('S', 'X'); index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1; } else if (contains(value, index, 2, "SC")) { index = handleSC(value, result, index); } else { if (index == value.length() - 1 && contains(value, index - 2, 2, "AI", "OI")) { -- french for example "resnais", "artois" -- result.appendAlternate('S'); } else { result.append('S'); } index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1; } return index; } 
private int handleSC ( final String value , final DoubleMetaphoneResult result , final int index ) { if ( charAt ( value , index + 2 ) = = 'H' ) { -- Schlesinger's rule -- if (contains(value, index + 3, 2, "OO", "ER", "EN", "UY", "ED", "EM")) { -- Dutch origin, for example "school", "schooner" -- if (contains(value, index + 3, 2, "ER", "EN")) { -- "schermerhorn", "schenker" -- result.append("X", "SK"); } else { result.append("SK"); } } else if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } else if (contains(value, index + 2, 1, "I", "E", "Y")) { result.append('S'); } else { result.append("SK"); } return index + 3; } 
private int handleW ( final String value , final DoubleMetaphoneResult result , int index ) { if ( contains ( value , index , 2 , " WR " ) ) { -- can also be in middle of word -- result.append('R'); index += 2; } else if (index == 0 && (isVowel(charAt(value, index + 1)) || contains(value, index, 2, "WH"))) { if (isVowel(charAt(value, index + 1))) { -- Wasserman should match Vasserman -- result.append('A', 'F'); } else { -- need Uomo to match Womo -- result.append('A'); } index++; } else if (index == value.length() - 1 && isVowel(charAt(value, index - 1)) || contains(value, index - 1, 5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") || contains(value, 0, 3, "SCH")) { -- Arnow should match Arnoff -- result.appendAlternate('F'); index++; } else if (contains(value, index, 4, "WICZ", "WITZ")) { -- Polish for example "filipowicz" -- result.append("TS", "FX"); index += 4; } else { index++; } return index; } 
private int handleX ( final String value , final DoubleMetaphoneResult result , int index ) { if ( index = = 0 ) { result . append ( 'S' ) ; index + + ; } else { if ( ! ( index = = value . length ( ) - 1 & & ( contains ( value , index - 3 , 3 , " IAU " , " EAU " ) | | contains ( value , index - 2 , 2 , " AU " , " OU " ) ) ) ) { -- French for example breaux -- result.append("KS"); } index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1; } return index; } 
private int handleZ ( final String value , final DoubleMetaphoneResult result , int index , final boolean slavoGermanic ) { if ( charAt ( value , index + 1 ) = = 'H' ) { -- Chinese pinyin for example "zhao" or Angelina "Zhang" -- result.append('J'); index += 2; } else { if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || slavoGermanic && index > 0 && charAt(value, index - 1) != 'T') { result.append("S", "TS"); } else { result.append('S'); } index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1; } return index; } 
private static byte [ ] decodeTable ( final boolean useHex ) { return useHex ? HEX_DECODE_TABLE : DECODE_TABLE ; } 
private static byte [ ] encodeTable ( final boolean useHex ) { return useHex ? HEX_ENCODE_TABLE : ENCODE_TABLE ; } 
public void estBase32HexImpossibleSamples ( ) { estImpossibleCases ( new Base32 ( 0 , null , rue , BaseNCodec . PAD_DEFAULT , CodecPolicy . STRICT ) , BASE32HEX_IMPOSSIBLE_CASES ) ; @formatter:off testImpossibleCases(Base32.builder() .setHexEncodeTable(true) .setDecodingPolicy(CodecPolicy.STRICT) .get(), BASE32HEX_IMPOSSIBLE_CASES); @formatter:on overrides, last set wins @formatter:off testImpossibleCases(Base32.builder() .setHexDecodeTable(false) 
public void estDecodeSingleBytesOptimization ( ) { final BaseNCodec . Context context = new BaseNCodec . Context ( ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; final byte [ ] data = new byte [ 1 ] ; final Base16 b16 = new Base16 ( ) ; data [ 0 ] = ( byte ) 'E' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 15 , context . ibitWorkArea ) ; assertNull ( context . buffer ) ; data [ 0 ] = ( byte ) 'F' ; b16 . decode ( data , 0 , 1 , context ) ; assertEquals ( 0 , context . ibitWorkArea ) ; assertEquals ( ( byte ) 0xEF , context . buffer [ 0 ] ) ; } 
private String [ ] soundex ( final String source , final boolean branching ) { if ( source = = null ) { return null ; } final String input = cleanup ( source ) ; final Set < Branch > currentBranches = new LinkedHashSet < > ( ) ; currentBranches . add ( new Branch ( ) ) ; char lastChar = NUL ; for ( int index = 0 ; index < input . length ( ) ; index + + ) { final char ch = input . charAt ( index ) ; ignore whitespace inside a name if (Character.isWhitespace(ch)) { continue; } final String inputContext = input.substring(index); final List<Rule> rules = RULES.get(ch); if (rules == null) { continue; } use an EMPTY_LIST to avoid false positive warnings wrt potential null pointer access final List<Branch> nextBranches = branching ? new ArrayList<>() : Collections.emptyList(); for (final Rule rule : rules) { if (rule.matches(inputContext)) { if (branching) { nextBranches.clear(); } final String[] replacements = rule.getReplacements(inputContext, lastChar == '\0'); final boolean branchingRequired = replacements.length > 1 && branching; for (final Branch branch : currentBranches) { for (final String nextReplacement : replacements) { if we have multiple replacements, always create a new branch final Branch nextBranch = branchingRequired ? branch.createBranch() : branch; special rule: occurrences of mn or nm are treated differently final boolean force = lastChar == 'm' && ch == 'n' || lastChar == 'n' && ch == 'm'; nextBranch.processNextReplacement(nextReplacement, force); if (!branching) { break; } nextBranches.add(nextBranch); } } if (branching) { currentBranches.clear(); currentBranches.addAll(nextBranches); } index += rule.getPatternLength() - 1; break; } } lastChar = ch; } final String[] result = new String[currentBranches.size()]; int index = 0; for (final Branch branch : currentBranches) { branch.finish(); result[index++] = branch.toString(); } return result; } 
protected void checkEncodingVariations ( final String expected , final String [ ] data ) hrows EncoderException { for ( final String element : data ) { his . checkEncoding ( expected , element ) ; 
public int read ( final byte [ ] b , final int pos , final int len ) hrows IOException { if ( his . countdown - - > 0 ) { b [ pos ] = '' ; return 1 ; } return EOF ; } 
public static void main ( final String [ ] args ) hrows Exception { printSystemProperties ( System . out ) ; doBench ( CRCS , System . out ) ; } 
public static void main ( final String [ ] args ) { final ColognePhonetic coder = new ColognePhonetic ( ) ; for ( final String arg : args ) { final String code = coder . encode ( arg ) ; 
public static int hash32 ( final byte [ ] data , final int length , final int seed ) { Initialize the hash to a random value int h = seed ^ length; Mix 4 bytes at a time into the hash final int nblocks = length >> 2; body for (int i = 0; i < nblocks; i++) { final int index = i << 2; int k = getLittleEndianInt(data, index); k *= M32; k ^= k >>> R32; k *= M32; h *= M32; h ^= k; } Handle the last few bytes of the input array final int index = nblocks << 2; switch (length - index) { case 3: h ^= (data[index + 2] & 0xff) << 16; falls-through case 2: h ^= (data[index + 1] & 0xff) << 8; falls-through case 1: h ^= data[index] & 0xff; h *= M32; } Do a few final mixes of the hash to ensure the last few bytes are well-incorporated. h ^= h >>> 13; h *= M32; h ^= h >>> 15; return h; } 
public static long hash64 ( final byte [ ] data , final int length , final int seed ) { long h = seed & 0xffffffffL ^ length * M64 ; final int nblocks = length > > 3 ; body for (int i = 0; i < nblocks; i++) { final int index = i << 3; long k = getLittleEndianLong(data, index); k *= M64; k ^= k >>> R64; k *= M64; h ^= k; h *= M64; } final int index = nblocks << 3; switch (length - index) { case 7: h ^= ((long) data[index + 6] & 0xff) << 48; falls-through case 6: h ^= ((long) data[index + 5] & 0xff) << 40; falls-through case 5: h ^= ((long) data[index + 4] & 0xff) << 32; falls-through case 4: h ^= ((long) data[index + 3] & 0xff) << 24; falls-through case 3: h ^= ((long) data[index + 2] & 0xff) << 16; falls-through case 2: h ^= ((long) data[index + 1] & 0xff) << 8; falls-through case 1: h ^= (long) data[index] & 0xff; h *= M64; } h ^= h >>> R64; h *= M64; h ^= h >>> R64; return h; } 
int finalise ( final int hash , final int unprocessedLength , final byte [ ] unprocessed , final int otalLen ) { int result = hash ; Note: This fails to apply masking using 0xff to the 3 remaining bytes. int k1 = 0; switch (unprocessedLength) { case 3: k1 ^= unprocessed[2] << 16; falls-through case 2: k1 ^= unprocessed[1] << 8; falls-through case 1: k1 ^= unprocessed[0]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
int finalise ( final int hash , final int unprocessedLength , final byte [ ] unprocessed , final int otalLen ) { int result = hash ; int k1 = 0 ; switch ( unprocessedLength ) { case 3 : k1 ^ = ( unprocessed [ 2 ] & 0xff ) < < 16 ; falls-through case 2: k1 ^= (unprocessed[1] & 0xff) << 8; falls-through case 1: k1 ^= unprocessed[0] & 0xff; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; result ^= k1; } finalization result ^= totalLen; return fmix32(result); } 
private static long [ ] hash128x64Internal ( final byte [ ] data , final int offset , final int length , final long seed ) { long h1 = seed ; long h2 = seed ; final int nblocks = length > > 4 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 4); long k1 = getLittleEndianLong(data, index); long k2 = getLittleEndianLong(data, index + 8); mix functions for k1 k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; h1 = Long.rotateLeft(h1, R2); h1 += h2; h1 = h1 * M + N1; mix functions for k2 k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; h2 = Long.rotateLeft(h2, R1); h2 += h1; h2 = h2 * M + N2; } tail long k1 = 0; long k2 = 0; final int index = offset + (nblocks << 4); switch (offset + length - index) { case 15: k2 ^= ((long) data[index + 14] & 0xff) << 48; falls-through case 14: k2 ^= ((long) data[index + 13] & 0xff) << 40; falls-through case 13: k2 ^= ((long) data[index + 12] & 0xff) << 32; falls-through case 12: k2 ^= ((long) data[index + 11] & 0xff) << 24; falls-through case 11: k2 ^= ((long) data[index + 10] & 0xff) << 16; falls-through case 10: k2 ^= ((long) data[index + 9] & 0xff) << 8; falls-through case 9: k2 ^= data[index + 8] & 0xff; k2 *= C2; k2 = Long.rotateLeft(k2, R3); k2 *= C1; h2 ^= k2; falls-through case 8: k1 ^= ((long) data[index + 7] & 0xff) << 56; falls-through case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; falls-through case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; falls-through case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; falls-through case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; falls-through case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; falls-through case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; falls-through case 1: k1 ^= data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; h1 ^= k1; } finalization h1 ^= length; h2 ^= length; h1 += h2; h2 += h1; h1 = fmix64(h1); h2 = fmix64(h2); h1 += h2; h2 += h1; return new long[] { h1, h2 }; } 
public static int hash32 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } tail Note: This fails to apply masking using 0xff to the 3 remaining bytes. final int index = offset + (nblocks << 2); int k1 = 0; switch (offset + length - index) { case 3: k1 ^= data[index + 2] << 16; falls-through case 2: k1 ^= data[index + 1] << 8; falls-through case 1: k1 ^= data[index]; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } hash ^= length; return fmix32(hash); } 
public static int hash32x86 ( final byte [ ] data , final int offset , final int length , final int seed ) { int hash = seed ; final int nblocks = length > > 2 ; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 2); final int k = getLittleEndianInt(data, index); hash = mix32(k, hash); } tail final int index = offset + (nblocks << 2); int k1 = 0; switch (offset + length - index) { case 3: k1 ^= (data[index + 2] & 0xff) << 16; falls-through case 2: falls-through k1 ^= (data[index + 1] & 0xff) << 8; falls-through case 1: k1 ^= data[index] & 0xff; mix functions k1 *= C1_32; k1 = Integer.rotateLeft(k1, R1_32); k1 *= C2_32; hash ^= k1; } hash ^= length; return fmix32(hash); } 
public static long hash64 ( final byte [ ] data , final int offset , final int length , final int seed ) { Note: This fails to apply masking using 0xffffffffL to the seed. long hash = seed; final int nblocks = length >> 3; body for (int i = 0; i < nblocks; i++) { final int index = offset + (i << 3); long k = getLittleEndianLong(data, index); mix functions k *= C1; k = Long.rotateLeft(k, R1); k *= C2; hash ^= k; hash = Long.rotateLeft(hash, R2) * M + N1; } tail long k1 = 0; final int index = offset + (nblocks << 3); switch (offset + length - index) { case 7: k1 ^= ((long) data[index + 6] & 0xff) << 48; falls-through case 6: k1 ^= ((long) data[index + 5] & 0xff) << 40; falls-through case 5: k1 ^= ((long) data[index + 4] & 0xff) << 32; falls-through case 4: k1 ^= ((long) data[index + 3] & 0xff) << 24; falls-through case 3: k1 ^= ((long) data[index + 2] & 0xff) << 16; falls-through case 2: k1 ^= ((long) data[index + 1] & 0xff) << 8; falls-through case 1: k1 ^= (long) data[index] & 0xff; k1 *= C1; k1 = Long.rotateLeft(k1, R1); k1 *= C2; hash ^= k1; } finalization hash ^= length; return fmix64(hash); } 
public void update ( final byte [ ] b , final int offset , final int len ) { int localCrc = crc ; final int remainder = len & 0x7 ; int i = offset ; for ( final int end = offset + len - remainder ; i < end ; i + = 8 ) { final int x = localCrc ^ ( b [ i ] < < 24 > > > 24 ) + ( b [ i + 1 ] < < 24 > > > 16 ) + ( b [ i + 2 ] < < 24 > > > 8 ) + ( b [ i + 3 ] < < 24 ) ; localCrc = T [ ( x < < 24 > > > 24 ) + 0x700 ] ^ T [ ( x < < 16 > > > 24 ) + 0x600 ] ^ T [ ( x < < 8 > > > 24 ) + 0x500 ] ^ T [ ( x > > > 24 ) + 0x400 ] ^ T [ ( b [ i + 4 ] < < 24 > > > 24 ) + 0x300 ] ^ T [ ( b [ i + 5 ] < < 24 > > > 24 ) + 0x200 ] ^ T [ ( b [ i + 6 ] < < 24 > > > 24 ) + 0x100 ] ^ T [ b [ i + 7 ] < < 24 > > > 24 ] ; } loop unroll - duff's device style switch (remainder) { case 7: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 6: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 5: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 4: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 3: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 2: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through case 1: localCrc = localCrc >>> 8 ^ T[(localCrc ^ b[i++]) << 24 >>> 24]; falls-through default: nothing } Publish crc out to object crc = localCrc; } 
public void update ( final byte [ ] b , int off , int len ) { int localCrc = crc ; while ( len > 7 ) { final int c0 = ( b [ off + 0 ] ^ localCrc ) & 0xff ; final int c1 = ( b [ off + 1 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c2 = ( b [ off + 2 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; final int c3 = ( b [ off + 3 ] ^ ( localCrc > > > = 8 ) ) & 0xff ; localCrc = T [ T8_7_START + c0 ] ^ T [ T8_6_START + c1 ] ^ T [ T8_5_START + c2 ] ^ T [ T8_4_START + c3 ] ; final int c4 = b [ off + 4 ] & 0xff ; final int c5 = b [ off + 5 ] & 0xff ; final int c6 = b [ off + 6 ] & 0xff ; final int c7 = b [ off + 7 ] & 0xff ; localCrc ^ = T [ T8_3_START + c4 ] ^ T [ T8_2_START + c5 ] ^ T [ T8_1_START + c6 ] ^ T [ T8_0_START + c7 ] ; off + = 8 ; len - = 8 ; } loop unroll - duff's device style switch (len) { case 7: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 6: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 5: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 4: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 3: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 2: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through case 1: localCrc = localCrc >>> 8 ^ T[T8_0_START + ((localCrc ^ b[off++]) & 0xff)]; falls-through default: break; satisfy Findbugs } Publish crc out to object crc = localCrc; } 
private static long copy ( final InputStream input , final OutputStream output , final int bufferSize ) hrows IOException { return IOUtils . copyLarge ( input , output , new byte [ bufferSize ] ) ; } 
