public static void main ( String [ ] argv ) { RubyInstanceConfig config = new RubyInstanceConfig ( ) ; config . setArgv ( argv ) ; List < String > loadPaths = new ArrayList < String > ( ) ; tloadPaths . add ( " lib " ) ; Ruby runtime = JavaEmbedUtils . initialize ( loadPaths , config ) ; RubyRuntimeAdapter evaler = JavaEmbedUtils . newRuntimeAdapter ( ) ; String main = " bin/cucumber " ; InputStream mainScript = Cucumber . class . getClassLoader ( ) . getResourceAsStream ( main ) ; try { evaler . parse ( runtime , mainScript , " cucumber " , 0 ) . run ( ) ; 
public void iHaveNCukes ( String , String color ) { this . cukes . put ( color , ) ; } 
public void iAddATable ( Table table ) { Map < String , String > hash = table . hashes ( ) . get ( 0 ) ; assertEquals ( " 1 " , hash . get ( " a " ) ) ; assertEquals ( " 2 " , hash . get ( " b " ) ) ; } 
public void iShouldHaveNCukes ( String , String color ) { if ( ! . equals ( cukes . get ( color ) ) ) { throw new RuntimeException ( " Expected " + + " , got " + cukes . get ( color ) ) ; 
public String file_colon_line ( ) { return method . toGenericString ( ) ; } 
public void invoke ( RubyNil world , RubyArray args ) throws Throwable { invokeOnTarget ( args . toArray ( ) ) ; } 
public void invokeOnTarget ( Object [ ] args ) throws Throwable { try { method . invoke ( target , args ) ; 
public void add ( Class stepsClass ) { stepsClasses . add ( stepsClass ) ; } 
public void iHaveNCukes ( int , String color ) { this . cukes . put ( color , ) ; } 
public void iShouldHaveNCukes ( int , String color ) { if ( ! = cukes . get ( color ) ) { throw new RuntimeException ( " Expected " + + " , got " + cukes . get ( color ) ) ; 
public void shouldInvokeSuccessfully ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( FooSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { 56 , " green " } ) ; then . invokeOnTarget ( new Object [ ] { 56 , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( FooSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { 56 , " green " } ) ; then . invokeOnTarget ( new Object [ ] { 99 , " green " } ) ; } 
public void iAddATable ( Table table ) { Map < String , String > hash = table . hashes ( ) . get ( 0 ) ; assertEquals ( " 1 " , hash . get ( " a " ) ) ; assertEquals ( " 3 " , hash . get ( " b " ) ) ; } 
public void invokeOnTarget ( RubyArray args ) throws Throwable { invokeOnTarget ( args . toArray ( ) ) ; } 
void invokeOnTarget ( Object [ ] args ) throws Throwable { try { method . invoke ( target , args ) ; 
public void iShouldHaveNCukes ( String , String color ) { assertEquals ( , cukes . get ( color ) ) ; } 
public void iShouldHaveNCukes ( int , String color ) { assertEquals ( ( long ) , ( long ) cukes . get ( color ) ) ; } 
void invokeOnTarget ( Object [ ] args ) throws Throwable { try { Object [ ] convArgs = new Object [ args . length ] ; 
public void shouldInvokeSuccessfully ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( FooSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( FooSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 99 " , " green " } ) ; } 
public void iShouldHaveNCukes ( int , String color ) { assertEquals ( , cukes . get ( color ) ) ; } 
public void iShouldHaveNCukes ( int , String color ) { assertEquals ( , ( int ) cukes . get ( color ) ) ; } 
protected void ensureGems ( String [ ] gemNames ) throws MojoExecutionException { List args = new ArrayList ( ) ; args . add ( " -S " ) ; args . add ( " maybe_install_gems " ) ; for ( int i = 0 ; i < gemNames . length ; i + + ) { args . add ( gemNames [ i ] ) ; } Java jruby = jruby ( ( String [ ] ) args . toArray ( new String [ args . size ( ) ] ) ) ; jruby . execute ( ) ; } 
protected void ensureGem ( String gemName ) throws MojoExecutionException { ensureGems ( new String [ ] { gemName } ) ; } 
protected Project getProject ( ) throws DependencyResolutionRequiredException { Project project = new Project ( ) ; project . setBaseDir ( mavenProject . getBasedir ( ) ) ; project . addBuildListener ( new LogAdapter ( ) ) ; addReference ( project , " maven.compile.classpath " , compileClasspathElements ) ; addReference ( project , " maven.plugin.classpath " , pluginArtifacts ) ; return project ; } 
protected void addReference ( Project project , String reference , List artifacts ) throws DependencyResolutionRequiredException { List list = new ArrayList ( artifacts . size ( ) ) ; for ( Iterator i = artifacts . iterator ( ) ; i . hasNext ( ) ; ) { Object elem = i . next ( ) ; String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( project ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; project . addReference ( reference , p ) ; } 
public void buildStarted ( BuildEvent event ) { log ( event ) ; } 
public void buildFinished ( BuildEvent event ) { log ( event ) ; } 
public void targetStarted ( BuildEvent event ) { log ( event ) ; } 
public void targetFinished ( BuildEvent event ) { log ( event ) ; } 
public void taskStarted ( BuildEvent event ) { log ( event ) ; } 
public void taskFinished ( BuildEvent event ) { log ( event ) ; } 
public void messageLogged ( BuildEvent event ) { log ( event ) ; } 
private void log ( BuildEvent event ) { int priority = event . getPriority ( ) ; Log log = getLog ( ) ; switch ( priority ) { case Project . MSG_ERR : 
public void execute ( ) throws MojoFailureException , MojoExecutionException { outputDirectory . mkdirs ( ) ; ensureGem ( " cucumber " ) ; List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -S " ) ; allArgs . add ( " cucumber " ) ; if ( featuresDirectory ! = null ) { allArgs . add ( featuresDirectory ) ; } else { allArgs . add ( " src/test/features " ) ; } Java jruby = null ; jruby = jruby ( ( String [ ] ) allArgs . toArray ( new String [ allArgs . size ( ) ] ) ) ; try { jruby . execute ( ) ; 
public void execute ( ) throws MojoExecutionException { String commandString = " -S gem " ; if ( args ! = null ) { commandString + = " " + args ; } executeCmd ( commandString ) ; } 
public void execute ( ) throws MojoExecutionException { ensureGems ( gems . split ( " [, ]+ " ) ) ; } 
public void execute ( ) throws MojoExecutionException { executeCmd ( args ) ; } 
protected void executeCmd ( String commandline ) throws MojoExecutionException { Java jruby = jruby ( commandline . split ( " \\ s+ " ) ) ; jruby . execute ( ) ; } 
void invokeOnTarget ( Object [ ] args ) throws Throwable { try { Object [ ] convertedArgs = conertArgs ( args ) ; 
private Object convertArg ( Class clazz , Object arg ) { if ( clazz . equals ( Integer . TYPE ) ) { return Integer . valueOf ( ( String ) arg ) ; 
public void longs ( long ) { } public void thisIsNotAStep ( ) { } } 
public void shouldInvokeSuccessfully ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 99 " , " green " } ) ; } 
public void shouldConvertLongs ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 2 ) ; given.invokeOnTarget(new Object[]{"33"}); 
protected void installGem ( List < String > gem ) throws MojoExecutionException { List args = new ArrayList ( ) ; args . add ( " -S " ) ; maybe_install_gems only takes a list of gems, no versions or sources if (gem.size() > 1) { args.add("gem"); args.add("install"); } else { args.add("maybe_install_gems"); } args.addAll(gem); Java jruby = jruby(args); jruby.execute(); } 
protected void addReference ( Project project , String reference , List artifacts ) throws DependencyResolutionRequiredException { List list = new ArrayList ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( project ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; project . addReference ( reference , p ) ; } 
public static < T > List < T > listify ( T . . . objects ) { List < T > res = new ArrayList < T > ( ) ; res . addAll ( Arrays . asList ( objects ) ) ; return res ; } 
private void log ( BuildEvent event ) { int priority = event . getPriority ( ) ; Log log = getLog ( ) ; switch ( priority ) { case Project . MSG_ERR : 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { installGem ( listify ( " cucumber " ) ) ; for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -S " ) ; allArgs . add ( " cucumber " ) ; allArgs . add ( ( features ! = null ) ? features : " src/test/features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
private List parseGem ( String gemSpec ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . isEmpty ( ) ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { args . add ( name ) ; } if ( version ! = null & & ! version . isEmpty ( ) ) { args . add ( " -v " + version ) ; } if ( source ! = null & & ! source . isEmpty ( ) ) { if ( source . contains ( " github " ) ) { args . add ( " --source " ) ; args . add ( " http:gems.github.com " ) ; } } return args ; } 
protected void executeCmd ( String commandline ) throws MojoExecutionException { Java jruby = jruby ( Arrays . asList ( commandline . split ( " \\ s+ " ) ) ) ; jruby . execute ( ) ; } 
void invokeOnTarget ( Object [ ] args ) throws Throwable { try { Object [ ] convertedArgs = convertArgs ( args ) ; 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; List stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs1 . size ( ) ) ; mother . newWorld ( ) ; List stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs1 . size ( ) ) ; } 
private List parseGem ( String gemSpec ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { args . add ( name ) ; } if ( version ! = null & & version . length ( ) ! = 0 ) { args . add ( " -v " + version ) ; } if ( source ! = null & & source . length ( ) = = 0 ) { if ( source . contains ( " github " ) ) { args . add ( " --source " ) ; args . add ( " http:gems.github.com " ) ; } } return args ; } 
private Object convertArg ( Class < ? > clazz , Object arg ) { if ( clazz . equals ( Integer . TYPE ) ) { return Integer . valueOf ( ( String ) arg ) ; 
public void add ( Class < ? > stepsClass ) { stepsClasses . add ( stepsClass ) ; } 
public void shouldConvertLongs ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 2 ) ; given . invokeOnTarget ( new Object [ ] { " 33 " } ) ; } 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; List < StepDefinition > stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs1 . size ( ) ) ; mother . newWorld ( ) ; List < StepDefinition > stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs2 . size ( ) ) ; for ( int i = 0 ; i < 3 ; i + + ) { tassertNotSame ( stepDefs1 . get ( i ) , stepDefs2 . get ( i ) ) ; 
public void iShouldHaveNCukes ( int , String color ) { int number = cukes . get ( color ) ! = null ? cukes . get ( color ) : 0 ; tassertEquals ( , number ) ; } 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . add ( CukeSteps . class ) ; mother . newWorld ( ) ; List < StepDefinition > stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs1 . size ( ) ) ; List < StepDefinition > oldSteps = new ArrayList < StepDefinition > ( ) ; for ( StepDefinition stepDefinition : stepDefs1 ) { toldSteps . add ( stepDefinition ) ; } mother . newWorld ( ) ; List < StepDefinition > stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs2 . size ( ) ) ; for ( int i = 0 ; i < 3 ; i + + ) { tassertNotSame ( oldSteps . get ( i ) , stepDefs2 . get ( i ) ) ; 
public void newWorld ( ) { tif ( appContext = = null ) { tappContext = new ClassPathXmlApplicationContext ( new String [ ] { config } ) ; } else { tappContext . refresh ( ) ; } for ( Class < ? > stepsClass : stepsClasses ) { @SuppressWarnings ( " unchecked " ) 
public void shouldInitSpringContext ( ) throws Throwable { tSpringBasedStepMother mother = new SpringBasedStepMother ( " steps.xml " ) ; tmother . add ( SpringSteps . class ) ; tmother . newWorld ( ) ; tList < StepDefinition > stepDefinitions = mother . getStepDefinitions ( ) ; tassertEquals ( 3 , stepDefinitions . size ( ) ) ; tStepDefinition helloStep = stepDefinitions . get ( 1 ) ; thelloStep . invokeOnTarget ( new Object [ ] { } ) ; } 
public void iSayHello ( ) { tString hello = service . hello ( ) ; tif ( ! hello . equals ( " Have a cuke, Duke " ) ) { tthrow new RuntimeException ( " Wrong reply from service " ) ; 
public void iAskTheWorldForHello ( ) { thelloResponse = world . hello ( ) ; } 
public void theResponseShouldBe ( String response ) { tassertEquals ( response , helloResponse ) ; } 
public void registerSteps ( Class < ? > stepsClass ) { stepsClasses . add ( stepsClass ) ; } 
public void shouldInitSpringContext ( ) throws Throwable { tSpringBasedStepMother mother = new SpringBasedStepMother ( " steps.xml " ) ; tmother . registerSteps ( SpringSteps . class ) ; tmother . newWorld ( ) ; tList < StepDefinition > stepDefinitions = mother . getStepDefinitions ( ) ; tassertEquals ( 3 , stepDefinitions . size ( ) ) ; tStepDefinition helloStep = stepDefinitions . get ( 1 ) ; thelloStep . invokeOnTarget ( new Object [ ] { } ) ; } 
public void shouldInvokeSuccessfully ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . registerSteps ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . registerSteps ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 99 " , " green " } ) ; } 
public void shouldConvertLongs ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . registerSteps ( CukeSteps . class ) ; mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 2 ) ; given . invokeOnTarget ( new Object [ ] { " 33 " } ) ; } 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { StepMother mother = new StepMother ( ) ; mother . registerSteps ( CukeSteps . class ) ; mother . newWorld ( ) ; List < StepDefinition > stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs1 . size ( ) ) ; List < StepDefinition > oldSteps = new ArrayList < StepDefinition > ( ) ; for ( StepDefinition stepDefinition : stepDefs1 ) { toldSteps . add ( stepDefinition ) ; } mother . newWorld ( ) ; List < StepDefinition > stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 3 , stepDefs2 . size ( ) ) ; for ( int i = 0 ; i < 3 ; i + + ) { tassertNotSame ( oldSteps . get ( i ) , stepDefs2 . get ( i ) ) ; 
public void newWorld ( ) { stepDefinitions . clear ( ) ; appContext . refresh ( ) ; for ( Class < ? > clazz : classes ) { @SuppressWarnings ( " unchecked " ) 
public void registerClass ( Class < ? > stepsClass ) { classes . add ( stepsClass ) ; } 
public String hello ( ) { return " Have a cuke, Duke " ; } 
public void createStepMother ( ) { mother = new PicoContainerStepMother ( ) ; mother . registerClass ( PicoContainerHelloService . class ) ; mother . registerClass ( PicoContainerSteps . class ) ; } 
public void createStepMother ( ) { mother = new SpringStepMother ( ) ; ( ( SpringStepMother ) mother ) . setConfigs ( new String [ ] { " steps.xml " } ) ; mother . registerClass ( SpringSteps . class ) ; } 
public void shouldInvokeSuccessfully ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 0 ) ; StepDefinition then = mother . getStepDefinitions ( ) . get ( 1 ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 99 " , " green " } ) ; } 
public void shouldConvertLongs ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinitions ( ) . get ( 2 ) ; given . invokeOnTarget ( new Object [ ] { " 33 " } ) ; } 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { mother . newWorld ( ) ; List < StepDefinition > stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 4 , stepDefs1 . size ( ) ) ; List < StepDefinition > oldSteps = new ArrayList < StepDefinition > ( ) ; for ( StepDefinition stepDefinition : stepDefs1 ) { oldSteps . add ( stepDefinition ) ; } mother . newWorld ( ) ; List < StepDefinition > stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 4 , stepDefs2 . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertNotSame ( oldSteps . get ( i ) , stepDefs2 . get ( i ) ) ; 
protected abstract HelloService getHelloService ( ) ; @Given ( " I have ( \\ d+) (.*) cukes " ) public void iHaveNCukes ( int , String color ) { this . cukes . put ( color , ) ; } @Then ( " I should have ( \\ d+) (.*) cukes " ) public void iShouldHaveNCukes ( int , String color ) { if ( ! = cukes . get ( color ) ) { throw new RuntimeException ( " Expected " + + " , got " + cukes . get ( color ) ) ; } } @Given ( " Longs: ( \\ d+) " ) public void longs ( long ) { } @Given ( " I say hello " ) public void iSayHello ( ) { String hello = getHelloService ( ) . hello ( ) ; if ( ! hello . equals ( " Have a cuke, Duke " ) ) { throw new RuntimeException ( " Wrong reply from service " ) ; } } public void thisIsNotAStep ( ) { } } 
public void iShouldHaveNCukes ( int , String color ) { if ( ! = cukes . get ( color ) ) { throw new RuntimeException ( " Expected " + + " , got " + cukes . get ( color ) ) ; 
public void longs ( long ) { } @Given ( " I say hello " ) public void iSayHello ( ) { String hello = getHelloService ( ) . hello ( ) ; if ( ! hello . equals ( " Have a cuke, Duke " ) ) { throw new RuntimeException ( " Wrong reply from service " ) ; } } public void thisIsNotAStep ( ) { } } 
public void iSayHello ( ) { String hello = getHelloService ( ) . hello ( ) ; if ( ! hello . equals ( " Have a cuke, Duke " ) ) { throw new RuntimeException ( " Wrong reply from service " ) ; 
protected Project getProject ( ) throws DependencyResolutionRequiredException { Project project = new Project ( ) ; project . setBaseDir ( mavenProject . getBasedir ( ) ) ; project . addBuildListener ( new LogAdapter ( ) ) ; addReference ( project , " maven.compile.classpath " , compileClasspathElements ) ; addReference ( project , " maven.plugin.classpath " , pluginArtifacts ) ; addReference ( project , " maven.test.classpath " , testClasspathElements ) ; return project ; } 
protected Statement methodInvoker ( FrameworkMethod method , Object test ) { if ( scenarioMethods . contains ( method ) ) { return executeScenario ( test , method ) ; } return super . methodInvoker ( method , test ) ; } 
protected void validateInstanceMethods ( List < Throwable > errors ) { validatePublicVoidNoArgMethods ( After . class , false , errors ) ; validatePublicVoidNoArgMethods ( Before . class , false , errors ) ; validateTestMethods ( errors ) ; } 
protected Statement executeScenario ( final Object featureObject , final FrameworkMethod method ) { return new Statement ( ) { public void evaluate ( ) throws Throwable { 
public void evaluate ( ) throws Throwable { System . out . println ( " Executing scenario = " + method . getName ( ) ) ; } 
private String extractScenarioName ( Method method , Scenario scenarioAnnotation ) { return scenarioAnnotation . value ( ) . isEmpty ( ) ? method . getName ( ) . replace ( " _ " , " " ) : scenarioAnnotation . value ( ) ; } 
private String extractFeatureName ( Class featureClass ) { Feature featureAnnotation = ( Feature ) featureClass . getAnnotation ( Feature . class ) ; return featureAnnotation ! = null ? featureAnnotation . value ( ) : featureClass . getSimpleName ( ) + " .feature " ; } 
public String toString ( ) { String res = scenarioName ; if ( ! tags . isEmpty ( ) ) { res + = " , tags= " + tags ; } return res ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CucumberScenarioWrapper ) ) return false ; CucumberScenarioWrapper that = ( CucumberScenarioWrapper ) o ; if ( ! scenarioName . equals ( that . scenarioName ) ) return false ; return true ; } 
public int hashCode ( ) { return scenarioName . hashCode ( ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CucumberScenarioMethod ) ) return false ; CucumberScenarioMethod that = ( CucumberScenarioMethod ) o ; if ( ! cucumberScenario . equals ( that . cucumberScenario ) ) return false ; return true ; } 
public int hashCode ( ) { int result = 31 * cucumberScenario . hashCode ( ) ; return result ; } 
public void ThreeGreenCukes ( ) { } @Scenario ( " 4 green cukes " ) @Tag ( { " aTag " , " otherTag " } ) public void FourGreenCukes ( ) { } @Scenario ( " 0 yellow cukes " ) @Ignore This scenario should be ignored public void ZeroYellowCukes() { } @Scenario public void lots_of_green_cukes() { }} 
public void FourGreenCukes ( ) { } @Scenario ( " 0 yellow cukes " ) @Ignore This scenario should be ignored public void ZeroYellowCukes() { } @Scenario public void lots_of_green_cukes() { }} 
public void ZeroYellowCukes ( ) { } @Scenario public void lots_of_green_cukes ( ) { } } 
protected Statement methodInvoker ( FrameworkMethod method , Object test ) { if ( scenarioMethods . contains ( method ) ) { return executeScenario ( test , ( CucumberScenarioMethod ) method ) ; } return super . methodInvoker ( method , test ) ; } 
protected Statement executeScenario ( final Object featureObject , final CucumberScenarioMethod method ) { return new Statement ( ) { public void evaluate ( ) throws Throwable { 
public void evaluate ( ) throws Throwable { System . out . println ( " Executing scenario = " + method . getName ( ) ) ; String cli = " cucumber --name " + method . getName ( ) ; if ( method . hasTags ( ) ) { cli + = " --tags " + method . tagsAsCSV ( ) ; } cli + = " " + featureName ; System . out . println ( cli ) ; 
public String tagsAsCSV ( ) { String res = " " ; for ( String tag : cucumberScenario . tags ) { res + = tag + " , " ; } if ( res . endsWith ( " , " ) ) { res = res . substring ( 0 , res . length ( ) - 1 ) ; } return res ; } 
public boolean hasTags ( ) { return ! cucumberScenario . tags . isEmpty ( ) ; } 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cucumber' " ) ; add ( " require 'cucumber/pico_container' " ) ; add("register_class(Java::" + Feature.class.getCanonicalName() + ")"); add("register_class(Java::cucumber.junit.CukeFeature)"); add("load 'cucumber'"); add(" puts 'Executing scenario : " + method.getName() + "'"); }}; String script = ""; for (String scriptLine : scriptLines) { script += scriptLine + ""; } exec(script); } 
public void exec ( String script ) throws BSFException { try { rubyEngine . exec ( " CucumberJunit4Runner " , 0 , 0 , script ) ; 
public String tagsAsCSV ( ) { String res = " " ; for ( String tag : cucumberScenario . tags ) { res + = tag + " , " ; } if ( res . endsWith ( " , " ) ) { res = res . substring ( 0 , res . length ( ) - 1 ) ; } return res ; } 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cucumber' " ) ; add ( " require 'cucumber/java' " ) ; add("register_class(Java::" + Feature.class.getCanonicalName() + ")"); add("stepMother = ::Java::CucumberInternal::PicoContainerStepMother.new "); add("cli = Cucumber::Cli::Main.new(stepMother)"); add("stepMother.register_class(Java::cucumber.junit.CukeFeature)"); add("cli.initialize(['src/test/java/cucumber/junit/demo.feature'])"); add("cli.execute!(step_mother)"); add(" puts 'Executing scenario : " + method.getName() + "'"); }}; String script = ""; for (String scriptLine : scriptLines) { script += scriptLine + ""; } exec(script); } 
private String extractScenarioName ( Method method , Scenario scenarioAnnotation ) { return scenarioAnnotation . value ( ) . length ( ) = = 0 ? method . getName ( ) . replace ( " _ " , " " ) : scenarioAnnotation . value ( ) ; } 
protected Statement methodInvoker ( FrameworkMethod method , Object test ) { This throws NPE on JUnit 4.5 because CucumberScenarioMethod ctor passes null to super. (Java 1.5) if (scenarioMethods.contains(method)) { return executeScenario(test, (CucumberScenarioMethod) method); } return super.methodInvoker(method, test); } 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cucumber' " ) ; add ( " require 'cucumber/pico_container' " ) ; add ( " Cucumber::Cli::Main.execute(['--help']) " ) ; } } ; String script = " " ; for ( String scriptLine : scriptLines ) { script + = scriptLine + " " ; } exec ( script ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CucumberScenarioWrapper ) ) return false ; CucumberScenarioWrapper that = ( CucumberScenarioWrapper ) o ; return scenarioName . equals ( that . scenarioName ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CucumberScenarioMethod ) ) return false ; CucumberScenarioMethod that = ( CucumberScenarioMethod ) o ; return cucumberScenario . equals ( that . cucumberScenario ) ; } 
public int hashCode ( ) { return 31 * cucumberScenario . hashCode ( ) ; } 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cucumber' " ) ; add ( " require 'cucumber/pico_container' " ) ; add("Cucumber::Cli::Main.execute(['--help'])"); }}; String script = ""; for (String scriptLine : scriptLines) { script += scriptLine + ""; } exec(script); } 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cucumber' " ) ; add ( " require 'cucumber/junit' " ) ; add ( " register_class(Java::cucumber.junit.JunitCukeSteps) " ) ; add ( " Cucumber::Cli::Main.execute(['--format', 'progress', '/Users/kaare/develop/projects/com/github/cucumber_java/cucumber-java/src/test/java " + featureName + " ']) " ) ; } } ; String script = " " ; for ( String scriptLine : scriptLines ) { script + = scriptLine + " " ; } exec ( script ) ; } 
public void newWorld ( ) { stepDefinitions . clear ( ) ; } 
public void registerSteps ( Object object ) { super . addStepDefinitions ( object ) ; } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { installGem ( listify ( " cucumber " ) ) ; for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -S " ) ; allArgs . add ( " cucumber " ) ; tallArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " src/test/features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
private List parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . isEmpty ( ) ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & ! version . isEmpty ( ) ) { gemArgs . add ( " -v " + version ) ; } if ( source ! = null & & ! source . isEmpty ( ) ) { if ( source . contains ( " github " ) ) { gemArgs . add ( " --source " ) ; gemArgs . add ( " http:gems.github.com " ) ; } } return gemArgs ; } 
protected void installGem ( List < String > gem ) throws MojoExecutionException { List args = new ArrayList ( ) ; args . add ( " -S " ) ; maybe_install_gems only takes a list of gems, no versions or sources if (gem.size() > 1) { args.add("gem"); args.add("install"); } else { args.add("maybe_install_gems"); } args.addAll(gem); args.add("--no-ri"); args.add("--no-rdoc"); Java jruby = jruby(args); jruby.execute(); } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { installGem ( listify ( " cucumber " ) ) ; for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -S " ) ; allArgs . add ( " cucumber " ) ; tallArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
public void evaluate ( ) throws Throwable { List < String > scriptLines = new ArrayList < String > ( ) { { add ( " require 'rubygems' " ) ; add ( " require 'cuke4duke' " ) ; add ( " require 'cuke4duke/junit' " ) ; add ( " register_class(Java::cuke4duke.junit.JunitCukeSteps) " ) ; add ( " Cucumber::Cli::Main.execute(['--format', 'progress', '/Users/kaare/develop/projects/com/github/cucumber_java/cuke4duke-java/src/test/java " + featureName + " ']) " ) ; } } ; String script = " " ; for ( String scriptLine : scriptLines ) { script + = scriptLine + " " ; } exec ( script ) ; } 
public void registerSteps ( Object object ) { super . addCucumberMethods ( object ) ; } 
public void executeBeforeHooks ( RubyArray arrayWithScenario ) throws Throwable { for ( Hook hook : beforeHooks ) { hook . invokeOnTarget ( arrayWithScenario ) ; 
private void registerBefore ( Object object , Method method ) { if ( method . isAnnotationPresent ( Before . class ) ) { beforeHooks . add ( new Hook ( object , method , method . getAnnotation ( Before . class ) . value ( ) ) ) ; 
private void registerStepDefinition ( Object object , Method method ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { stepDefinitions . add ( new StepDefinition ( object , method , regexpString ) ) ; 
public void thenB4 ( String b4Value ) { assertEquals ( b4Value , b4 ) ; } 
private List parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } if ( source ! = null & & source . trim ( ) . length ( ) > 0 ) { if ( source . contains ( " github " ) ) { gemArgs . add ( " --source " ) ; gemArgs . add ( " http:gems.github.com " ) ; } } return gemArgs ; } 
private void log ( BuildEvent event ) { int priority = event . getPriority ( ) ; Log log = getLog ( ) ; String message = event . getMessage ( ) ; if ( message . contains ( " nbb " ) ) return ; tswitch ( priority ) { case Project . MSG_ERR : 
private void log ( BuildEvent event ) { int priority = event . getPriority ( ) ; Log log = getLog ( ) ; String message = event . getMessage ( ) ; switch ( priority ) { case Project . MSG_ERR : 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { installGem ( listify ( " cucumber " ) ) ; for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -S " ) ; allArgs . add ( " cucumber " ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
protected void installGem ( List < String > gem ) throws MojoExecutionException { List args = new ArrayList ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( gem ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
protected List parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } if ( source ! = null & & source . trim ( ) . length ( ) > 0 ) { if ( source . contains ( " github " ) ) { gemArgs . add ( " --source " ) ; gemArgs . add ( " http:gems.github.com " ) ; } } return gemArgs ; } 
protected File dotGemParent ( ) { return new File ( localRepository . getBasedir ( ) ) ; } 
protected File gemHome ( ) { return new File ( dotGemParent ( ) , " .gem " ) ; } 
protected File binDir ( ) { return new File ( gemHome ( ) , " bin " ) ; } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { installGem ( listify ( " cucumber " ) ) ; for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
private File cucumberBin ( ) { return new File ( binDir ( ) , " cucumber " ) ; } 
private void registerStepDefinition ( Object object , Method method ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { stepDefinitions . put ( regexpString , new StepDefinition ( object , method , regexpString ) ) ; 
public void shouldInvokeSuccessfully ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinition ( " I have ( \\ d+) (.*) cukes " ) ; StepDefinition then = mother . getStepDefinition ( " I should have ( \\ d+) (.*) cukes " ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; } 
public void shouldInvokeWithFailure ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinition ( " I have ( \\ d+) (.*) cukes " ) ; StepDefinition then = mother . getStepDefinition ( " I should have ( \\ d+) (.*) cukes " ) ; given . invokeOnTarget ( new Object [ ] { " 56 " , " green " } ) ; then . invokeOnTarget ( new Object [ ] { " 99 " , " green " } ) ; } 
public void shouldConvertLongs ( ) throws Throwable { mother . newWorld ( ) ; StepDefinition given = mother . getStepDefinition ( " Longs: ( \\ d+) " ) ; given . invokeOnTarget ( new Object [ ] { " 33 " } ) ; } 
public void shouldCreateNewStepDefinitionsForEachNewWorld ( ) throws Throwable { mother . newWorld ( ) ; Collection < StepDefinition > stepDefs1 = mother . getStepDefinitions ( ) ; assertEquals ( 4 , stepDefs1 . size ( ) ) ; List < StepDefinition > oldSteps = new ArrayList < StepDefinition > ( stepDefs1 ) ; mother . newWorld ( ) ; Collection < StepDefinition > stepDefs2 = mother . getStepDefinitions ( ) ; assertEquals ( 4 , stepDefs2 . size ( ) ) ; List < StepDefinition > newSteps = new ArrayList < StepDefinition > ( stepDefs1 ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertNotSame ( oldSteps . get ( i ) , newSteps . get ( i ) ) ; 
protected void installGem ( List < String > gem ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( gem ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
protected List < String > parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } if ( source ! = null & & source . trim ( ) . length ( ) > 0 ) { if ( source . contains ( " github " ) ) { gemArgs . add ( " --source " ) ; gemArgs . add ( " http:gems.github.com " ) ; } } return gemArgs ; } 
protected void addReference ( Project project , String reference , List < ? extends Object > artifacts ) throws DependencyResolutionRequiredException { List < String > list = new ArrayList < String > ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( project ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; project . addReference ( reference , p ) ; } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
private void registerStepDefinitions ( StepMother stepMother , Class < ? > featureClass ) { StepDefinitions stepDefinitions = ( StepDefinitions ) featureClass . getAnnotation ( StepDefinitions . class ) ; for ( Class stepDefinition : stepDefinitions . value ( ) ) { stepMother . registerClass ( stepDefinition ) ; 
protected Statement methodInvoker ( FrameworkMethod method , Object test ) { if ( scenarioMethods . contains ( method ) ) { return scenarioStatement ( ( CucumberScenarioMethod ) method ) ; } return super . methodInvoker ( method , test ) ; } 
protected Statement scenarioStatement ( final CucumberScenarioMethod method ) { return new Statement ( ) { public void evaluate ( ) throws Throwable { 
private String featurePathFor ( Class featureClass ) { Feature featureAnnotation = ( Feature ) featureClass . getAnnotation ( Feature . class ) ; return featureAnnotation ! = null ? featureAnnotation . value ( ) : featureClass . getSimpleName ( ) + " .feature " ; } 
public void visitStepResult ( String keyword , String status , RubyException exception ) { if ( exception ! = null & & this . exception = = null ) { this . exception = new Exception ( exception . message . toString ( ) ) ; 
public List < Map < String , String > > hashes ( ) ; public void diff ( List < List < String > > table ) ; public void diff(List<Map<String, String>> table);} 
public void diff ( List < List < String > > table ) ; public void diff(List<Map<String, String>> table);} 
public void run ( String featurePath , String scenarioName , Visitor visitor ) throws BSFException { bsfManager . declareBean ( " cuke4duke_visitor_delegate " , visitor , visitor . getClass ( ) ) ; String fullFeaturePath = fullFeaturePath ( featurePath ) ; String mainScript = " Cucumber::Cli::Main.execute(['--format', 'Cuke4duke::Formatter', '--name', ' " + scenarioName + " ', ' " + fullFeaturePath + " ']) " ; try { rubyEngine . exec ( " CucumberRunner.run " , 0 , 0 , mainScript ) ; 
private String fullFeaturePath ( String featurePath ) { URL featureURL = getClass ( ) . getResource ( featurePath ) ; if ( featureURL = = null ) { throw new RuntimeException ( " Couldn't find " + featurePath + " on the classpath. " ) ; 
void invokeOnTarget ( Object [ ] args ) throws Throwable { Object [ ] convertedArgs = convertArgs ( args ) ; try { method . invoke ( target , convertedArgs ) ; 
void visitFeatures ( ) ; void visitScenarioName ( String keyword , String scenarioName ) ; void visitStepResult ( String keyword , String status , RubyException exception ) ; } 
void visitScenarioName ( String keyword , String scenarioName ) ; void visitStepResult ( String keyword , String status , RubyException exception ) ; } 
void visitStepResult ( String keyword , String status , RubyException exception ) ; } 
public void dummy ( ) { } @Test public void shouldBeAbleToRunSingleFeature() throws BSFException { Visitor visitor = mock(Visitor.class); StepMother stepMother = new PicoContainerStepMother(); stepMother.registerClass(JunitCukeSteps.class); CucumberRunner runner = new CucumberRunner(stepMother); runner.run("/demo.feature", "3 green and 4 yellow cukes", visitor); verify(visitor).visitFeatures(); verify(visitor).visitScenarioName("Scenario:", "3 green and 4 yellow cukes"); }} 
public void shouldBeAbleToRunSingleFeature ( ) throws BSFException { Visitor visitor = mock ( Visitor . class ) ; StepMother stepMother = new PicoContainerStepMother ( ) ; stepMother . registerClass ( JunitCukeSteps . class ) ; CucumberRunner runner = new CucumberRunner ( stepMother ) ; runner . run ( " /demo.feature " , " 3 green and 4 yellow cukes " , visitor ) ; verify ( visitor ) . visitFeatures ( ) ; verify ( visitor ) . visitScenarioName ( " Scenario: " , " 3 green and 4 yellow cukes " ) ; } 
public void dummy ( ) { } @Scenario("3 green cukes") Use the method name (replace _ with space) if a value is not present @Tag("aTag") public void ThreeGreenCukes() { } @Scenario("4 green cukes") @Tag({"aTag", "otherTag"}) public void FourGreenCukes() { } @Scenario("0 yellow cukes") @Ignore This scenario should be ignored public void ZeroYellowCukes() { } @Scenario public void lots_of_green_cukes() { }} 
public void iShouldHaveNCukes ( int , String color ) { int cukesOfColor = cukes . get ( color ) ; if ( ! = cukesOfColor ) { throw new RuntimeException ( " Expected " + + " , got " + cukes . get ( color ) ) ; 
public void aTable ( Table table ) { assertEquals ( 1 , table . hashes ( ) . size ( ) ) ; } 
public void dummy ( ) { } @Test public void shouldBeAbleToRunSingleFeature ( ) throws BSFException { Visitor visitor = mock ( Visitor . class ) ; StepMother stepMother = new PicoContainerStepMother ( ) ; stepMother . registerClass ( JunitCukeSteps . class ) ; CucumberRunner runner = new CucumberRunner ( stepMother ) ; runner . run ( " /demo.feature " , " 3 green and 4 yellow cukes " , visitor ) ; verify ( visitor ) . visitFeatures ( ) ; verify ( visitor ) . visitScenarioName ( " Scenario: " , " 3 green and 4 yellow cukes " ) ; } } 
private File cucumberBin ( ) { return ( cucumberBin ! = null ) ? cucumberBin : gemCucumberBin ( ) ; } 
private File gemCucumberBin ( ) { return new File ( binDir ( ) , " cucumber " ) ; } 
public void invokeSingleTarget ( Object arg ) throws Throwable { nSystem . out . println ( " SINGLE JAVA ARG: " + arg ) ; } 
public void dummy ( ) { } @Scenario("3 green cukes") Use the method name (replace _ with space) if a value is not present @Tag("aTag") public void ThreeGreenCukes() { } @Scenario("4 green cukes") @Tag({"aTag", "otherTag"}) public void FourGreenCukes() { } @Scenario("0 yellow cukes") @Ignore This scenario should be ignored public void ZeroYellowCukes() { } @Scenario public void lots_of_green_cukes() { }} 
public List < Map < String , String > > hashes ( ) ; public void diff(List<List<String>> table); public void diff(List<Map<String, String>> table);} 
public void invokeOnTarget ( Object [ ] args ) throws Throwable { Object [ ] convertedArgs = convertArgs ( args ) ; try { method . invoke ( target , convertedArgs ) ; 
public void executeBeforeHooks ( Object [ ] arrayWithScenario ) throws Throwable { for ( Hook hook : beforeHooks ) { hook . invokeOnTarget ( arrayWithScenario ) ; 
public void shouldBeAbleToRunSingleFeature ( ) throws BSFException { if ( 2 = = 2 ) { throw new RuntimeException ( " Temporarily disabled in maven - some javas don't like this " ) ; } Visitor visitor = mock ( Visitor . class ) ; StepMother stepMother = new PicoContainerStepMother ( ) ; stepMother . registerClass ( JunitCukeSteps . class ) ; CucumberRunner runner = new CucumberRunner ( stepMother ) ; runner . run ( " /demo.feature " , " 3 green and 4 yellow cukes " , visitor ) ; verify ( visitor ) . visitFeatures ( ) ; verify ( visitor ) . visitScenarioName ( " Scenario: " , " 3 green and 4 yellow cukes " ) ; } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { for ( String s : gems ) { installGem ( parseGem ( s ) ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
public List < Map < String , String > > hashes ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public void iAddATable ( Table table ) { table . diffLists ( Arrays . asList ( Arrays . asList ( " a " , " b " ) , Arrays . asList ( " 1 " , " 2 " ) ) ) ; List < Map < String , String > > hashes = new ArrayList ( table . hashes ( ) ) ; Map < String , String > newRow = hashes . get ( 0 ) ; hashes . add ( newRow ) ; table . diffHashes ( hashes , new HashMap ( ) { { put ( " surplus_row " , false ) ; 
protected void installGem ( List < String > gems ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( gems ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
protected void addReference ( Project project , String reference , List < ? > artifacts ) throws DependencyResolutionRequiredException { List < String > list = new ArrayList < String > ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( project ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; project . addReference ( reference , p ) ; } 
public List < Map < String , String > > hashes ( ) ; public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map options ) ; } 
protected void installGem ( String gemSpec ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( parseGem ( gemSpec ) ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
private List < String > parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; String source = gem . length > 2 ? gem [ 2 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } if ( source ! = null & & source . trim ( ) . length ( ) > 0 ) { if ( source . contains ( " github " ) ) { gemArgs . add ( " --source " ) ; gemArgs . add ( " http:gems.github.com " ) ; } } return gemArgs ; } 
public void execute ( ) throws MojoFailureException , MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
public void push ( double arg ) { } public double divide ( ) { return 1.5 ; } } 
public void executeAfterHooks ( Object [ ] arrayWithScenario ) throws Throwable { for ( Hook hook : afterHooks ) { hook . invokeOnTarget ( arrayWithScenario ) ; 
private void registerAfter ( Object object , Method method ) { if ( method . isAnnotationPresent ( After . class ) ) { afterHooks . add ( new Hook ( object , method , method . getAnnotation ( After . class ) . value ( ) ) ) ; 
public void givenStaticIs ( String currentValue ) { assertEquals ( currentValue , myStatic ) ; } 
public void givenStaticShouldBe ( String currentValue ) { assertEquals ( currentValue , myStatic ) ; } 
protected String cmd ( Java jruby ) { return join ( jruby . getCommandLine ( ) . getCommandline ( ) ) ; } 
protected String join ( String [ ] strings ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < strings . length ; i + + ) { if ( i ! = 0 ) sb . append ( ' ' ) ; sb . append ( strings [ i ] ) ; } return sb . toString ( ) ; } 
public static void Before ( List < String > tagNames , Closure body ) { stepMotherAdapter . registerBefore ( new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public static void Given ( Pattern pattern , Closure body ) { registerStepDefinition ( pattern , body ) ; } 
public static void When ( Pattern pattern , Closure body ) { registerStepDefinition ( pattern , body ) ; } 
public static void Then ( Pattern pattern , Closure body ) { registerStepDefinition ( pattern , body ) ; } 
private static void registerStepDefinition ( Pattern pattern , Closure body ) { stepMotherAdapter . registerStepDefinition ( new GroovyStepDefinition ( groovyLanguage , pattern , body ) ) ; } 
public void registerStepDefinition ( StepDefinition stepDefinition ) { invoke ( " register_step_definition " , new Object [ ] { stepDefinition } ) ; } 
public void registerBefore ( Hook hook ) { invoke ( " register_hook " , new Object [ ] { " before " , hook } ) ; } 
public void registerAfter ( Hook hook ) { invoke ( " register_hook " , new Object [ ] { " after " , hook } ) ; } 
private void invoke ( String method , Object [ ] args ) { JavaEmbedUtils . invokeMethod ( stepMother . getRuntime ( ) , 
public Object [ ] convert ( Class < ? > [ ] types , RubyArray args ) { return convert ( types , args . toArray ( ) ) ; } 
public Object [ ] convert ( Class < ? > [ ] types , Object [ ] objetcs ) { if ( types . length ! = objetcs . length ) { throwArgumentError ( types , objetcs ) ; } Object [ ] converted = new Object [ objetcs . length ] ; for ( int i = 0 ; i < types . length ; i + + ) { converted [ i ] = convertObject ( types [ i ] , objetcs [ i ] ) ; } return converted ; } 
private Object convertObject ( Class < ? > type , Object arg ) { try { if ( type . equals ( Integer . TYPE ) ) { 
private void throwArgumentError ( Class < ? > [ ] types , Object [ ] objetcs ) { throw new RuntimeException ( " Wrong number of arguments. Expected ( " + join ( types , " , " ) + " ) - got ( " + join ( objetcs , " , " ) + " ) " ) ; } 
public static String join ( Object [ ] oa , String sep ) { String s = " " ; boolean doSep = false ; for ( Object o : oa ) { if ( doSep ) { s + = sep ; } doSep = true ; s + = o ; } return s ; } 
public void invoke ( String location , IRubyObject scenario ) { RubyArray args = RubyArray . newArray ( Ruby . getGlobalRuntime ( ) ) ; args . add ( null ) ; Needed because groovy closures always seem to have arity 1(??) groovyLanguage.invokeClosure(body, args); } 
void invokeClosure ( Closure body , RubyArray args ) { Object [ ] converted = new StringConverter ( ) . convert ( body . getParameterTypes ( ) , args ) ; body . setDelegate ( currentWorld ) ; body . call ( converted ) ; } 
public void load_step_def_file ( String step_def_file ) throws IOException { shell . evaluate ( new File ( step_def_file ) ) ; } 
public void new_world ( IRubyObject stepMother ) { currentWorld = new Object ( ) ; } 
public void nil_world ( ) { currentWorld = null ; } 
public RubyRegexp regexp ( ) { TODO: Translate and pass correct flags. return RubyRegexp.newRegexp(Ruby.getGlobalRuntime(), pattern.pattern(), RubyRegexp.RE_OPTION_LONGEST); } 
public String file_colon_line ( ) { return body . toString ( ) ; } 
public void invoke ( RubyArray args ) { groovyLanguage . invokeClosure ( body , args ) ; } 
public void invoke ( String location , IRubyObject scenario ) throws Throwable { Object target = javaLanguage . getTarget ( method . getDeclaringClass ( ) ) ; RubyArray args = RubyArray . newArray ( Ruby . getGlobalRuntime ( ) ) ; args . append ( scenario ) ; methodInvoker . invoke ( target , method . getParameterTypes ( ) , args ) ; } 
public void load_step_def_file ( String step_def_file ) throws Exception { Class clazz = loadClass ( step_def_file ) ; registerStepDefinitionsFor ( clazz ) ; objectFactory . addClass ( clazz ) ; } 
public void new_world ( IRubyObject stepMother ) { objectFactory . newWorld ( ) ; } 
private Class loadClass ( String javaPath ) throws ClassNotFoundException { String withoutExt = javaPath . substring ( 0 , javaPath . length ( ) - " .java " . length ( ) ) ; String [ ] pathElements = withoutExt . split ( " \\ / " ) ; String className = null ; for ( int i = pathElements . length - 1 ; i > = 0 ; i - - ) { if ( className = = null ) { className = pathElements [ i ] ; } else { className = pathElements [ i ] + " . " + className ; } try { return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( " Couldn't determine class from file: " + javaPath ) ; } 
private void registerStepDefinitionMaybe ( Method method ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { StepDefinition stepDefinition = new JavaStepDefinition ( this , method , regexpString ) ; 
private void registerBeforeMaybe ( Method method ) { if ( method . isAnnotationPresent ( Before . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( Before . class ) . value ( ) . split ( " , " ) ) ; 
private void registerAfterMaybe ( Method method ) { if ( method . isAnnotationPresent ( After . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( After . class ) . value ( ) . split ( " , " ) ) ; 
public void nil_world ( ) { objectFactory . dispose ( ) ; } 
public void invoke ( RubyArray rubyArgs ) throws Throwable { Object target = javaLanguage . getTarget ( method . getDeclaringClass ( ) ) ; Class < ? > [ ] types = method . getParameterTypes ( ) ; methodInvoker . invoke ( target , types , rubyArgs ) ; } 
void dispose ( ) ; Object getComponent ( Class < ? > type ) ; void addClass ( Class clazz ) ; void newWorld ( ) ; } 
Object getComponent ( Class < ? > type ) ; void addClass ( Class clazz ) ; void newWorld ( ) ; } 
public void dispose ( ) { pico . stop ( ) ; pico . dispose ( ) ; } 
public void addClass ( Class clazz ) { classes . add ( clazz ) ; } 
public void newWorld ( ) { pico = new PicoBuilder ( ) . withCaching ( ) . build ( ) ; for ( Class clazz : classes ) { pico . addComponent ( clazz ) ; } pico . start ( ) ; } 
public void addClass ( Class clazz ) { } public void newWorld ( ) { appContext . refresh ( ) ; } } 
public void newWorld ( ) { appContext . refresh ( ) ; } 
public RubyArray tag_names ( ) { RubyArray arr = RubyArray . newArray ( Ruby . getGlobalRuntime ( ) ) ; for ( String tag : tagNames ) { String trimmed = tag . trim ( ) ; if ( ! trimmed . equals ( " " ) ) { arr . add ( tag ) ; } } return arr ; } 
public RubyArray tag_names ( ) ; void invoke ( String location , IRubyObject scenario ) throws Throwable ; } 
void invoke ( String location , IRubyObject scenario ) throws Throwable ; } 
public void invoke ( Object target , Class < ? > [ ] types , RubyArray rubyArgs ) throws Throwable { Object [ ] args = rubyArgs . toArray ( ) ; Object [ ] converted = new StringConverter ( ) . convert ( types , args ) ; try { method . invoke ( target , converted ) ; 
void load_step_def_file ( String step_def_file ) throws Exception ; void new_world ( IRubyObject stepMother ) ; TODO: begin_scenario void nil_world(); TODO: end_scenario} 
void new_world ( IRubyObject stepMother ) ; TODO: begin_scenario void nil_world(); TODO: end_scenario} 
RubyRegexp regexp ( ) ; String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; } 
String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; } 
public void shouldBeAbleToRunSingleFeature ( ) throws BSFException { if ( 2 = = 2 ) { throw new RuntimeException ( " Temporarily disabled in maven - some javas don't like this " ) ; } Visitor visitor = mock ( Visitor . class ) ; AnnotationStepMother stepMother = new PicoContainerStepMother(); stepMother.registerClass(JunitCukeSteps.class); CucumberRunner runner = new CucumberRunner(stepMother); runner.run("/demo.feature", "3 green and 4 yellow cukes", visitor); verify(visitor).visitFeatures(); verify(visitor).visitScenarioName("Scenario:", "3 green and 4 yellow cukes"); } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( null ) ; language . load_step_def_file ( " foo/java/lang/String.java " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( null ) ; language . load_step_def_file ( " foo/java/lang/Strix.java " ) ; } 
public void staticShouldBe ( String expected ) { assertEquals ( expected , myStatic ) ; } 
public void iAddATable ( Table table ) { table . diffLists ( Arrays . asList ( Arrays . asList ( " a " , " b " ) , Arrays . asList ( " 1 " , " 2 " ) ) ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( table . hashes ( ) ) ; Map < String , String > newRow = hashes . get ( 0 ) ; hashes . add ( newRow ) ; table . diffHashes ( hashes , new HashMap < String , Boolean > ( ) { { put ( " surplus_row " , false ) ; 
public static void Before ( List < String > tagNames , Closure body ) { stepMother . register_hook ( " before " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public static void After ( List < String > tagNames , Closure body ) { stepMother . register_hook ( " after " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
private static void registerStepDefinition ( Pattern pattern , Closure body ) { stepMother . register_step_definition ( new GroovyStepDefinition ( groovyLanguage , pattern , body ) ) ; } 
public void invoke ( String location , IRubyObject scenario ) { RubyArray args = RubyArray . newArray ( Ruby . getGlobalRuntime ( ) ) ; args . add ( scenario ) ; groovyLanguage . invokeClosure ( body , args ) ; } 
public void new_world ( StepMother stepMother ) { currentWorld = new Object ( ) ; } 
public void new_world ( StepMother stepMother ) { objectFactory . newWorld ( ) ; } 
void load_step_def_file ( String step_def_file ) throws Exception ; void new_world ( StepMother stepMother ) ; TODO: begin_scenario void nil_world(); TODO: end_scenario} 
void new_world ( StepMother stepMother ) ; TODO: begin_scenario void nil_world(); TODO: end_scenario} 
void register_step_definition ( StepDefinition stepDefinition ) ; void register_hook ( String phase , Hook hook ) ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) , Collections . EMPTY_LIST ) ; language . load_step_def_file ( " foo/java/lang/String.java " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) , Collections . EMPTY_LIST ) ; language . load_step_def_file ( " foo/java/lang/Strix.java " ) ; } 
public void begin_scenario ( ) { currentWorld = new Object ( ) ; } 
public void end_scenario ( ) { currentWorld = null ; } 
public void begin_scenario ( ) { objectFactory . newWorld ( ) ; } 
public void end_scenario ( ) { objectFactory . dispose ( ) ; } 
public abstract void load_step_def_file ( String step_def_file ) throws Exception ; public abstract void begin_scenario ( ) ; public abstract void end_scenario ( ) ; public StepMother step_mother ( ) { return stepMother ; } } 
public abstract void begin_scenario ( ) ; public abstract void end_scenario ( ) ; public StepMother step_mother ( ) { return stepMother ; } } 
public abstract void end_scenario ( ) ; public StepMother step_mother ( ) { return stepMother ; } } 
public StepMother step_mother ( ) { return stepMother ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) , Collections . < String > emptyList ( ) ) ; language . load_step_def_file ( " foo/java/lang/String.java " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) , Collections . < String > emptyList ( ) ) ; language . load_step_def_file ( " foo/java/lang/Strix.java " ) ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) ) ; language . load_step_def_file ( " foo/java/lang/String.java " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( StepMother . class ) ) ; language . load_step_def_file ( " foo/java/lang/Strix.java " ) ; } 
public static void Before ( List < String > tagNames , Closure body ) { languageMixin . add_hook ( " before " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public static void After ( List < String > tagNames , Closure body ) { languageMixin . add_hook ( " after " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
private static void registerStepDefinition ( Pattern pattern , Closure body ) { groovyLanguage . addStepDefinition ( new GroovyStepDefinition ( groovyLanguage , pattern , body ) ) ; } 
protected void load ( String groovy_file ) throws ClassNotFoundException , IOException { shell . evaluate ( new File ( groovy_file ) ) ; } 
protected void load ( String java_file ) throws ClassNotFoundException { Class clazz = loadClass ( java_file ) ; registerStepDefinitionsFor ( clazz ) ; objectFactory . addClass ( clazz ) ; } 
public List < StepDefinition > step_definitions_for ( String java_file ) throws Exception { stepDefinitions = new ArrayList < StepDefinition > ( ) ; load ( java_file ) ; return stepDefinitions ; } 
public abstract void begin_scenario ( ) ; public abstract void end_scenario ( ) ; protected abstract void load ( String java_file ) throws Exception ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
public abstract void end_scenario ( ) ; protected abstract void load ( String java_file ) throws Exception ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
protected abstract void load ( String java_file ) throws Exception ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( LanguageMixin . class ) ) ; language . step_definitions_for ( " foo/java/lang/String.java " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new JavaLanguage ( mock ( LanguageMixin . class ) ) ; language . step_definitions_for ( " foo/java/lang/Strix.java " ) ; } 
public void iAddAString ( String s ) { assertEquals ( " Hello nWorld " , s ) ; } 
public void invoke ( String location , IRubyObject scenario ) { RubyArray args = RubyArray . newArray ( JRuby . getRuntime ( ) ) ; args . add ( scenario ) ; groovyLanguage . invokeClosure ( body , args ) ; } 
public RubyRegexp regexp ( ) { TODO: Translate and pass correct flags. return RubyRegexp.newRegexp(JRuby.getRuntime(), pattern.pattern(), RubyRegexp.RE_OPTION_LONGEST); } 
public RubyArray tag_names ( ) { RubyArray arr = RubyArray . newArray ( JRuby . getRuntime ( ) ) ; for ( String tag : tagNames ) { String trimmed = tag . trim ( ) ; if ( ! trimmed . equals ( " " ) ) { arr . add ( tag ) ; } } return arr ; } 
public void invoke ( Object target , Class < ? > [ ] types , RubyArray rubyArgs ) throws Throwable { Object [ ] args = rubyArgs . toArray ( ) ; Object [ ] javaArgs = new StringConverter ( ) . convert ( types , args ) ; try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
private void raisePending ( ) { String message = method . getAnnotation ( Pending . class ) . value ( ) ; RubyModule cucumber = JRuby . getRuntime ( ) . getModule ( " Cucumber " ) ; RubyClass pending = cucumber . getClass ( " Pending " ) ; throw new RaiseException ( JRuby . getRuntime ( ) , 
public void dontExecuteMe ( ) { throw new RuntimeException ( " Shouldn't be executed " ) ; } 
public void definePendingException ( ) { JRuby . getRuntime ( ) . evalScriptlet ( " module Cucumber;class Pending < StandardError;end;end " ) ; } 
public void shouldRaiseCucumberPendingWhenAnnotatedWithPending ( ) throws Throwable { Method dontExecuteMe = SomethingWithPending . class . getDeclaredMethod ( " dontExecuteMe " ) ; MethodInvoker mi = new MethodInvoker ( dontExecuteMe ) ; RubyArray emptyArgs = RubyArray . newArray ( JRuby . getRuntime ( ) ) ; mi . invoke ( new SomethingWithPending ( ) , new Class [ ] { } , emptyArgs ) ; } 
public void intentionallyPending ( ) { throw new RuntimeException ( " We shouldn't get here because we are @Pending " ) ; } 
public void intentionallyFailing ( ) { throw new RuntimeException ( " We shouldn't get here either because the previous one is pending " ) ; } 
public List < Map < String , String > > hashes ( ) ; public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; } 
protected void load ( String java_file ) throws ClassNotFoundException { Class < ? > clazz = loadClass ( java_file ) ; registerStepDefinitionsFor ( clazz ) ; objectFactory . addClass ( clazz ) ; } 
private Class < ? > loadClass ( String javaPath ) throws ClassNotFoundException { String withoutExt = javaPath . substring ( 0 , javaPath . length ( ) - " .java " . length ( ) ) ; String [ ] pathElements = withoutExt . split ( " \\ / " ) ; String className = null ; for ( int i = pathElements . length - 1 ; i > = 0 ; i - - ) { if ( className = = null ) { className = pathElements [ i ] ; } else { className = pathElements [ i ] + " . " + className ; } try { return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( " Couldn't determine class from file: " + javaPath ) ; } 
void dispose ( ) ; Object getComponent ( Class < ? > type ) ; void addClass ( Class < ? > clazz ) ; void newWorld ( ) ; } 
Object getComponent ( Class < ? > type ) ; void addClass ( Class < ? > clazz ) ; void newWorld ( ) ; } 
public void addClass ( Class < ? > clazz ) { classes . add ( clazz ) ; } 
public void newWorld ( ) { pico = new PicoBuilder ( ) . withCaching ( ) . build ( ) ; for ( Class < ? > clazz : classes ) { pico . addComponent ( clazz ) ; } pico . start ( ) ; } 
public void addClass ( Class < ? > clazz ) { } public void newWorld ( ) { appContext . refresh ( ) ; } } 
public void shouldBeAbleToRunSingleFeature ( ) throws BSFException { if ( 2 = = 2 ) { throw new RuntimeException ( " Temporarily disabled in maven - some javas don't like this " ) ; 
public void iAddATable ( Table table ) { tList < List < String > > diffList = new ArrayList < List < String > > ( ) ; tdiffList . add ( Arrays . asList ( " a " , " b " ) ) ; tdiffList . add ( Arrays . asList ( " 1 " , " 2 " ) ) ; table . diffLists ( diffList ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( table . hashes ( ) ) ; Map < String , String > newRow = hashes . get ( 0 ) ; hashes . add ( newRow ) ; Map < String , Boolean > hashesMap = new HashMap < String , Boolean > ( ) ; hashesMap . put ( " surplus_row " , false ) ; ttable . diffHashes ( hashes , hashesMap ) ; } 
protected void installGem ( String gemSpec ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --source " ) ; args . add ( " http:gems.rubyforge.org " ) ; args . add ( " --source " ) ; args . add ( " http:gems.github.com " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( parseGem ( gemSpec ) ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
protected void installGem ( String gemSpec ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --source " ) ; args . add ( " http:gems.rubyforge.org " ) ; args . add ( " --source " ) ; args . add ( " http:gemcutter.org " ) ; args . add ( " --source " ) ; args . add ( " http:gems.github.com " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( parseGem ( gemSpec ) ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
private List < String > parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } return gemArgs ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( Arrays . asList ( args ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; jruby . execute ( ) ; } 
private List < String > parseGem ( String gemSpec ) throws MojoExecutionException { List < String > gemArgs = new ArrayList < String > ( ) ; String [ ] gem = gemSpec . split ( " : " ) ; String name = gem . length > 0 ? gem [ 0 ] : null ; String version = gem . length > 1 ? gem [ 1 ] : null ; if ( name = = null | | name . trim ( ) . length ( ) = = 0 ) { throw new MojoExecutionException ( " Requires atleast a name for <gem> " ) ; } else { gemArgs . add ( name ) ; } if ( version ! = null & & version . trim ( ) . length ( ) > 0 ) { gemArgs . add ( " -v " + version ) ; } return gemArgs ; } 
protected Project getProject ( ) throws DependencyResolutionRequiredException { Project project = new Project ( ) ; project . setBaseDir ( mavenProject . getBasedir ( ) ) ; project . addBuildListener ( new LogAdapter ( ) ) ; addReference ( project , " maven.compile.classpath " , compileClasspathElements ) ; addReference ( project , " maven.plugin.classpath " , pluginArtifacts ) ; addReference ( project , " maven.test.classpath " , testClasspathElements ) ; return project ; } 
protected void addReference ( Project project , String reference , List < ? > artifacts ) throws DependencyResolutionRequiredException { List < String > list = new ArrayList < String > ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( project ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; project . addReference ( reference , p ) ; } 
protected String join ( String [ ] strings ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < strings . length ; i + + ) { if ( i ! = 0 ) sb . append ( ' ' ) ; sb . append ( strings [ i ] ) ; } return sb . toString ( ) ; } 
private void log ( BuildEvent event ) { int priority = event . getPriority ( ) ; Log log = getLog ( ) ; String message = event . getMessage ( ) ; switch ( priority ) { case Project . MSG_ERR : 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; if ( args ! = null ) allArgs . addAll ( args ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; jruby . execute ( ) ; } 
List < String > addCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( addCucumberArgs ! = null ) allCucumberArgs . addAll ( Arrays . asList ( addCucumberArgs . split ( " : " ) ) ) ; return allCucumberArgs ; } 
public void shouldAllowZeroCucumberArgs ( ) { mojo . cucumberArgs = null ; mojo . addCucumberArgs ( ) ; } 
public void shouldAddCucumberArgs ( ) { String cucumberArg = " testArg " ; mojo . cucumberArgs = new ArrayList < String > ( ) ; mojo . cucumberArgs . add ( cucumberArg ) ; assertTrue ( mojo . addCucumberArgs ( ) . contains ( cucumberArg ) ) ; } 
public void shouldAllowZeroAddCucumberArgs ( ) { mojo . addCucumberArgs = null ; mojo . addCucumberArgs ( ) ; } 
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . addCucumberArgs = " arg1:arg2:arg3 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; referenceList . add ( " arg2 " ) ; referenceList . add ( " arg3 " ) ; assertEquals ( referenceList , mojo . addCucumberArgs ( ) ) ; } 
public void shouldHandleOneAddCucumberArg ( ) { mojo . addCucumberArgs = " arg1 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; assertEquals ( referenceList , mojo . addCucumberArgs ( ) ) ; } 
public static void Given ( String regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
public static void When ( String regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
public static void Then ( String regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
private static void registerStepDefinition ( String regexp , Closure body ) { groovyLanguage . addStepDefinition ( new GroovyStepDefinition ( groovyLanguage , regexp , body ) ) ; } 
public RubyRegexp regexp ( ) { return RubyRegexp . newRegexp ( JRuby . getRuntime ( ) , regexp , RubyRegexp . RE_OPTION_LONGEST ) ; } 
public static void World ( Closure body ) { groovyLanguage . registerWorldFactory ( body ) ; } 
public void begin_scenario ( ) { currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; } 
public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } 
public void iHaveAGreeter ( ) { assertNotNull ( greeter ) ; } 
public void iAskTheWorldForHello ( ) { helloResponse = greeter . hello ( ) ; } 
public void theResponseShouldBe ( String response ) { assertEquals ( response , helloResponse ) ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; if ( args ! = null ) allArgs . addAll ( args ) ; allArgs . addAll ( addExtraCucumberArgs ( ) ) ; allArgs . add ( ( features ! = null ) ? features : " features " ) ; Java jruby = jruby ( allArgs ) ; jruby . execute ( ) ; } 
List < String > addExtraCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( extraCucumberArgs ! = null ) allCucumberArgs . addAll ( Arrays . asList ( extraCucumberArgs . split ( " : " ) ) ) ; return allCucumberArgs ; } 
public void shouldAllowZeroCucumberArgs ( ) { mojo . cucumberArgs = null ; mojo . addExtraCucumberArgs ( ) ; } 
public void shouldAddCucumberArgs ( ) { String cucumberArg = " testArg " ; mojo . cucumberArgs = new ArrayList < String > ( ) ; mojo . cucumberArgs . add ( cucumberArg ) ; assertTrue ( mojo . addExtraCucumberArgs ( ) . contains ( cucumberArg ) ) ; } 
public void shouldAllowZeroAddCucumberArgs ( ) { mojo . extraCucumberArgs = null ; mojo . addExtraCucumberArgs ( ) ; } 
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . extraCucumberArgs = " arg1:arg2:arg3 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; referenceList . add ( " arg2 " ) ; referenceList . add ( " arg3 " ) ; assertEquals ( referenceList , mojo . addExtraCucumberArgs ( ) ) ; } 
public void shouldHandleOneAddCucumberArg ( ) { mojo . extraCucumberArgs = " arg1 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; assertEquals ( referenceList , mojo . addExtraCucumberArgs ( ) ) ; } 
List < String > addCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( extraCucumberArgs ! = null ) allCucumberArgs . addAll ( Arrays . asList ( extraCucumberArgs . split ( " : " ) ) ) ; return allCucumberArgs ; } 
public void shouldAllowZeroAddCucumberArgs ( ) { mojo . extraCucumberArgs = null ; mojo . addCucumberArgs ( ) ; } 
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . extraCucumberArgs = " arg1:arg2:arg3 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; referenceList . add ( " arg2 " ) ; referenceList . add ( " arg3 " ) ; assertEquals ( referenceList , mojo . addCucumberArgs ( ) ) ; } 
public void shouldHandleOneAddCucumberArg ( ) { mojo . extraCucumberArgs = " arg1 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; assertEquals ( referenceList , mojo . addCucumberArgs ( ) ) ; } 
List < String > addCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( extraCucumberArgs ! = null ) allCucumberArgs . addAll ( Arrays . asList ( extraCucumberArgs . split ( " " ) ) ) ; return allCucumberArgs ; } 
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . extraCucumberArgs = " arg1 arg2 arg3 " ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; referenceList . add ( " arg2 " ) ; referenceList . add ( " arg3 " ) ; assertEquals ( referenceList , mojo . addCucumberArgs ( ) ) ; } 
public void iAddATable ( Table table ) { tList < List < String > > diffList = new ArrayList < List < String > > ( ) ; tdiffList . add ( Arrays . asList ( " a " , " b " ) ) ; tdiffList . add ( Arrays . asList ( " 1 " , " 2 " ) ) ; table . diffLists ( diffList ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; Map < String , Boolean > options = new HashMap < String , Boolean > ( ) ; options . put ( " surplus_row " , false ) ; table . diffHashes ( hashes , options ) ; } 
public void thisIsNotAStep ( ) { } private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } } 
private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { StepDefinition stepDefinition = new JavaStepDefinition ( classLanguage , method , regexpString ) ; 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( Before . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( Before . class ) . value ( ) . split ( " , " ) ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( After . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( After . class ) . value ( ) . split ( " , " ) ) ; 
public void invoke ( RubyArray rubyArgs ) throws Throwable { Object target = classLanguage . getTarget ( method . getDeclaringClass ( ) ) ; Class < ? > [ ] types = method . getParameterTypes ( ) ; methodInvoker . invoke ( target , types , rubyArgs ) ; } 
public void begin_scenario ( ) { objectFactory . createObjects ( ) ; } 
public void end_scenario ( ) { objectFactory . disposeObjects ( ) ; } 
private void registerHooksAndStepDefinitionsFor ( Class < ? > clazz ) throws Throwable { for ( HookAndStepDefinitionRegistrar registrar : registrars ) { registrar . registerHooksAndStepDefinitionsFor ( clazz , this ) ; 
private Class < ? > loadClass ( String classFile ) throws ClassNotFoundException { String withoutExt = classFile . substring ( 0 , classFile . length ( ) - " .class " . length ( ) ) ; String [ ] pathElements = withoutExt . split ( " \\ / " ) ; String className = null ; for ( int i = pathElements . length - 1 ; i > = 0 ; i - - ) { if ( className = = null ) { className = pathElements [ i ] ; } else { className = pathElements [ i ] + " . " + className ; } try { return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( " Couldn't determine class from file: " + classFile ) ; } 
public void addHook ( String phase , Hook hook ) { languageMixin . add_hook ( phase , hook ) ; } 
void registerHooksAndStepDefinitionsFor ( Class < ? > clazz , ClassLanguage classLanguage ) ; } 
void disposeObjects ( ) ; Object getComponent ( Class < ? > type ) ; void addClass ( Class < ? > clazz ) ; void createObjects ( ) ; } 
Object getComponent ( Class < ? > type ) ; void addClass ( Class < ? > clazz ) ; void createObjects ( ) ; } 
void addClass ( Class < ? > clazz ) ; void createObjects ( ) ; } 
public void disposeObjects ( ) { pico . stop ( ) ; pico . dispose ( ) ; } 
public void createObjects ( ) { pico = new PicoBuilder ( ) . withCaching ( ) . build ( ) ; for ( Class < ? > clazz : classes ) { pico . addComponent ( clazz ) ; } pico . start ( ) ; } 
public void addClass ( Class < ? > clazz ) { } public void createObjects ( ) { appContext . refresh ( ) ; } } 
public void createObjects ( ) { appContext . refresh ( ) ; } 
public List < StepDefinition > step_definitions_for ( String file ) throws Throwable { stepDefinitions = new ArrayList < StepDefinition > ( ) ; load ( file ) ; return stepDefinitions ; } 
public abstract void begin_scenario ( ) ; public abstract void end_scenario ( ) ; protected abstract void load ( String file ) throws Throwable ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
public abstract void end_scenario ( ) ; protected abstract void load ( String file ) throws Throwable ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
protected abstract void load ( String file ) throws Throwable ; public void addStepDefinition ( StepDefinition stepDefinition ) { stepDefinitions . add ( stepDefinition ) ; } } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new ClassLanguage ( mock ( LanguageMixin . class ) ) ; language . step_definitions_for ( " foo/java/lang/String.class " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { ProgrammingLanguage language = new ClassLanguage ( mock ( LanguageMixin . class ) ) ; language . step_definitions_for ( " foo/java/lang/Strix.class " ) ; } 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { StepDefinition stepDefinition = new AnnotationStepDefinition ( classLanguage , method , regexpString ) ; 
private void registerHooksAndStepDefinitionsFor ( Class < ? > clazz ) throws Throwable { for ( HookAndStepDefinitionRegistrar analyzer : analyzers ) { analyzer . registerHooksAndStepDefinitionsFor ( clazz , this ) ; 
void add_hook ( String phase , Hook hook ) ; void activate ( ClassAnalyzer analyzer ) ; } 
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( LanguageMixin . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { language . step_definitions_for ( " foo/java/lang/String.class " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { language . step_definitions_for ( " foo/java/lang/Strix.class " ) ; } 
private void registerHooksAndStepDefinitionsFor ( Class < ? > clazz ) throws Throwable { for ( ClassAnalyzer analyzer : analyzers ) { analyzer . registerHooksAndStepDefinitionsFor ( clazz , this ) ; 
public void addHook ( String phase , Hook hook , ClassAnalyzer analyzer ) { languageMixin . activate ( analyzer ) ; languageMixin . add_hook ( phase , hook ) ; } 
public void addStepDefinition ( StepDefinition stepDefinition , ClassAnalyzer analyzer ) { languageMixin . activate ( analyzer ) ; addStepDefinition ( stepDefinition ) ; } 
public static void raisePending ( String message ) { RubyModule cucumber = getRuntime ( ) . getModule ( " Cucumber " ) ; RubyClass pending = cucumber . getClass ( " Pending " ) ; throw new RaiseException ( getRuntime ( ) , 
public void addHook ( String phase , Hook hook , ClassAnalyzer analyzer ) { classLanguageMixin . activate ( analyzer ) ; classLanguageMixin . add_hook ( phase , hook ) ; } 
public void addStepDefinition ( StepDefinition stepDefinition , ClassAnalyzer analyzer ) { classLanguageMixin . activate ( analyzer ) ; addStepDefinition ( stepDefinition ) ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; Object getComponent ( Class < ? > type ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; Object getComponent ( Class < ? > type ) ; } 
void addClass ( Class < ? > clazz ) ; Object getComponent ( Class < ? > type ) ; } 
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; } 
protected void installGem ( String gemArgs ) throws MojoExecutionException { List < String > args = new ArrayList < String > ( ) ; args . add ( " -S " ) ; args . add ( " gem " ) ; args . add ( " install " ) ; args . add ( " --no-ri " ) ; args . add ( " --no-rdoc " ) ; args . add ( " --install-dir " ) ; args . add ( gemHome ( ) . getAbsolutePath ( ) ) ; args . addAll ( Arrays . asList ( gemArgs . split ( " \\ s+ " ) ) ) ; Java jruby = jruby ( args ) ; We have to override HOME to make RubyGems install gems where we want it. Setting GEM_HOME and using --install-dir is not enough. Environment.Variable homeVar = new Environment.Variable(); homeVar.setKey("HOME"); homeVar.setValue(dotGemParent().getAbsolutePath()); jruby.addEnv(homeVar); dotGemParent().mkdirs(); jruby.execute(); } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke/cucumber_ext " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( features ) ; Java jruby = jruby ( allArgs ) ; jruby . execute ( ) ; } 
public void shouldConvertFromStringToInteger ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Integer . TYPE } , new Object [ ] { String . format ( " %d " , Integer . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Integer . class ) ) ; } 
public void shouldConvertFromStringToLong ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Long . TYPE } , new Object [ ] { String . format ( " %d " , Long . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Long . class ) ) ; } 
public void shouldConvertFromStringToDouble ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Double . TYPE } , new Object [ ] { String . format ( " %f " , Double . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Double . class ) ) ; } 
public void shouldConvertFromStringToString ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { String . class } , new Object [ ] { " String " } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( String . class ) ) ; 
public void shouldConvertFromTableToTable ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Table . class } , new Object [ ] { new MyTable ( ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . getInterfaces ( ) [ 0 ] . equals ( Table . class ) ) ; } 
public void shouldConvertFromClassToClass ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { MyClass . class } , new Object [ ] { new MyClass ( ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( MyClass . class ) ) ; 
public void diffHashes ( List < Map < String , String > > table ) { TODO Auto-generated method stub } public void diffHashes(List<Map<String, String>> table, Map<?, ?> options) { TODO Auto-generated method stub } public void diffLists(List<List<String>> table) { TODO Auto-generated method stub } public void diffLists(List<List<String>> table, Map<?, ?> options) { TODO Auto-generated method stub } public List<Map<String, String>> hashes() { TODO Auto-generated method stub return null; } public List<List<String>> raw() { TODO Auto-generated method stub return null; } public List<List<String>> rows() { TODO Auto-generated method stub return null; } public Map<String, String> rowsHash() { TODO Auto-generated method stub return null; } }} 
public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) { TODO Auto-generated method stub } public void diffLists(List<List<String>> table) { TODO Auto-generated method stub } public void diffLists(List<List<String>> table, Map<?, ?> options) { TODO Auto-generated method stub } public List<Map<String, String>> hashes() { TODO Auto-generated method stub return null; } public List<List<String>> raw() { TODO Auto-generated method stub return null; } public List<List<String>> rows() { TODO Auto-generated method stub return null; } public Map<String, String> rowsHash() { TODO Auto-generated method stub return null; } }} 
public void diffLists ( List < List < String > > table ) { TODO Auto-generated method stub } public void diffLists(List<List<String>> table, Map<?, ?> options) { TODO Auto-generated method stub } public List<Map<String, String>> hashes() { TODO Auto-generated method stub return null; } public List<List<String>> raw() { TODO Auto-generated method stub return null; } public List<List<String>> rows() { TODO Auto-generated method stub return null; } public Map<String, String> rowsHash() { TODO Auto-generated method stub return null; } }} 
public void diffLists ( List < List < String > > table , Map < ? , ? > options ) { TODO Auto-generated method stub } public List<Map<String, String>> hashes() { TODO Auto-generated method stub return null; } public List<List<String>> raw() { TODO Auto-generated method stub return null; } public List<List<String>> rows() { TODO Auto-generated method stub return null; } public Map<String, String> rowsHash() { TODO Auto-generated method stub return null; } }} 
public List < Map < String , String > > hashes ( ) { TODO Auto-generated method stub return null; } 
public List < List < String > > raw ( ) { TODO Auto-generated method stub return null; } 
public List < List < String > > rows ( ) { TODO Auto-generated method stub return null; } 
public Map < String , String > rowsHash ( ) { TODO Auto-generated method stub return null; } 
void invokeClosure ( Closure body , RubyArray args ) { Object [ ] converted = new ArgumentsConverter ( ) . convert ( body . getParameterTypes ( ) , args ) ; body . setDelegate ( currentWorld ) ; body . call ( converted ) ; } 
public void invoke ( Object target , Class < ? > [ ] types , RubyArray rubyArgs ) throws Throwable { Object [ ] args = rubyArgs . toArray ( ) ; Object [ ] javaArgs = new ArgumentsConverter ( ) . convert ( types , args ) ; try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
public void shouldConvertFromTableToTable ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Table . class } , new Object [ ] { mock ( Table . class ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . getInterfaces ( ) [ 0 ] . equals ( Table . class ) ) ; } 
public static void Given ( Pattern regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
public static void When ( Pattern regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
public static void Then ( Pattern regexp , Closure body ) { registerStepDefinition ( regexp , body ) ; } 
private static void registerStepDefinition ( Pattern regexp , Closure body ) { groovyLanguage . addStepDefinition ( new GroovyStepDefinition ( groovyLanguage , regexp , body ) ) ; } 
public List < Group > groups ( String stepName ) { return JdkRegexpGroup . groupsFrom ( regexp , stepName ) ; } 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { Pattern regexp = Pattern . compile ( regexpString ) ; 
public boolean op_equal ( StepDefinition other ) { throw new RuntimeException ( " GOT HERE " ) ; } 
public static List < Group > groupsFrom ( Pattern regexp , String stepName ) { Matcher matcher = regexp . matcher ( stepName ) ; if ( matcher . matches ( ) ) { List < Group > groups = new ArrayList < Group > ( ) ; 
String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; List < Group > groups ( String stepName ) ; } 
void invoke ( RubyArray args ) throws Throwable ; List < Group > groups ( String stepName ) ; } 
public void begin_scenario ( ) { System . out . println ( " begin_scenario " ) ; } 
public void end_scenario ( ) { System . out . println ( " end_scenario " ) ; } 
protected void load ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } 
public String file_colon_line ( ) { throw new RuntimeException ( " Not implemented " ) ; } 
public void invoke ( RubyArray args ) throws Throwable { throw new RuntimeException ( " Not implemented " ) ; } 
public List < Group > groups ( String stepName ) { throw new RuntimeException ( " Not implemented " ) ; } 
public static void addStepDefinition ( Pattern regexp , AFunction closure ) throws Exception { instance . createAndAddStepDefinition ( regexp , closure ) ; } 
public void createAndAddStepDefinition ( Pattern regexp , AFunction closure ) throws Exception { StepDefinition stepDefinition = new CljStepDefinition ( regexp , closure ) ; addStepDefinition ( stepDefinition ) ; } 
public void begin_scenario ( ) { } public void end_scenario ( ) { } protected void load ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } } 
public void end_scenario ( ) { } protected void load ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } } 
public String file_colon_line ( ) { return closure . toString ( ) ; } 
public void invoke ( RubyArray args ) throws Throwable { Object [ ] javaArgs = args . toArray ( ) ; Method functionInvoke = lookupInvokeMethod ( javaArgs . length ) ; functionInvoke . invoke ( closure , javaArgs ) ; } 
private Method lookupInvokeMethod ( int argCount ) throws NoSuchMethodException { Class [ ] parameterTypes = new Class [ argCount ] ; for ( int i = 0 ; i < argCount ; i + + ) { parameterTypes [ i ] = Object . class ; } return AFunction . class . getMethod ( " invoke " , parameterTypes ) ; } 
public String regexp_source ( ) { return regexp . pattern ( ) ; } 
String regexp_source ( ) ; String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; List < Group > groups ( String stepName ) ; } 
String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; List < Group > groups ( String stepName ) ; } 
void invoke ( RubyArray args ) throws Throwable ; List < Group > groups ( String stepName ) ; } 
public List < StepArgument > arguments_from ( String stepName ) { return JdkPatternArgumentMatcher . argumentsFrom ( regexp , stepName ) ; } 
public static List < StepArgument > argumentsFrom ( Pattern regexp , String stepName ) { Matcher matcher = regexp . matcher ( stepName ) ; if ( matcher . matches ( ) ) { List < StepArgument > groups = new ArrayList < StepArgument > ( ) ; 
String regexp_source ( ) ; String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) ; } 
String file_colon_line ( ) ; void invoke ( RubyArray args ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) ; } 
void invoke ( RubyArray args ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) ; } 
public void invoke ( RubyArray args ) throws Throwable { Object [ ] javaArgs = args . toArray ( ) ; Method functionInvoke = lookupInvokeMethod ( javaArgs . length ) ; try { functionInvoke . invoke ( closure , javaArgs ) ; 
public static RaiseException cucumberPending ( String message ) { return error ( " Pending " , message ) ; } 
public static RaiseException cucumberArityMismatchError ( String message ) { return error ( " ArityMismatchError " , message ) ; } 
public static RaiseException cucumberUndefined ( String message ) { return error ( " Undefined " , message ) ; } 
private static RaiseException error ( String errorClass , String message ) { RubyModule cucumber = getRuntime ( ) . getModule ( " Cucumber " ) ; RubyClass error = cucumber . getClass ( errorClass ) ; return new RaiseException ( getRuntime ( ) , 
public void addStepDefinition ( NativeRegExp regexp , NativeFunction closure ) throws Exception { System . out . println ( " CLOSURE: " + closure + " : " + closure . getClass ( ) . getSuperclass ( ) ) ; instance.createAndAddStepDefinition(regexp, closure); 
public void begin_scenario ( ) { } public void end_scenario ( ) { } protected void load ( String file ) throws Throwable { cx . evaluateReader ( scope , new FileReader ( file ) , file , 1 , null ) ; } } 
public void end_scenario ( ) { } protected void load ( String file ) throws Throwable { cx . evaluateReader ( scope , new FileReader ( file ) , file , 1 , null ) ; } } 
protected void load ( String file ) throws Throwable { cx . evaluateReader ( scope , new FileReader ( file ) , file , 1 , null ) ; } 
public String regexp_source ( ) { throw new RuntimeException ( " Not implemented " ) ; } 
public List < StepArgument > arguments_from ( String stepName ) { throw new RuntimeException ( " Not implemented " ) ; } 
private static void registerStepDefinition ( Pattern regexp , Closure body ) { groovyLanguage.addStepDefinition(new GroovyStepDefinition(groovyLanguage, regexp, body)); throw new UnsupportedOperationException("fixme"); } 
public void createAndAddStepDefinition ( Pattern regexp , AFunction closure ) throws Exception { StepDefinition stepDefinition = new CljStepDefinition ( regexp , closure ) ; addStepDefinition(stepDefinition); 
public void begin_scenario ( ) { } public void end_scenario ( ) { } public void load_code_file ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } @Override public List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) { throw new UnsupportedOperationException ( " Fixme " ) ; } } 
public void end_scenario ( ) { } public void load_code_file ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } @Override public List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) { throw new UnsupportedOperationException ( " Fixme " ) ; } } 
public void load_code_file ( String file ) throws Throwable { Compiler . loadFile ( file ) ; } 
public List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) { throw new UnsupportedOperationException ( " Fixme " ) ; } 
public void load_code_file ( String groovy_file ) throws ClassNotFoundException , IOException { shell . evaluate ( new File ( groovy_file ) ) ; } 
private void registerBeforeMaybe ( Method method , List < Hook > befores , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Before . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( Before . class ) . value ( ) . split ( " , " ) ) ; 
private void registerStepDefinitionMaybe ( Method method , List < StepDefinition > stepDefinitions , ObjectFactory objectFactory ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { Pattern regexp = Pattern . compile ( regexpString ) ; 
private void registerAfterMaybe ( Method method , List < Hook > afters , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( After . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( After . class ) . value ( ) . split ( " , " ) ) ; 
public void invoke ( RubyArray rubyArgs ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; Class < ? > [ ] types = method . getParameterTypes ( ) ; methodInvoker . invoke ( target , types , rubyArgs ) ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , List < Hook > befores , List < StepDefinition > stepDefinitions , List < Hook > afters ) ; } 
public void begin_scenario ( ) throws Throwable { befores = new ArrayList < Hook > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; afters = new ArrayList < Hook > ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { for ( Class < ? > clazz : classes ) { analyzer . populateStepDefinitionsAndHooksFor ( clazz , objectFactory , befores , stepDefinitions , afters ) ; } } for ( Hook before : befores ) { before . invoke ( " before " , null ) ; 
public List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) { List < IRubyObject > matches = new ArrayList < IRubyObject > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( classLanguageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; } 
public void end_scenario ( ) throws Throwable { for ( Hook after : afters ) { after . invoke ( " after " , null ) ; } objectFactory . disposeObjects ( ) ; dispose stepdefinitions 
void add_hook ( String phase , Hook hook ) ; IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; } 
IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; } 
final public RubyArray step_matches ( String step_name , String formatted_step_name ) { return RubyArray . newArray ( JRuby . getRuntime ( ) , step_match_list ( step_name , formatted_step_name ) ) ; } 
public abstract void load_code_file ( String file ) throws Throwable ; protected abstract List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) ; public abstract void begin_scenario ( ) throws Throwable ; public abstract void end_scenario ( ) throws Throwable ; } 
protected abstract List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) ; public abstract void begin_scenario ( ) throws Throwable ; public abstract void end_scenario ( ) throws Throwable ; } 
public abstract void begin_scenario ( ) throws Throwable ; public abstract void end_scenario ( ) throws Throwable ; } 
public void shouldLoadExistingClassFromJavaFileName ( ) throws Throwable { language . load_code_file ( " foo/java/lang/String.class " ) ; } 
public void shouldFailToLoadMissingClassFromJavaFileName ( ) throws Throwable { language . load_code_file ( " foo/java/lang/Strix.class " ) ; } 
public static void addStepDefinition ( Pattern regexp , AFunction closure ) throws Exception { instance . addStepDefinition ( new CljStepDefinition ( regexp , closure ) ) ; } 
public void load_code_file ( String cljFile ) throws Throwable { Compiler . loadFile ( cljFile ) ; } 
protected void prepareScenario ( ) throws Throwable { } public void cleanupScenario ( ) throws Throwable { } } 
public void prepareScenario ( ) throws IOException { clearHooksAndStepDefinitions ( ) ; worldFactory = null ; GroovyShell shell = new GroovyShell ( new Binding ( ) ) ; for ( String groovyFile : groovyFiles ) { shell . evaluate ( new File ( groovyFile ) ) ; } currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; } 
public void cleanupScenario ( ) { } public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; } public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } } 
public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; } 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Before . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( Before . class ) . value ( ) . split ( " , " ) ) ; 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { Pattern regexp = Pattern . compile ( regexpString ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( After . class ) ) { List < String > tagNames = Arrays . asList ( method . getAnnotation ( After . class ) . value ( ) . split ( " , " ) ) ; 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { for ( Class < ? > clazz : classes ) { 
public void cleanupScenario ( ) throws Throwable { objectFactory . disposeObjects ( ) ; } 
public final List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) { List < IRubyObject > matches = new ArrayList < IRubyObject > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( languageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; } 
public final void begin_scenario ( ) throws Throwable { prepareScenario ( ) ; for ( Hook before : befores ) { before . invoke ( " before " , null ) ; 
protected void clearHooksAndStepDefinitions ( ) { befores = new ArrayList < Hook > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; afters = new ArrayList < Hook > ( ) ; } 
public final void end_scenario ( ) throws Throwable { for ( Hook after : afters ) { after . invoke ( " after " , null ) ; } cleanupScenario ( ) ; } 
public void addBeforeHook ( Hook before ) { befores . add ( before ) ; } 
public void addAfterHook ( Hook after ) { afters . add ( after ) ; } 
protected abstract void prepareScenario ( ) throws Throwable ; public abstract void cleanupScenario ( ) throws Throwable ; } 
public abstract void cleanupScenario ( ) throws Throwable ; } 
public void push ( double arg ) { stack . add ( arg ) ; } 
public double divide ( ) { return stack . get ( 0 ) / stack . get ( 1 ) ; } 
public void load_code_file ( String jsFile ) throws Throwable { jsFiles . add ( jsFile ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; cx = Context . enter ( ) ; scope = cx . initStandardObjects ( ) ; scope . put ( " jsLanguage " , scope , this ) ; cx . evaluateReader ( scope , new InputStreamReader ( getClass ( ) . getResourceAsStream ( JS_DSL ) ) , JS_DSL , 1 , null ) ; for ( String jsFile : jsFiles ) { cx . evaluateReader ( scope , new FileReader ( jsFile ) , jsFile , 1 , null ) ; 
public void addStepDefinition ( NativeObject jsStepDefinition , NativeFunction argumentsFrom , NativeRegExp regexp , NativeFunction closure ) throws Exception { addStepDefinition ( new JsStepDefinition ( cx , scope , jsStepDefinition , argumentsFrom , regexp , closure ) ) ; } 
public String regexp_source ( ) { return regexp . toString ( ) ; } 
public String file_colon_line ( ) { return jsStepDefinition . toString ( ) ; } 
public void invoke ( RubyArray rubyArgs ) throws Throwable { Object [ ] args = rubyArgs . toArray ( ) ; closure . call ( cx , scope , scope , args ) ; } 
public List < StepArgument > arguments_from ( String stepName ) { arguments = null ; argumentsFrom . call ( cx , scope , jsStepDefinition , new Object [ ] { stepName , this } ) ; return arguments ; } 
public void addArguments ( List < StepArgument > arguments ) { this . arguments = arguments ; } 
public static List < StepArgument > argumentsFrom ( Pattern regexp , String stepName ) { Matcher matcher = regexp . matcher ( stepName ) ; if ( matcher . matches ( ) ) { List < StepArgument > arguments = new ArrayList < StepArgument > ( ) ; 
public void shouldConvertFromStringToDouble ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Double . TYPE } , new Object [ ] { String . format ( " %e " , Double . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Double . class ) ) ; } 
public static RubyArray newArray ( Collection collection ) { RubyArray result = RubyArray . newArray ( getRuntime ( ) ) ; for ( Object o : collection ) { result . add ( o ) ; } return result ; } 
public static Class < ? > [ ] objectClassArray ( int ) { Class < ? > [ ] arr = new Class < ? > [ ] ; for ( int i = 0 ; i < ; i + + ) { arr [ i ] = Object . class ; } return arr ; } 
public String file_colon_line ( ) { return regexp_source ( ) ; } 
public void invokeWithJavaArgs ( Object [ ] javaArgs ) throws Throwable { Method functionInvoke = lookupInvokeMethod ( javaArgs ) ; try { functionInvoke . invoke ( closure , javaArgs ) ; 
private Method lookupInvokeMethod ( Object [ ] args ) throws NoSuchMethodException { return AFunction . class . getMethod ( " invoke " , getParameterTypes ( args ) ) ; } 
public void invoke ( String location , IRubyObject scenario ) { groovyLanguage . invokeClosure ( body , new Object [ ] { scenario } ) ; } 
void invokeClosure ( Closure body , Object [ ] args ) { body . setDelegate ( currentWorld ) ; body . call ( args ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) { groovyLanguage . invokeClosure ( body , args ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; classLanguage . invokedStepDefinition ( regexp_source ( ) , file_colon_line ( ) ) ; methodInvoker . invoke ( target , args ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { closure . call ( cx , scope , scope , args ) ; } 
public final void invoke ( RubyArray rubyArgs ) throws Throwable { Object [ ] args = rubyArgs . toArray ( ) ; Object [ ] javaArgs = argumentsConverter . convert ( getParameterTypes ( args ) , args ) ; invokeWithJavaArgs ( javaArgs ) ; } 
protected abstract Class < ? > [ ] getParameterTypes ( Object [ ] args ) ; public abstract void invokeWithJavaArgs ( Object [ ] args ) throws Throwable ; } 
public abstract void invokeWithJavaArgs ( Object [ ] args ) throws Throwable ; } 
void add_hook ( String phase , Hook hook ) ; IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
public void invoke ( Object target , Object [ ] javaArgs ) throws Throwable { try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
final public RubyArray step_matches ( String step_name , String formatted_step_name ) { return JRuby . newArray ( step_match_list ( step_name , formatted_step_name ) ) ; } 
protected abstract void prepareScenario ( ) throws Throwable ; public abstract void cleanupScenario ( ) throws Throwable ; public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; } public void invokedStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } } 
public abstract void cleanupScenario ( ) throws Throwable ; public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; } public void invokedStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } } 
public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; } 
public void invokedStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } 
public void shouldRaiseCucumberPendingWhenAnnotatedWithPending ( ) throws Throwable { Method dontExecuteMe = SomethingWithPending . class . getDeclaredMethod ( " dontExecuteMe " ) ; MethodInvoker mi = new MethodInvoker ( dontExecuteMe ) ; mi . invoke ( new SomethingWithPending ( ) , new Object [ 0 ] ) ; } 
public static void addStepDefinition ( Pattern regexp , AFunction closure ) throws Exception { instance . addStepDefinition ( new CljStepDefinition ( instance , regexp , closure ) ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; methodInvoker . invoke ( target , args ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; cx = Context . enter ( ) ; scope = new Global ( cx ) ; This gives us access to global functions like load() scope.put("jsLanguage", scope, this); cx.evaluateReader(scope, new InputStreamReader(getClass().getResourceAsStream(JS_DSL)), JS_DSL, 1, null); for (String jsFile : jsFiles) { cx.evaluateReader(scope, new FileReader(jsFile), jsFile, 1, null); 
public void addStepDefinition ( Global jsStepDefinition , NativeFunction argumentsFrom , NativeRegExp regexp , NativeFunction closure ) throws Exception { addStepDefinition ( new JsStepDefinition ( this , cx , scope , jsStepDefinition , argumentsFrom , regexp , closure ) ) ; } 
protected void register ( ) { programmingLanguage . availableStepDefinition ( regexp_source ( ) , file_colon_line ( ) ) ; } 
public final void invoke ( RubyArray rubyArgs ) throws Throwable { programmingLanguage . invokedStepDefinition ( regexp_source ( ) , file_colon_line ( ) ) ; Object [ ] args = rubyArgs . toArray ( ) ; Object [ ] javaArgs = argumentsConverter . convert ( getParameterTypes ( args ) , args ) ; invokeWithJavaArgs ( javaArgs ) ; } 
public RubyArray tag_names ( ) { return JRuby . newArray ( tagNames ) ; } 
private Method lookupInvokeMethod ( int argCount ) throws NoSuchMethodException { Class < ? > [ ] parameterTypes = new Class [ argCount ] ; for ( int i = 0 ; i < argCount ; i + + ) { parameterTypes [ i ] = Object . class ; } return AFunction . class . getMethod ( " invoke " , parameterTypes ) ; } 
public void addStepDefinition ( Global jsStepDefinition , NativeFunction argumentsFrom , NativeRegExp regexp , NativeFunction closure ) throws Exception { addStepDefinition ( new JsStepDefinition ( cx , scope , jsStepDefinition , argumentsFrom , regexp , closure ) ) ; } 
public static RubyArray newArray ( Collection < ? > collection ) { RubyArray result = RubyArray . newArray ( getRuntime ( ) ) ; for ( Object o : collection ) { result . add ( o ) ; } return result ; } 
public void transformedToA ( int integer ) { } } 
public void addIokeStepDefinition ( Object iokeStepDefObject ) { Cast because of Ioke bug (?) addStepDefinition(new IkStepDefinition(this, ioke, (IokeObject) iokeStepDefObject)); } 
public void load_code_file ( String ikFile ) throws Throwable { this . ioke . evaluateString ( " use( \" " + ikFile + " \" ) " ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { throw new RuntimeException ( " Not implemented " ) ; } 
public String regexp_source ( ) { return " /NOT_IMPLEMENTED/ " ; } 
public String file_colon_line ( ) { return " NOT_IMPLEMENTED:-1 " ; } 
public List < StepArgument > arguments_from ( String stepName ) throws Throwable { IokeObject msg = ioke . newMessage ( " arguments_from " ) ; Message arguments_from = ( Message ) IokeObject . data ( msg ) ; Object args = arguments_from . sendTo ( msg , iokeStepDefObject , iokeStepDefObject , stepName ) ; if ( args instanceof List ) { return ( List < StepArgument > ) args ; 
final public RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable { return JRuby . newArray ( step_match_list ( step_name , formatted_step_name ) ) ; } 
public final List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) throws Throwable { List < IRubyObject > matches = new ArrayList < IRubyObject > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( languageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; } 
String regexp_source ( ) ; String file_colon_line ( ) ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray args ) throws Throwable ; } 
String file_colon_line ( ) ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray args ) throws Throwable ; } 
List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray args ) throws Throwable ; } 
public void addIokeStepDefinition ( Object iokeStepDefObject ) { Cast because of Ioke bug (?) addStepDefinition(new IkStepDefinition(this, ioke, (IokeObject) iokeStepDefObject)); } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; We could pass the args, but I don't think it's needed. The ioke stepdef code block will access the arguments by group name instead. We just need to figure out a way to make them available. invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject); } 
public Integer stringToInteger ( String number ) { return Integer . valueOf ( number ) ; } 
RubyArray step_matches ( String step_name , String formatted_step_name ) ; void load_code_file ( String file ) throws Throwable ; void begin_scenario ( ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
void load_code_file ( String file ) throws Throwable ; void begin_scenario ( ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
void begin_scenario ( ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; invoke . sendTo ( msg , iokeStepDefObject , iokeStepDefObject ) ; } 
public static void Given ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; } 
public static void When ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; } 
public static void Then ( Pattern regexp , Closure body ) throws Throwable { registerStepDefinition ( regexp , body ) ; } 
private static void registerStepDefinition ( Pattern regexp , Closure body ) throws Throwable { groovyLanguage . addStepDefinition ( new GroovyStepDefinition ( groovyLanguage , regexp , body ) ) ; } 
public static void addStepDefinition ( Pattern regexp , AFunction closure ) throws Throwable { instance . addStepDefinition ( new CljStepDefinition ( instance , regexp , closure ) ) ; } 
public void addIokeStepDefinition ( Object iokeStepDefObject ) throws Throwable { Cast because of Ioke bug (?) addStepDefinition(new IkStepDefinition(this, ioke, (IokeObject) iokeStepDefObject)); } 
public String regexp_source ( ) throws Throwable { if ( regexpSource = = null ) findRegexpSource ( ) ; return regexpSource ; } 
public String file_colon_line ( ) throws Throwable { return regexp_source ( ) ; } 
private void findRegexpSource ( ) throws ControlFlow { IokeObject msg = ioke . newMessage ( " regexp_source " ) ; Message regexp_source = ( Message ) IokeObject . data ( msg ) ; regexpSource = regexp_source . sendTo ( msg , iokeStepDefObject , iokeStepDefObject ) . toString ( ) ; } 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) throws Throwable { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { Pattern regexp = Pattern . compile ( regexpString ) ; 
public void addStepDefinition ( Global jsStepDefinition , NativeFunction argumentsFrom , NativeRegExp regexp , NativeFunction closure ) throws Throwable { addStepDefinition ( new JsStepDefinition ( this , cx , scope , jsStepDefinition , argumentsFrom , regexp , closure ) ) ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; } 
protected void register ( ) throws Throwable { programmingLanguage . availableStepDefinition ( regexp_source ( ) , file_colon_line ( ) ) ; } 
String regexp_source ( ) throws Throwable ; String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray args ) throws Throwable ; } 
String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray args ) throws Throwable ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; TODO: Change Cucumber API so that we get an additional argument telling us whether or not we have a multiline argument. Needed to support multiline Strings. if(args[args.length-1] instanceof Table) { invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, args[args.length-1]); 
public static RaiseException error ( String errorClass , String message ) { RubyModule cucumber = getRuntime ( ) . getModule ( " Cucumber " ) ; RubyClass error = cucumber . getClass ( errorClass ) ; return new RaiseException ( getRuntime ( ) , 
public static void throwCucumberIokeException ( String message ) { throw JRuby . error ( " IokeException " , message ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; Object multilineArg ; TODO: Change Cucumber API so that we get an additional argument telling us whether or not we have a multiline argument. Needed to support multiline Strings. if(args[args.length-1] instanceof Table) { multilineArg = args[args.length-1]; } else { multilineArg = IokeData.Nil; } Object result = invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, multilineArg); Maybe look at result to figure out whether or not to throw an exception 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( features ) ; Java jruby = jruby ( allArgs ) ; jruby . execute ( ) ; } 
void invoke ( String step ) ; void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; } 
void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; } 
public void Given ( String step ) { stepMother . invoke ( step ) ; } 
public void Given ( String step , Table table ) { stepMother . invoke ( step , table ) ; } 
public void Given ( String step , String multilineString ) { stepMother . invoke ( step , multilineString ) ; } 
public void When ( String step ) { Given ( step ) ; } 
public void When ( String step , Table table ) { Given ( step , table ) ; } 
public void When ( String step , String multilineString ) { Given ( step , multilineString ) ; } 
public void Then ( String step ) { Given ( step ) ; } 
public void Then ( String step , Table table ) { Given ( step , table ) ; } 
public void Then ( String step , String multilineString ) { Given ( step , multilineString ) ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addInstance ( Object instance ) ; Object getComponent ( Class < ? > type ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addInstance ( Object instance ) ; Object getComponent ( Class < ? > type ) ; } 
void addClass ( Class < ? > clazz ) ; void addInstance ( Object instance ) ; Object getComponent ( Class < ? > type ) ; } 
void addInstance ( Object instance ) ; Object getComponent ( Class < ? > type ) ; } 
public void createObjects ( ) { pico = new PicoBuilder ( ) . withCaching ( ) . build ( ) ; for ( Class < ? > clazz : classes ) { pico . addComponent ( clazz ) ; } for ( Object instance : instances ) { pico . addComponent ( instance ) ; } pico . start ( ) ; } 
public void addInstance ( Object instance ) { instances . add ( instance ) ; } 
public void addInstance ( Object instance ) { System . err . println ( " WARNING: Adding instances to Spring is not implemented. " ) ; } 
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; } 
public void itIs ( String what ) { if ( what . equals ( " magic " ) ) { magic = true ; 
public void magicShouldHappen ( ) { assertTrue ( magic ) ; } 
public void iCallAnotherStep ( ) { Given ( " it is magic " ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; Object multilineArg ; TODO: Change Cucumber API so that we get an additional argument telling us whether or not we have a multiline argument. Needed to support multiline Strings. if(args[args.length-1] instanceof Table) { multilineArg = args[args.length-1]; } else { multilineArg = ioke.nil; } invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, multilineArg); } 
public void shouldConvertFromStringToInteger ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Integer . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Integer . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Integer . class ) ) ; } 
public void shouldConvertFromStringToLong ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Long . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Long . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Long . class ) ) ; } 
public void shouldConvertFromStringToDouble ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Double . TYPE } , new Object [ ] { String . format ( Locale . US , " %f " , Double . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Double . class ) ) ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; invoke . sendTo ( msg , iokeStepDefObject , iokeStepDefObject , multilineArg ( args ) ) ; } 
private Object multilineArg ( Object [ ] args ) { Object multilineArg ; if ( args . length > 0 ) { if ( args [ args . length - 1 ] instanceof PyString ) { multilineArg = ioke . newText ( ( ( PyString ) args [ args . length - 1 ] ) . to_s ( ) ) ; } else if ( args [ args . length - 1 ] instanceof Table ) { multilineArg = args [ args . length - 1 ] ; } else { multilineArg = ioke . nil ; } } else { multilineArg = ioke . nil ; } return multilineArg ; } 
public void invokeWithJavaArgs ( Object [ ] args ) throws Throwable { IokeObject msg = ioke . newMessage ( " invoke " ) ; Message invoke = ( Message ) IokeObject . data ( msg ) ; Object multilineArg ; TODO: Change Cucumber API so that we get an additional argument telling us whether or not we have a multiline argument. Needed to support multiline Strings. if(args.length > 0 && (args[args.length-1] instanceof Table)) { multilineArg = args[args.length-1]; } else { multilineArg = ioke.nil; } TODO: catch pending and resignal it TODO: catch expectation failures and resignal correctly invoke.sendTo(msg, iokeStepDefObject, iokeStepDefObject, multilineArg); } 
private void registerTransformMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Transform . class ) ) { classLanguage . addTransformHook ( new JavaHook ( method , objectFactory ) ) ; 
protected void clearHooksAndStepDefinitions ( ) { transforms = new ArrayList < Hook > ( ) ; befores = new ArrayList < Hook > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; afters = new ArrayList < Hook > ( ) ; } 
public void addTransformHook ( Hook transform ) { transforms . add ( transform ) ; } 
public int transformToInteger ( String input ) { return Integer . valueOf ( input ) ; } 
public void addClass ( Class < ? > clazz ) { instanceMap . put ( clazz , injector . getInstance ( clazz ) ) ; } 
public Status createTransaction ( Transaction transaction ) ; } 
public CreateTransactionResponse sendTransactionToBilling ( Transaction transaction ) { Status status = database . createTransaction ( transaction ) ; return new CreateTransactionResponse ( status , " OK " ) ; } 
public boolean isOK ( ) { return Status . OK . equals ( status ) ; } 
protected void configure ( ) { bind ( BillingDatabase . class ) . toInstance ( simpleBillingDatabase ) ; } 
public Status createTransaction ( Transaction transaction ) { return Status . OK ; } 
public String toString ( ) { return " Transaction [amount= " + amount + " , customerId= " + customerId + " ] " ; } 
public void iHaveATransaction ( ) { transaction = new Transaction ( " 12345678 " , new BigDecimal ( " 50.00 " ) ) ; } 
public void iSendTheTransactionToBilling ( ) { response = billingService . sendTransactionToBilling ( transaction ) ; } 
public void theResponseShouldBeOK ( ) { assertTrue ( response . isOK ( ) ) ; } 
public void createObjects ( ) { injector = Guice . createInjector ( module ) ; tfor ( Class < ? > clazz : classes ) { instanceMap . put ( clazz , injector . getInstance ( clazz ) ) ; 
public void iHaveATransaction ( ) { tif ( transaction ! = null ) { tthrow new RuntimeException ( " Wait what? The instance is shared across scenarios? " ) ; } transaction = new Transaction ( " 12345678 " , new BigDecimal ( " 50.00 " ) ) ; } 
public void addInstance ( Object instance ) { if ( appContext = = null ) { mother . set ( ( StepMother ) instance ) ; 
public void afterPropertiesSet ( ) throws Exception { this . mother = SpringFactory . mother . get ( ) ; SpringFactory . mother . set ( null ) ; } 
public Object getObject ( ) throws Exception { return mother ; } 
public boolean isSingleton ( ) { return true ; } 
public void itIsMagic ( ) { this . magic = true ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; } 
void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; } 
void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; } 
public void addStepMother ( StepMother instance ) { instances . add ( instance ) ; } 
public void addStepMother ( StepMother instance ) { if ( appContext = = null ) { mother . set ( instance ) ; 
RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; void load_code_file ( String file ) throws Throwable ; void begin_scenario ( ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
private void registerTransformMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Transform . class ) ) { classLanguage . addTransformHook ( method . getReturnType ( ) , new JavaHook ( method , objectFactory ) ) ; 
protected void clearHooksAndStepDefinitions ( ) { transforms = new HashMap < Class < ? > , Hook > ( ) ; befores = new ArrayList < Hook > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; afters = new ArrayList < Hook > ( ) ; } 
public void addTransformHook ( Class < ? > type , Hook transform ) { transforms . put ( type , transform ) ; } 
public void shouldAddTransformHooksToTransformsMap ( ) throws Throwable { AbstractProgrammingLanguage programmingLanguage = new TestProgrammingLanguage ( null ) ; programmingLanguage . prepareScenario ( ) ; programmingLanguage . addTransformHook ( Integer . TYPE , transformHook ) ; assertEquals ( transformHook , programmingLanguage . getTransforms ( ) . get ( Integer . TYPE ) ) ; } 
public void cleanupScenario ( ) throws Throwable { TODO Auto-generated method stub } @Override public void load_code_file(String file) throws Throwable { TODO Auto-generated method stub } @Override protected void prepareScenario() throws Throwable { clearHooksAndStepDefinitions(); } }} 
public void load_code_file ( String file ) throws Throwable { TODO Auto-generated method stub } @Override protected void prepareScenario() throws Throwable { clearHooksAndStepDefinitions(); } }} 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } 
public List < StepArgument > arguments_from ( String stepName ) throws Throwable { IokeObject msg = ioke . newMessage ( " arguments_from " ) ; Message arguments_from = ( Message ) IokeObject . data ( msg ) ; Object args = arguments_from . sendTo ( msg , iokeStepDefObject , iokeStepDefObject , stepName ) ; if ( args instanceof List < ? > ) { return ( List < StepArgument > ) args ; 
public int transformStringToInt ( String integer ) { return Integer . valueOf ( integer ) ; } 
private Object convertObject ( Class < ? > type , Object arg ) { try { Hook hook = transforms . get ( type ) ; 
public void setUp ( ) throws Throwable { converter = new ArgumentsConverter ( transforms ) ; } 
public Class < ? > transform ( Class < ? > returnType , Object arg ) { String argument = String . valueOf ( arg ) ; Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; return methodInvoker . invoke ( target , new Object [ ] { argument } ) ; } 
public Class < ? > transform ( Class < ? > returnType , Object argument ) ; } 
private void registerTransformMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Transform . class ) ) { classLanguage . addTransform ( method . getReturnType ( ) , new JavaTransform ( method , objectFactory ) ) ; 
public Class < ? > transform ( Class < ? > returnType , Object arg ) throws Throwable { String argument = String . valueOf ( arg ) ; Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; methodInvoker . invoke ( target , new Object [ ] { argument } ) ; return null ; } 
public final List < IRubyObject > step_match_list ( String step_name , String formatted_step_name ) throws Throwable { List < IRubyObject > matches = new ArrayList < IRubyObject > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( languageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; } 
public final void begin_scenario ( ) throws Throwable { prepareScenario ( ) ; for ( Hook before : befores ) { before . invoke ( " before " , null ) ; 
protected void clearHooksAndStepDefinitions ( ) { transforms = new HashMap < Class < ? > , Transformable > ( ) ; befores = new ArrayList < Hook > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; afters = new ArrayList < Hook > ( ) ; } 
public final void end_scenario ( ) throws Throwable { for ( Hook after : afters ) { after . invoke ( " after " , null ) ; } cleanupScenario ( ) ; } 
public void addTransform ( Class < ? > type , Transformable transform ) { this . transforms . put ( type , transform ) ; } 
private Object convertObject ( Class < ? > type , Object arg ) { try { 
public Class < ? > transform ( Class < ? > returnType , Object argument ) throws Throwable ; } 
public void shouldAddTransformHooksToTransformsMap ( ) throws Throwable { AbstractProgrammingLanguage programmingLanguage = new TestProgrammingLanguage ( null ) ; programmingLanguage . prepareScenario ( ) ; programmingLanguage . addTransform ( Integer . TYPE , transform ) ; assertEquals ( transform , programmingLanguage . getTransforms ( ) . get ( Integer . TYPE ) ) ; } 
public Object invoke ( Object target , Object [ ] javaArgs ) throws Throwable { try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
public void addStepMother ( StepMother stepMother ) { modules . add ( new StepMotherModule ( stepMother ) ) ; } 
public void createObjects ( ) { injector = Guice . createInjector ( modules ) ; for ( Class < ? > clazz : classes ) { instances . put ( clazz , injector . getInstance ( clazz ) ) ; 
protected void configure ( ) { bind ( StepMother . class ) . toProvider ( stepMotherProvider ) ; } 
public StepMother get ( ) { return stepMother ; } 
public int transformStringToInt ( String argument ) { return Integer . valueOf ( argument ) ; } 
public Integer transformStringToInteger ( String argument ) { return Integer . valueOf ( argument ) ; } 
public long transformStringToLongPrimitive ( String argument ) { return Long . valueOf ( argument ) ; } 
public Long transformStringToLong ( String argument ) { return Long . valueOf ( argument ) ; } 
public double transformStringToDoublePrimitive ( String argument ) { return Double . valueOf ( argument ) ; } 
public Double transformStringToDouble ( String argument ) { return Double . valueOf ( argument ) ; } 
public float transformStringToFloatPrimitive ( String argument ) { return Float . valueOf ( argument ) ; } 
public Float transformStringToFloat ( String argument ) { return Float . valueOf ( argument ) ; } 
public short transformStringToShortPrimitive ( String argument ) { return Short . valueOf ( argument ) ; } 
public Short transformStringToShort ( String argument ) { return Short . valueOf ( argument ) ; } 
public byte transformStringToBytePrimitive ( String argument ) { return Byte . valueOf ( argument ) ; } 
public Byte transformStringToByte ( String argument ) { return Byte . valueOf ( argument ) ; } 
public char transformStringToChar ( String argument ) { return Character . valueOf ( argument . charAt ( 0 ) ) ; } 
public Character transformStringToCharacters ( String argument ) { return Character . valueOf ( argument . charAt ( 0 ) ) ; } 
public BigDecimal transformStringToBigDecimal ( String argument ) { return BigDecimal . valueOf ( Double . valueOf ( argument ) ) ; } 
public BigInteger transformStringToBigInteger ( String argument ) { return BigInteger . valueOf ( Long . valueOf ( argument ) ) ; } 
public boolean transformStringToBooleanPrimitive ( String argument ) { return Boolean . valueOf ( argument ) ; } 
public Boolean transformStringToBoolean ( String argument ) { return Boolean . valueOf ( argument ) ; } 
public < T > T transform ( Class < T > returnType , Object arg ) throws Throwable { String argument = String . valueOf ( arg ) ; Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; return ( T ) ( methodInvoker . invoke ( target , new Object [ ] { argument } ) ) ; } 
private Object convertObject ( Class < ? > type , Object arg ) { try { if ( type . equals ( String . class ) ) { 
private void throwArgumentError ( Class < ? > [ ] types , Object [ ] objetcs ) { throw new RuntimeException ( " Wrong number of arguments. Expected ( " + join ( types , " , " ) + " ) - got ( " + join ( objetcs , " , " ) + " ) " ) ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; void addDefaultTransforms ( ObjectFactory objectFactory , ClassLanguage classLanguage ) ; } 
void addDefaultTransforms ( ObjectFactory objectFactory , ClassLanguage classLanguage ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . addDefaultTransforms ( objectFactory , this ) ; 
public < T > T transform ( Class < T > returnType , Object argument ) throws Throwable ; } 
public static void classSetUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( StepMother . class ) , Arrays . asList ( new ClassAnalyzer [ ] { new JavaAnalyzer ( ) } ) ) ; classLanguage . load_code_file ( " cuke4duke/internal/java/DefaultJavaTransforms.class " ) ; classLanguage . prepareScenario ( ) ; ArgumentsConverterTest . transforms = classLanguage . getTransforms ( ) ; } 
public void setUp ( ) throws Throwable { converter = new ArgumentsConverter ( ArgumentsConverterTest . transforms ) ; } 
public void shouldConvertFromStringToInt ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Integer . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Integer . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Integer . class ) ) ; } 
public void shouldConvertFromStringToInteger ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Integer . class } , new Object [ ] { String . format ( Locale . US , " %d " , Integer . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Integer . class ) ) ; } 
public void shouldConvertFromStringToLongPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Long . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Long . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Long . class ) ) ; } 
public void shouldConvertFromStringToLong ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Long . class } , new Object [ ] { String . format ( Locale . US , " %d " , Long . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Long . class ) ) ; } 
public void shouldConvertFromStringToDoublePrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Double . TYPE } , new Object [ ] { String . format ( Locale . US , " %f " , Double . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Double . class ) ) ; } 
public void shouldConvertFromStringToDouble ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Double . class } , new Object [ ] { String . format ( Locale . US , " %f " , Double . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Double . class ) ) ; } 
public void shouldConvertFromStringToFloatPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Float . TYPE } , new Object [ ] { String . format ( Locale . US , " %f " , Float . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Float . class ) ) ; } 
public void shouldConvertFromStringToFloat ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Float . class } , new Object [ ] { String . format ( Locale . US , " %f " , Float . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Float . class ) ) ; } 
public void shouldConvertFromStringToShortPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Short . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Short . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Short . class ) ) ; } 
public void shouldConvertFromStringToShort ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Short . class } , new Object [ ] { String . format ( Locale . US , " %d " , Short . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Short . class ) ) ; } 
public void shouldConvertFromStringToBytePrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Byte . TYPE } , new Object [ ] { String . format ( Locale . US , " %d " , Byte . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Byte . class ) ) ; } 
public void shouldConvertFromStringToByte ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Byte . class } , new Object [ ] { String . format ( Locale . US , " %d " , Byte . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Byte . class ) ) ; } 
public void shouldConvertFromStringToChar ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Character . TYPE } , new Object [ ] { String . format ( Locale . US , " %c " , Character . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Character . class ) ) ; } 
public void shouldConvertFromStringToCharacter ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Character . class } , new Object [ ] { String . format ( Locale . US , " %c " , Character . MAX_VALUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Character . class ) ) ; } 
public void shouldConvertFromStringToBigDecimal ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { BigDecimal . class } , new Object [ ] { String . format ( Locale . US , " %f " , BigDecimal . TEN ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( BigDecimal . class ) ) ; } 
public void shouldConvertFromStringToBigInteger ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { BigInteger . class } , new Object [ ] { String . format ( Locale . US , " %d " , BigInteger . TEN ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( BigInteger . class ) ) ; } 
public void shouldConvertFromStringToBooleanPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Boolean . TYPE } , new Object [ ] { String . format ( Locale . US , " %b " , Boolean . TRUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Boolean . class ) ) ; } 
public void shouldConvertFromStringToBoolean ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Boolean . class } , new Object [ ] { String . format ( Locale . US , " %b " , Boolean . TRUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Boolean . class ) ) ; } 
public void shouldConvertFromStringToString ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { String . class } , new Object [ ] { " String " } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( String . class ) ) ; 
public void shouldConvertFromTableToTable ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Table . class } , new Object [ ] { mock ( Table . class ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . getInterfaces ( ) [ 0 ] . equals ( Table . class ) ) ; } 
public void shouldConvertFromClassToClass ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { MyClass . class } , new Object [ ] { new MyClass ( ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( MyClass . class ) ) ; 
public void transformedToA ( int value ) { assertEquals ( 10 , value ) ; } 
public void transformedToA ( Car value ) { assertEquals ( 10 , value ) ; } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { } private class Car { } } 
public void allIsGood ( ) { } private class Car { } } 
public Class < ? > [ ] allwaysLoad ( ) { return new Class < ? > [ 0 ] ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] allwaysLoad ( ) ; } 
public Class < ? > [ ] alwaysLoad ( ) { return new Class < ? > [ 0 ] ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] alwaysLoad ( ) ; } 
private ObjectFactory createObjectFactory ( ) throws Throwable { String className = System . getProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; if ( className = = null ) { throw new RuntimeException ( " Missing system property: cuke4duke.objectFactory " ) ; } Class < ? > ofc = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; Constructor < ? > ctor = ofc . getConstructor ( ) ; try { return ( ObjectFactory ) ctor . newInstance ( ) ; 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; void addDefaultTransforms ( ClassLanguage classLanguage , ObjectFactory objectFactory ) ; } 
void addDefaultTransforms ( ClassLanguage classLanguage , ObjectFactory objectFactory ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . addClass ( DefaultJavaTransforms . class ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . addDefaultTransforms ( this , objectFactory ) ; 
public static void classSetUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( StepMother . class ) , Arrays . asList ( new ClassAnalyzer [ ] { new JavaAnalyzer ( ) } ) ) ; classLanguage . prepareScenario ( ) ; ArgumentsConverterTest . transforms = classLanguage . getTransforms ( ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . addDefaultTransforms ( this , objectFactory ) ; 
public void transformToA ( int value ) { assertEquals ( 10 , value ) ; } 
public void transformToA ( String value ) { try { Given ( " pass '(.*)' as a Car " , value ) ; 
public void passACar ( Car value ) { } @Transform public User transformStringToUserWithAge ( String age ) { return new User ( Integer . valueOf ( age ) ) ; } @Given ( " ^I pass '(.*)' to a method with User as parameter$ " ) public void transformToA ( User user ) { this . user = user ; } @When ( " ^something happens$ " ) public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } private class Car { } private class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public User transformStringToUserWithAge ( String age ) { return new User ( Integer . valueOf ( age ) ) ; } 
public void transformToA ( User user ) { this . user = user ; } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } private class Car { } private class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } 
public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } 
public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } 
public < T > T transform ( Class < T > returnType , Object arg ) throws Throwable { String argument = String . valueOf ( arg ) ; Object target = objectFactory . getComponent ( ( Class < ? > ) method . getDeclaringClass ( ) ) ; return ( T ) ( methodInvoker . invoke ( target , new Object [ ] { argument } ) ) ; } 
void populateStepDefinitionsAndHooksFor ( Class < ? > clazz , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] alwaysLoad ( ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; addDefaultJvmTransforms(); objectFactory.createObjects(); for (ClassAnalyzer analyzer : analyzers) { for (Class<?> clazz : classes) { 
private Class < ? > loadClass ( String classFile ) throws ClassNotFoundException { String withoutExt = classFile . substring ( 0 , classFile . length ( ) - " .class " . length ( ) ) ; String [ ] pathElements = withoutExt . split ( " \\ / " ) ; String className = null ; for ( int i = pathElements . length - 1 ; i > = 0 ; i - - ) { if ( className = = null ) { className = pathElements [ i ] ; } else { className = pathElements [ i ] + " . " + className ; } try { return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( " Couldn't determine class from file: " + classFile ) ; } 
private ObjectFactory createObjectFactory ( ) throws Throwable { String className = System . getProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; if ( className = = null ) { throw new RuntimeException ( " Missing system property: cuke4duke.objectFactory " ) ; } Class < ? > ofc = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; Constructor < ? > ctor = ofc . getConstructor ( ) ; try { return ( ObjectFactory ) ctor . newInstance ( ) ; 
protected void clearHooksAndStepDefinitions ( ) { transforms = new HashMap<Class<?>, Transformable>(); befores = new ArrayList<Hook>(); stepDefinitions = new ArrayList<StepDefinition>(); afters = new ArrayList<Hook>(); } 
public void setUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Arrays . asList ( new ClassAnalyzer [ ] { new JavaAnalyzer ( ) } ) ) ; classLanguage . prepareScenario ( ) ; transforms = classLanguage . getTransforms ( ) ; converter = new ArgumentsConverter ( transforms ) ; } 
public void shouldConvertFromStringToBooleanPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Boolean . TYPE } , new Object [ ] { String . format ( Locale . US , " %b " , Boolean . TRUE ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Boolean . class ) ) ; assertTrue ( ( Boolean ) convertedObject [ 0 ] ) ; } 
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; } 
public void shouldAddDefaultJavaTransformsToClassLanguage ( ) throws Throwable { language . prepareScenario ( ) ; assertTrue ( language . getTransforms ( ) . size ( ) > 0 ) ; } 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; addDefaultJvmTransforms ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { for ( Class < ? > clazz : classes ) { 
private void registerTransformMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Transform . class ) ) { classLanguage . addTransform ( method . getReturnType ( ) , new JvmTransform ( method , objectFactory ) ) ; 
protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { for ( Class < ? > clazz : classes ) { 
public Object transformStringToObject ( String argument ) { return argument ; } 
public < T > T transform ( Class < T > returnType , Object argument ) throws Throwable { Method method = methods . get ( returnType ) ; if ( method = = null ) throw new IllegalArgumentException ( ) ; return ( T ) method . invoke ( this , argument ) ; } 
public void shouldConvertFromStringToObject ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Object . class } , new Object [ ] { " An Object " } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( String . class ) ) ; } 
public void cleanupScenario ( ) throws Throwable { } @Override public void load_code_file ( String file ) throws Throwable { } @Override protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } } } 
public void load_code_file ( String file ) throws Throwable { } @Override protected void prepareScenario ( ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } } } 
public void seeSearchResults ( String results ) { assertThat ( facade . getBrowser ( ) . getPageSource ( ) , containsString ( results ) ) ; } 
public void visit ( ) { facade . getBrowser ( ) . get ( " http:google.com/ " ) ; } 
public void search ( String query ) { WebElement searchField = facade . getBrowser ( ) . findElement ( By . name ( " q " ) ) ; searchField . sendKeys ( query ) ; WebDriver will find the containing form for us from the searchField element searchField.submit(); } 
public void createBrowser ( ) throws IllegalAccessException , InvocationTargetException , InstantiationException { browser = driverConstructor . newInstance ( ) ; } 
public void closeBrowser ( ) throws IllegalAccessException , InvocationTargetException , InstantiationException { browser . close ( ) ; browser . quit ( ) ; } 
public RubyArray tag_names ( ) { return null ; To change body of implemented methods use File | Settings | File Templates. } 
public void invoke ( String location , IRubyObject scenario ) throws Throwable { closure . call ( ) ; } 
public static void addCljBeforeHook ( AFunction closure ) { instance . addBeforeHook ( new CljHook ( instance , closure ) ) ; } 
public static void addCljStepDefinition ( Pattern regexp , AFunction closure ) throws Throwable { instance . addStepDefinition ( new CljStepDefinition ( instance , regexp , closure ) ) ; } 
public void shouldConvertFromTableToObject ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Object . class } , new Object [ ] { mock ( Table . class ) } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . getInterfaces ( ) [ 0 ] . equals ( Table . class ) ) ; } 
public static void addCljAfterHook ( AFunction closure ) { instance . addAfterHook ( new CljHook ( instance , closure ) ) ; } 
public static void addCljBeforeHook ( AFunction closure ) { instance . addBeforeHook ( new CljHook ( Collections . < String > emptyList ( ) , closure ) ) ; } 
public static void addCljAfterHook ( AFunction closure ) { instance . addAfterHook ( new CljHook ( Collections . < String > emptyList ( ) , closure ) ) ; } 
public final RubyArray tag_names ( ) { return JRuby . newArray ( tagNames ) ; } 
private HashMap < Class < ? > , Transformable > createDefaultTransformations ( ) { return new HashMap < Class < ? > , Transformable > ( new DefaultJvmTransforms ( ) . createDefaultJvmTransforms ( ) ) ; } 
public boolean overrideBooleanTransform ( String yes ) { if ( yes . equals ( " yes " ) ) return true ; 
public void setUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Arrays . asList ( new ClassAnalyzer [ ] { new JavaAnalyzer ( ) } ) ) ; classLanguage . load_code_file ( " cuke4duke/internal/jvmclass/MyTransforms.class " ) ; classLanguage . prepareScenario ( ) ; transforms = classLanguage . getTransforms ( ) ; converter = new ArgumentsConverter ( transforms ) ; } 
public void shouldConvertFromStringToBooleanPrimitive ( ) { Object [ ] convertedObject = converter . convert ( new Class < ? > [ ] { Boolean . TYPE } , new Object [ ] { " yes " } ) ; assertTrue ( convertedObject [ 0 ] . getClass ( ) . isAssignableFrom ( Boolean . class ) ) ; assertTrue ( ( Boolean ) convertedObject [ 0 ] ) ; } 
public boolean overrideBooleanPrimitiveTransform ( String boolValue ) { return boolValue . equals ( " yes " ) ? true : false ; } 
public void passACar ( Car value ) { } @Given ( " ^I pass '(.*)' to a method with User as parameter$ " ) public void transformToA ( User user ) { this . user = user ; } @Given ( " ^I pass '(.*)' to a method with boolean as parameter$ " ) public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; } @When ( " ^something happens$ " ) public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } private class Car { } private class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } private class Car { } private class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Before . class ) ) { List < String > tagNames = JavaHook . getTagNames ( method . getAnnotation ( Before . class ) . value ( ) ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( After . class ) ) { List < String > tagNames = JavaHook . getTagNames ( method . getAnnotation ( After . class ) . value ( ) ) ; 
public final void begin_scenario ( IRubyObject scenario ) throws Throwable { prepareScenario ( ) ; } 
protected void clearHooksAndStepDefinitions ( ) { transforms = new HashMap < Class < ? > , Transformable > ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; } 
public final void end_scenario ( ) throws Throwable { cleanupScenario ( ) ; } 
public void addBeforeHook ( Hook before ) { languageMixin . add_hook ( " before " , before ) ; } 
public void addAfterHook ( Hook after ) { languageMixin . add_hook ( " after " , after ) ; } 
RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; void load_code_file ( String file ) throws Throwable ; void begin_scenario ( IRubyObject scenario ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
void load_code_file ( String file ) throws Throwable ; void begin_scenario ( IRubyObject scenario ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
void begin_scenario ( IRubyObject scenario ) throws Throwable ; void end_scenario ( ) throws Throwable ; } 
public void cryWolf ( ) { throw new RuntimeException ( " CRY WOLF " ) ; } 
public static void Before ( Object . . . tagsAndBody ) { String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( " before " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public static void After ( Object . . . tagsAndBody ) { String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( " after " , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public static void addCljBeforeHook ( AFunction closure ) { instance . addBeforeHook ( new CljHook ( new String [ 0 ] , closure ) ) ; } 
public static void addCljAfterHook ( AFunction closure ) { instance . addAfterHook ( new CljHook ( new String [ 0 ] , closure ) ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } } 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( Before . class ) ) { classLanguage . addBeforeHook ( new JavaHook ( method . getAnnotation ( Before . class ) . value ( ) , method , objectFactory ) ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage , ObjectFactory objectFactory ) { if ( method . isAnnotationPresent ( After . class ) ) { classLanguage . addAfterHook ( new JavaHook ( method . getAnnotation ( After . class ) . value ( ) , method , objectFactory ) ) ; 
public final String [ ] tag_names ( ) { return tagNames ; } 
public String [ ] tag_names ( ) ; void invoke ( String location , IRubyObject scenario ) throws Throwable ; } 
public void thenB4AndForever ( String b4AndForeverValue ) { assertEquals ( b4AndForeverValue , b4AndForever ) ; } 
public static void Before ( Object . . . tagsAndBody ) { addHook ( " before " , tagsAndBody ) ; } 
public static void After ( Object . . . tagsAndBody ) { addHook ( " after " , tagsAndBody ) ; } 
private static void addHook ( String phase , Object [ ] tagsAndBody ) { if ( tagsAndBody . length = = 0 ) return ; String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( phase , new GroovyHook ( tagNames , body , groovyLanguage ) ) ; } 
public void seeSearchResults ( String results ) { assertThat ( d . getPageSource ( ) , containsString ( results ) ) ; } 
public void visit ( ) { d . get ( " http:google.com/ " ) ; } 
public void search ( String query ) { WebElement searchField = d . findElement ( By . name ( " q " ) ) ; searchField . sendKeys ( query ) ; WebDriver will find the containing form for us from the searchField element searchField.submit(); } 
tprotected void configure ( ) { } } tGuiceFactory guiceFactory ; @Before public void setUp ( ) throws Throwable { tSystem . setProperty ( " cuke4duke.guiceModule " , " cuke4duke.internal.jvmclass.SomeModule " ) ; tguiceFactory = new GuiceFactory ( ) ; } @Test public void shouldNotAbortIfClassCannotBeInstantiated ( ) { tguiceFactory . addClass ( SomeClass . class ) ; tSomeClass instance = new SomeClass ( ) ; tClass < ? extends SomeInnerClass > someInnerClass = instance . new SomeInnerClass ( ) . getClass ( ) ; tguiceFactory . addClass ( someInnerClass ) ; tguiceFactory . createObjects ( ) ; } } 
public void setUp ( ) throws Throwable { tSystem . setProperty ( " cuke4duke.guiceModule " , " cuke4duke.internal.jvmclass.SomeModule " ) ; tguiceFactory = new GuiceFactory ( ) ; } 
public void shouldNotAbortIfClassCannotBeInstantiated ( ) { tguiceFactory . addClass ( SomeClass . class ) ; tSomeClass instance = new SomeClass ( ) ; tClass < ? extends SomeInnerClass > someInnerClass = instance . new SomeInnerClass ( ) . getClass ( ) ; tguiceFactory . addClass ( someInnerClass ) ; tguiceFactory . createObjects ( ) ; 
public void createObjects ( ) { injector = Guice . createInjector ( modules ) ; for ( Class < ? > clazz : classes ) { ttry { 
public void createObjects ( ) { Injector injector = Guice . createInjector ( modules ) ; for ( Class < ? > clazz : classes ) { try { 
protected void configure ( ) { } } private GuiceFactory guiceFactory ; @Before public void setUp ( ) throws Throwable { guiceFactory = new GuiceFactory ( " cuke4duke.internal.jvmclass.SomeModule " ) ; } @Test public void shouldNotAbortIfClassCannotBeInstantiated ( ) { guiceFactory . addClass ( SomeClass . class ) ; SomeClass instance = new SomeClass ( ) ; Class < ? extends SomeInnerClass > someInnerClass = instance . new SomeInnerClass ( ) . getClass ( ) ; guiceFactory . addClass ( someInnerClass ) ; guiceFactory . createObjects ( ) ; } } 
public void setUp ( ) throws Throwable { guiceFactory = new GuiceFactory ( " cuke4duke.internal.jvmclass.SomeModule " ) ; } 
public void shouldNotAbortIfClassCannotBeInstantiated ( ) { guiceFactory . addClass ( SomeClass . class ) ; SomeClass instance = new SomeClass ( ) ; Class < ? extends SomeInnerClass > someInnerClass = instance . new SomeInnerClass ( ) . getClass ( ) ; guiceFactory . addClass ( someInnerClass ) ; guiceFactory . createObjects ( ) ; 
public void populateStepDefinitionsAndHooksFor ( Method method , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable { registerBeforeMaybe ( method , classLanguage , objectFactory ) ; registerStepDefinitionMaybe ( method , classLanguage , objectFactory ) ; registerAfterMaybe ( method , classLanguage , objectFactory ) ; registerTransformMaybe ( method , classLanguage , objectFactory ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; cx = Context . enter ( ) ; scope = new Global ( cx ) ; This gives us access to global functions like load() scope.put("jsLanguage", scope, this); cx.evaluateReader(scope, new InputStreamReader(getClass().getResourceAsStream(JS_DSL)), JS_DSL, 1, null); for (String jsFile : jsFiles) { cx.evaluateReader(scope, new FileReader(jsFile), jsFile, 1, null); 
void populateStepDefinitionsAndHooksFor ( Method method , ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] alwaysLoad ( ) ; } 
public void load_code_file ( String classFile ) throws Throwable { Class < ? > clazz = loadClass ( classFile ) ; addClass ( clazz ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; List < Method > orderedMethods = orderedMethods ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { for ( Method method : orderedMethods ) { 
private List < Method > orderedMethods ( ) { List < Method > methods = new ArrayList < Method > ( ) ; for ( Class clazz : classes ) { methods . addAll ( Arrays . asList ( clazz . getMethods ( ) ) ) ; } Collections . sort ( methods , new Comparator < Method > ( ) { public int compare ( Method m1 , Method m2 ) { return order ( m1 ) - order ( m2 ) ; } private int order ( Method m ) { Order order = m . getAnnotation ( Order . class ) ; return ( order = = null ) ? Integer . MAX_VALUE : order . value ( ) ; } } ) ; return methods ; } 
public int compare ( Method m1 , Method m2 ) { return order ( m1 ) - order ( m2 ) ; } 
private int order ( Method m ) { Order order = m . getAnnotation ( Order . class ) ; return ( order = = null ) ? Integer . MAX_VALUE : order . value ( ) ; } 
public void end_scenario ( ) throws Throwable { objectFactory . disposeObjects ( ) ; } 
private static ObjectFactory createObjectFactory ( ) throws Throwable { String objectFactoryClassName = System . getProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; Class < ? > ofc = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( objectFactoryClassName ) ; Constructor < ? > ctor = ofc . getConstructor ( ) ; try { return ( ObjectFactory ) ctor . newInstance ( ) ; 
protected abstract void begin_scenario ( IRubyObject scenario ) throws Throwable ; public abstract void end_scenario ( ) throws Throwable ; public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; } public void invokedStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } } 
public abstract void end_scenario ( ) throws Throwable ; public void availableStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . available_step_definition ( regexp_source , file_colon_line ) ; } public void invokedStepDefinition ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } } 
RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; void load_code_file ( String file ) throws Throwable ; } 
public void doA ( ) { assertEquals ( " Heldlo from B " , b . message ) ; } 
public void doB ( ) { message = " Hello from B " ; } 
public void shouldRunBeforeHooksInOrderOfDependencies ( ) throws Throwable { ObjectFactory objectFactory = new PicoFactory ( ) ; ClassLanguageMixin languageMixin = mock ( ClassLanguageMixin . class ) ; language = new ClassLanguage ( languageMixin , mock ( StepMother . class ) , Collections . < ClassAnalyzer > singletonList ( new JavaAnalyzer ( ) ) , objectFactory ) ; language . addClass ( A . class ) ; language . addClass ( B . class ) ; language . begin_scenario ( null ) ; InOrder order = inOrder ( languageMixin ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doA " ) ) ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doB " ) ) ) ; } 
private Matcher < JavaHook > isHook ( String methodName ) { return new HookMatcher ( methodName ) ; } 
public void describeTo ( Description description ) { description . appendText ( " Expected " + methodName + " , but got " + actualMethodName ) ; } 
public boolean matches ( Object o ) { JavaHook hook = ( JavaHook ) o ; actualMethodName = hook . getMethod ( ) . getName ( ) ; return methodName . equals ( actualMethodName ) ; } 
public void passACar ( Car value ) { } @Given ( " ^I pass '(.*)' to a method with User as parameter$ " ) public void transformToA ( User user ) { this . user = user ; } @Given ( " ^I pass '(.*)' to a method with boolean as parameter$ " ) public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; } @When ( " ^something happens$ " ) public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
void populateStepDefinitionsAndHooks ( ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] alwaysLoad ( ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . populateStepDefinitionsAndHooks ( objectFactory , this ) ; 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( features ) ; Java jruby = jruby ( allArgs ) ; if ( failOnError ) { jruby . execute ( ) ; 
public void shouldHandleNullJvmArg ( ) throws MojoExecutionException { setUpMojo ( ) ; mojo . jvmArgs = Arrays . asList ( new String [ ] { " arg1 " , null } ) ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; Assert . assertNotNull ( mojo . jruby ( new ArrayList < String > ( ) ) ) ; } 
public void shouldHandleEmptyJvmArg ( ) throws MojoExecutionException { setUpMojo ( ) ; mojo . jvmArgs = Arrays . asList ( new String [ ] { " arg1 " , " " } ) ; List < String > referenceList = new ArrayList < String > ( ) ; referenceList . add ( " arg1 " ) ; Assert . assertNotNull ( mojo . jruby ( new ArrayList < String > ( ) ) ) ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( features ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
public void execute ( ) throws BuildException { createArg ( ) . setValue ( " -S " ) ; createArg ( ) . setValue ( " gem " ) ; super . setArgs ( args ) ; super . execute ( ) ; } 
public void execute ( ) throws BuildException { setClassname ( " org.jruby.Main " ) ; setGemPath ( ) ; setHome ( ) ; super . execute ( ) ; } 
private File gemRoot ( ) { return new File ( getProject ( ) . getProperty ( " jruby.gem.root " ) ) ; } 
private File gemHome ( ) { return new File ( gemRoot ( ) , " .gem " ) ; } 
private File binDir ( ) { return new File ( gemHome ( ) , " bin " ) ; } 
public List < StepArgument > arguments_from ( String stepName ) throws UnsupportedEncodingException { return JdkPatternArgumentMatcher . argumentsFrom ( regexp , stepName ) ; } 
public static List < StepArgument > argumentsFrom ( Pattern regexp , String stepName ) throws UnsupportedEncodingException { Matcher matcher = regexp . matcher ( stepName ) ; if ( matcher . matches ( ) ) { List < StepArgument > arguments = new ArrayList < StepArgument > ( ) ; 
void load_code_file ( String file ) throws Throwable ; RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; } 
RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; } 
public void shouldDealWithOnlyAscii ( ) throws UnsupportedEncodingException { assertVariables ( " Ja (.+) elsker (.+) landet " , " Ja vi elsker dette landet " , " vi " , 3 , " dette " , 13 ) ; } 
private void assertVariables ( String regex , String string , String v1 , int pos1 , String v2 , int pos2 ) throws UnsupportedEncodingException { List < StepArgument > args = JdkPatternArgumentMatcher . argumentsFrom ( Pattern . compile ( regex ) , string ) ; assertEquals ( 2 , args . size ( ) ) ; assertEquals ( v1 , args . get ( 0 ) . getVal ( ) ) ; assertEquals ( pos1 , args . get ( 0 ) . getByteOffset ( ) ) ; assertEquals ( v2 , args . get ( 1 ) . getVal ( ) ) ; assertEquals ( pos2 , args . get ( 1 ) . getByteOffset ( ) ) ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } List < String > allArgs = new ArrayList < String > ( ) ; if ( cucumberBin ! = null ) { allArgs . add ( " -I " ) ; allArgs . add ( new File ( cucumberBin . getParentFile ( ) . getParentFile ( ) , " lib " ) . getAbsolutePath ( ) ) ; } allArgs . add ( " -r " ) ; allArgs . add ( " cuke4duke " ) ; allArgs . add ( cucumberBin ( ) . getAbsolutePath ( ) ) ; allArgs . addAll ( addCucumberArgs ( ) ) ; allArgs . add ( features ) ; Java jruby = jruby ( allArgs ) ; try { jruby . execute ( ) ; 
public static String join ( Object [ ] objects , String separator ) { StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; for ( Object o : objects ) { if ( i ! = 0 ) sb . append ( separator ) ; sb . append ( o ) ; i + + ; } return sb . toString ( ) ; } 
public String file_colon_line ( ) { return methodFormat . format ( method ) ; } 
public String format ( Method method ) { String signature = method . toGenericString ( ) ; Matcher matcher = METHOD_PATTERN . matcher ( signature ) ; if ( matcher . find ( ) ) { String M = matcher . group ( 1 ) ; 
public void methodWithoutArgs ( ) { } public List methodWithArgsAndException ( String foo , Map bar ) throws IllegalArgumentException , IOException { return null ; } @Before public void lookupMethod ( ) throws NoSuchMethodException { this . methodWithoutArgs = this . getClass ( ) . getMethod ( " methodWithoutArgs " ) ; this . methodWithArgsAndException = this . getClass ( ) . getMethod ( " methodWithArgsAndException " , String . class , Map . class ) ; } @Test public void shouldUseSimpleFormatWhenMethodHasException ( ) { assertEquals ( " MethodFormatTest.methodWithArgsAndException(String,Map) " , new MethodFormat ( " %c.%m(%a) " ) . format ( methodWithArgsAndException ) ) ; } @Test public void shouldUseSimpleFormatWhenMethodHasNoException ( ) { assertEquals ( " MethodFormatTest.methodWithoutArgs() " , new MethodFormat ( " %c.%m(%a) " ) . format ( methodWithoutArgs ) ) ; } } 
public List methodWithArgsAndException ( String foo , Map bar ) throws IllegalArgumentException , IOException { return null ; } 
public void lookupMethod ( ) throws NoSuchMethodException { this . methodWithoutArgs = this . getClass ( ) . getMethod ( " methodWithoutArgs " ) ; this . methodWithArgsAndException = this . getClass ( ) . getMethod ( " methodWithArgsAndException " , String . class , Map . class ) ; } 
public void shouldUseSimpleFormatWhenMethodHasException ( ) { assertEquals ( " MethodFormatTest.methodWithArgsAndException(String,Map) " , new MethodFormat ( " %c.%m(%a) " ) . format ( methodWithArgsAndException ) ) ; } 
public void shouldUseSimpleFormatWhenMethodHasNoException ( ) { assertEquals ( " MethodFormatTest.methodWithoutArgs() " , new MethodFormat ( " %c.%m(%a) " ) . format ( methodWithoutArgs ) ) ; } 
public void setUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . begin_scenario ( null ) ; Map < Class < ? > , Transformable > transforms = classLanguage . getTransforms ( ) ; converter = new ArgumentsConverter ( transforms ) ; } 
public void setUp ( ) throws Throwable { System . setProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; ClassLanguage classLanguage = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( StepMother . class ) , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . load_code_file ( " cuke4duke/internal/jvmclass/MyTransforms.class " ) ; classLanguage . begin_scenario ( null ) ; Map < Class < ? > , Transformable > transforms = classLanguage . getTransforms ( ) ; converter = new ArgumentsConverter ( transforms ) ; } 
public void shouldAddTransformHooksToTransformsMap ( ) throws Throwable { AbstractProgrammingLanguage programmingLanguage = new TestProgrammingLanguage ( null ) ; programmingLanguage . begin_scenario ( null ) ; programmingLanguage . addTransform ( Integer . TYPE , transform ) ; assertEquals ( transform , programmingLanguage . getTransforms ( ) . get ( Integer . TYPE ) ) ; } 
public void end_scenario ( ) throws Throwable { } @Override public void load_code_file ( String file ) throws Throwable { } @Override protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } } } 
public void load_code_file ( String file ) throws Throwable { } @Override protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } } } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } 
protected void installGem ( String gemArgs ) throws MojoExecutionException { GemTask gem = new GemTask ( ) ; gem . setProject ( getProject ( ) ) ; gem . setArgs ( gemArgs ) ; gem . execute ( ) ; } 
protected File jrubyHome ( ) { return new File ( localRepository . getBasedir ( ) , " .jruby " ) ; } 
protected Project getProject ( ) throws MojoExecutionException { Project project = new Project ( ) ; project . setBaseDir ( mavenProject . getBasedir ( ) ) ; project . setProperty ( " jruby.home " , jrubyHome ( ) . getAbsolutePath ( ) ) ; project . addBuildListener ( new LogAdapter ( ) ) ; Path jrubyClasspath = new Path ( project ) ; project . addReference ( " jruby.classpath " , jrubyClasspath ) ; try { append ( jrubyClasspath , compileClasspathElements ) ; 
protected void append ( Path classPath , List < ? > artifacts ) throws DependencyResolutionRequiredException { List < String > list = new ArrayList < String > ( artifacts . size ( ) ) ; for ( Object elem : artifacts ) { String path ; if ( elem instanceof Artifact ) { Artifact a = ( Artifact ) elem ; File file = a . getFile ( ) ; if ( file = = null ) { throw new DependencyResolutionRequiredException ( a ) ; } path = file . getPath ( ) ; } else { path = elem . toString ( ) ; } list . add ( path ) ; } Path p = new Path ( classPath . getProject ( ) ) ; p . setPath ( StringUtils . join ( list . iterator ( ) , File . pathSeparator ) ) ; classPath . append ( p ) ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } CucumberTask cucumber = cucumber ( allCucumberArgs ( ) ) ; try { cucumber . execute ( ) ; 
String allCucumberArgs ( ) { List < String > allCucumberArgs = new ArrayList < String > ( ) ; if ( cucumberArgs ! = null ) allCucumberArgs . addAll ( cucumberArgs ) ; if ( extraCucumberArgs ! = null ) allCucumberArgs . add ( extraCucumberArgs ) ; allCucumberArgs . add ( features ) ; return Utils . join ( allCucumberArgs . toArray ( ) , " " ) ; } 
public void shouldAddCucumberArgs ( ) { String cucumberArg = " testArg " ; mojo . cucumberArgs = new ArrayList < String > ( ) ; mojo . cucumberArgs . add ( cucumberArg ) ; assertTrue ( mojo . allCucumberArgs ( ) . contains ( cucumberArg ) ) ; } 
public void shouldAllowZeroAddCucumberArgs ( ) { mojo . extraCucumberArgs = null ; mojo . allCucumberArgs ( ) ; } 
public void shouldSplitAddCucumberArgsIntoRealCucumberArgs ( ) { mojo . extraCucumberArgs = " arg1 arg2 arg3 " ; assertEquals ( " arg1 arg2 arg3 features " , mojo . allCucumberArgs ( ) ) ; } 
public void shouldIgnoreNullJvmArg ( ) throws MojoExecutionException { mojo . jvmArgs = Arrays . asList ( " -Dfoo=bar " , null , " " ) ; assertEquals ( Arrays . asList ( " -Dfoo=bar " , " " ) , Arrays . asList ( mojo . cucumber ( " " ) . getCommandLine ( ) . getVmCommand ( ) . getArguments ( ) ) ) ; } 
public void execute ( ) throws BuildException { createArg ( ) . setValue ( " -r " ) ; createArg ( ) . setValue ( " cuke4duke " ) ; setCucumberBin ( ) ; getCommandLine ( ) . createArgument ( ) . setLine ( args ) ; super . execute ( ) ; } 
public void execute ( ) throws BuildException { createArg ( ) . setValue ( " -S " ) ; createArg ( ) . setValue ( " gem " ) ; getCommandLine ( ) . createArgument ( ) . setLine ( args ) ; createArg ( ) . setValue ( " --install-dir " ) ; createArg ( ) . setFile ( getJrubyHome ( ) ) ; createArg ( ) . setValue ( " --no-ri " ) ; createArg ( ) . setValue ( " --no-rdoc " ) ; super . execute ( ) ; } 
public void execute ( ) throws BuildException { setClassname ( " org.jruby.Main " ) ; setClasspath ( getJrubyClasspath ( ) ) ; ensureJrubyHomeExists ( ) ; setJRubyHome ( ) ; super . execute ( ) ; } 
private void ensureJrubyHomeExists ( ) { getJrubyHome ( ) . mkdirs ( ) ; } 
private Class < ? > loadClass ( String classFile ) throws ClassNotFoundException { String withoutExt = classFile . substring ( 0 , classFile . length ( ) - " .class " . length ( ) ) ; String [ ] pathElements = withoutExt . split ( " \\ / " ) ; String className = null ; for ( int i = pathElements . length - 1 ; i > = 0 ; i - - ) { if ( className = = null ) { className = pathElements [ i ] ; } else { className = pathElements [ i ] + " . " + className ; } try { return JRuby . getRuntime ( ) . getJRubyClassLoader ( ) . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( " Couldn't determine class from file: " + classFile ) ; } 
private static ObjectFactory createObjectFactory ( ) throws Throwable { String objectFactoryClassName = System . getProperty ( " cuke4duke.objectFactory " , " cuke4duke.internal.jvmclass.PicoFactory " ) ; Class < ? > ofc = JRuby . getRuntime ( ) . getJRubyClassLoader ( ) . loadClass ( objectFactoryClassName ) ; Constructor < ? > ctor = ofc . getConstructor ( ) ; try { return ( ObjectFactory ) ctor . newInstance ( ) ; 
public void execute ( ) throws BuildException { createArg ( ) . setFile ( getCuke4dukeBinFile ( ) ) ; getCommandLine ( ) . createArgument ( ) . setLine ( args ) ; super . execute ( ) ; } 
protected void installGem ( String gemArgs ) throws MojoExecutionException { GemTask gem = new GemTask ( ) ; if ( gemDirectory ! = null & & gemDirectory . exists ( ) ) { gem . setDir ( gemDirectory ) ; } gem . setProject ( getProject ( ) ) ; gem . setArgs ( gemArgs ) ; gem . execute ( ) ; } 
public final String [ ] tag_expressions ( ) { return tagExpressions ; } 
public String [ ] tag_expressions ( ) ; void invoke ( String location , IRubyObject scenario ) throws Throwable ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } } 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } } 
protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } 
public Object invokeWithArgs ( Object [ ] javaArgs ) throws Throwable { Method functionInvoke = lookupInvokeMethod ( javaArgs ) ; try { return functionInvoke . invoke ( closure , javaArgs ) ; 
private Method lookupInvokeMethod ( Object [ ] args ) throws NoSuchMethodException { return AFunction . class . getMethod ( " invoke " , Utils . objectClassArray ( args . length ) ) ; } 
public void invoke ( String location , IRubyObject scenario ) throws Throwable { groovyLanguage . invokeClosure ( body , new Object [ ] { scenario } ) ; } 
Object invokeClosure ( Closure body , Object [ ] args ) throws Throwable { body . setDelegate ( currentWorld ) ; Class [ ] classes = body . getParameterTypes ( ) ; Object [ ] transformedArgs = transform ( args , classes ) ; return body . call ( transformedArgs ) ; } 
public void begin_scenario ( IRubyObject scenario ) throws IOException { clearHooksAndStepDefinitions ( ) ; worldFactory = null ; GroovyShell shell = new GroovyShell ( new Binding ( ) ) ; for ( String groovyFile : groovyFiles ) { shell . evaluate ( new File ( groovyFile ) ) ; } currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; } 
public void end_scenario ( ) { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; } public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } } 
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return groovyLanguage . invokeClosure ( body , args ) ; } 
public static Object throwCucumberIokeException ( String message ) { throw JRuby . error ( " IokeException " , message ) ; } 
private void registerTransformMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( Transform . class ) ) { classLanguage . addTransform ( method . getReturnType ( ) , new JavaTransform ( classLanguage , method ) ) ; 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( Before . class ) ) { classLanguage . addBeforeHook ( new JavaHook ( classLanguage , method , method . getAnnotation ( Before . class ) . value ( ) ) ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( After . class ) ) { classLanguage . addAfterHook ( new JavaHook ( classLanguage , method , method . getAnnotation ( After . class ) . value ( ) ) ) ; 
private void registerStepDefinitionMaybe ( Method method , ClassLanguage classLanguage ) throws Throwable { String regexpString = null ; if ( method . isAnnotationPresent ( Given . class ) ) { regexpString = method . getAnnotation ( Given . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( When . class ) ) { regexpString = method . getAnnotation ( When . class ) . value ( ) ; } else if ( method . isAnnotationPresent ( Then . class ) ) { regexpString = method . getAnnotation ( Then . class ) . value ( ) ; } if ( regexpString ! = null ) { Pattern regexp = Pattern . compile ( regexpString ) ; 
public void invoke ( String location , IRubyObject scenario ) throws Throwable { classLanguage . invokeHook ( method , scenario ) ; } 
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return classLanguage . invoke ( method , args ) ; } 
public < T > T transform ( Object arg ) throws Throwable { return ( T ) classLanguage . invoke ( method , new Object [ ] { arg } ) ; } 
public Object invoke ( Method method , Object target , Object [ ] javaArgs ) throws Throwable { try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return closure . call ( cx , scope , scope , args ) ; } 
public void addTransform ( Class < ? > returnType , Transformable javaTransform ) { transformers . put ( returnType , javaTransform ) ; } 
protected Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable { Transformable transformer = transformers . get ( parameterType ) ; return transformer = = null ? null : transformer . transform ( arg ) ; } 
public void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . populateStepDefinitionsAndHooks ( objectFactory , this ) ; 
public Object invoke ( Method method , Object [ ] args ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; Object [ ] transformedArgs = transform ( args , method . getParameterTypes ( ) ) ; return methodInvoker . invoke ( method , target , transformedArgs ) ; } 
public static Object transformStringToObject ( String argument ) { return argument ; } 
public static int transformStringToInt ( String argument ) { return Integer . valueOf ( argument ) ; } 
public static Integer transformStringToInteger ( String argument ) { return Integer . valueOf ( argument ) ; } 
public static long transformStringToLongPrimitive ( String argument ) { return Long . valueOf ( argument ) ; } 
public static Long transformStringToLong ( String argument ) { return Long . valueOf ( argument ) ; } 
public static double transformStringToDoublePrimitive ( String argument ) { return Double . valueOf ( argument ) ; } 
public static Double transformStringToDouble ( String argument ) { return Double . valueOf ( argument ) ; } 
public static float transformStringToFloatPrimitive ( String argument ) { return Float . valueOf ( argument ) ; } 
public static Float transformStringToFloat ( String argument ) { return Float . valueOf ( argument ) ; } 
public static short transformStringToShortPrimitive ( String argument ) { return Short . valueOf ( argument ) ; } 
public static Short transformStringToShort ( String argument ) { return Short . valueOf ( argument ) ; } 
public static byte transformStringToBytePrimitive ( String argument ) { return Byte . valueOf ( argument ) ; } 
public static Byte transformStringToByte ( String argument ) { return Byte . valueOf ( argument ) ; } 
public static char transformStringToChar ( String argument ) { return Character . valueOf ( argument . charAt ( 0 ) ) ; } 
public static Character transformStringToCharacters ( String argument ) { return Character . valueOf ( argument . charAt ( 0 ) ) ; } 
public static BigDecimal transformStringToBigDecimal ( String argument ) { return BigDecimal . valueOf ( Double . valueOf ( argument ) ) ; } 
public static BigInteger transformStringToBigInteger ( String argument ) { return BigInteger . valueOf ( Long . valueOf ( argument ) ) ; } 
public static boolean transformStringToBooleanPrimitive ( String argument ) { return Boolean . valueOf ( argument ) ; } 
public static Boolean transformStringToBoolean ( String argument ) { return Boolean . valueOf ( argument ) ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; List < Class < ? > > getClasses ( ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addStepMother ( StepMother mother ) ; Object getComponent ( Class < ? > type ) ; List < Class < ? > > getClasses ( ) ; } 
Object getComponent ( Class < ? > type ) ; List < Class < ? > > getClasses ( ) ; } 
protected void clearHooksAndStepDefinitions ( ) { languageMixin . clear_hooks ( ) ; stepDefinitions = new ArrayList < StepDefinition > ( ) ; } 
public void invoked ( String regexp_source , String file_colon_line ) { languageMixin . invoked_step_definition ( regexp_source , file_colon_line ) ; } 
protected Object [ ] transform ( Object [ ] args , Class < ? > [ ] parameterTypes ) throws Throwable { Object [ ] transformed = new Object [ args . length ] ; for ( int i = 0 ; i < transformed . length ; i + + ) { transformed [ i ] = transformOne ( args [ i ] , parameterTypes [ i ] ) ; } return transformed ; } 
private Object defaultTransform ( Object arg , Class < ? > parameterType ) throws Throwable { Method transformMethod = transformMethods . get ( parameterType ) ; if ( transformMethod = = null ) { throw new CantTransform ( arg , parameterType ) ; } return methodInvoker . invoke ( transformMethod , null , new Object [ ] { arg } ) ; } 
protected abstract Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable ; } 
public final void invoke ( RubyArray rubyArgs ) throws Throwable { programmingLanguage . invoked ( regexp_source ( ) , file_colon_line ( ) ) ; invokeWithArgs ( rubyArgs . toArray ( ) ) ; } 
public abstract Object invokeWithArgs ( Object [ ] args ) throws Throwable ; } 
void add_hook ( String phase , Hook hook ) ; void clear_hooks ( ) ; IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void clear_hooks ( ) ; IRubyObject create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
String regexp_source ( ) throws Throwable ; String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray rubyArgs ) throws Throwable ; } 
String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray rubyArgs ) throws Throwable ; } 
List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( RubyArray rubyArgs ) throws Throwable ; } 
public < T > T transform ( Object argument ) throws Throwable ; } 
public Class whereIsDino ( ) { return getClass ( ) ; } 
public void shouldAllowOneInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , stepMother , Arrays . < ClassAnalyzer > asList ( javaAnalyzer ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
public void shouldFailWithTwoInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , stepMother , Arrays . < ClassAnalyzer > asList ( javaAnalyzer ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . addClass ( Wilma . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
public void shouldRaiseCucumberPendingWhenAnnotatedWithPending ( ) throws Throwable { Method dontExecuteMe = SomethingWithPending . class . getDeclaredMethod ( " dontExecuteMe " ) ; MethodInvoker mi = new MethodInvoker ( ) ; mi . invoke ( dontExecuteMe , new SomethingWithPending ( ) , new Object [ 0 ] ) ; } 
public void setup ( ) { p = new AbstractProgrammingLanguage ( null ) { @Override 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable { return null ; } } ; } @Test public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class ) ) ; } @Test public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " An Object " , Integer . TYPE ) ) ; } @Test public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( new Integer ( 4 ) , p . transformOne ( " An Object " , Integer . class ) ) ; } @Test public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " An Object " , Long . TYPE ) ) ; } @Test public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( new Long ( 3L ) , p . transformOne ( " An Object " , Long . class ) ) ; } } 
protected Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable { return null ; } 
public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class ) ) ; } 
public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " An Object " , Integer . TYPE ) ) ; } 
public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( new Integer ( 4 ) , p . transformOne ( " An Object " , Integer . class ) ) ; } 
public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " An Object " , Long . TYPE ) ) ; } 
public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( new Long ( 3L ) , p . transformOne ( " An Object " , Long . class ) ) ; } 
public boolean matches ( Object o ) { JavaHook hook = ( JavaHook ) o ; actualMethodName = hook.getMethod().getName(); return methodName.equals(actualMethodName); } 
public void shouldAddTransformHooksToTransformsMap ( ) throws Throwable { AbstractProgrammingLanguage programmingLanguage = new TestProgrammingLanguage ( null ) ; programmingLanguage . begin_scenario ( null ) ; programmingLanguage.addTransform(Integer.TYPE, transform); 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } @Override public void load_code_file ( String file ) throws Throwable { } @Override protected void begin_scenario ( IRubyObject scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; } } } 
protected Object customTransform ( Object arg , Class < ? > parameterType ) { return null ; } 
public boolean overrideBooleanPrimitiveTransform ( String boolValue ) { return boolValue . equals ( " yes " ) ; } 
tvoid AddBook ( Book book , int quantity ) ; public List < LineItem > getLineItems ( ) ; tdouble getTotalPrice ( ) ; tvoid checkout ( ) throws Exception ; } 
public List < LineItem > getLineItems ( ) ; tdouble getTotalPrice ( ) ; tvoid checkout ( ) throws Exception ; } 
tdouble getTotalPrice ( ) ; tvoid checkout ( ) throws Exception ; } 
public void AddBook ( Book book , int quantity ) { tLineItem lineItem = new LineItem ( ) ; tlineItem . setBook ( book ) ; tlineItem . setQuantity ( quantity ) ; tlineItems . add ( lineItem ) ; } 
public void checkout ( ) throws Exception { torderManager . createOrder ( lineItems , null , null ) ; } 
public List < Book > searchBooks ( BookQuery bookQuery ) ; public void setMessage ( String message ) ; public String getMessage ( ) ; } 
public void setMessage ( String message ) ; public String getMessage ( ) ; } 
public void createOrder ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) throws Exception ; } 
public void createOrder ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) throws Exception { tdouble price = priceCalculator . getTotalPrice ( lineItems , address , paymentInfo ) ; tOrder order = new Order ( ) ; tfor ( LineItem lineItem : lineItems ) { torder . getLineItems ( ) . add ( lineItem ) ; } torder . setPrice ( price ) ; torderDao . addOrder ( order ) ; tsendOrder ( order . getId ( ) ) ; } 
public void sendOrder ( long orderId ) throws JMSException { tConnection connection = null ; tSession session = null ; ttry { tconnection = connectionFactory . createConnection ( ) ; 
public void onMessage ( Message message ) { ttry { tString id = ( ( TextMessage ) message ) . getText ( ) ; 
public void closeOrder ( Timer timer ) throws EJBException { tString msg = ( String ) timer . getInfo ( ) ; tOrder order = entityManager . find ( Order . class , Long . parseLong ( msg ) ) ; torder . setStatus ( Order . Status . Closed ) ; } 
public double getTotalPrice ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) ; } 
void addBook ( Book book ) throws Exception ; void deleteBook ( Book book ) throws Exception ; List < Book > getBooks ( ) ; } 
void deleteBook ( Book book ) throws Exception ; List < Book > getBooks ( ) ; } 
public void addBook ( Book book ) throws Exception { entityManager . persist ( book ) ; } 
public void deleteBook ( Book book ) throws Exception { entityManager . remove ( book ) ; } 
public abstract void addOrder ( Order order ) throws Exception ; public abstract void deleteOrder ( Order order ) throws Exception ; public abstract List < Order > getOrders ( ) ; } 
public abstract void deleteOrder ( Order order ) throws Exception ; public abstract List < Order > getOrders ( ) ; } 
public void addOrder ( Order order ) throws Exception { entityManager . persist ( order ) ; } 
public void deleteOrder ( Order order ) throws Exception { entityManager . remove ( order ) ; } 
public void cartContainsBook ( int count , double price ) throws Exception { tfor ( int i = 0 ; i < count ; i + + ) { tBook book = new Book ( ) ; 
public void checkoutCart ( ) throws Exception { tcartManager . checkout ( ) ; } 
public void checkOrderCreationAndPrice ( double price ) { tList < Order > orders = orderDao . getOrders ( ) ; tassertEquals ( 1 , orders . size ( ) ) ; tOrder order = orders . get ( 0 ) ; tassertEquals ( price , order . getPrice ( ) , 0 ) ; } 
public void theOrderStateShouldBe ( String state ) { tOrder . Status status = Order . Status . valueOf ( state ) ; tList < Order > orders = orderDao . getOrders ( ) ; tassertEquals ( 1 , orders . size ( ) ) ; tOrder order = orders . get ( 0 ) ; tassertEquals ( status , order . getStatus ( ) ) ; } 
public void shutdown ( ) throws Exception { tcontext . close ( ) ; } 
public void createNewOrder ( ) throws Exception { tList < LineItem > lineItems = new ArrayList < LineItem > ( ) ; torderManager . createOrder ( lineItems , null , null ) ; } 
public void wait ( int seconds ) throws Exception { tThread . sleep ( seconds * 1000 ) ; } 
public void init ( ) { tbookQuery = new BookQuery ( ) ; } 
public void shutdown ( ) throws NamingException { context . close ( ) ; } 
public void theFollowingBooksWithTable ( cuke4duke . Table table ) throws Exception { for ( List < String > row : table . rows ( ) ) { tbookDao . addBook ( new Book ( row . get ( 0 ) , row . get ( 1 ) , Integer . parseInt ( ( row . get ( 2 ) ) ) , row . get ( 3 ) ) ) ; 
public void searchForAuthor ( String author ) { tbookQuery . setAuthor ( author ) ; } 
public void searchForTitle ( String title ) { tbookQuery . setTitle ( title ) ; } 
public void searchForPublisher ( String publisher ) { tbookQuery . setPublisher ( publisher ) ; } 
public void checkSearchResultCount ( int count ) throws Exception { foundBooks = catalogManager . searchBooks ( bookQuery ) ; assertEquals ( " Result contains wrong count. " , count , foundBooks . size ( ) ) ; } 
public void iPutABookIntoMyShoppingCart ( double price ) { tBook book = new Book ( ) ; tbook . setPrice ( price ) ; tcartManager . AddBook ( book , 1 ) ; } 
public void myShoppingCartShouldContainLineItems ( int count ) { tassertEquals ( " Shopping cart contains wrong count. " , count , cartManager . getLineItems ( ) . size ( ) ) ; } 
public void theTotalPriceShouldBe ( double price ) { tassertEquals ( " Shopping cart contains wrong count. " , price , cartManager . getTotalPrice ( ) , 0 ) ; } 
public void shouldAllowOneInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
public void shouldFailWithTwoInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . addClass ( Wilma . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { } @Override public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable { return null ; } } ; } @Test public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class ) ) ; } @Test public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE ) ) ; } @Test public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class ) ) ; } @Test public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE ) ) ; } @Test public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class ) ) ; } } 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType ) throws Throwable { return null ; } } ; } @Test public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class ) ) ; } @Test public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE ) ) ; } @Test public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class ) ) ; } @Test public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE ) ) ; } @Test public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class ) ) ; } } 
public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE ) ) ; } 
public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class ) ) ; } 
public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE ) ) ; } 
public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class ) ) ; } 
void AddBook ( Book book , int quantity ) ; public List < LineItem > getLineItems ( ) ; double getTotalPrice ( ) ; void checkout ( ) throws Exception ; } 
public List < LineItem > getLineItems ( ) ; double getTotalPrice ( ) ; void checkout ( ) throws Exception ; } 
double getTotalPrice ( ) ; void checkout ( ) throws Exception ; } 
public void AddBook ( Book book , int quantity ) { LineItem lineItem = new LineItem ( ) ; lineItem . setBook ( book ) ; lineItem . setQuantity ( quantity ) ; lineItems . add ( lineItem ) ; } 
public void checkout ( ) throws Exception { orderManager . createOrder ( lineItems , null , null ) ; } 
public List < Book > searchBooks ( BookQuery bookQuery ) ; public void setMessage ( String message ) ; public String getMessage ( ) ; } 
public void setMessage ( String message ) ; public String getMessage ( ) ; } 
public void createOrder ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) throws Exception ; } 
public void createOrder ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) throws Exception { double price = priceCalculator . getTotalPrice ( lineItems , address , paymentInfo ) ; Order order = new Order ( ) ; for ( LineItem lineItem : lineItems ) { order . getLineItems ( ) . add ( lineItem ) ; } order . setPrice ( price ) ; orderDao . addOrder ( order ) ; sendOrder ( order . getId ( ) ) ; } 
public void sendOrder ( long orderId ) throws JMSException { Connection connection = null ; Session session = null ; try { connection = connectionFactory . createConnection ( ) ; 
public void onMessage ( Message message ) { try { String id = ( ( TextMessage ) message ) . getText ( ) ; 
public void closeOrder ( Timer timer ) throws EJBException { String msg = ( String ) timer . getInfo ( ) ; Order order = entityManager . find ( Order . class , Long . parseLong ( msg ) ) ; order . setStatus ( Order . Status . Closed ) ; } 
public double getTotalPrice ( List < LineItem > lineItems , Address address , PaymentInfo paymentInfo ) ; } 
void addBook ( Book book ) throws Exception ; void deleteBook ( Book book ) throws Exception ; List < Book > getBooks ( ) ; } 
void deleteBook ( Book book ) throws Exception ; List < Book > getBooks ( ) ; } 
public abstract void addOrder ( Order order ) throws Exception ; public abstract void deleteOrder ( Order order ) throws Exception ; public abstract List < Order > getOrders ( ) ; } 
public abstract void deleteOrder ( Order order ) throws Exception ; public abstract List < Order > getOrders ( ) ; } 
public void cartContainsBook ( int count , double price ) throws Exception { for ( int i = 0 ; i < count ; i + + ) { Book book = new Book ( ) ; 
public void checkoutCart ( ) throws Exception { cartManager . checkout ( ) ; } 
public void checkOrderCreationAndPrice ( double price ) { List < Order > orders = orderDao . getOrders ( ) ; assertEquals ( 1 , orders . size ( ) ) ; Order order = orders . get ( 0 ) ; assertEquals ( price , order . getPrice ( ) , 0 ) ; } 
public void theOrderStateShouldBe ( String state ) { Order . Status status = Order . Status . valueOf ( state ) ; List < Order > orders = orderDao . getOrders ( ) ; assertEquals ( 1 , orders . size ( ) ) ; Order order = orders . get ( 0 ) ; assertEquals ( status , order . getStatus ( ) ) ; } 
public void shutdown ( ) throws Exception { context . close ( ) ; } 
public void createNewOrder ( ) throws Exception { List < LineItem > lineItems = new ArrayList < LineItem > ( ) ; orderManager . createOrder ( lineItems , null , null ) ; } 
public void wait ( int seconds ) throws Exception { Thread . sleep ( seconds * 1000 ) ; } 
public void init ( ) { bookQuery = new BookQuery ( ) ; } 
public void theFollowingBooksWithTable ( cuke4duke . Table table ) throws Exception { for ( List < String > row : table . rows ( ) ) { bookDao . addBook ( new Book ( row . get ( 0 ) , row . get ( 1 ) , Integer . parseInt ( ( row . get ( 2 ) ) ) , row . get ( 3 ) ) ) ; 
public void searchForAuthor ( String author ) { bookQuery . setAuthor ( author ) ; } 
public void searchForTitle ( String title ) { bookQuery . setTitle ( title ) ; } 
public void searchForPublisher ( String publisher ) { bookQuery . setPublisher ( publisher ) ; } 
public void checkSearchResultCount ( int count ) throws Exception { foundBooks = catalogManager . searchBooks ( bookQuery ) ; assertEquals ( " Result contains wrong count. " , count , foundBooks . size ( ) ) ; } 
public void iPutABookIntoMyShoppingCart ( double price ) { Book book = new Book ( ) ; book . setPrice ( price ) ; cartManager . AddBook ( book , 1 ) ; } 
public void myShoppingCartShouldContainLineItems ( int count ) { assertEquals ( " Shopping cart contains wrong count. " , count , cartManager . getLineItems ( ) . size ( ) ) ; } 
public void theTotalPriceShouldBe ( double price ) { assertEquals ( " Shopping cart contains wrong count. " , price , cartManager . getTotalPrice ( ) , 0 ) ; } 
public void letsDebug ( ) throws InvocationTargetException , InstantiationException , IllegalAccessException { WebDriverFacade wdf = new WebDriverFacade ( ) ; ResultsPage rp = new ResultsPage ( wdf ) ; SearchPage sp = new SearchPage ( wdf ) ; sp . visit ( ) ; sp . search ( " cucumber github " ) ; rp . shouldSee ( " <em>Cucumber</em> itself is written in Ruby " ) ; } 
public void shouldSee ( String results ) { assertThat ( d . getPageSource ( ) , containsString ( results ) ) ; } 
public WebDriver getWebDriver ( ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( browser = = null ) { browser = driverConstructor . newInstance ( ) ; } return browser ; } 
public void closeBrowser ( ) throws IllegalAccessException , InvocationTargetException , InstantiationException { if ( browser = = null ) { browser . close ( ) ; 
public List < Map < String , String > > hashes ( ) ; public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public void convertColumn ( String column , TableConverter converter ) ; public void convertHeaders ( TableConverter converter ) ; } 
public List < Map < String , String > > hashes ( ) ; public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void thisIsNotAStep ( ) { } private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } @Given ( " a table that we convert: " ) public void converTable ( Table ) { . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , . hashes ( ) ) ; } } 
public void converTable ( Table ) { . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , . hashes ( ) ) ; } 
public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } 
void invoke ( String step ) ; void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
String ask ( String question , int timeoutSecs ) ; void embed ( String file , String mimeType ) ; } 
void announce ( String message ) ; void embed ( String file , String mimeType ) ; } 
protected String ask ( String question , int timeoutSecs ) { return stepMother . ask ( question , timeoutSecs ) ; } 
protected void announce ( String message ) { stepMother . announce ( message ) ; } 
protected void embed ( String file , String mimeType ) { stepMother . embed ( file , mimeType ) ; } 
public static char transformStringToChar ( String argument ) { return argument . charAt ( 0 ) ; } 
public static Character transformStringToCharacters ( String argument ) { return argument . charAt ( 0 ) ; } 
public void askForInput ( ) { try { String answer = ask ( " Here is a question for you. Wait 5 secs to make it pass. Type a string and hit enter to fail. " , 5 ) ; 
public void thisIsNotAStep ( ) { } private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } @Given ( " a table that we convert: " ) public void convertTable ( Table ) { . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , . hashes ( ) ) ; } } 
public void convertTable ( Table ) { . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , . hashes ( ) ) ; } 
public void passACar ( Car value ) { } @Given ( " ^I pass '(.*)' to a method with User as parameter$ " ) public void transformToA ( User user ) { this . user = user ; } @Given ( " ^I pass '(.*)' to a method with boolean as parameter$ " ) public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; } @When ( " ^something happens$ " ) public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } 
protected Project getProject ( ) throws MojoExecutionException { Project project = new Project ( ) ; project . setBaseDir ( mavenProject . getBasedir ( ) ) ; project . setProperty ( " jruby.home " , jrubyHome ( ) . getAbsolutePath ( ) ) ; project . addBuildListener ( new LogAdapter ( ) ) ; Path jrubyClasspath = new Path ( project ) ; project . addReference ( " jruby.classpath " , jrubyClasspath ) ; try { append ( jrubyClasspath , testClasspathElements ) ; 
public void closeBrowser ( ) throws IllegalAccessException , InvocationTargetException , InstantiationException { if ( browser ! = null ) { browser . close ( ) ; 
public static Locale localeFor ( String isoString ) { String [ ] languageAndCountry = isoString . split ( " - " ) ; if ( languageAndCountry . length = = 1 ) { return new Locale ( isoString ) ; 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } 
public void invoke ( String location , IRubyObject scenario ) throws Throwable { groovyLanguage . invokeClosure ( body , new Object [ ] { scenario } , Locale . getDefault ( ) ) ; } 
Object invokeClosure ( Closure body , Object [ ] args , Locale locale ) throws Throwable { body . setDelegate ( currentWorld ) ; Class [ ] classes = body . getParameterTypes ( ) ; Object [ ] transformedArgs = transform ( args , classes , locale ) ; return body . call ( transformedArgs ) ; } 
public void end_scenario ( ) { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; } public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } } 
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return groovyLanguage . invokeClosure ( body , args , Locale . getDefault ( ) ) ; } 
public Object invokeWithArgs ( Object [ ] args ) throws Throwable { return classLanguage . invoke ( method , args , locale ) ; } 
public < T > T transform ( Object arg , Locale locale ) throws Throwable { return ( T ) classLanguage . invoke ( method , new Object [ ] { arg } , locale ) ; } 
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { Transformable transformer = transformers . get ( parameterType ) ; return transformer = = null ? null : transformer . transform ( arg , locale ) ; } 
public Object invoke ( Method method , Object [ ] args , Locale locale ) throws Throwable { Object target = objectFactory . getComponent ( method . getDeclaringClass ( ) ) ; Object [ ] transformedArgs = transform ( args , method . getParameterTypes ( ) , locale ) ; return methodInvoker . invoke ( method , target , transformedArgs ) ; } 
public static Object transformStringToObject ( String argument , Locale locale ) { return argument ; } 
public static int transformStringToInt ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . intValue ( ) ; } 
public static Integer transformStringToInteger ( String argument , Locale locale ) throws ParseException { return transformStringToInt ( argument , locale ) ; } 
public static long transformStringToLongPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . longValue ( ) ; } 
public static Long transformStringToLong ( String argument , Locale locale ) throws ParseException { return transformStringToLongPrimitive ( argument , locale ) ; } 
public static double transformStringToDoublePrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . doubleValue ( ) ; } 
public static Double transformStringToDouble ( String argument , Locale locale ) throws ParseException { return transformStringToDoublePrimitive ( argument , locale ) ; } 
public static float transformStringToFloatPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . floatValue ( ) ; } 
public static Float transformStringToFloat ( String argument , Locale locale ) throws ParseException { return transformStringToFloatPrimitive ( argument , locale ) ; } 
public static short transformStringToShortPrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . shortValue ( ) ; } 
public static Short transformStringToShort ( String argument , Locale locale ) throws ParseException { return transformStringToShortPrimitive ( argument , locale ) ; } 
public static byte transformStringToBytePrimitive ( String argument , Locale locale ) throws ParseException { return NumberFormat . getInstance ( locale ) . parse ( argument ) . byteValue ( ) ; } 
public static Byte transformStringToByte ( String argument , Locale locale ) throws ParseException { return transformStringToBytePrimitive ( argument , locale ) ; } 
public static char transformStringToChar ( String argument , Locale locale ) { return argument . charAt ( 0 ) ; } 
public static Character transformStringToCharacters ( String argument , Locale locale ) { return argument . charAt ( 0 ) ; } 
public static BigDecimal transformStringToBigDecimal ( String argument , Locale locale ) throws ParseException { return BigDecimal . valueOf ( transformStringToDoublePrimitive ( argument , locale ) ) ; } 
public static BigInteger transformStringToBigInteger ( String argument , Locale locale ) throws ParseException { return BigInteger . valueOf ( transformStringToLongPrimitive ( argument , locale ) ) ; } 
public static boolean transformStringToBooleanPrimitive ( String argument , Locale locale ) { return Boolean . valueOf ( argument ) ; } 
public static Boolean transformStringToBoolean ( String argument , Locale locale ) { return Boolean . valueOf ( argument ) ; } 
protected Object [ ] transform ( Object [ ] args , Class < ? > [ ] parameterTypes , Locale locale ) throws Throwable { Object [ ] transformed = new Object [ args . length ] ; for ( int i = 0 ; i < transformed . length ; i + + ) { transformed [ i ] = transformOne ( args [ i ] , parameterTypes [ i ] , locale ) ; } return transformed ; } 
private Object defaultTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { Method transformMethod = transformMethods . get ( parameterType ) ; if ( transformMethod = = null ) { throw new CantTransform ( arg , parameterType ) ; } return methodInvoker . invoke ( transformMethod , null , new Object [ ] { arg , locale } ) ; } 
protected abstract Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable ; } 
public < T > T transform ( Object argument , Locale locale ) throws Throwable ; } 
public void shouldCreateEnglishLocale ( ) { assertEquals ( Locale . ENGLISH , Utils . localeFor ( " en " ) ) ; } 
public void shouldCreateUSLocale ( ) { assertEquals ( Locale . US , Utils . localeFor ( " en-US " ) ) ; } 
public void shouldFormatLolcatDoubles ( ) throws ParseException { assertEquals ( 10.4 , NumberFormat . getInstance ( Utils . localeFor ( " en-LOL " ) ) . parse ( " 10.4 " ) . doubleValue ( ) , 0.0 ) ; } 
public void shouldFormatEnglishDoubles ( ) throws ParseException { assertEquals ( 10.4 , NumberFormat . getInstance ( Utils . localeFor ( " en-US " ) ) . parse ( " 10.4 " ) . doubleValue ( ) , 0.0 ) ; } 
public void shouldFormatNorwegianDoubles ( ) throws ParseException { assertEquals ( 10.4 , NumberFormat . getInstance ( Utils . localeFor ( " no " ) ) . parse ( " 10,4 " ) . doubleValue ( ) , 0.0 ) ; } 
public void shouldFormatNorwegianDoublesWithEnglishLocaleDifferently ( ) throws ParseException { assertEquals ( 104.0 , NumberFormat . getInstance ( Utils . localeFor ( " en-US " ) ) . parse ( " 10,4 " ) . doubleValue ( ) , 0.0 ) ; } 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { return null ; } } ; } @Test public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class , Locale . getDefault ( ) ) ) ; } @Test public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE , Locale . getDefault ( ) ) ) ; } @Test public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class , Locale . getDefault ( ) ) ) ; } @Test public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE , Locale . getDefault ( ) ) ) ; } @Test public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class , Locale . getDefault ( ) ) ) ; } } 
protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { return null ; } 
public void shouldConvertFromStringToObject ( ) throws Throwable { assertEquals ( " An Object " , p . transformOne ( " An Object " , Object . class , Locale . getDefault ( ) ) ) ; } 
public void shouldConvertFromStringToInt ( ) throws Throwable { assertEquals ( 3 , p . transformOne ( " 3 " , Integer . TYPE , Locale . getDefault ( ) ) ) ; } 
public void shouldConvertFromStringToInteger ( ) throws Throwable { assertEquals ( 4 , p . transformOne ( " 4 " , Integer . class , Locale . getDefault ( ) ) ) ; } 
public void shouldConvertFromStringToLongPrimitive ( ) throws Throwable { assertEquals ( 3L , p . transformOne ( " 3 " , Long . TYPE , Locale . getDefault ( ) ) ) ; } 
public void shouldConvertFromStringToLong ( ) throws Throwable { assertEquals ( 4L , p . transformOne ( " 4 " , Long . class , Locale . getDefault ( ) ) ) ; } 
public void numberShouldBeParserCorrectly ( Double d ) { assertEquals ( 10.4 , d , 0.0 ) ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
< T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
protected void begin_scenario ( IRubyObject scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
protected abstract Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable ; public Exception cucumberArityMismatchError ( String message ) { return exceptionFactory . cucumberArityMismatchError ( message ) ; } public Exception cucumberPending ( String message ) { return exceptionFactory . cucumberPending ( message ) ; } public Exception error ( String type , String message ) { return exceptionFactory . error ( type , message ) ; } } 
public Exception cucumberArityMismatchError ( String message ) { return exceptionFactory . cucumberArityMismatchError ( message ) ; } 
public Exception cucumberPending ( String message ) { return exceptionFactory . cucumberPending ( message ) ; } 
public Exception error ( String type , String message ) { return exceptionFactory . error ( type , message ) ; } 
void load_code_file ( String file ) throws Throwable ; RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
RubyArray step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
Exception error ( String errorClass , String message ) ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; } 
Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; } 
public Exception error ( String errorClass , String message ) { RubyModule cucumber = JRuby . getRuntime ( ) . getModule ( " Cucumber " ) ; RubyClass error = cucumber . getClass ( errorClass ) ; return new RaiseException ( JRuby . getRuntime ( ) , 
public Exception cucumberPending ( String message ) { return error ( " Pending " , message ) ; } 
public Exception cucumberArityMismatchError ( String message ) { return error ( " ArityMismatchError " , message ) ; } 
public void shouldAllowOneInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
public void shouldFailWithTwoInheritedSubclass ( ) throws Throwable { ClassLanguage classLanguage = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , stepMother , Arrays . < ClassAnalyzer > asList ( new JavaAnalyzer ( ) ) ) ; classLanguage . addClass ( FlintStone . class ) ; classLanguage . addClass ( Fred . class ) ; classLanguage . addClass ( Wilma . class ) ; classLanguage . begin_scenario ( null ) ; List < StepDefinition > stepDefinitions = classLanguage . getStepDefinitions ( ) ; assertEquals ( 1 , stepDefinitions . size ( ) ) ; assertEquals ( Fred . class , ( ( AbstractStepDefinition ) stepDefinitions . get ( 0 ) ) . invokeWithArgs ( new Object [ 0 ] ) ) ; } 
public void shouldRaiseCucumberPendingWhenAnnotatedWithPending ( ) throws Throwable { Method dontExecuteMe = SomethingWithPending . class . getDeclaredMethod ( " dontExecuteMe " ) ; MethodInvoker mi = new MethodInvoker ( new JRubyExceptionFactory ( ) ) ; mi . invoke ( dontExecuteMe , new SomethingWithPending ( ) , new Object [ 0 ] ) ; } 
public void setup ( ) { p = new AbstractProgrammingLanguage ( null , null ) { @Override 
public void createLanguage ( ) throws Throwable { language = new ClassLanguage ( mock ( ClassLanguageMixin . class ) , mock ( ExceptionFactory . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > emptyList ( ) ) ; } 
public void shouldRunBeforeHooksInOrderOfDependencies ( ) throws Throwable { ObjectFactory objectFactory = new PicoFactory ( ) ; ClassLanguageMixin languageMixin = mock ( ClassLanguageMixin . class ) ; language = new ClassLanguage ( languageMixin , mock ( ExceptionFactory . class ) , mock ( StepMother . class ) , Collections . < ClassAnalyzer > singletonList ( new JavaAnalyzer ( ) ) , objectFactory ) ; language . addClass ( A . class ) ; language . addClass ( B . class ) ; language . begin_scenario ( null ) ; InOrder order = inOrder ( languageMixin ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doA " ) ) ) ; order . verify ( languageMixin ) . add_hook ( eq ( " before " ) , argThat ( isHook ( " doB " ) ) ) ; } 
public void invoke ( String location , Scenario scenario ) throws Throwable { closure . call ( ) ; } 
protected void begin_scenario ( Scenario scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
public void invoke ( String location , Scenario scenario ) throws Throwable { groovyLanguage . invokeClosure ( body , new Object [ ] { scenario } , Locale . getDefault ( ) ) ; } 
public void begin_scenario ( Scenario scenario ) throws IOException { clearHooksAndStepDefinitions ( ) ; worldFactory = null ; GroovyShell shell = new GroovyShell ( new Binding ( ) ) ; for ( String groovyFile : groovyFiles ) { shell . evaluate ( new File ( groovyFile ) ) ; } currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; } 
protected void begin_scenario ( Scenario scenario ) throws Throwable { } public void end_scenario ( ) throws Throwable { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } } 
public void invoke ( String location , Scenario scenario ) throws Throwable { classLanguage . invokeHook ( method , scenario ) ; } 
protected void begin_scenario ( Scenario scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; cx = Context . enter ( ) ; scope = new Global ( cx ) ; This gives us access to global functions like load() scope.put("jsLanguage", scope, this); cx.evaluateReader(scope, new InputStreamReader(getClass().getResourceAsStream(JS_DSL)), JS_DSL, 1, null); for (String jsFile : jsFiles) { cx.evaluateReader(scope, new FileReader(jsFile), jsFile, 1, null); 
public void begin_scenario ( Scenario scenario ) throws Throwable { clearHooksAndStepDefinitions ( ) ; objectFactory . createObjects ( ) ; for ( ClassAnalyzer analyzer : analyzers ) { analyzer . populateStepDefinitionsAndHooks ( objectFactory , this ) ; 
public String [ ] tag_expressions ( ) ; void invoke ( String location , Scenario scenario ) throws Throwable ; } 
void invoke ( String location , Scenario scenario ) throws Throwable ; } 
final public List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable { return step_match_list ( step_name , formatted_step_name ) ; } 
public final List < StepMatch > step_match_list ( String step_name , String formatted_step_name ) throws Throwable { List < StepMatch > matches = new ArrayList < StepMatch > ( ) ; for ( StepDefinition stepDefinition : stepDefinitions ) { List < StepArgument > arguments = stepDefinition . arguments_from ( step_name ) ; if ( arguments ! = null ) { matches . add ( languageMixin . create_step_match ( stepDefinition , step_name , formatted_step_name , arguments ) ) ; } } return matches ; } 
void add_hook ( String phase , Hook hook ) ; void clear_hooks ( ) ; StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void clear_hooks ( ) ; StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void load_code_file ( String file ) throws Throwable ; List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
String file_colon_line ( ) ; String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; void invoke ( Object format ) ; } 
String format_args ( Object format ) ; void invoke ( Object format ) ; } 
public final void invoke ( List arguments ) throws Throwable { programmingLanguage . invoked ( regexp_source ( ) , file_colon_line ( ) ) ; invokeWithArgs ( arguments . toArray ( ) ) ; } 
String regexp_source ( ) throws Throwable ; String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
String file_colon_line ( ) ; String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
private static void addHook ( String phase , Object [ ] tagsAndBody ) { if ( tagsAndBody . length = = 0 ) return ; String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( phase , new GroovyHook ( Arrays . asList ( tagNames ) , body , groovyLanguage ) ) ; } 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( Before . class ) ) { classLanguage . addBeforeHook ( new JavaHook ( classLanguage , method , Arrays . asList ( method . getAnnotation ( Before . class ) . value ( ) ) ) ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( After . class ) ) { classLanguage . addAfterHook ( new JavaHook ( classLanguage , method , Arrays . asList ( method . getAnnotation ( After . class ) . value ( ) ) ) ) ; 
public List < String > getTagExpressions ( ) ; void invoke ( String location , Scenario scenario ) throws Throwable ; } 
private void registerBeforeMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( Before . class ) ) { String [ ] tagExpressions = method . getAnnotation ( Before . class ) . value ( ) ; 
private void registerAfterMaybe ( Method method , ClassLanguage classLanguage ) { if ( method . isAnnotationPresent ( After . class ) ) { String [ ] tagExpressions = method . getAnnotation ( After . class ) . value ( ) ; 
public void checkThatRubyBeforeSetsFlag ( ) { assertTrue ( flag ) ; } 
public void execute ( ) throws BuildException { createArg ( ) . setValue ( " -S " ) ; createArg ( ) . setValue ( " gem " ) ; getCommandLine ( ) . createArgument ( ) . setLine ( args ) ; createArg ( ) . setValue ( " --install-dir " ) ; createArg ( ) . setFile ( getJrubyHome ( ) ) ; createArg ( ) . setValue ( " --no-ri " ) ; createArg ( ) . setValue ( " --no-rdoc " ) ; try { super . execute ( ) ; 
private static void addHook ( String phase , Object [ ] tagsAndBody ) { if ( tagsAndBody . length = = 0 ) return ; String [ ] tagNames = new String [ tagsAndBody . length - 1 ] ; System . arraycopy ( tagsAndBody , 0 , tagNames , 0 , tagNames . length ) ; Closure body = ( Closure ) tagsAndBody [ tagsAndBody . length - 1 ] ; languageMixin . add_hook ( phase , new GroovyHook ( Arrays . asList ( tagNames ) , body , groovyLanguage ) ) ; } 
void invoke ( String step ) ; void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
void invoke ( String step , Table table ) ; void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
void invoke ( String step , String multilineString ) ; void embed ( String file , String mimeType ) ; } 
protected String ask ( String question , int timeoutSecs ) { return stepMother . ask ( question , timeoutSecs ) ; } 
protected void embed ( String file , String mimeType ) { stepMother . embed ( file , mimeType ) ; } 
public List < Map < String , String > > hashes ( ) ; public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public Map < String , String > rowsHash ( ) ; public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public List < List < String > > raw ( ) ; public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public List < List < String > > rows ( ) ; public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffLists ( List < List < String > > table ) ; public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffLists ( List < List < String > > table , Map < ? , ? > options ) ; public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffHashes ( List < Map < String , String > > table ) ; public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void diffHashes ( List < Map < String , String > > table , Map < ? , ? > options ) ; public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public void mapColumn ( String column , CellConverter converter ) ; public void mapHeaders ( Map < Object , String > mappings ) ; } 
public static Class < ? > [ ] objectClassArray ( int ) { Class < ? > [ ] arr = new Class < ? > [ ] ; for ( int i = 0 ; i < ; i + + ) { arr [ i ] = Object . class ; } return arr ; } 
public static Locale localeFor ( String isoString ) { String [ ] languageAndCountry = isoString . split ( " - " ) ; if ( languageAndCountry . length = = 1 ) { return new Locale ( isoString ) ; 
public void begin_scenario ( Scenario scenario ) throws IOException { clearHooksAndStepDefinitions ( ) ; worldFactory = null ; GroovyShell shell = new GroovyShell ( new Binding ( ) ) ; for ( String groovyFile : groovyFiles ) { shell . evaluate ( new File ( groovyFile ) ) ; } currentWorld = worldFactory = = null ? new Object ( ) : worldFactory . call ( ) ; } 
public void end_scenario ( ) { } @Override protected Object customTransform ( Object arg , Class < ? > parameterType , Locale locale ) { return null ; } public void load_code_file ( String groovyFile ) throws ClassNotFoundException , IOException { groovyFiles . add ( groovyFile ) ; } public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } } 
public void registerWorldFactory ( Closure worldFactory ) { if ( this . worldFactory ! = null ) { throw new RuntimeException ( " You can only define one World closure " ) ; } this . worldFactory = worldFactory ; } 
public String regexp_source ( ) throws Throwable { if ( regexpSource = = null ) findRegexpSource ( ) ; return regexpSource ; } 
public List < StepArgument > arguments_from ( String stepName ) throws Throwable { IokeObject msg = ioke . newMessage ( " arguments_from " ) ; Message arguments_from = ( Message ) IokeObject . data ( msg ) ; Object args = arguments_from . sendTo ( msg , iokeStepDefObject , iokeStepDefObject , stepName ) ; if ( args instanceof List < ? > ) { return ( List < StepArgument > ) args ; 
private Object multilineArg ( Object [ ] args ) { Object multilineArg ; if ( args . length > 0 ) { if ( args [ args . length - 1 ] instanceof PyString ) { multilineArg = ioke . newText ( ( ( PyString ) args [ args . length - 1 ] ) . to_s ( ) ) ; } else if ( args [ args . length - 1 ] instanceof Table ) { multilineArg = args [ args . length - 1 ] ; } else { multilineArg = ioke . nil ; } } else { multilineArg = ioke . nil ; } return multilineArg ; } 
public String format ( Method method ) { String signature = method . toGenericString ( ) ; Matcher matcher = METHOD_PATTERN . matcher ( signature ) ; if ( matcher . find ( ) ) { String M = matcher . group ( 1 ) ; 
public Object invoke ( Method method , Object target , Object [ ] javaArgs ) throws Throwable { try { if ( method . isAnnotationPresent ( Pending . class ) ) { 
void populateStepDefinitionsAndHooks ( ObjectFactory objectFactory , ClassLanguage classLanguage ) throws Throwable ; Class < ? > [ ] alwaysLoad ( ) ; } 
void createObjects ( ) ; void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void disposeObjects ( ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
< T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
private Object defaultTransform ( Object arg , Class < ? > parameterType , Locale locale ) throws Throwable { Method transformMethod = transformMethods . get ( parameterType ) ; if ( transformMethod = = null ) { throw new CantTransform ( arg , parameterType ) ; } return methodInvoker . invoke ( transformMethod , null , new Object [ ] { arg , locale } ) ; } 
public List < String > getTagExpressions ( ) ; void invoke ( String location , Scenario scenario ) throws Throwable ; } 
public static List < StepArgument > argumentsFrom ( Pattern regexp , String stepName ) throws UnsupportedEncodingException { Matcher matcher = regexp . matcher ( stepName ) ; if ( matcher . matches ( ) ) { List < StepArgument > arguments = new ArrayList < StepArgument > ( ) ; 
void add_hook ( String phase , Hook hook ) ; void clear_hooks ( ) ; StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void clear_hooks ( ) ; StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
StepMatch create_step_match ( StepDefinition step_definition , String step_name , String formatted_step_name , List < StepArgument > step_arguments ) ; void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void available_step_definition ( String regexp_source , String file_colon_line ) ; void invoked_step_definition ( String regexp_source , String file_colon_line ) ; } 
void load_code_file ( String file ) throws Throwable ; List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
List < StepMatch > step_matches ( String step_name , String formatted_step_name ) throws Throwable ; Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
Exception cucumberPending ( String message ) ; Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
Exception cucumberArityMismatchError ( String message ) ; Exception error ( String type , String message ) ; } 
String regexp_source ( ) throws Throwable ; String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
String file_colon_line ( ) throws Throwable ; List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
List < StepArgument > arguments_from ( String stepName ) throws Throwable ; void invoke ( List < Object > arguments ) throws Throwable ; } 
String file_colon_line ( ) ; String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String backtrace_line ( ) ; int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
int text_length ( ) ; StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
StepDefinition step_definition ( ) ; String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String name ( ) ; String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String inspect ( ) ; String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String format_args ( Object format , Object proc ) ; String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
String format_args ( Object format ) ; String format_args ( ) ; void invoke ( Object format ) ; } 
public Status createTransaction ( Transaction transaction ) ; } 
public void iHaveATransaction ( ) { if ( transaction ! = null ) { throw new RuntimeException ( " Wait what? The instance is shared across scenarios? " ) ; } transaction = new Transaction ( " 12345678 " , new BigDecimal ( " 50.00 " ) ) ; } 
public void itIs ( String what ) { if ( what . equals ( " magic " ) ) { magic = true ; 
public WebDriver getWebDriver ( ) throws InvocationTargetException , IllegalAccessException , InstantiationException { if ( browser = = null ) { browser = driverConstructor . newInstance ( ) ; } return browser ; } 
public void closeBrowser ( ) throws IllegalAccessException , InvocationTargetException , InstantiationException { if ( browser ! = null ) { browser . close ( ) ; 
public void iAddATable ( Table table ) { List < List < String > > diffList = new ArrayList < List < String > > ( ) ; diffList . add ( Arrays . asList ( " a " , " b " ) ) ; diffList . add ( Arrays . asList ( " 1 " , " 2 " ) ) ; table . diffLists ( diffList ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; hashes . add ( hash ( " a " , " 1 " , " b " , " 2 " ) ) ; Map < String , Boolean > options = new HashMap < String , Boolean > ( ) ; options . put ( " surplus_row " , false ) ; table . diffHashes ( hashes , options ) ; } 
public void iAddAString ( String s ) { assertEquals ( " Hello nWorld " , s ) ; } 
public void iShouldHaveNCukes ( int , String color ) { int number = cukes . get ( color ) ! = null ? cukes . get ( color ) : 0 ; assertEquals ( , number ) ; } 
public void thisIsNotAStep ( ) { } private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } @Given ( " a table that we convert: " ) public void convertTable ( Table ) { . mapColumn ( " b " , new CellConverter ( ) { public String convertCell ( String cellValue ) { return " converted_ " + cellValue ; } } ) ; . mapHeaders ( new HashMap < Object , String > ( ) { { put ( " a " , " A " ) ; } } ) ; List < Map < String , String > > hashes = new ArrayList < Map < String , String > > ( ) ; hashes . add ( hash ( " A " , " eenie " , " b " , " converted_meenie " ) ) ; hashes . add ( hash ( " A " , " miney " , " b " , " converted_moe " ) ) ; assertEquals ( hashes , . hashes ( ) ) ; } } 
private Map < String , String > hash ( String . . . values ) { Map < String , String > hash = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < values . length ; i + = 2 ) { hash . put ( values [ i ] , values [ i + 1 ] ) ; } return hash ; } 
public void passACar ( Car value ) { } @Given ( " ^I pass '(.*)' to a method with User as parameter$ " ) public void transformToA ( User user ) { this . user = user ; } @Given ( " ^I pass '(.*)' to a method with boolean as parameter$ " ) public void iPassYesToAMethodWithBooleanAsParameter ( boolean yes ) { this . yes = yes ; } @When ( " ^something happens$ " ) public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public void somethingHappens ( ) { } @Then ( " ^all is good$ " ) public void allIsGood ( ) { assertFalse ( exceptionThrown ) ; } @Then ( " ^a User with age '(.*)' is created$ " ) public void aUserWithAgeIsCreated ( int age ) { assertTrue ( this . user . age = = age ) ; } @Then ( " ^an exception is thrown$ " ) public void exceptionIsThrown ( ) { assertTrue ( exceptionThrown ) ; } @Then ( " ^the parameter is true$ " ) public void theParameterIsTrue ( ) { assertTrue ( yes ) ; } public static class Car { } public static class User { public final int age ; public User ( int age ) { this . age = age ; } } } 
public String hello ( ) { return " Have a cuke, Duke! " ; } 
public void itIsMagic ( ) { this . magic = true ; } 
public void disposeObjects ( ) { instances . clear ( ) ; } 
public boolean canHandle ( Class < ? > clazz ) { return Modifier . isStatic ( clazz . getModifiers ( ) ) | | clazz . getEnclosingClass ( ) = = null ; 
void createObjects ( ) ; void disposeObjects ( ) ; boolean canHandle ( Class < ? > clazz ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
void disposeObjects ( ) ; boolean canHandle ( Class < ? > clazz ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
boolean canHandle ( Class < ? > clazz ) ; void addClass ( Class < ? > clazz ) ; void addStepMother ( StepMother mother ) ; < T > T getComponent ( Class < T > type ) ; List < Class < ? > > getClasses ( ) ; } 
public boolean canHandle ( Class < ? > clazz ) { return true ; } 
public void shouldNotAbortIfClassCannotBeInstantiated ( ) { guiceFactory . addClass ( SomeClass . class ) ; SomeClass instance = new SomeClass ( ) ; Class < ? extends SomeInnerClass > someInnerClass = instance . new SomeInnerClass ( ) . getClass ( ) ; if ( guiceFactory . canHandle ( someInnerClass ) ) { guiceFactory . addClass ( someInnerClass ) ; } guiceFactory . createObjects ( ) ; 
public final void invoke ( List < Object > arguments ) throws Throwable { programmingLanguage . invoked ( regexp_source ( ) , file_colon_line ( ) ) ; invokeWithArgs ( arguments . toArray ( ) ) ; } 
protected void installGem ( String gemArgs ) throws MojoExecutionException { GemTask gem = new GemTask ( ) ; if ( gemDirectory ! = null & & gemDirectory . exists ( ) ) { gem . setDir ( gemDirectory ) ; } gem . setProject ( getProject ( ) ) ; gem . setArgs ( gemArgs + getProxyArg ( ) ) ; gem . execute ( ) ; } 
public void execute ( ) throws MojoExecutionException { if ( installGems ) { for ( String gemSpec : gems ) { installGem ( gemSpec ) ; } } if ( skip ) { getLog ( ) . info ( " Cucumber Features are skipped " ) ; return ; } CucumberTask cucumber = cucumber ( allCucumberArgs ( ) ) ; try { cucumber . execute ( ) ; 
