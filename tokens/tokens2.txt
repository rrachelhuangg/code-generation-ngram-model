public synchronized Date time ( ) { if ( isPaused ) return time ; if ( currentTimeMillis ( ) ! = millis ) { set ( new Date ( currentTimeMillis ( ) ) ) ; } return time ; } 
public synchronized void recover ( Date newTime ) { if ( ! isPaused ) throw new RuntimeException ( " AlarmClock must be paused for advancing. " ) ; long newMillis = newTime . getTime ( ) ; if ( newMillis < = millis ) throw new RuntimeException ( " AlarmClock's time cannot move forwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) throw new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( newTime ) ; } 
public synchronized void pause ( ) { if ( isPaused ) throw new RuntimeException ( " AlarmClock was already paused. " ) ; time ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
public synchronized void resume ( ) { if ( ! isPaused ) throw new RuntimeException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
protected long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } 
private void set ( Date time ) { this . time = time ; this . millis = time . getTime ( ) ; } 
Serializable execute ( PrevalentSystem system ) throws Exception ; } 
public synchronized Serializable executeCommand ( Command command ) throws Exception { clock . pause ( ) ; To be deterministic, the system must know exactly at what time the command is being executed. try { Date thisTime = clock.time(); 
public synchronized void takeSnapshot ( ) throws IOException { clock . pause ( ) ; try { output . writeSnapshot ( system ) ; 
public PrevalentSystem system ( ) { return system ; } 
public Prevayler create ( PrevalentSystemFactory factory , String directory ) throws IOException , ClassNotFoundException { CommandInputStream input = new CommandInputStream ( directory ) ; PrevalentSystem system = ( PrevalentSystem ) input . readLastSnapshot ( ) ; if ( system = = null ) system = factory . create ( ) ; this . recoverCommands ( system , input ) ; system . clock ( ) . resume ( ) ; return new Prevayler ( system , input . commandOutputStream ( ) ) ; } 
private void recoverCommands ( PrevalentSystem system , CommandInputStream input ) throws IOException , ClassNotFoundException { Command command ; while ( true ) { try { 
public void write ( byte [ ] b ) throws IOException { tsuper . write ( b ) ; bytesWritten + = b . length ; } 
public void write ( byte [ ] b , int off , int len ) throws IOException { tsuper . write ( b , off , len ) ; tbytesWritten + = len ; } 
public void write ( int b ) throws IOException { tsuper . write ( b ) ; + + bytesWritten ; } 
public long bytesWritten ( ) { return bytesWritten ; } 
public Serializable execute ( PrevalentSystem system ) { system . clock ( ) . recover ( new Date ( millis ) ) ; return null ; } 
public Object readLastSnapshot ( ) throws IOException , ClassNotFoundException { File snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; try { return ois . readObject ( ) ; 
public Command readCommand ( ) throws IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; try { return ( Command ) currentLogStream . readObject ( ) ; 
public CommandOutputStream commandOutputStream ( ) { return new CommandOutputStream ( fileFinder . fileCreator ( ) ) ; } 
private ObjectInputStream newLogStream ( ) throws IOException { File logFile = fileFinder . nextPendingLog ( ) ; return new ObjectInputStream ( new FileInputStream ( logFile ) ) ; } 
public void writeCommand ( Serializable command ) throws IOException { ObjectOutputStream oos = logStream ( ) ; try { oos . writeObject ( command ) ; } catch ( IOException iox ) { oos . close ( ) ; throw iox ; } toos . flush ( ) ; } 
public synchronized void writeSnapshot ( Serializable system ) throws IOException { closeLogStream ( ) ; ObjectOutputStream snapshot = snapshotStream ( ) ; try { snapshot . writeObject ( system ) ; 
private ObjectOutputStream logStream ( ) throws IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = 100000L ) { } 
private void closeLogStream ( ) throws IOException { if ( logStream ! = null ) logStream . close ( ) ; logStream = null ; } 
private ObjectOutputStream snapshotStream ( ) throws IOException { File file = fileCreator . newSnapshot ( ) ; return new ObjectOutputStream ( new FileOutputStream ( file ) ) ; } 
public File newLog ( ) throws IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; log . createNewFile ( ) ; + + nextFileNumber ; return log ; } 
public File newSnapshot ( ) throws IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . createNewFile ( ) ; return snapshot ; } 
public File lastSnapshot ( ) { return lastSnapshot ; } 
public File nextPendingLog ( ) throws EOFException { File log = new File ( directory , NumberFileCreator . LOG_FORMAT . format ( fileNumber + 1 ) ) ; if ( ! log . exists ( ) ) { fileCreator = new NumberFileCreator ( directory , fileNumber + 1 ) ; throw new EOFException ( ) ; } + + fileNumber ; return log ; } 
public NumberFileCreator fileCreator ( ) { return fileCreator ; } 
private void init ( ) throws IOException { findLastSnapshot ( ) ; fileNumber = lastSnapshot = = null ? 0 
private long number ( File snapshot ) { try { return ( NumberFileCreator . SNAPSHOT_FORMAT . parse ( snapshot . getName ( ) ) ) . longValue ( ) ; 
private void findLastSnapshot ( ) throws IOException { File [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; Arrays . sort ( snapshots ) ; lastSnapshot = snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
public boolean accept ( File file ) { try { number ( file ) ; } catch ( InternalParseException ipe ) { return false ; } return true ; } 
public AlarmClock clock ( ) { return clock ; } 
public PrevalentSystem create ( ) { return new AddingSystem ( ) ; } 
public Serializable execute ( PrevalentSystem system ) { ( ( AddingSystem ) system ) . add ( value ) ; return null ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) throw new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; currentTimeMillis = newMillis ; } 
protected long currentTimeMillis ( ) { return currentTimeMillis ; } 
static public void main ( String [ ] args ) { try { 
static private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) throw new RuntimeException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) throw new RuntimeException ( " AlarmClock's time cannot move forwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) throw new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
synchronized void pause ( ) { if ( isPaused ) throw new RuntimeException ( " AlarmClock was already paused. " ) ; time ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) throw new RuntimeException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
public synchronized Serializable executeCommand ( Command command ) throws Exception { clock . pause ( ) ; To be deterministic, the system must know exactly at what time the command is being executed. try { output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
private void recoverCommands ( CommandInputStream input ) throws IOException , ClassNotFoundException { Command command ; while ( true ) { try { 
public Serializable execute ( PrevalentSystem system ) throws Exception { system . clock ( ) . recover ( millis ) ; return command . execute ( system ) ; } 
public String toString ( ) { } 
public String numberString ( ) { treturn numberString ( number ) ; } 
tstatic String numberString ( long number ) { treturn ( new java . text . DecimalFormat ( " 00000 " ) . format ( number ) ) ; } 
public void holder ( String holder ) throws InvalidHolder { verify ( holder ) ; tthis . holder = holder ; notifyListeners ( ) ; } 
public void deposit ( long ammount ) throws InvalidAmmount { verify ( ammount ) ; register ( ammount ) ; } 
public void withdraw ( long ammount ) throws InvalidAmmount { verify ( ammount ) ; register ( - ammount ) ; } 
private void register ( long ammount ) { tbalance + = ammount ; transactionHistory . add ( new Transaction ( ammount ) ) ; notifyListeners ( ) ; } 
private void verify ( long ammount ) throws InvalidAmmount { if ( ammount < = 0 ) throw new InvalidAmmount ( " Ammount must be greater than zero. " ) ; if ( ammount > 10000 ) throw new InvalidAmmount ( " Ammount maximum (10000) exceeded. " ) ; } 
public List transactionHistory ( ) { return transactionHistory ; } 
public void addAccountListener ( AccountListener listener ) { tlisteners ( ) . add ( listener ) ; } 
public void removeAccountListener ( AccountListener listener ) { tlisteners ( ) . remove ( listener ) ; } 
private Set listeners ( ) { if ( listeners = = null ) listeners = new HashSet ( ) ; treturn listeners ; } 
private void notifyListeners ( ) { tIterator it = listeners ( ) . iterator ( ) ; twhile ( it . hasNext ( ) ) { ( ( AccountListener ) it . next ( ) ) . accountChanged ( ) ; 
private void verify ( String holder ) throws InvalidHolder { if ( holder = = null | | holder . equals ( " " ) ) throw new InvalidHolder ( ) ; } 
public String toString ( ) { return timestampString ( ) + " Ammount: " + ammount ; } 
private String timestampString ( ) { return new java . text . SimpleDateFormat ( " yyyy/MM/dd hh:mm:ss.SSS " ) . format ( timestamp ) ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { tAccount account = new Account ( nextAccountNumber , holder , clock ) ; taccountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; treturn account ; } 
public void deleteAccount ( long number ) throws AccountNotFound { tAccount account = findAccount ( number ) ; taccountsByNumber . remove ( new Long ( number ) ) ; if ( bankListener ! = null ) bankListener . accountDeleted ( account ) ; } 
public List accounts ( ) { tList accounts = new ArrayList ( accountsByNumber . values ( ) ) ; tCollections . sort ( accounts , new Comparator ( ) { public int compare ( Object acc1 , Object acc2 ) { treturn ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } } ) ; treturn accounts ; } 
public int compare ( Object acc1 , Object acc2 ) { treturn ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } 
public Account findAccount ( long number ) throws AccountNotFound { tAccount account = searchAccount ( number ) ; if ( account = = null ) throw new AccountNotFound ( number ) ; treturn account ; } 
public void transfer ( long sourceNumber , long destinationNumber , long ammount ) throws AccountNotFound , Account . InvalidAmmount { tAccount source = findAccount ( sourceNumber ) ; tAccount destination = findAccount ( destinationNumber ) ; tsource . withdraw ( ammount ) ; tdestination . deposit ( ammount ) ; } 
private Account searchAccount ( long number ) { treturn ( Account ) accountsByNumber . get ( new Long ( number ) ) ; } 
public void accountCreated ( Account account ) ; public void accountDeleted ( Account account ) ; } 
public static void run ( ) throws IOException , ClassNotFoundException , InterruptedException { tString prevalenceBase = System . getProperty ( " user.dir " ) + " /prevalenceBase " ; out ( " The following directory shall be used for the snapshot files and log files: " + prevalenceBase ) ; Prevayler prevayler = new Prevayler ( new Bank ( ) , prevalenceBase ) ; tnew BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 60 * 60 * 24 ) ; 
private static void out ( String message ) { tSystem . out . println ( message ) ; } 
protected Serializable execute ( Bank bank ) throws Exception { texecute ( bank . findAccount ( accountNumber ) ) ; treturn null ; } 
protected abstract void execute ( Account account ) throws Exception ; } 
protected Serializable execute ( Bank bank ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected Serializable execute ( Bank bank ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } 
public Serializable execute ( PrevalentSystem bank ) throws Exception { treturn execute ( ( Bank ) bank ) ; } 
protected abstract Serializable execute ( Bank bank ) throws Exception ; } 
public void execute ( Account account ) throws Account . InvalidAmmount { taccount . deposit ( ammount ) ; } 
public void execute ( Account account ) throws Account . InvalidHolder { taccount . holder ( newHolder ) ; } 
public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , ammount ) ; return null ; } 
public void execute ( Account account ) throws Account . InvalidAmmount { taccount . withdraw ( ammount ) ; } 
protected void addFields ( Box fieldBox ) { tsuper . addFields ( fieldBox ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Transaction History " ) ) ; thistoryList = new JList ( ) ; historyList . disable ( ) ; tfieldBox . add ( new JScrollPane ( historyList ) ) ; tfieldBox . add ( gap ( ) ) ; tfieldBox . add ( labelContainer ( " Balance " ) ) ; tbalanceField = new JTextField ( ) ; tbalanceField . disable ( ) ; tfieldBox . add ( balanceField ) ; } 
protected void addButtons ( JPanel buttonPanel ) { tbuttonPanel . add ( new JButton ( new DepositAction ( ) ) ) ; tbuttonPanel . add ( new JButton ( new WithdrawAction ( ) ) ) ; tbuttonPanel . add ( new JButton ( new TransferAction ( ) ) ) ; } 
public void action ( ) throws Exception { Number ammount = enterAmmount ( " Deposit " ) ; if ( ammount = = null ) return ; prevayler . executeCommand ( new Deposit ( account , ammount . longValue ( ) ) ) ; } 
public void action ( ) throws Exception { Number ammount = enterAmmount ( " Withdrawal " ) ; if ( ammount = = null ) return ; prevayler . executeCommand ( new Withdrawal ( account , ammount . longValue ( ) ) ) ; } 
private Number enterAmmount ( String operation ) throws Exception { String ammountText = JOptionPane . showInputDialog ( null , " Enter ammount " , operation , JOptionPane . PLAIN_MESSAGE ) ; if ( ammountText = = null ) return null ; return new Long ( parse ( ammountText ) ) ; } 
public void action ( ) { new TransferFrame ( account , prevayler , getDesktopPane ( ) ) ; } 
public void accountChanged ( ) { } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; ttry { tprevayler . executeCommand ( new HolderChange ( account , holderText ( ) ) ) ; 
protected String holderText ( ) { treturn holderField . getText ( ) ; } 
private Box fieldBox ( ) { tBox fieldBox = Box . createVerticalBox ( ) ; taddFields ( fieldBox ) ; treturn fieldBox ; } 
protected void addFields ( Box fieldBox ) { tfieldBox . add ( labelContainer ( " Holder " ) ) ; tfieldBox . add ( holderField ) ; } ; 
private JPanel buttonPanel ( ) { tJPanel buttonPanel = new JPanel ( ) ; taddButtons ( buttonPanel ) ; treturn buttonPanel ; } 
tabstract protected void addButtons ( JPanel buttonPanel ) ; protected Container labelContainer ( String text ) { tBox box = Box . createHorizontalBox ( ) ; tJLabel label = new JLabel ( text ) ; tbox . add ( label ) ; tbox . add ( Box . createHorizontalGlue ( ) ) ; treturn box ; } protected Component gap ( ) { treturn Box . createVerticalStrut ( 3 ) ; } protected long parse ( String numericString ) throws ParseException { return new DecimalFormat ( " # " ) . parse ( numericString ) . longValue ( ) ; The exception thrown has a better message than Long.parseLong(String). }} 
protected Container labelContainer ( String text ) { tBox box = Box . createHorizontalBox ( ) ; tJLabel label = new JLabel ( text ) ; tbox . add ( label ) ; tbox . add ( Box . createHorizontalGlue ( ) ) ; treturn box ; } 
protected Component gap ( ) { treturn Box . createVerticalStrut ( 3 ) ; } 
protected long parse ( String numericString ) throws ParseException { return new DecimalFormat ( " # " ) . parse ( numericString ) . longValue ( ) ; The exception thrown has a better message than Long.parseLong(String). } 
private void listenToAccounts ( ) { tjava . util . Iterator it = accounts ( ) . iterator ( ) ; twhile ( it . hasNext ( ) ) { ( ( Account ) it . next ( ) ) . addAccountListener ( this ) ; 
private void refreshAccounts ( ) { taccountList . setListData ( accounts ( ) . toArray ( ) ) ; } 
private java . util . List accounts ( ) { treturn bank ( ) . accounts ( ) ; } 
private Bank bank ( ) { treturn ( Bank ) prevayler . system ( ) ; } 
public void accountCreated ( Account a ) { } 
public void accountDeleted ( Account a ) { } 
public void accountChanged ( ) { } 
private JPanel accountButtons ( ) { tJPanel result = new JPanel ( ) ; tresult . add ( new JButton ( new AccountCreation ( ) ) ) ; tresult . add ( new JButton ( new AccountEditAction ( ) ) ) ; tresult . add ( new JButton ( new AccountDeleteAction ( ) ) ) ; treturn result ; } 
public void actionPerformed ( ActionEvent e ) { tnew NewAccountFrame ( prevayler , getDesktopPane ( ) ) ; } 
private void refreshEnabled ( ) { tthis . setEnabled ( accountList . getSelectedValue ( ) ! = null ) ; } 
public void valueChanged ( ListSelectionEvent event ) { trefreshEnabled ( ) ; } 
protected void action ( ) throws Exception { taction ( ( Account ) accountList . getSelectedValue ( ) ) ; } 
tabstract void action ( Account account ) throws Exception ; } tclass AccountEditAction extends SelectedAccountAction { tAccountEditAction ( ) { tsuper ( " Edit " ) ; } tvoid action ( Account account ) { tnew AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } } tclass AccountDeleteAction extends SelectedAccountAction { tAccountDeleteAction ( ) { tsuper ( " Delete " ) ; } tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; tprevayler . executeCommand ( new AccountDeletion ( account ) ) ; } } } 
tvoid action ( Account account ) { tnew AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } 
tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; tprevayler . executeCommand ( new AccountDeletion ( account ) ) ; } 
private void addLine ( String line ) { tJLabel label = new JLabel ( line ) ; tlabel . setAlignmentX ( 0.5f ) ; tgetContentPane ( ) . add ( label ) ; } 
protected void addButtons ( JPanel buttonPanel ) { tbuttonPanel . add ( new JButton ( new OKAction ( ) ) ) ; } 
protected void action ( ) throws Exception { tprevayler . executeCommand ( new AccountCreation ( holderText ( ) ) ) ; tdispose ( ) ; } 
public void actionPerformed ( ActionEvent e ) { ttry { taction ( ) ; 
protected abstract void action ( ) throws Exception ; tstatic void display ( Exception exception ) { tJOptionPane . showMessageDialog ( null , exception . getMessage ( ) , " Error " , JOptionPane . ERROR_MESSAGE ) ; } } 
tstatic void display ( Exception exception ) { tJOptionPane . showMessageDialog ( null , exception . getMessage ( ) , " Error " , JOptionPane . ERROR_MESSAGE ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . disable ( ) ; fieldBox . add ( sourceField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Ammount " ) ) ; ammountField = new JTextField ( ) ; fieldBox . add ( ammountField ) ; } 
protected void addButtons ( JPanel buttonPanel ) { buttonPanel . add ( new JButton ( new OKAction ( ) ) ) ; } 
public void action ( ) throws Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long ammount = parse ( ammountField . getText ( ) ) ; prevayler . executeCommand ( new Transfer ( account . number ( ) , destinationNumber , ammount ) ) ; dispose ( ) ; } 
public void flush ( ) throws IOException { super . flush ( ) ; "The flush method of OutputStream does nothing." - JDK1.3 API documentation. I'm calling it just in case it starts doing something in a future version of FileOutputStream or OutputStream. getFD().sync(); "Force all system buffers to synchronize with the underlying device." - JDK1.3 API documentation. } 
public PrevalentSystem readLastSnapshot ( ) throws IOException , ClassNotFoundException { File snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; out ( snapshotFile ) ; ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; try { return ( PrevalentSystem ) ois . readObject ( ) ; 
public Command readCommand ( ) throws IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; Throws EOFException if there are no more log streams. try { return (Command)currentLogStream.readObject(); } catch (EOFException eof) { No more commands in this file. } catch (ObjectStreamException osx) { logStreamExceptionMessage(osx); } catch (RuntimeException rx) { logStreamExceptionMessage(rx); Some stream corruptions cause runtime exceptions! } currentLogStream.close(); currentLogStream = null; return readCommand(); } 
private ObjectInputStream newLogStream ( ) throws IOException { File logFile = fileFinder . nextPendingLog ( ) ; Throws EOFException if there are no more pending log files. out(logFile); return new ObjectInputStream(new FileInputStream(logFile)); } 
private void logStreamExceptionMessage ( Exception exception ) { out ( " " + exception ) ; out ( " Some commands might have been lost. Looking for the next file... " ) ; } 
private static void out ( File file ) { out ( " Reading " + file + " ... " ) ; } 
private static void out ( Object obj ) { System . out . println ( obj ) ; } 
public void writeCommand ( Command command ) throws IOException { ObjectOutputStream oos = logStream ( ) ; try { oos . writeObject ( command ) ; 
public synchronized void writeSnapshot ( PrevalentSystem system ) throws IOException { closeLogStream ( ) ; After every snapshot, a new commandLog file must be started. File tempSnapshot = fileCreator.newTempSnapshot(); ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(tempSnapshot)); stream.writeObject(system); stream.close(); File snapshot = fileCreator.newSnapshot(); if (!tempSnapshot.renameTo(snapshot)) throw new IOException("Unable to rename " + tempSnapshot + " to " + snapshot); } 
private ObjectOutputStream logStream ( ) throws IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = LOG_FILE_SIZE ) { closeLogStream ( ) ; return logStream ( ) ; } 
private void closeLogStream ( ) throws IOException { if ( logStream = = null ) return ; logStream . close ( ) ; logStream = null ; } 
File newLog ( ) throws IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) throw new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; + + nextFileNumber ; return log ; } 
File newSnapshot ( ) throws IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . delete ( ) ; If no commands are logged, the same snapshot file will be created over and over. return snapshot; } 
File newTempSnapshot ( ) throws IOException { return File . createTempFile ( " temp " , " generatingSnapshot " , directory ) ; } 
private long number ( File snapshot ) throws NumberFormatException { NumberFomatException is a RuntimeException. String name = snapshot.getName(); if (!name.endsWith("." + NumberFileCreator.SNAPSHOT_SUFFIX)) throw new NumberFormatException(); return Long.parseLong(name.substring(0,name.indexOf('.'))); "00000.snapshot" becomes "00000". The following doesn't work! It throws ParseException (UnparseableNumber): return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue(); 
public boolean accept ( File file ) { try { number ( file ) ; } catch ( NumberFormatException nfx ) { return false ; } return true ; } 
Long add ( long value ) { total + = value ; return new Long ( total ) ; } 
public Serializable execute ( PrevalentSystem system ) { return ( ( AddingSystem ) system ) . add ( value ) ; } 
static public void main ( String [ ] args ) { try { header ( " Persistence Test... " ) ; 
static public void run ( ) throws Exception { clearPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. crashRecover(); add(40,40); 1 add(30,70); 2 verify(70); crashRecover(); verify(70); add(20,90); 3 add(15,105); 4 snapshot(); snapshot(); verify(105); crashRecover(); snapshot(); add(10,115); 5 snapshot(); add(5,120); 6 add(4,124); 7 verify(124); crashRecover(); add(3,127); 8 verify(127); snapshot(); clearPrevalenceBase(); snapshot(); crashRecover(); verify(127); add(2,129); 9 crashRecover(); verify(129); clearPrevalenceBase(); Check if all files were properly closed and can be deleted. 
static private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; prevayler = new Prevayler ( new AddingSystem ( ) , prevalenceBase ) ; prevaylers . add ( prevayler ) ; } 
static private void snapshot ( ) throws IOException { out ( " Snapshot. " ) ; prevayler . takeSnapshot ( ) ; } 
static private void add ( long value , long expectedTotal ) throws Exception { out ( " Adding " + value ) ; Long total = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; compare ( total . longValue ( ) , expectedTotal , " Total " ) ; } 
static private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; compare ( system ( ) . total ( ) , expectedTotal , " Total " ) ; } 
static private AddingSystem system ( ) { return ( AddingSystem ) prevayler . system ( ) ; } 
static private void clearPrevalenceBase ( ) throws Exception { Iterator it = prevaylers . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( Prevayler ) it . next ( ) ) . takeSnapshot ( ) ; } 
static private void delete ( File [ ] files ) { for ( int i = 0 ; i < files . length ; + + i ) { verify ( files [ i ] . delete ( ) , " Unable to delete " + files [ i ] ) ; 
static private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
static private void verify ( boolean condition , String message ) { if ( ! condition ) { throw new RuntimeException ( message ) ; 
static private void out ( Object obj ) { } static private Prevayler prevayler; static private final Set prevaylers = new HashSet(); static private final String prevalenceBase = System.getProperty("user.dir") + "\\prevalenceBase";} 
public static void run ( ) throws IOException , ClassNotFoundException , InterruptedException { tString prevalenceBase = System . getProperty ( " user.dir " ) + " /prevalenceBase " ; out ( " The following directory shall be used for the snapshot files and log files: " + prevalenceBase ) ; Prevayler prevayler = new Prevayler ( new Bank ( ) , prevalenceBase ) ; tnew BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; twhile ( true ) { Thread . sleep ( 1000 * 60 * 60 * 24 ) ; 
tvoid clock ( AlarmClock clock ) ; tAlarmClock clock ( ) ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( Command command ) throws Exception ; } 
public Serializable executeCommand ( Command command ) throws Exception ; } 
public void deposit ( long amount ) throws InvalidAmount { verify ( amount ) ; register ( amount ) ; } 
public void withdraw ( long amount ) throws InvalidAmount { verify ( amount ) ; register ( - amount ) ; } 
private void register ( long amount ) { tbalance + = amount ; transactionHistory . add ( new Transaction ( amount ) ) ; notifyListeners ( ) ; } 
private void verify ( long amount ) throws InvalidAmount { if ( amount < = 0 ) throw new InvalidAmount ( " Amount must be greater than zero. " ) ; if ( amount > 10000 ) throw new InvalidAmount ( " Amount maximum (10000) exceeded. " ) ; } 
public String toString ( ) { return timestampString ( ) + " Amount: " + amount ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { tAccount account = new Account ( nextAccountNumber , holder , clock ( ) ) ; taccountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; treturn account ; } 
public void transfer ( long sourceNumber , long destinationNumber , long amount ) throws AccountNotFound , Account . InvalidAmount { tAccount source = findAccount ( sourceNumber ) ; tAccount destination = findAccount ( destinationNumber ) ; tsource . withdraw ( amount ) ; tdestination . deposit ( amount ) ; } 
public static void run ( ) throws IOException , ClassNotFoundException , InterruptedException { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) ) ; tnew BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 60 * 60 * 24 ) ; 
public void execute ( Account account ) throws Account . InvalidAmount { taccount . deposit ( amount ) ; } 
public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } 
public void execute ( Account account ) throws Account . InvalidAmount { taccount . withdraw ( amount ) ; } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; prevayler . executeCommand ( new Deposit ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; prevayler . executeCommand ( new Withdrawal ( account , amount . longValue ( ) ) ) ; } 
private Number enterAmount ( String operation ) throws Exception { String amountText = JOptionPane . showInputDialog ( null , " Enter amount " , operation , JOptionPane . PLAIN_MESSAGE ) ; if ( amountText = = null ) return null ; return new Long ( parse ( amountText ) ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . disable ( ) ; fieldBox . add ( sourceField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Amount " ) ) ; amountField = new JTextField ( ) ; fieldBox . add ( amountField ) ; } 
public void action ( ) throws Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; prevayler . executeCommand ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) ; dispose ( ) ; } 
public void clock ( AlarmClock clock ) { if ( this . clock ! = null ) throw new IllegalStateException ( " The clock had already been set. " ) ; tthis . clock = clock ; } 
tboolean isCommandSequenceRestarted ( ) { treturn isCommandSequenceRestarted ; } 
tboolean recover ( long nextNumber ) throws EOFException , IOException , ClassNotFoundException { tpreparePendingCommand ( ) ; if ( nextNumber ! = pendingCommandNumber ) return false ; tclock . recover ( pendingCommandExecutionTime ) ; ttry { tpendingCommand . execute ( system ) ; } catch ( Exception e ) { } 
private void preparePendingCommand ( ) throws EOFException , IOException , ClassNotFoundException { if ( pendingCommand ! = null ) return ; ry { 
private void abort ( Exception exception ) throws EOFException { out ( " " + exception + " (File: " + logFile + " ) " ) ; out ( " Some commands might have been lost. Looking for the next command... " ) ; tthrow new EOFException ( ) ; } 
tstatic private void out ( String message ) { tSystem . out . println ( message ) ; } 
tvoid writeCommand ( Command command ) throws IOException { tobjectOutputStream . writeObject ( command ) ; } 
tvoid commandSequence ( long executionTime , long commandSequence ) { tthis . executionTime = executionTime ; tthis . commandSequence = commandSequence ; } 
tvoid flushToDisk ( ) throws IOException { tobjectOutputStream . writeLong ( executionTime ) ; tobjectOutputStream . writeLong ( commandSequence ) ; tflushStreams ( safeCommandLogs ) ; } 
tboolean isValid ( ) { treturn ! isExpired ( ) & & ! isFull ( ) ; } 
private boolean isExpired ( ) { if ( commandLogsThresholdMillis = = 0 ) return false ; treturn stopWatch . millisEllapsed ( ) > = commandLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( commandLogsThresholdBytes = = 0 ) return false ; treturn logFile . length ( ) > = commandLogsThresholdBytes ; } 
tvoid close ( ) throws IOException { tobjectOutputStream . close ( ) ; } 
tstatic private long parseSystemProperty ( String propertyName ) { ttry { treturn Long . parseLong ( System . getProperty ( propertyName ) ) ; 
tstatic private boolean safeCommandLogsSystemProperty ( ) { tboolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeCommandLogs " ) ) ; tsafeCommandLogsMessage ( safe ) ; treturn safe ; } 
tstatic private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost, though. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } tlastTimeWasSafe = safe ; } 
tstatic private void out ( Object message ) { tSystem . out . println ( message ) ; } 
tFile newLog ( File directory ) throws IOException { tFile log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) throw new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; tnextFileNumber + + ; treturn log ; } 
tFile newSnapshot ( File directory ) throws IOException { tFile snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; tsnapshot . delete ( ) ; } 
tFile newTempSnapshot ( File directory ) throws IOException { treturn File . createTempFile ( " temp " , " generatingSnapshot " , directory ) ; } 
public PrevalentSystem recoverSystem ( PrevalentSystem newSystem ) throws ClassNotFoundException , IOException { tSystemRecoverer recoverer = new SystemRecoverer ( snapshotDirectory , commandLogDirectories ) ; tPrevalentSystem system = recoverer . recover ( newSystem ) ; tfileCreator = new FileCreator ( recoverer . nextLogFileNumber ( ) ) ; treturn system ; } 
public CommandLogger availableCommandLogger ( ) throws IOException { tsynchronized ( availableLoggers ) { twhile ( availableLoggers . isEmpty ( ) ) { 
private void waitForAvailableLogger ( ) { ttry { tavailableLoggers . wait ( ) ; 
private void createLoggers ( ) throws IOException { tcreateLogger ( commandLogDirectories [ 0 ] , true ) ; tfor ( int i = 1 ; i < commandLogDirectories . length ; i + + ) { tcreateLogger ( commandLogDirectories [ i ] , false ) ; } tnextCommandSequence = 1 ; tloggersCreated = true ; } 
private void createLogger ( File directory , boolean sequenceRestarted ) throws IOException { tFile logFile = fileCreator . newLog ( directory ) ; tavailableLoggers . add ( new CommandLogger ( logFile , sequenceRestarted ) ) ; } 
public void generateCommandSequence ( CommandLogger commandLogger , long executionTime ) { tcommandLogger . commandSequence ( executionTime , nextCommandSequence + + ) ; } 
public void flushToDisk ( CommandLogger commandLogger ) throws IOException { tcommandLogger . flushToDisk ( ) ; tmakeLoggerAvailable ( commandLogger ) ; } 
private void makeLoggerAvailable ( CommandLogger commandLogger ) throws IOException { tsynchronized ( availableLoggers ) { if ( commandLogger . isValid ( ) ) { 
public void writeSnapshot ( PrevalentSystem system ) throws IOException { tFile tempSnapshot = fileCreator . newTempSnapshot ( snapshotDirectory ) ; tObjectOutputStream stream = new ObjectOutputStream ( new FileOutputStream ( tempSnapshot ) ) ; tstream . writeObject ( system ) ; tstream . close ( ) ; tFile snapshot = fileCreator . newSnapshot ( snapshotDirectory ) ; if ( ! tempSnapshot . renameTo ( snapshot ) ) throw new IOException ( " Unable to rename " + tempSnapshot + " to " + snapshot ) ; tcloseLoggers ( ) ; } 
private void closeLoggers ( ) throws IOException { tIterator it = availableLoggers . iterator ( ) ; twhile ( it . hasNext ( ) ) { ( ( CommandLogger ) it . next ( ) ) . close ( ) ; } tavailableLoggers . clear ( ) ; tloggersCreated = false ; } 
tstatic private File findDirectory ( String directoryName ) throws IOException { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + directoryName ) ; treturn directory ; } 
tstatic private File [ ] findDirectories ( String [ ] directoryNames ) throws IOException { tFile [ ] directories = new File [ directoryNames . length ] ; tfor ( int i = 0 ; i < directoryNames . length ; i + + ) { tdirectories [ i ] = findDirectory ( directoryNames [ i ] ) ; } treturn directories ; } 
public void takeSnapshot ( ) throws IOException { tsynchronized ( snapshotMonitor ) { twhile ( commandsBeingExecuted ! = 0 ) Thread . yield ( ) ; 
public Serializable executeCommand ( Command command ) throws Exception { tprepareForMyTurn ( command ) ; ttry { 
private void prepareForMyTurn ( Command command ) throws IOException { tcommandExecutionStarting ( ) ; tCommandLogger myCommandLogger = prevalenceBase . availableCommandLogger ( ) ; tmyCommandLogger . writeCommand ( command ) ; } 
private void waitForMyTurn ( Object myPlaceHolder ) { tsynchronized ( myPlaceHolder ) { tObject firstPlaceHolder ; 
private void endMyTurn ( ) { tObject nextPlaceHolder = null ; tsynchronized ( commandQueue ) { tcommandQueue . remove ( 0 ) ; if ( commandQueue . isEmpty ( ) ) { tclock . resume ( ) ; } else { tnextPlaceHolder = commandQueue . get ( 0 ) ; } } if ( nextPlaceHolder ! = null ) { tsynchronized ( nextPlaceHolder ) { tnextPlaceHolder . notify ( ) ; } } tcommandExecutionFinishing ( ) ; } 
private void commandExecutionStarting ( ) { tsynchronized ( snapshotMonitor ) { tsynchronized ( commandExecutionMonitor ) { 
private void commandExecutionFinishing ( ) { tsynchronized ( commandExecutionMonitor ) { tcommandsBeingExecuted - - ; 
tstatic private String [ ] fillArray ( String element , int size ) { tString [ ] result = new String [ size ] ; tArrays . fill ( result , element ) ; treturn result ; } 
synchronized void pause ( ) { if ( isPaused ) throw new IllegalStateException ( " AlarmClock was already paused. " ) ; time ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) throw new IllegalStateException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) throw new RuntimeException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) throw new RuntimeException ( " AlarmClock's time cannot be set backwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) throw new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
tPrevalentSystem recover ( PrevalentSystem newSystem ) throws ClassNotFoundException , IOException { tFile snapshotFile = findLastSnapshotFile ( snapshotDirectory ) ; if ( snapshotFile = = null ) { tsystem = newSystem ; tnextLogFileNumber = 1 ; } else { tsystem = readSystem ( snapshotFile ) ; tnextLogFileNumber = number ( snapshotFile ) + 1 ; } trecoverPendingCommands ( ) ; treturn system ; } 
private void recoverPendingCommands ( ) throws IOException , ClassNotFoundException { tlong nextCommandNumber = 1 ; tfinal List logRecoverers = new LinkedList ( ) ; twhile ( nextLogFile ( ) ) { tCommandLogRecoverer newLogRecoverer = new CommandLogRecoverer ( currentLogFile , system ) ; 
private boolean recoverNextCommand ( long nextCommandNumber , List logRecoverers ) throws IOException , ClassNotFoundException { tIterator iterator = logRecoverers . iterator ( ) ; twhile ( iterator . hasNext ( ) ) { tCommandLogRecoverer logRecoverer = ( CommandLogRecoverer ) iterator . next ( ) ; ttry { if ( logRecoverer . recover ( nextCommandNumber ) ) return true ; } catch ( EOFException eof ) { tlogRecoverer . close ( ) ; titerator . remove ( ) ; } } treturn false ; } 
private boolean nextLogFile ( ) throws IOException { tfor ( int i = 0 ; i < commandLogDirectories . length ; i + + ) { tcurrentLogFile = new File ( commandLogDirectories [ i ] , FileCreator . LOG_FORMAT . format ( nextLogFileNumber ) ) ; if ( currentLogFile . exists ( ) ) { tnextLogFileNumber + + ; treturn true ; } } treturn false ; } 
tstatic private void clearLogRecoverers ( List logRecoverers ) throws IOException { tIterator iterator = logRecoverers . iterator ( ) ; twhile ( iterator . hasNext ( ) ) { ( ( CommandLogRecoverer ) iterator . next ( ) ) . close ( ) ; } tlogRecoverers . clear ( ) ; } 
tstatic private File findLastSnapshotFile ( File directory ) throws IOException { tFile [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tArrays . sort ( snapshots ) ; treturn snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
tstatic private long number ( File snapshot ) throws NumberFormatException { } 
tstatic private PrevalentSystem readSystem ( File snapshotFile ) throws ClassNotFoundException , IOException { tObjectInputStream ois = objectInputStream ( snapshotFile ) ; ttry { treturn ( PrevalentSystem ) ois . readObject ( ) ; 
tstatic private ObjectInputStream objectInputStream ( File file ) throws IOException { tSystem . out . println ( " Reading " + file + " ... " ) ; treturn new ObjectInputStream ( new FileInputStream ( file ) ) ; } 
public boolean accept ( File file ) { ttry { tnumber ( file ) ; } catch ( NumberFormatException nfx ) { treturn false ; } treturn true ; } 
tLong add ( long value ) { ttotal + = value ; treturn new Long ( total ) ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) throw new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; tcurrentTimeMillis = newMillis ; } 
public long currentTimeMillis ( ) { treturn currentTimeMillis ; } 
tstatic public void run ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
tstatic private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tclockPuppet = new AlarmClockPuppet ( clockPuppet . currentTimeMillis ( ) ) ; } 
tstatic private void snapshot ( ) throws IOException { out ( " Snapshot. " ) ; tprevayler . takeSnapshot ( ) ; } 
tstatic private void setTime ( long newTime ) throws Exception { out ( " Setting time: " + newTime ) ; tclockPuppet . currentTimeMillis ( newTime ) ; tprevayler . executeCommand ( new NullCommand ( ) ) ; } 
tstatic private void verify ( long expectedTime ) { out ( " Expecting time: " + expectedTime ) ; tcompare ( system ( ) . clock ( ) . time ( ) . getTime ( ) , expectedTime , " Time " ) ; } 
tstatic private PrevalentSystem system ( ) { treturn prevayler . system ( ) ; } 
tstatic private String prevalenceBase ( ) { if ( prevalenceBase = = null ) { tprevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } treturn prevalenceBase ; } 
tstatic private void newPrevalenceBase ( ) { tprevalenceBase = null ; } 
tstatic private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
tstatic private void verify ( boolean condition , String message ) { if ( ! condition ) { tthrow new RuntimeException ( message ) ; 
tstatic private void out ( Object obj ) { tSystem . out . println ( obj ) ; } 
static public void main ( String [ ] args ) { try { header ( " PersistenceTest... " ) ; 
public Serializable execute ( PrevalentSystem system ) { return null ; } 
tstatic public void run ( ) throws Exception { tclearPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
tstatic private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; tprevaylers . add ( prevayler ) ; } 
tstatic private void add ( long value , long expectedTotal ) throws Exception { out ( " Adding " + value ) ; tLong total = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; tcompare ( total . longValue ( ) , expectedTotal , " Total " ) ; } 
tstatic private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; tcompare ( system ( ) . total ( ) , expectedTotal , " Total " ) ; } 
tstatic private AddingSystem system ( ) { treturn ( AddingSystem ) prevayler . system ( ) ; } 
tstatic private String prevalenceBase ( ) { treturn " PrevalenceBase " ; } 
tstatic private void clearPrevalenceBase ( ) throws Exception { tIterator it = prevaylers . iterator ( ) ; twhile ( it . hasNext ( ) ) { ( ( SnapshotPrevayler ) it . next ( ) ) . takeSnapshot ( ) ; } 
tstatic public void deletePrevalenceFiles ( String directoryName ) { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; tFile [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; tfor ( int i = 0 ; i < files . length ; + + i ) { out ( " Deleting: " + files [ i ] ) ; 
tstatic private void out ( Object obj ) { }} 
public boolean accept ( File directory , String filename ) { treturn filename . endsWith ( " commandLog " ) | | filename . endsWith ( " snapshot " ) ; 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) ; } 
protected String name ( ) { treturn " Manipulation Test " ; } 
protected void executeOperation ( Object connection , long operationSequence ) { tRecord recordToInsert = new Record ( operationSequence + 1000000 ) ; tlong idToDelete = spreadId ( operationSequence ) ; tRecord recordToUpdate = new Record ( idToDelete + 500000 ) ; ( ( ManipulationConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
tstatic private long spreadId ( long id ) { treturn ( id / 500000 ) * 500000 + ( ( id * 16807 ) % 500000 ) ; 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 500000. This guarantees that all ids in the range will be covered. 
protected void executeOperation ( Object connection , long operationSequence ) { ( ( QueryConnection ) connection ) . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
tstatic private String generateLargeString ( ) { tchar [ ] chars = new char [ 980 ] ; tArrays . fill ( chars , 'A' ) ; treturn new String ( chars ) ; } 
tstatic private BigDecimal randomBigDecimal ( ) { treturn new BigDecimal ( 0.12 + random . nextInt ( ) ) ; } 
tstatic private Date randomDate ( ) { treturn new Date ( random . nextInt ( 10000000 ) ) ; } 
public boolean hasNext ( ) { treturn remainingRecords ! = 0 ; } 
public Record next ( ) { tindicateProgress ( ) ; tremainingRecords - - ; treturn new Record ( remainingRecords ) ; } 
private void indicateProgress ( ) { if ( remainingRecords = = 1000000 ) { out ( " Creating one million records... " ) ; treturn ; } if ( remainingRecords % 100000 = = 0 ) out ( " " + ( 1000000 - remainingRecords ) + " ... " ) ; } 
static private String [ ] logDirectories ( ) { tString [ ] logDirectories = new String [ 10 ] ; tjava . util . Arrays . fill ( logDirectories , " PrevalenceBase " ) ; treturn logDirectories ; } 
private void performTest ( int minThreads , int maxThreads ) { tint threads = minThreads ; twhile ( threads < = maxThreads ) { tdouble operationsPerSecond = performRound ( threads ) ; 
private double performRound ( int threads ) { tlong initialOperationCount = operationCount ; tStopWatch stopWatch = StopWatch . start ( ) ; tstartThreads ( threads ) ; tsleep ( ) ; tstopThreads ( ) ; treturn ( operationCount - initialOperationCount ) / stopWatch . secondsEllapsed ( ) ; } 
private void startThreads ( int threads ) { tisRoundFinished = false ; tfor ( int i = 1 ; i < = threads ; i + + ) { tstartThread ( ) ; 
private void startThread ( ) { ( new Thread ( ) { public void run ( ) { tObject connection = acquireConnection ( ) ; twhile ( ! isRoundFinished ) { tlong operation ; tsynchronized ( roundMonitor ) { toperation = operationCount ; toperationCount + + ; } texecuteOperation ( connection , operation ) ; } tsynchronized ( roundMonitor ) { tconnectionCache . add ( connection ) ; tactiveRoundThreads - - ; } } } ) . start ( ) ; tactiveRoundThreads + + ; } 
public void run ( ) { tObject connection = acquireConnection ( ) ; twhile ( ! isRoundFinished ) { tlong operation ; tsynchronized ( roundMonitor ) { toperation = operationCount ; toperationCount + + ; } texecuteOperation ( connection , operation ) ; } tsynchronized ( roundMonitor ) { tconnectionCache . add ( connection ) ; 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { tsynchronized ( roundMonitor ) { treturn connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { tisRoundFinished = true ; twhile ( activeRoundThreads ! = 0 ) { tThread . yield ( ) ; } } tstatic private String toResultString ( double operationsPerSecond , int threads ) { tString operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; treturn " " + operations + " operations/second ( " + threads + " threads) " ; } tstatic private void sleep ( ) { ttry { tThread . sleep ( ROUND_DURATION_MILLIS ) ; } catch ( InterruptedException ix ) { tthrow new RuntimeException ( " Unexpected InterruptedException. " ) ; } } tstatic private void out ( Object obj ) { tSystem . out . println ( obj ) ; } } 
private Object acquireConnection ( ) { tsynchronized ( roundMonitor ) { treturn connectionCache . isEmpty ( ) 
private void stopThreads ( ) { tisRoundFinished = true ; twhile ( activeRoundThreads ! = 0 ) { tThread . yield ( ) ; 
tstatic private String toResultString ( double operationsPerSecond , int threads ) { tString operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; treturn " " + operations + " operations/second ( " + threads + " threads) " ; } 
tstatic private void sleep ( ) { ttry { tThread . sleep ( ROUND_DURATION_MILLIS ) ; 
tstatic private void out ( Object obj ) { tSystem . out . println ( obj ) ; } 
public String name ( ) ; public void replaceAllRecords ( RecordIterator newRecords ) ; public Object createTestConnection ( ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) ; public Object createTestConnection ( ) ; } 
protected String table ( ) { treturn " PREVAYLER_MANIPULATION_TEST " ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { tinsert ( recordToInsert ) ; tupdate ( recordToUpdate ) ; tdelete ( idToDelete ) ; ttry { tconnection . commit ( ) ; 
private void update ( Record recordToUpdate ) { ttry { tupdateStatement . setString ( 1 , recordToUpdate . getName ( ) ) ; 
private void delete ( long idToDelete ) { ttry { tdeleteStatement . setLong ( 1 , idToDelete ) ; 
public Object createTestConnection ( ) { treturn new JDBCManipulationConnection ( createConnection ( ) ) ; } 
public List queryByName ( String name ) { tArrayList list = new ArrayList ( ) ; ttry { tselectStatement . setString ( 1 , name ) ; tResultSet resultSet = selectStatement . executeQuery ( ) ; twhile ( resultSet . next ( ) ) { tlist . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { tdealWithSQLException ( sqlex , " selecting record from " + table ( ) ) ; } treturn list ; } 
public Object createTestConnection ( ) { treturn new JDBCQueryConnection ( createConnection ( ) ) ; } 
protected void insert ( Record recordToInsert ) { ttry { tinsertStatement . setLong ( 1 , recordToInsert . getId ( ) ) ; 
protected PreparedStatement prepare ( String statement ) { ttry { treturn connection . prepareStatement ( statement ) ; 
tvoid replaceAllRecords ( RecordIterator newRecords ) { ttry { tconnection . createStatement ( ) . execute ( " delete from " + table ( ) ) ; } catch ( SQLException sqlx ) { tdealWithSQLException ( sqlx , " deleting all records from " + table ( ) ) ; } twhile ( newRecords . hasNext ( ) ) { tinsert ( newRecords . next ( ) ) ; } ttry { tconnection . commit ( ) ; 
tstatic protected void dealWithSQLException ( SQLException sqlx , String duringOperation ) { tsqlx . printStackTrace ( ) ; tthrow new RuntimeException ( " SQLException " + duringOperation + " . " ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( newRecords ) ; } 
public Serializable execute ( PrevalentSystem system ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; treturn null ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { tput ( recordToInsert ) ; tput ( recordToUpdate ) ; trecordsById . remove ( new Long ( idToDelete ) ) ; } 
private void put ( Record newRecord ) { tObject key = new Long ( newRecord . getId ( ) ) ; trecordsById . put ( key , newRecord ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { trecordsById . clear ( ) ; twhile ( newRecords . hasNext ( ) ) { tput ( newRecords . next ( ) ) ; 
public java . io . Serializable execute ( PrevalentSystem system ) { ( ( ManipulationSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; treturn null ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { ttry { 
public Object createTestConnection ( ) { treturn new PrevaylerManipulationConnection ( prevayler ) ; } 
public List queryByName ( String name ) { treturn querySystem . queryByName ( name ) ; } 
public Object createTestConnection ( ) { treturn new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . system ( ) ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { ttry { 
public List queryByName ( String name ) { treturn ( List ) recordsByName . get ( name ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { trecordsByName . clear ( ) ; twhile ( newRecords . hasNext ( ) ) { tput ( newRecords . next ( ) ) ; } tmakeReadOnly ( ) ; } 
private void put ( Record newRecord ) { tList records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { trecords = new ArrayList ( ) ; trecordsByName . put ( newRecord . getName ( ) , records ) ; } trecords . add ( newRecord ) ; } 
private void makeReadOnly ( ) { tIterator entries = recordsByName . entrySet ( ) . iterator ( ) ; twhile ( entries . hasNext ( ) ) { tMap . Entry entry = ( Map . Entry ) entries . next ( ) ; 
tstatic public StopWatch start ( ) { treturn new StopWatch ( ) ; } 
public long millisEllapsed ( ) { treturn System . currentTimeMillis ( ) - t0 ; } 
public double secondsEllapsed ( ) { treturn millisEllapsed ( ) / 1000.0 ; } 
public Serializable execute ( PrevalentSystem system ) throws Exception ; } 
public void clock ( AlarmClock clock ) ; public AlarmClock clock ( ) ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( Command command ) throws Exception ; } 
public Serializable executeCommand ( Command command ) throws Exception ; } 
public static void main ( String [ ] args ) throws Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. When you restart the system, you will see that nothing was lost. " ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeFrame ( prevayler ) ; } 
void keep ( int nextNumber ) { numbers . add ( new Integer ( nextNumber ) ) ; } 
int lastNumber ( ) { return numbers . isEmpty ( ) ? 0 
public Serializable execute ( PrevalentSystem system ) throws Exception { ( ( NumberKeeper ) system ) . keep ( numberToKeep ) ; return null ; } 
void start ( ) throws Exception { int primeCandidate = numberKeeper . lastNumber ( ) = = 0 ? 2 : numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { primeFrame . setCandidate ( primeCandidate ) ; 
private boolean isPrime ( int candidate ) { int factor = 2 ; while ( factor < candidate ) { if ( candidate % factor = = 0 ) return false ; factor + + ; } return true ; } 
private JPanel numbersPanel ( ) { JPanel result = new JPanel ( new GridLayout ( 3 , 2 , 10 , 10 ) ) ; result . setBorder ( new EmptyBorder ( 10 , 10 , 10 , 10 ) ) ; result . add ( new JLabel ( " Primes Found: " ) ) ; result . add ( primesFoundLabel ) ; result . add ( new JLabel ( " Largest Prime: " ) ) ; result . add ( largestPrimeLabel ) ; result . add ( new JLabel ( " Current Candidate: " ) ) ; result . add ( candidateLabel ) ; return result ; } 
private JButton snapshotButton ( ) { JButton result = new JButton ( " Take Snapshot " ) ; result . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { takeSnapshot ( ) ; } } ) ; return result ; } 
public void actionPerformed ( ActionEvent e ) { takeSnapshot ( ) ; 
public void clock ( AlarmClock clock ) { if ( this . clock ! = null ) throw new IllegalStateException ( " The clock had already been set. " ) ; this . clock = clock ; } 
boolean isExecutionSequenceRestarted ( ) { return isExecutionSequenceRestarted ; } 
boolean recover ( long nextExecutionSequence ) throws EOFException , IOException , ClassNotFoundException { preparePendingCommand ( ) ; if ( nextExecutionSequence ! = executionSequence ) return false ; clock . recover ( executionTime ) ; try { pendingCommand . execute ( system ) ; } catch ( Exception e ) { Don't do anything at all now, during recovery. This exception was already treated by the client when it was thrown the first time, during normal system execution. } pendingCommand = null; return true; } 
private void preparePendingCommand ( ) throws EOFException , IOException , ClassNotFoundException { if ( pendingCommand ! = null ) return ; Had already been prepared. try { 
private void abort ( Exception exception ) throws EOFException { out ( " " + exception + " (File: " + logFile + " ) " ) ; out ( " The above is a stream corruption that can be caused by: " ) ; out ( " - A system crash while writing to the commandLog file (that is OK). " ) ; out ( " - A corruption in the file system (that is NOT OK). " ) ; out ( " - Tampering with the commandLog file (that is NOT OK). " ) ; out ( " Looking for the next command... " ) ; throw new EOFException ( ) ; } 
void close ( ) throws IOException { logStream . close ( ) ; } 
static private void out ( String message ) { System . out . println ( message ) ; } 
void writeCommand ( Command command ) throws IOException { objectOutputStream . writeObject ( command ) ; } 
void executionSequence ( long executionTime , long executionSequence ) { this . executionTime = executionTime ; this . executionSequence = executionSequence ; } 
void flushToDisk ( ) throws IOException { objectOutputStream . writeLong ( executionTime ) ; objectOutputStream . writeLong ( executionSequence ) ; flushStreams ( safeCommandLogs ) ; } 
private void flushStreams ( boolean sync ) throws IOException { objectOutputStream . flush ( ) ; if ( sync ) fileOutputStream . getFD ( ) . sync ( ) ; } 
boolean isValid ( ) { return ! isExpired ( ) & & ! isFull ( ) ; } 
private boolean isExpired ( ) { if ( commandLogsThresholdMillis = = 0 ) return false ; return stopWatch . millisEllapsed ( ) > = commandLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( commandLogsThresholdBytes = = 0 ) return false ; return logFile . length ( ) > = commandLogsThresholdBytes ; } 
void close ( ) throws IOException { objectOutputStream . close ( ) ; } 
File directory ( ) { return logFile . getParentFile ( ) ; } 
static private long parseSystemProperty ( String propertyName ) { try { return Long . parseLong ( System . getProperty ( propertyName ) ) ; 
static private boolean safeCommandLogsSystemProperty ( ) { boolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeCommandLogs " ) ) ; safeCommandLogsMessage ( safe ) ; return safe ; } 
static private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost, though. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } lastTimeWasSafe = safe ; } 
static private void out ( Object message ) { System . out . println ( message ) ; } 
tPrevalentSystem recoverSystem ( PrevalentSystem newSystem ) throws ClassNotFoundException , IOException { tSystemRecoverer recoverer = new SystemRecoverer ( snapshotDirectory , commandLogDirectories ) ; tPrevalentSystem system = recoverer . recover ( newSystem ) ; tfileCreator = new FileCreator ( recoverer . nextLogFileNumber ( ) ) ; treturn system ; } 
tCommandLogger availableCommandLogger ( ) throws IOException { tsynchronized ( availableLoggers ) { twhile ( availableLoggers . isEmpty ( ) ) { 
tvoid generateExecutionSequence ( CommandLogger commandLogger , long executionTime ) { tcommandLogger . executionSequence ( executionTime , nextCommandSequence + + ) ; } 
tvoid flushToDisk ( CommandLogger commandLogger ) throws IOException { tcommandLogger . flushToDisk ( ) ; tmakeLoggerAvailable ( commandLogger ) ; } 
tvoid writeSnapshot ( PrevalentSystem system ) throws IOException { tcloseLoggers ( ) ; tFile tempSnapshot = fileCreator . newTempSnapshot ( snapshotDirectory ) ; tObjectOutputStream stream = new ObjectOutputStream ( new FileOutputStream ( tempSnapshot ) ) ; tstream . writeObject ( system ) ; tstream . close ( ) ; tFile snapshot = fileCreator . newSnapshot ( snapshotDirectory ) ; if ( ! tempSnapshot . renameTo ( snapshot ) ) throw new IOException ( " Unable to rename " + tempSnapshot + " to " + snapshot ) ; } 
private void prepareForMyTurn ( Command command ) throws IOException { tcommandExecutionStarting ( ) ; tCommandLogger myCommandLogger = prevalenceBase . availableCommandLogger ( ) ; tmyCommandLogger . writeCommand ( command ) ; } 
public synchronized Date time ( ) { if ( isPaused ) return time ; long currentMillis = currentTimeMillis ( ) ; if ( currentMillis ! = millis ) { set ( new Date ( currentMillis ) ) ; } return time ; } 
synchronized void pause ( ) { if ( isPaused ) throw new IllegalStateException ( " AlarmClock was already paused. " ) ; time ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) throw new IllegalStateException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) throw new IllegalStateException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) throw new IllegalArgumentException ( " AlarmClock's time cannot be set backwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) throw new IllegalArgumentException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
protected long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } 
private void set ( Date time ) { this . time = time ; this . millis = time . getTime ( ) ; } 
static private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } lastTimeWasSafe = safe ; } 
protected void prepare ( ) { tsuper . prepare ( ) ; thalfTheObjects = numberOfObjects / 2 ; } 
protected void executeOperation ( Object connection , long operationSequence ) { tRecord recordToInsert = new Record ( numberOfObjects + operationSequence ) ; tlong idToDelete = spreadId ( operationSequence ) ; tRecord recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( ManipulationConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
private long spreadId ( long id ) { treturn ( id / halfTheObjects ) * halfTheObjects + ((id * 16807) % halfTheObjects); 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 50000, 500000 and 5000000. This guarantees that all ids in the range will be covered. 
tstatic private BigDecimal randomBigDecimal ( ) { treturn new BigDecimal ( random . nextInt ( ) ) ; } 
public boolean hasNext ( ) { treturn nextRecordId < numberOfRecords ; } 
public Record next ( ) { tindicateProgress ( ) ; treturn new Record ( nextRecordId + + ) ; } 
private void indicateProgress ( ) { if ( nextRecordId = = 0 ) { out ( " Creating " + numberOfRecords + " objects... " ) ; treturn ; } if ( nextRecordId % 100000 = = 0 ) out ( " " + nextRecordId + " ... " ) ; } 
tstatic public void main ( String [ ] args ) { out ( " n============================================================= " ) ; out ( " Prevayler vs JDBC Scalability Tests " ) ; out ( " ============================================================= " ) ; out ( " If you have any trouble running the tests, just write to " ) ; out ( " prevayler-scalability@lists.sourceforge.net and we will be glad to help. " ) ; ttry { out ( " Reading the properties file: " + propertiesFile ( ) . getAbsolutePath ( ) ) ; 
tstatic private void runPrevaylerQuery ( ) throws Exception { tnew QueryTestRun ( tnew PrevaylerQuerySubject ( ) , 
tstatic private void runPrevaylerManipulation ( ) throws Exception { tnew ManipulationTestRun ( tnew PrevaylerManipulationSubject ( prevaylerManipulationLogDirectories ( ) ) , 
tstatic private void runJdbcQuery ( ) { tnew QueryTestRun ( tnew JDBCQuerySubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
tstatic private void runJdbcManipulation ( ) { tnew ManipulationTestRun ( tnew JDBCManipulationSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
tstatic private File propertiesFile ( ) throws IOException { tFile result = new File ( " ScalabilityTestProperties.txt " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; tcreatePropertiesFile ( result ) ; } treturn result ; } 
tstatic private void createPropertiesFile ( File file ) throws IOException { tPrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; tstream . println ( " ########################################################### " + 
tstatic private int numberOfObjects ( ) { tString property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; tthrow new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION or TEN_MILLION. " ) ; } 
tstatic private boolean isPrevaylerQueryChosen ( ) { treturn booleanProperty ( " RunPrevaylerQueryTest " ) ; } 
tstatic private int prevaylerQueryThreadsMin ( ) { treturn intProperty ( " PrevaylerQueryThreadsMinimum " ) ; } 
tstatic private int prevaylerQueryThreadsMax ( ) { treturn intProperty ( " PrevaylerQueryThreadsMaximum " ) ; } 
tstatic private boolean isPrevaylerManipulationChosen ( ) { treturn booleanProperty ( " RunPrevaylerManipulationTest " ) ; } 
tstatic private int prevaylerManipulationThreadsMin ( ) { treturn intProperty ( " PrevaylerManipulationThreadsMinimum " ) ; } 
tstatic private int prevaylerManipulationThreadsMax ( ) { treturn intProperty ( " PrevaylerManipulationThreadsMaximum " ) ; } 
tstatic private String [ ] prevaylerManipulationLogDirectories ( ) { out ( " nPrevayler CommandLog Directories: " ) ; tList directories = new ArrayList ( ) ; tint i = 1 ; twhile ( true ) { tString directory = properties . getProperty ( " CommandLogDirectory " + i ) ; if ( directory = = null ) break ; out ( directory ) ; tdirectories . add ( directory ) ; ti + + ; } if ( directories . isEmpty ( ) ) throw new RuntimeException ( " There must be at least one CommandLog directory to run the Prevayler Manipulation Test. " ) ; treturn ( String [ ] ) directories . toArray ( new String [ 0 ] ) ; } 
tstatic private boolean isJdbcQueryChosen ( ) { treturn booleanProperty ( " RunJdbcQueryTest " ) ; } 
tstatic private int jdbcQueryThreadsMin ( ) { treturn intProperty ( " JdbcQueryThreadsMinimum " ) ; } 
tstatic private int jdbcQueryThreadsMax ( ) { treturn intProperty ( " JdbcQueryThreadsMaximum " ) ; } 
tstatic private boolean isJdbcManipulationChosen ( ) { treturn booleanProperty ( " RunJdbcManipulationTest " ) ; } 
tstatic private int jdbcManipulationThreadsMin ( ) { treturn intProperty ( " JdbcManipulationThreadsMinimum " ) ; } 
tstatic private int jdbcManipulationThreadsMax ( ) { treturn intProperty ( " JdbcManipulationThreadsMaximum " ) ; } 
tstatic private String jdbcDriverClassName ( ) { treturn property ( " JdbcDriverClassName " ) ; } 
tstatic private String jdbcConnectionURL ( ) { treturn property ( " JdbcConnectionURL " ) ; } 
tstatic private String jdbcUser ( ) { treturn property ( " JdbcUser " ) ; } 
tstatic private String jdbcPassword ( ) { treturn property ( " JdbcPassword " ) ; } 
tstatic private String property ( String name ) { tString result = properties . getProperty ( name ) ; if ( result = = null ) throw new RuntimeException ( " Property " + name + " not found. " ) ; treturn result ; } 
tstatic private int intProperty ( String name ) { ttry { treturn Integer . valueOf ( property ( name ) ) . intValue ( ) ; 
tstatic private boolean booleanProperty ( String name ) { tboolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return true ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; treturn false ; } 
protected void prepare ( ) { tsubject . replaceAllRecords ( new RecordIterator ( numberOfObjects ) ) ; tSystem . gc ( ) ; } 
private double performRound ( int threads ) { tlong initialOperationCount = operationCount ; tStopWatch stopWatch = StopWatch . start ( ) ; tstartThreads ( threads ) ; tsleep ( ) ; tstopThreads ( ) ; tdouble secondsEllapsed = stopWatch . secondsEllapsed ( ) ; tdouble operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + toResultString ( operationsPerSecond , threads ) ) ; treturn operationsPerSecond ; } 
private void startThread ( ) { ( new Thread ( ) { public void run ( ) { ttry { tObject connection = acquireConnection ( ) ; twhile ( ! isRoundFinished ) { tlong operation ; tsynchronized ( roundMonitor ) { toperation = operationCount ; toperationCount + + ; } texecuteOperation ( connection , operation ) ; } tsynchronized ( roundMonitor ) { tconnectionCache . add ( connection ) ; tactiveRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; tactiveRoundThreads + + ; } 
public void run ( ) { ttry { tObject connection = acquireConnection ( ) ; 
tstatic void outOfMemory ( ) { tSystem . gc ( ) ; out ( " nOutOfMemoryError. " + 
protected String table ( ) { treturn " MANIPULATION_TEST " ; } 
public void flush ( ) throws IOException { tsuper . flush ( ) ; getFD().sync(); "Force all system buffers to synchronize with the underlying device." - JDK1.3 API documentation. } 
public void write ( byte [ ] b ) throws IOException { tsuper . write ( b ) ; tbytesWritten + = b . length ; } 
public void write ( byte [ ] b , int off , int len ) throws IOException { tsuper . write ( b , off , len ) ; tbytesWritten + = len ; } 
public void write ( int b ) throws IOException { tsuper . write ( b ) ; + + bytesWritten ; } 
public PrevalentSystem readLastSnapshot ( ) throws IOException , ClassNotFoundException { tFile snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; out ( snapshotFile ) ; tObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; ttry { return ( PrevalentSystem ) ois . readObject ( ) ; 
public Command readCommand ( ) throws IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; return readCommand(); } 
public CommandOutputStream commandOutputStream ( ) { treturn new CommandOutputStream ( fileFinder . fileCreator ( ) ) ; } 
private ObjectInputStream newLogStream ( ) throws IOException { tFile logFile = fileFinder . nextPendingLog ( ) ; return new ObjectInputStream(new FileInputStream(logFile)); } 
private void logStreamExceptionMessage ( Exception exception ) { out ( " " + exception ) ; out ( " Some commands might have been lost. Looking for the next file... " ) ; } 
private static void out ( File file ) { out ( " Reading " + file + " ... " ) ; } 
private static void out ( Object obj ) { tSystem . out . println ( obj ) ; } 
public void writeCommand ( Command command ) throws IOException { tObjectOutputStream oos = logStream ( ) ; ttry { oos . writeObject ( command ) ; 
public synchronized void writeSnapshot ( PrevalentSystem system ) throws IOException { tcloseLogStream ( ) ; if (!tempSnapshot.renameTo(snapshot)) throw new IOException("Unable to rename " + tempSnapshot + " to " + snapshot); } 
private ObjectOutputStream logStream ( ) throws IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = LOG_FILE_SIZE ) { closeLogStream ( ) ; return logStream ( ) ; } 
private void closeLogStream ( ) throws IOException { if ( logStream = = null ) return ; tlogStream . close ( ) ; tlogStream = null ; } 
File newLog ( ) throws IOException { tFile log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) throw new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; + + nextFileNumber ; treturn log ; } 
File newSnapshot ( ) throws IOException { tFile snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; tsnapshot . delete ( ) ; return snapshot; } 
File newTempSnapshot ( ) throws IOException { treturn File . createTempFile ( " temp " , " generatingSnapshot " , directory ) ; } 
public File nextPendingLog ( ) throws EOFException { tFile log = new File ( directory , NumberFileCreator . LOG_FORMAT . format ( fileNumber + 1 ) ) ; if ( ! log . exists ( ) ) { fileCreator = new NumberFileCreator ( directory , fileNumber + 1 ) ; throw new EOFException ( ) ; } + + fileNumber ; treturn log ; } 
public NumberFileCreator fileCreator ( ) { treturn fileCreator ; } 
private void init ( ) throws IOException { tfindLastSnapshot ( ) ; tfileNumber = lastSnapshot = = null ? 0 
private long number ( File snapshot ) throws NumberFormatException { The following doesn't work! It throws ParseException (UnparseableNumber): return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue(); 
private void findLastSnapshot ( ) throws IOException { tFile [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tArrays . sort ( snapshots ) ; tlastSnapshot = snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
public boolean accept ( File file ) { try { tnumber ( file ) ; } catch ( NumberFormatException nfx ) { treturn false ; } return true ; } 
public synchronized Serializable executeCommand ( Command command ) throws Exception { tclock . pause ( ) ; output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
public synchronized void takeSnapshot ( ) throws IOException { tclock . pause ( ) ; ttry { output . writeSnapshot ( system ) ; 
private void recoverCommands ( CommandInputStream input ) throws IOException , ClassNotFoundException { tCommand command ; twhile ( true ) { ttry { 
public Serializable execute ( PrevalentSystem system ) throws Exception { ( ( SystemClock ) system . clock ( ) ) . recover ( millis ) ; treturn command . execute ( system ) ; } 
public Serializable execute ( PrevalentSystem system ) { treturn ( ( AddingSystem ) system ) . add ( value ) ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) throw new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; tcurrentTimeMillis = newMillis ; } 
protected long currentTimeMillis ( ) { treturn currentTimeMillis ; } 
static public void main ( String [ ] args ) { ttry { header ( " Persistence Test... " ) ; 
static private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
static private void out ( Object obj ) { tSystem . out . println ( obj ) ; } 
static public void run ( ) throws Exception { tclearPrevalenceBase ( ) ; tcrashRecover ( ) ; clearPrevalenceBase(); Check if all files were properly closed and can be deleted. 
static private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; tprevaylers . add ( prevayler ) ; } 
static private void snapshot ( ) throws IOException { out ( " Snapshot. " ) ; tprevayler . takeSnapshot ( ) ; } 
static private void add ( long value , long expectedTotal ) throws Exception { out ( " Adding " + value ) ; tLong total = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; tcompare ( total . longValue ( ) , expectedTotal , " Total " ) ; } 
static private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; tcompare ( system ( ) . total ( ) , expectedTotal , " Total " ) ; } 
static private AddingSystem system ( ) { treturn ( AddingSystem ) prevayler . system ( ) ; } 
static private void clearPrevalenceBase ( ) throws Exception { tIterator it = prevaylers . iterator ( ) ; twhile ( it . hasNext ( ) ) { ( ( SnapshotPrevayler ) it . next ( ) ) . takeSnapshot ( ) ; } 
static private void delete ( File [ ] files ) { tfor ( int i = 0 ; i < files . length ; + + i ) { verify ( files [ i ] . delete ( ) , " Unable to delete " + files [ i ] ) ; 
static private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
static private void verify ( boolean condition , String message ) { if ( ! condition ) { throw new RuntimeException ( message ) ; 
static private void out ( Object obj ) { } static private SnapshotPrevayler prevayler; static private final Set prevaylers = new HashSet(); static private final String prevalenceBase = System.getProperty("user.dir") + "\\prevalenceBase";} 
tstatic private long randomDate ( ) { treturn random . nextInt ( 10000000 ) ; } 
public static void main ( String [ ] args ) throws Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. When you restart the system, you will see that nothing was lost. " ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeFrame ( prevayler ) ; } 
public static void run ( ) throws IOException , ClassNotFoundException , InterruptedException { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2 " ) ; tnew BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 60 * 60 * 24 ) ; 
public static void main ( String [ ] args ) { out ( " Using NullPrevayler. System state will NOT be persisted. " ) ; tnew BankFrame ( new NullPrevayler ( new Bank ( ) ) ) ; } 
public Serializable executeCommand ( Command command ) throws Exception { treturn command . execute ( system ) ; } 
private static AlarmClock defaultClock ( ) { tSystemClock clock = new SystemClock ( ) ; tclock . resume ( ) ; treturn clock ; } 
public static void main ( String [ ] args ) throws Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; tBufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ttry { tString typed = bf . readLine ( ) ; } tcatch ( IOException ioe ) { tioe . printStackTrace ( ) ; } SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
void start ( ) throws Exception { tint largestPrime = 0 ; tint primesFound = 0 ; int primeCandidate = numberKeeper . lastNumber ( ) = = 0 ? 2 : numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
static private long parseSystemProperty ( String propertyName ) { tString property = System . getProperty ( propertyName ) ; if ( property = = null ) return 0 ; try { return Long . parseLong ( property ) ; 
tstatic String snapshotFileName ( long fileNumber ) { tString fileName = " 000000000000000000000 " + fileNumber ; treturn fileName . substring ( fileName . length ( ) - 21 ) + FileCreator . SNAPSHOT_SUFFIX ; } 
tstatic String logFileName ( long fileNumber ) { tString fileName = " 000000000000000000000 " + fileNumber ; treturn fileName . substring ( fileName . length ( ) - 21 ) + FileCreator . LOG_SUFFIX ; } 
tFile newLog ( File directory ) throws IOException { tFile log = new File ( directory , FileCreator . logFileName ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) throw new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; tnextFileNumber + + ; treturn log ; } 
tFile newSnapshot ( File directory ) throws IOException { tFile snapshot = new File ( directory , FileCreator . snapshotFileName ( nextFileNumber - 1 ) ) ; tsnapshot . delete ( ) ; } 
private boolean nextLogFile ( ) throws IOException { tfor ( int i = 0 ; i < commandLogDirectories . length ; i + + ) { tcurrentLogFile = new File ( commandLogDirectories [ i ] , FileCreator . logFileName ( nextLogFileNumber ) ) ; if ( currentLogFile . exists ( ) ) { tnextLogFileNumber + + ; treturn true ; } } treturn false ; } 
tstatic private long number ( File snapshot ) throws NumberFormatException { } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) throws java . io . IOException ; } 
public void execute ( Transaction transaction ) throws java . io . IOException ; } 
public static void main ( String [ ] args ) throws Exception { tprintMessage ( ) ; tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; tnew PrimeCalculator ( prevayler ) . start ( ) ; } 
tstatic private void printMessage ( ) throws Exception { tSystem . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) . readLine ( ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( NumberKeeper ) prevalentSystem ) . keep ( _numberToKeep ) ; } 
tvoid start ( ) throws Exception { tint largestPrime = 0 ; tint primesFound = 0 ; tint primeCandidate = _numberKeeper . lastNumber ( ) = = 0 ? 2 : _numberKeeper . lastNumber ( ) + 1 ; twhile ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
private boolean isPrime ( int candidate ) { tint factor = 2 ; twhile ( factor < candidate ) { if ( candidate % factor = = 0 ) return false ; tfactor + + ; } treturn true ; } 
public static void main ( String [ ] ignored ) throws Exception { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; tnew BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE from the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated tests scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
protected Object executeAndQuery ( Bank bank ) throws Account . InvalidHolder { treturn bank . createAccount ( _holder ) ; } 
protected Object executeAndQuery ( Bank bank ) throws Bank . AccountNotFound { tbank . deleteAccount ( _accountNumber ) ; treturn null ; } 
protected Object executeAndQuery ( Bank bank ) throws Exception { texecuteAndQuery ( bank . findAccount ( _accountNumber ) ) ; treturn null ; } 
protected abstract void executeAndQuery ( Account account ) throws Exception ; } 
public Object executeAndQuery ( Object bank ) throws Exception { treturn executeAndQuery ( ( Bank ) bank ) ; } 
protected abstract Object executeAndQuery ( Bank bank ) throws Exception ; } 
public void executeAndQuery ( Account account ) throws Account . InvalidAmount { taccount . deposit ( _amount ) ; } 
public void executeAndQuery ( Account account ) throws Account . InvalidHolder { taccount . holder ( _newHolder ) ; } 
public Object executeAndQuery ( Bank bank ) throws Exception { tbank . transfer ( _originAccountNumber , _destinationAccountNumber , _amount ) ; treturn null ; } 
public void executeAndQuery ( Account account ) throws Account . InvalidAmount { taccount . withdraw ( _amount ) ; } 
protected void addFields ( Box fieldBox ) { tsuper . addFields ( fieldBox ) ; tfieldBox . add ( gap ( ) ) ; tfieldBox . add ( labelContainer ( " Transaction History " ) ) ; thistoryList = new JList ( ) ; thistoryList . disable ( ) ; tfieldBox . add ( new JScrollPane ( historyList ) ) ; tfieldBox . add ( gap ( ) ) ; tfieldBox . add ( labelContainer ( " Balance " ) ) ; tbalanceField = new JTextField ( ) ; tbalanceField . disable ( ) ; tfieldBox . add ( balanceField ) ; } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; ( new Deposit ( account , amount . longValue ( ) ) ) . executeUsing ( prevayler ) ; } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; ( new Withdrawal ( account , amount . longValue ( ) ) ) . executeUsing ( prevayler ) ; } 
public void accountChanged ( ) { } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; ttry { ( new HolderChange ( account , holderText ( ) ) ) . executeUsing ( prevayler ) ; 
private Bank bank ( ) { treturn ( Bank ) prevayler . prevalentSystem ( ) ; } 
tabstract void action ( Account account ) throws Exception ; } tclass AccountEditAction extends SelectedAccountAction { tAccountEditAction ( ) { tsuper ( " Edit " ) ; } tvoid action ( Account account ) { tnew AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } } tclass AccountDeleteAction extends SelectedAccountAction { tAccountDeleteAction ( ) { tsuper ( " Delete " ) ; } tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; ( new AccountDeletion ( account ) ) . executeUsing ( prevayler ) ; } } } 
tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; ( new AccountDeletion ( account ) ) . executeUsing ( prevayler ) ; } 
protected void action ( ) throws Exception { ( new AccountCreation ( holderText ( ) ) ) . executeUsing ( prevayler ) ; tdispose ( ) ; } 
public void action ( ) throws Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) . executeUsing ( prevayler ) ; dispose ( ) ; } 
tstatic public File produceDirectory ( String directoryName ) throws IOException { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + directoryName ) ; treturn directory ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { treturn _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public long objectCount ( ) throws IOException , ClassNotFoundException { tlong result = 0 ; twhile ( true ) { ttry { 
public void close ( ) throws IOException { t_delegate . close ( ) ; t_EOF = true ; } 
private void message ( Exception exception ) { tSystem . out . println ( " " + exception + " (File: " + _file + " ) " + 
public void writeObject ( Object object ) throws IOException { t_delegate . writeObject ( object ) ; } 
public void sync ( ) throws IOException { t_fileDescriptor . sync ( ) ; } 
public void close ( ) throws IOException { t_delegate . close ( ) ; t_isValid = false ; } 
tvoid writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = File . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " , directory ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; } 
protected void writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws IOException { tSimpleOutputStream stream = new SimpleOutputStream ( snapshotFile ) ; tstream . writeObject ( prevalentSystem ) ; tstream . close ( ) ; } 
tlong latestVersion ( ) throws IOException { tString [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tlong result = 0 ; tfor ( int i = 0 ; i < fileNames . length ; i + + ) { tlong candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } treturn result ; } 
tObject readSnapshot ( Object initialVersion , long version ) throws ClassNotFoundException , IOException { if ( version = = 0 ) return initialVersion ; tFile snapshotFile = snapshotFile ( version ) ; treturn readSnapshot ( snapshotFile ) ; } 
protected Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { tSimpleInputStream ois = new SimpleInputStream ( snapshotFile ) ; ttry { treturn ois . readObject ( ) ; } finally { ois . close ( ) ; } } 
private File snapshotFile ( long version ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; } 
public Object prevalentSystem ( ) { treturn _prevalentSystem ; } 
public void takeSnapshot ( ) throws IOException { tsynchronized ( _subscriber ) { t_snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void execute ( Transaction transaction ) { t_publisher . publish ( transaction ) ; } 
private TransactionSubscriber subscriber ( ) { treturn new TransactionSubscriber ( ) { public synchronized void receive ( Transaction transaction ) { 
public synchronized void receive ( Transaction transaction ) { t_systemVersion + + ; ttransaction . executeOn ( _prevalentSystem ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void publish ( Transaction transaction ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransactionIgnored ) throws IOException , ClassNotFoundException { t_subscribers . add ( subscriber ) ; } 
public void publish ( Transaction transaction ) { tIterator i = _subscribers . iterator ( ) ; twhile ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transaction ) ; } 
public synchronized void publish ( Transaction transaction ) { if ( ! _nextTransactionKnown ) throw new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; ttry { _outputLog . writeObject ( transaction ) ; _outputLog . sync ( ) ; } catch ( IOException iox ) { thandleExceptionWhileWriting ( iox , _outputLog . file ( ) , transaction , _nextTransaction ) ; } t_nextTransaction + + ; tsuper . publish ( transaction ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { t_nextTransaction = initialTransaction ; t_nextTransactionKnown = true ; } else { if ( initialTransaction > _nextTransaction ) throw new IOException ( " Unable to find transactions from " + _nextTransaction + " to " + ( initialTransaction - 1 ) + " . " ) ; tlong initialFileCandidate = initialTransaction ; twhile ( ! transactionLogFile ( initialFileCandidate ) . exists ( ) ) { tinitialFileCandidate - - ; if ( initialFileCandidate < = 0 ) throwNotFound ( initialTransaction ) ; } tupdate ( subscriber , initialTransaction , initialFileCandidate ) ; } tsuper . addSubscriber ( subscriber , - 1 ) ; } 
private File lastTransactionFile ( ) throws IOException { tFile [ ] files = _directory . listFiles ( this ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; if ( files . length = = 0 ) return null ; treturn ( File ) Collections . max ( Arrays . asList ( files ) ) ; } 
public boolean accept ( File file ) { tString name = file . getName ( ) ; if ( ! name . endsWith ( " .transactionLog " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; ttry { tnumber ( file ) ; } catch ( RuntimeException r ) { return false ; } treturn true ; } 
tstatic private long number ( File file ) { treturn Long . parseLong ( file . getName ( ) . substring ( 0 , 19 ) ) ; } 
private void createNewOutputLog ( ) { tFile file = transactionLogFile ( _nextTransaction ) ; ttry { _outputLog = new SimpleOutputStream ( file ) ; 
private File transactionLogFile ( long transaction ) { tString fileName = " 0000000000000000000 " + transaction ; tfileName = fileName . substring ( fileName . length ( ) - 19 ) + " .transactionLog " ; treturn new File ( _directory , fileName ) ; } 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) throws IOException , ClassNotFoundException { tlong recoveringTransaction = initialFile ; tSimpleInputStream inputLog = new SimpleInputStream ( transactionLogFile ( recoveringTransaction ) ) ; twhile ( recoveringTransaction < _nextTransaction ) { ttry { 
tstatic private void throwNotFound ( long transaction ) throws IOException { tthrow new IOException ( " Unable to find transactionLog file containing transaction " + transaction ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Transaction transaction , long transactionNumber ) { thang ( iox , " nThe exception above was thrown while trying to write transaction " + transactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and stop all transaction logging. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Transaction transaction, long transactionNumber). " ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { thang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and stop all transaction logging. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
tstatic private void hang ( IOException iox , String message ) { tiox . printStackTrace ( ) ; tSystem . out . println ( message ) ; twhile ( true ) Thread . yield ( ) ; } 
public void run ( ) { ttry { twhile ( true ) new RemoteConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public void run ( ) { ttry { tlong initialTransaction = ( ( Long ) _fromRemote . readObject ( ) ) . longValue ( ) ; 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteTransaction = ( Transaction ) _fromRemote . readObject ( ) ; t_publisher . publish ( _remoteTransaction ) ; } 
public void receive ( Transaction transaction ) { tsend ( transaction = = _remoteTransaction ? ( Object ) Protocol . REMOTE_TRANSACTION 
private void send ( Object message ) { ttry { t_toRemote . writeObject ( message ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; tsynchronized ( _subscriberUpToDateMonitor ) { t_toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public synchronized void publish ( Transaction transaction ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, the RemoteTransactionPublisher needs a registered subscriber. " ) ; tsynchronized ( _myTransactionMonitor ) { t_myTransaction = transaction ; 
public void run ( ) { ttry { twhile ( true ) receiveTransactionFromServer ( ) ; 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( Protocol . TRANSACTIONS_UP_TO_DATE ) ) { notify ( _subscriberUpToDateMonitor ) ; treturn ; } if ( transactionCandidate . equals ( Protocol . REMOTE_TRANSACTION ) ) { tsynchronized ( _myTransactionMonitor ) { t_subscriber . receive ( _myTransaction ) ; notify ( _myTransactionMonitor ) ; } treturn ; } t_subscriber . receive ( ( Transaction ) transactionCandidate ) ; } 
private static void wait ( Object monitor ) { ttry { tmonitor . wait ( ) ; 
private static void notify ( Object monitor ) { tsynchronized ( monitor ) { monitor . notify ( ) ; } } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; } 
tstatic public void main ( String [ ] args ) throws Exception { } 
tstatic private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
tstatic public void run ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
tstatic private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
tstatic private void add ( long value , long expectedTotal ) throws Exception { out ( " Adding " + value ) ; tprevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
tstatic private AddingSystem system ( ) { treturn ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
tstatic private String prevalenceBase ( ) { treturn prevalenceBase ; } 
tstatic private void newPrevalenceBase ( ) throws Exception { tprevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
tstatic private void out ( Object obj ) { }} 
public boolean accept ( File directory , String filename ) { treturn filename . endsWith ( " transactionLog " ) | | filename . endsWith ( " snapshot " ) ; 
tstatic private void runPrevaylerTransaction ( ) throws Exception { tnew TransactionTestRun ( tnew PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerTransactionLogs ( ) ) , 
tstatic private void runJdbcTransaction ( ) { tnew TransactionTestRun ( tnew JDBCTransactionSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
tstatic private int numberOfObjects ( ) { tString property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; tthrow new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; } 
tstatic private boolean isPrevaylerTransactionChosen ( ) { treturn booleanProperty ( " RunPrevaylerTransactionTest " ) ; } 
tstatic private int prevaylerTransactionThreadsMin ( ) { treturn intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; } 
tstatic private int prevaylerTransactionThreadsMax ( ) { treturn intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; } 
tstatic private String prevaylerTransactionLogDirectory ( ) { tString result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; treturn result ; } 
tstatic private int prevaylerTransactionLogs ( ) { treturn prevaylerTransactionThreadsMax ( ) ; } 
tstatic private boolean isJdbcTransactionChosen ( ) { treturn booleanProperty ( " RunJdbcTransactionTest " ) ; } 
tstatic private int jdbcTransactionThreadsMin ( ) { treturn intProperty ( " JdbcTransactionThreadsMinimum " ) ; } 
tstatic private int jdbcTransactionThreadsMax ( ) { treturn intProperty ( " JdbcTransactionThreadsMaximum " ) ; } 
private double performRound ( int threads ) { tlong initialOperationCount = operationCount ; tStopWatch stopWatch = StopWatch . start ( ) ; tstartThreads ( threads , initialOperationCount ) ; tsleep ( ) ; tstopThreads ( ) ; tdouble secondsEllapsed = stopWatch . secondsEllapsed ( ) ; tdouble operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + toResultString ( operationsPerSecond , threads ) ) ; treturn operationsPerSecond ; } 
private void startThreads ( int threads , long initialOperationCount ) { tisRoundFinished = false ; tint i = 1 ; twhile ( i < = threads ) { tstartThread ( initialOperationCount + i , threads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { ttry { tObject connection = acquireConnection ( ) ; tlong operation = startingOperation ; twhile ( ! isRoundFinished ) { texecuteOperation ( connection , operation ) ; toperation + = operationIncrement ; } tsynchronized ( connectionCache ) { tconnectionCache . add ( connection ) ; toperationCount + = ( operation - startingOperation ) / operationIncrement ; tactiveRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; tactiveRoundThreads + + ; } 
private Object acquireConnection ( ) { tsynchronized ( connectionCache ) { treturn connectionCache . isEmpty ( ) 
protected void executeOperation ( Object connection , long operationSequence ) { tRecord recordToInsert = new Record ( numberOfObjects + operationSequence ) ; tlong idToDelete = spreadId ( operationSequence ) ; tRecord recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( TransactionConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
protected String table ( ) { treturn " TRANSACTION_TEST " ; } 
public Object createTestConnection ( ) { treturn new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( Object system ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; } 
public Object createTestConnection ( ) { treturn new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . prevalentSystem ( ) ) ; } 
public Object createTestConnection ( ) { treturn new PrevaylerTransactionConnection ( prevayler ) ; } 
public void executeOn ( Object system ) { ( ( TransactionSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
tvoid advanceTo ( Date newTime ) { if ( newTime . getTime ( ) < _time . getTime ( ) ) throw new RuntimeException ( " Attempt to set Clock to the past. From: " + _time + " to: " + newTime ) ; t_time = newTime ; } 
public Object executeUsing ( Prevayler prevayler ) throws Exception { tprevayler . execute ( this ) ; if ( _exception ! = null ) throw _exception ; treturn _result ; } 
public void executeOn ( Object prevalentSystem ) { ttry { t_result = executeAndQuery ( prevalentSystem ) ; 
protected abstract Object executeAndQuery ( Object prevalentSystem ) throws Exception ; } 
void write ( Transaction transaction ) throws IOException { _objectOutputStream . writeObject ( transaction ) ; } 
void stamp ( long executionTime , long sequence ) { _executionTime = executionTime . getTime ( ) ; _executionSequence = executionSequence ; } 
void sync ( ) throws IOException { _objectOutputStream . writeLong ( executionTime ) ; _objectOutputStream . writeLong ( executionSequence ) ; _flushStreams ( safeTransactionLogs ) ; } 
private void flushStreams ( boolean sync ) throws IOException { _objectOutputStream . flush ( ) ; if ( sync ) _fileOutputStream . getFD ( ) . sync ( ) ; } 
private boolean isExpired ( ) { if ( _transactionLogsThresholdMillis = = 0 ) return false ; return stopWatch . millisEllapsed ( ) > = _transactionLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( _transactionLogsThresholdBytes = = 0 ) return false ; return _logFile . length ( ) > = _transactionLogsThresholdBytes ; } 
void close ( ) throws IOException { _objectOutputStream . close ( ) ; } 
File directory ( ) { return _logFile . getParentFile ( ) ; } 
static private boolean safeTransactionLogsSystemProperty ( ) { boolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeTransactionLogs " ) ) ; safeTransactionLogsMessage ( safe ) ; return safe ; } 
static private void safeTransactionLogsMessage ( boolean safe ) { if ( ! safe & & _lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeTransactionLogs system property is OFF. " ) ; out ( " Writes to the transactionLog files will be cached for greater performance. In the event of a system crash, some of the last executed transactions might be lost. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! _lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeTransactionLogs system property is ON. " ) ; out ( " Writes to the transactionLog files will be flushed to the underlying device before each transaction is executed. " ) ; out ( " ===================================== " ) ; } _lastTimeWasSafe = safe ; } 
tTransactionLogger availableTransactionLogger ( ) throws IOException { tsynchronized ( _availableLoggers ) { twhile ( _availableLoggers . isEmpty ( ) ) { 
private void waitForAvailableLogger ( ) { ttry { t_availableLoggers . wait ( ) ; 
private void createLoggers ( ) throws IOException { tcreateLogger ( _transactionLogDirectory , true ) ; tfor ( int i = 2 ; i < = _transactionLogs ; i + + ) { tcreateLogger ( _transactionLogDirectory , false ) ; } t_loggersCreated = true ; } 
private void createLogger ( File directory , boolean sequenceRestarted ) throws IOException { tFile logFile = new File ( directory , logFileName ( 444 ) ) ; if ( ! logFile . createNewFile ( ) ) throw new IOException ( " Attempt to create transaction log file that already existed: " + logFile ) ; ; t_availableLoggers . add ( new TransactionLogger ( logFile , sequenceRestarted ) ) ; } 
tstatic String logFileName ( long fileNumber ) { tString fileName = " 000000000000000000000 " + fileNumber ; treturn fileName . substring ( fileName . length ( ) - 21 ) + " .transactionLog " ; } 
tvoid flushToDisk ( TransactionLogger transactionLogger ) throws IOException { ttransactionLogger . flushToDisk ( ) ; tmakeLoggerAvailable ( transactionLogger ) ; } 
private void makeLoggerAvailable ( TransactionLogger transactionLogger ) throws IOException { tsynchronized ( _availableLoggers ) { if ( transactionLogger . isValid ( ) ) { 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) throw new IllegalArgumentException ( " Clock's time can only be set forwards. " ) ; tcurrentTimeMillis = newMillis ; } 
tstatic private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tclockMock = new ClockMock ( clockMock . currentTimeMillis ( ) ) ; } 
tstatic private void setTime ( long newTime ) throws Exception { out ( " Setting time: " + newTime ) ; tclockMock . currentTimeMillis ( newTime ) ; tprevayler . executeCommand ( new NullCommand ( ) ) ; } 
tvoid startClock ( ) { tThread clockDaemon = new Thread ( ) { public void run ( ) { twhile ( true ) { ttry { tThread . sleep ( 1 ) ; } catch ( InterruptedException i ) { tthrow new RuntimeException ( " Unexpected interruption. " ) ; } ( ( ClockedSystem ) _prevayler . system ( ) ) . advanceClockTo ( _realClock . time ( ) ) ; } } } ; tclockDaemon . setDaemon ( true ) ; tclockDaemon . start ( ) ; } 
public void snapshotStarted ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the exception was: " + exception ) ; } 
public void snapshotError ( Prevayler prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void run ( ) { tsnapshotStarted ( ) ; ttry { tprevayler . takeSnapshot ( ) ; } catch ( Exception e ) { } 
public boolean cancel ( ) { tsnapshotShutdown ( ) ; treturn super . cancel ( ) ; } 
public void removeListener ( Listener listener ) { tlistenerList . remove ( listener ) ; } 
public void addListener ( Listener listener ) { tlistenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { tlong prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; tlong systemDate = System . currentTimeMillis ( ) ; tIterator i = listenerList . iterator ( ) ; twhile ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { tlong prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; tlong systemDate = System . currentTimeMillis ( ) ; tIterator i = listenerList . iterator ( ) ; twhile ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { tlong prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; tlong systemDate = System . currentTimeMillis ( ) ; tIterator i = listenerList . iterator ( ) ; twhile ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { tlong prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; tlong systemDate = System . currentTimeMillis ( ) ; tIterator i = listenerList . iterator ( ) ; twhile ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { tlong prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; tlong systemDate = System . currentTimeMillis ( ) ; tIterator i = listenerList . iterator ( ) ; twhile ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
tvoid advanceTo ( long newMillis ) { if ( newMillis < _millis ) throw new RuntimeException ( " Attempt to set Clock to the past. From: " + _time + " back to: " + new Date ( newMillis ) ) ; if ( newMillis = = _millis ) return ; t_millis = newMillis ; t_time = new Date ( _millis ) ; } 
public void takeSnapshot ( ) throws IOException { synchronized ( subscriber ) { lastSnapshot = systemVersion ; 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { public synchronized void receive ( Transaction transaction ) { 
public synchronized void receive ( Transaction transaction ) { systemVersion + + ; transaction . executeOn ( slave ) ; } 
public Object prevalentSystem ( ) { return slave ; } 
public void execute ( Transaction transaction ) throws IOException { Exception error = null ; boolean doCommit ; try { transaction . executeOn ( master ) ; doCommit = true ; } catch ( Exception e ) { doCommit = false ; error = e ; } if ( transaction instanceof RollbackTransaction ) { RollbackTransaction rollbackTransaction = ( RollbackTransaction ) transaction ; if ( rollbackTransaction . isRollbackOnly ( ) ) { doCommit = false ; } } if ( doCommit ) { transactionPublisher . publish ( transaction ) ; 
private void doRollback ( ) { master = slave ; try { slave = snapshotManager . readSnapshot ( slave , lastSnapshot ) ; 
tstatic public void main ( String [ ] args ) throws Exception { } 
public boolean isRollbackOnly ( ) { return rollbackOnly ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; setRollbackOnly ( ) ; } 
public static void run ( ) throws Exception { prevaylerBase = prevaylerBase ( ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; try { addRollback ( 30 , 30 ) ; throw new RuntimeException ( " Exception expected " ) ; } catch ( TransactionRolledbackException e ) { } add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; verify ( 60 ) ; try { addRollback ( 30 , 50 ) ; throw new RuntimeException ( " Exception expected " ) ; } catch ( TransactionRolledbackException e ) { } add ( 10 , 70 ) ; } 
private static void addRollback ( int value , int expectedTotal ) throws Exception { prevayler . execute ( new RollbackAddition ( value ) ) ; verify ( expectedTotal ) ; } 
static private void add ( long value , long expectedTotal ) throws Exception { prevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
private static void verify ( long expectedTotal ) { if ( expectedTotal ! = system ( ) . total ( ) ) { throw new RuntimeException ( " Expected " + expectedTotal + " but was " + system ( ) . total ( ) ) ; 
private static AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
private static String prevaylerBase ( ) { return " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) ; } 
public static void main ( String [ ] ignored ) throws Exception { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; tnew ClockActor ( prevayler ) ; tnew BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE from the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public synchronized void receive ( Transaction transaction ) { systemVersion + + ; transaction . executeOn ( king ) ; } 
public Object prevalentSystem ( ) { return king ; } 
public void execute ( Transaction transaction ) { try { transaction . executeOn ( foodTaster ) ; 
private void doRollback ( ) { foodTaster = king ; try { king = snapshotManager . readSnapshot ( king , lastSnapshot ) ; 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Transaction transaction , long transactionNumber ) { thang ( iox , " nThe exception above was thrown while trying to write transaction " + transactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Transaction transaction, long transactionNumber). " ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { thang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
tstatic public void main ( String [ ] args ) throws Exception { theader ( " RollbackTest... " ) ; tRollbackTest . run ( ) ; theader ( " PersistenceTest... " ) ; tPersistenceTest . run ( ) ; theader ( " S U C C E S S ! ! ! Can't you think of any more tests? " ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; throw new RuntimeException ( " Testing Rollback " ) ; } 
public static void run ( ) throws Exception { prevaylerBase = prevaylerBase ( ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; verify ( 60 ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
private static void addRollback ( int value , int expectedTotal ) throws Exception { tboolean isThrown = false ; ttry { prevayler . execute ( new RollbackAddition ( value ) ) ; } catch ( RuntimeException e ) { tisThrown = true ; } if ( ! isThrown ) throw new RuntimeException ( " RuntimeException expected and not thrown. " ) ; verify ( expectedTotal ) ; } 
tstatic private File propertiesFile ( ) throws IOException { tFile result = new File ( " ScalabilityTest.properties " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; tcreatePropertiesFile ( result ) ; } treturn result ; } 
private void startThreads ( int threads ) { tisRoundFinished = false ; tint i = 1 ; twhile ( i < = threads ) { tstartThread ( lastOperation + i , threads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { ttry { tObject connection = acquireConnection ( ) ; tlong operation = startingOperation ; twhile ( ! isRoundFinished ) { texecuteOperation ( connection , operation ) ; toperation + = operationIncrement ; } tsynchronized ( connectionCache ) { tconnectionCache . add ( connection ) ; toperationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; tactiveRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; tactiveRoundThreads + + ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { tsynchronized ( recordsById ) { tput ( recordToInsert ) ; 
private Object put ( Record newRecord ) { tObject key = new Long ( newRecord . getId ( ) ) ; treturn recordsById . put ( key , newRecord ) ; } 
private void verify ( boolean condition ) { if ( ! condition ) System . out . println ( " Assertion failed. " ) ; } 
tsynchronized void advanceTo ( Date newTime ) { tlong newMillis = newTime . getTime ( ) ; if ( newMillis < = _millis ) throw new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; t_millis = newMillis ; t_time = newTime ; } 
private void tick ( ) { tDate newTime = _clock . time ( ) ; if ( newTime = = _lastTime ) return ; t_lastTime = newTime ; t_prevayler . execute ( new ClockTick ( newTime ) ) ; } 
public void executeOn ( Object system ) { ( ( ClockedSystem ) system ) . advanceClockTo ( _newTime ) ; } 
tvoid advanceClockTo ( Date newTime ) { t_brokenClock . advanceTo ( newTime ) ; } 
public Date time ( ) { tupdate ( ) ; treturn super . time ( ) ; } 
private void update ( ) { tlong newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public Serializable execute ( MementoCollector collector , PrevalentSystem system ) throws Exception { findObjects ( system ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( PrevalentSystem system ) throws Exception ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void checkPrecondition ( ) throws Exception ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( MementoCommand command ) throws Exception ; } 
public Serializable executeCommand ( MementoCommand command ) throws Exception ; } 
public void restore ( ) { Account . this . holder = holder ; Account . this . balance = balance ; Account . this . transactionHistory . clear ( ) ; Account . this . transactionHistory . addAll ( transactionHistory ) ; } 
public void createMemento ( MementoCollector collector ) { collector . addMemento ( new AccountMemento ( ) ) ; } 
public String toString ( ) { } 
public void restore ( ) { Bank . this . nextAccountNumber = nextAccountNumber ; Bank . this . accountsByNumber . clear ( ) ; Bank . this . accountsByNumber . putAll ( accountsByNumber ) ; } 
public void createMemento ( MementoCollector collector ) { collector . addMemento ( new BankMemento ( ) ) ; } 
public String toString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . toString ( ) ; } 
private static Serializable execute ( MementoCommand command ) { try { return prevayler . executeCommand ( command ) ; } catch ( Exception exception ) { out ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { out ( bank . toString ( ) ) ; } return null ; } 
private static void out ( String message ) { System . out . println ( message ) ; } 
protected void findObjects ( Bank bank ) throws Exception { account = bank . findAccount ( accountNumber ) ; } 
protected final void createMementosAfterBank ( MementoCollector collector ) { account . createMemento ( collector ) ; } 
protected Serializable execute ( Bank bank ) throws Exception { texecute ( account ) ; treturn null ; } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected Serializable execute ( Bank bank ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } } 
protected Serializable execute ( MementoCollector collector ) throws Exception { treturn execute ( bank ) ; } 
protected abstract Serializable execute ( Bank bank ) throws Exception ; protected final void findObjects ( PrevalentSystem system ) throws Exception { bank = ( Bank ) system ; findObjects ( bank ) ; } protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected final void findObjects ( PrevalentSystem system ) throws Exception { bank = ( Bank ) system ; findObjects ( bank ) ; } 
protected abstract void findObjects ( Bank bank ) throws Exception ; protected final void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; createMementosAfterBank ( collector ) ; } protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected final void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; createMementosAfterBank ( collector ) ; } 
protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) throws Account . InvalidAmount { taccount . deposit ( amount ) ; } } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) throws Account . InvalidHolder { taccount . holder ( newHolder ) ; } } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
public java . io . Serializable execute ( Bank bank ) throws Exception { bank . transfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) throws Account . InvalidAmount { taccount . withdraw ( amount ) ; } } 
public void execute ( Account account ) throws Account . InvalidAmount { taccount . withdraw ( amount ) ; } 
protected void findObjects ( PrevalentSystem system ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = ( ( Bank ) system ) . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . deposit ( amount ) ; return null ; } 
protected void findObjects ( PrevalentSystem system ) throws Exception { bank = ( Bank ) system ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) throws Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) throws Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) throws Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( PrevalentSystem system ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = ( ( Bank ) system ) . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } if ( account . balance ( ) < amount ) { throw account . new InvalidAmount ( " Can not withdraw more than the balance " ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . withdraw ( amount ) ; return null ; } 
public MementoCommand readCommand ( ) throws IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; return readCommand(); } 
public void writeCommand ( MementoCommand command ) throws IOException { tObjectOutputStream oos = logStream ( ) ; ttry { oos . writeObject ( command ) ; 
public synchronized Serializable executeCommand ( MementoCommand command ) throws Exception { tclock . pause ( ) ; output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
public void addMemento ( Memento memento ) { mementos . add ( memento ) ; } 
private void recoverCommands ( CommandInputStream input ) throws IOException , ClassNotFoundException { tMementoCommand command ; twhile ( true ) { ttry { 
protected Serializable execute ( MementoCollector collector ) throws Exception { ( ( SystemClock ) system . clock ( ) ) . recover ( millis ) ; treturn command . execute ( collector , system ) ; } 
protected void findObjects ( PrevalentSystem system ) { this . system = system ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } } 
protected void createMementos ( MementoCollector collector ) { } } 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return true ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return true ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " There's a 50% chance of some transactions failing AFTER the system has been modified. " + " This will result in the state of the system being roll backed to the state before the transaction started. " ) ; tRollbackPrevayler prevayler = new RollbackPrevayler ( new RollbackBank ( ) , " demo2Acid " ) ; tnew ClockActor ( prevayler ) ; tnew BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public Account createAccount ( String holder ) throws Account . InvalidHolder { Account account = super . createAccount ( holder ) ; maybeFail ( ) ; return account ; } 
public void deleteAccount ( long number ) throws Bank . AccountNotFound { super . deleteAccount ( number ) ; maybeFail ( ) ; } 
public void transfer ( long sourceNumber , long destinationNumber , long amount ) throws Bank . AccountNotFound , Account . InvalidAmount { super . transfer ( sourceNumber , destinationNumber , amount ) ; maybeFail ( ) ; } 
public Object prevalentSystem ( ) { return king ( ) ; } 
private Object king ( ) { return _prevalentSystem ; } 
public void execute ( Transaction transaction ) { try { transaction . executeOn ( foodTaster ) ; 
private void doRollback ( ) { try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
tvoid writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { writeSnapshot ( prevalentSystem , out ) ; 
protected void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { ObjectOutputStream stream = new ObjectOutputStream ( out ) ; stream . writeObject ( prevalentSystem ) ; } 
tObject readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return readSnapshot ( in ) ; 
protected Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; return ois . readObject ( ) ; } 
private File snapshotFile ( long version ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
public Object executeUsing ( Prevayler prevayler ) throws Exception { try { prevayler . execute ( this ) ; } catch ( Exception e ) { } if ( _exception ! = null ) throw _exception ; treturn _result ; } 
public Object executeUsing ( Prevayler prevayler ) throws Exception { tprevayler . execute ( this ) ; if ( _exception ! = null ) throw _exception ; treturn _result ; } 
public void test ( ) throws Exception { Main . main ( new String [ 0 ] ) ; } 
protected void restore ( ) { Account . this . holder = holder ; Account . this . balance = balance ; Account . this . transactionHistory . clear ( ) ; Account . this . transactionHistory . addAll ( transactionHistory ) ; } 
public void holder ( String holder ) throws InvalidHolder { verify ( holder ) ; tthis . holder = holder ; } 
private void register ( long amount ) { tbalance + = amount ; transactionHistory . add ( new Transaction ( amount ) ) ; } 
protected void restore ( ) { Bank . this . nextAccountNumber = nextAccountNumber ; Bank . this . accountsByNumber . clear ( ) ; Bank . this . accountsByNumber . putAll ( accountsByNumber ) ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { tAccount account = new Account ( nextAccountNumber , holder , clock ( ) ) ; taccountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; treturn account ; } 
public void deleteAccount ( long number ) throws AccountNotFound { taccountsByNumber . remove ( new Long ( number ) ) ; } 
public static void run ( ) throws IOException , ClassNotFoundException { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = ( Account ) execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = ( Account ) execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . takeSnapshot ( ) ; } 
private static Object execute ( MementoTransaction command ) { try { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . toString ( ) ) ; } return null ; } 
protected void findObjects ( Object prevalentSystem ) { bank = ( Bank ) prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Serializable execute ( MementoCollector collector ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Serializable execute ( MementoCollector collector ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } } 
protected Serializable execute ( MementoCollector collector ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } 
protected void findObjects ( Object prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = ( ( Bank ) prevalentSystem ) . findAccount ( accountNumber ) ; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . deposit ( amount ) ; System . out . println ( " * Deposited " + amount + " into account " + account . numberString ( ) ) ; return null ; } 
protected void findObjects ( Object prevalentSystem ) throws Exception { bank = ( Bank ) prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Object prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = ( ( Bank ) prevalentSystem ) . findAccount ( accountNumber ) ; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . withdraw ( amount ) ; System . out . println ( " * Withdrew " + amount + " from account " + account . numberString ( ) ) ; return null ; } 
public int hashCode ( ) { return System . identityHashCode ( getOwner ( ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem ) throws Exception { tmementos = new HashMap ( ) ; ttry { treturn transaction . execute ( this , prevalentSystem ) ; 
public Serializable execute ( MementoCollector collector , Object prevalentSystem ) throws Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Object prevalentSystem ) throws Exception ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void checkPrecondition ( ) throws Exception ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
protected abstract Serializable execute ( MementoCollector collector ) throws Exception ; } 
public static void usage ( ) { tSystem . out . println ( " Usage: Main <list|proj|task|snap> <parameters> " + " Parameters: " + " list: <xpath expression> " + " proj: <id> <name> " + " task: <id> <name> <start> <end> <projectId> " + " snap " + " Note: dates should be entered in a locale-sensitive format (your locale is " + System . getProperty ( " user.language " ) + " _ " + System . getProperty ( " user.country " ) + " ). " ) ; tSystem . exit ( 0 ) ; } 
private static void list ( SnapshotPrevayler prevayler , String xpathExp ) { tSystem . out . println ( " Executing XPath expression... " ) ; tProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; tJXPathContext context = JXPathContext . newContext ( pms ) ; tIterator i = context . iterate ( xpathExp ) ; twhile ( i . hasNext ( ) ) { 
private static void addProject ( tSnapshotPrevayler prevayler , tString id , tString name ) tthrows Exception { tSystem . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; tProject p = new Project ( ) ; tp . setId ( Integer . parseInt ( id ) ) ; tp . setName ( name ) ; tAddProject cmd = new AddProject ( ) ; tcmd . setProject ( p ) ; tprevayler . execute ( cmd ) ; } 
private static void addTask ( tSnapshotPrevayler prevayler , tString id , tString name , tString start , tString end , tString projectId ) tthrows Exception { tSystem . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; tTask = new Task ( ) ; tt . setId ( Integer . parseInt ( id ) ) ; tt . setName ( name ) ; tt . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; tt . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; tSystem . out . println ( " Start: " + . getStart ( ) ) ; tSystem . out . println ( " End: " + . getEnd ( ) ) ; tAddTask cmd = new AddTask ( ) ; tcmd . setTask ( ) ; tcmd . setProjectId ( Integer . parseInt ( projectId ) ) ; tprevayler . execute ( cmd ) ; } 
public void executeOn ( Object system ) { if ( project ! = null ) { tProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public void executeOn ( Object system ) { if ( task ! = null & & projectId ! = Integer . MIN_VALUE ) { tProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; return suite ; } 
tstatic public void main ( String [ ] args ) throws Exception { TestResult testResult = new TestResult ( ) ; testResult . addListener ( new ResultPrinter ( System . out ) ) ; AllTestSuite . suite ( ) . run ( testResult ) ; } 
public void testPersistence ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
private void snapshot ( ) throws IOException { out ( " Snapshot. " ) ; tprevayler . takeSnapshot ( ) ; } 
private void add ( long value , long expectedTotal ) throws Exception { out ( " Adding " + value ) ; tprevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; tcompare ( system ( ) . total ( ) , expectedTotal , " Total " ) ; } 
private AddingSystem system ( ) { treturn ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
private String prevalenceBase ( ) { treturn prevalenceBase ; } 
private void newPrevalenceBase ( ) throws Exception { tprevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
public static void deletePrevalenceFiles ( String directoryName ) { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; tFile [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; tfor ( int i = 0 ; i < files . length ; + + i ) { out ( " Deleting: " + files [ i ] ) ; 
private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
private static void verify ( boolean condition , String message ) { if ( ! condition ) { tthrow new RuntimeException ( message ) ; 
private static void out ( Object obj ) { }} 
protected void setUp ( ) throws Exception { super . setUp ( ) ; File tempFile = File . createTempFile ( " Prevalence " , " Base " ) ; tempFile . delete ( ) ; tempFile . mkdirs ( ) ; tempFile . deleteOnExit ( ) ; prevaylerBase = tempFile . getAbsolutePath ( ) ; } 
protected void tearDown ( ) throws Exception { delete ( prevaylerBase ) ; } 
public void testRollback ( ) throws Exception { prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; assertEquals ( 60 , system ( ) . total ( ) ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
private void addRollback ( int value , int expectedTotal ) throws Exception { tboolean isThrown = false ; ttry { prevayler . execute ( new RollbackAddition ( value ) ) ; } catch ( RuntimeException e ) { tisThrown = true ; } if ( ! isThrown ) throw new RuntimeException ( " RuntimeException expected and not thrown. " ) ; assertEquals ( expectedTotal , system ( ) . total ( ) ) ; } 
private void add ( long value , long expectedTotal ) throws Exception { prevayler . execute ( new Addition ( value ) ) ; assertEquals ( expectedTotal , system ( ) . total ( ) ) ; } 
private AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
public static void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
public static void delete ( File file ) { if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { File sub = files [ i ] ; delete ( sub ) ; } } } file . delete ( ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { targetPublisher . addSubscriber ( subscriber , initialTransaction ) ; } 
public void publish ( Transaction transaction ) { try { transaction . executeOn ( foodTaster ) ; 
public void initKing ( Object king ) { this . king = king ; doRollback ( ) ; } 
public long transactionCount ( ) { return _systemVersion ; } 
public void doStop ( ) { doStop = true ; try { join ( ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( ClockTest . class ) ; return suite ; } 
public void date ( Date date ) { this . date = date ; } 
public Date date ( ) { return date ; } 
public void executeOn ( Object prevalentSystem ) { ClockedTestSystem clockedTestSystem = ( ClockedTestSystem ) prevalentSystem ; clockedTestSystem . date ( clockedTestSystem . clock ( ) . time ( ) ) ; } 
protected void setUp ( ) throws Exception { File prevalenceBase = File . createTempFile ( " prevalence " , " base " ) ; prevalenceBase . delete ( ) ; prevalenceBase . mkdirs ( ) ; prevalenceBase . deleteOnExit ( ) ; prevayler = new SnapshotPrevayler ( new ClockedTestSystem ( ) , new SnapshotManager ( prevalenceBase . getAbsolutePath ( ) ) , new TransactionLogger ( prevalenceBase . getAbsolutePath ( ) ) ) ; clockActor = new ClockActor ( prevayler ) ; Thread . sleep ( 100 ) ; } 
protected void tearDown ( ) throws Exception { clockActor . doStop ( ) ; } 
public void test ( ) throws IOException , ClassNotFoundException , InterruptedException { prevayler . execute ( new ChangeDateTransaction ( ) ) ; assertAboutSameDate ( new Date ( ) , system ( ) . date ( ) ) ; uncomment these lines to test clock-tick-optimizations 
private long transactionCount ( ) { return prevayler . transactionCount ( ) ; } 
private void assertAboutSameDate ( Date expected , Date observed ) { assertEquals ( expected . getTime ( ) / TOLERANCE , observed . getTime ( ) / TOLERANCE ) ; } 
private ClockedTestSystem system ( ) { return ( ClockedTestSystem ) prevayler . prevalentSystem ( ) ; } 
public void testRollback ( ) throws Exception { SnapshotManager snapshotManager = new SnapshotManager ( prevaylerBase ) ; TransactionLogger logger = new TransactionLogger ( prevaylerBase ) ; RollbackTransactionPublisher publisher = new RollbackTransactionPublisher ( snapshotManager , logger ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , snapshotManager , publisher ) ; publisher . initKing ( prevayler . prevalentSystem ( ) ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; assertEquals ( 60 , system ( ) . total ( ) ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
protected void setUp ( ) throws Exception { prevalenceBase = File . createTempFile ( " prevalence " , " base " ) ; prevalenceBase . delete ( ) ; prevalenceBase . mkdirs ( ) ; prevalenceBase . deleteOnExit ( ) ; prevayler = new SnapshotPrevayler ( new ClockedTestSystem ( ) , new SnapshotManager ( prevalenceBase . getAbsolutePath ( ) ) , new TransactionLogger ( prevalenceBase . getAbsolutePath ( ) ) ) ; clockActor = new ClockActor ( prevayler ) ; Thread . sleep ( 100 ) ; } 
protected void tearDown ( ) throws Exception { clockActor . doStop ( ) ; RollbackTest . delete ( prevalenceBase ) ; } 
protected void tearDown ( ) throws Exception { RollbackTest . delete ( prevalenceBase ) ; } 
protected void tearDown ( ) throws Exception { clockActor . interrupt ( ) ; RollbackTest . delete ( prevalenceBase ) ; } 
public synchronized Object registerCallback ( String message , IModelCallback callback ) { CallbackNode c = new CallbackNode ( message , callback ) ; callbacks . addLast ( c ) ; return c ; } 
public synchronized void unregisterCallback ( Object callback ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( ( CallbackNode ) i . next ( ) = = ( CallbackNode ) callback ) { i . remove ( ) ; } } ( ( CallbackNode ) callback ) . freed = true ; } 
public void checkCallbackFreed ( Object callback ) throws CallbackAlreadyFreedException { CallbackNode c = ( CallbackNode ) callback ; if ( c . freed ) throw new CallbackAlreadyFreedException ( " Callback has already been freed: " + c . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = ( CallbackNode ) i . next ( ) ; 
public void run ( ) { while ( true ) { try { 
public abstract void happened ( Long connectionID , String name , Object obj ) ; } 
public static void connect ( String host , int port ) throws IOException , ClassNotFoundException { conn = new Remote ( host , port ) ; } 
public synchronized Serializable exec ( Transaction transaction ) throws Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( transaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException thrownException = ( ThrownException ) result ; throw thrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction transaction , String errorMsg ) { Serializable result = null ; try { result = exec ( transaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public Object registerCallback ( String message , IModelCallback callback ) throws IOException { Tell the client to be prepared to receive the message Object result; result = callbackThread.registerCallback(message, callback); If it's not a wildcard callback, tell the server it's okay to send the message if (!message.equals("")) { out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new RegisterCallback(message)); } return result; } 
public void unregisterCallback ( Object callback ) throws IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public void close ( ) throws Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( new Disconnect ( ) ) ; socket . close ( ) ; } 
private void init ( ) { } 
public void store ( ) throws IOException { tproperties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } 
public static void error ( Exception e , String message ) { System . err . println ( message ) ; e . printStackTrace ( ) ; } 
public static void message ( String message ) { tSystem . out . println ( message ) ; } 
public static void debug ( String message ) { System . out . println ( message ) ; } 
private void handleRequests ( ) throws Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(new Long(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
public void run ( ) { try { handleRequests ( ) ; 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = new SnapshotPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
private static void runNotificationServer ( ) { new Notification ( port + 1 ) . start ( ) ; } 
private static void runCommandServer ( ) throws Exception { ServerSocket ss = null ; boolean listening = true ; Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread(prevayler, ss.accept()).start(); ss.close(); } 
public static void main ( String [ ] args ) { try { new ServerConfig ( ) ; 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } else { callbacks = new HashMap(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = true ; ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . addLast ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
private synchronized void checkWait ( ) throws Exception { if ( messageQueue . isEmpty ( ) ) wait ( ) ; 
private void handleNotifications ( ) throws Exception { This loop is broken when thread.interrupt() is called by the Reaper while (true) { checkWait(); 
public void run ( ) { try { handleNotifications ( ) ; 
public static long registerCommandThread ( ) { long id = getNextID ( ) ; return id ; } 
public static void registerNotificationThread ( Long id , NotificationThread thread ) { notificationThreads . put ( id , thread ) ; } 
public static void reap ( Long id ) { NotificationThread thread = ( NotificationThread ) notificationThreads . get ( id ) ; if ( thread ! = null ) { if ( thread . isAlive ( ) ) thread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
public void run ( ) { super . run ( ) ; Log . message ( " A system snapshot will be taken every 24h... " ) ; try { while ( true ) { 
public static synchronized void printList ( Object todoList ) { TodoList theList = ( TodoList ) todoList ; Todo [ ] items = theList . toArray ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { tSystem . out . println ( items [ i ] . getId ( ) + " " + items [ i ] . getDesc ( ) ) ; } System . out . println ( ) ; } 
private static char toUpperCase ( char ch ) { String result = " " ; result + = ch ; result = result . toUpperCase ( ) ; return result . toCharArray ( ) [ 0 ] ; } 
private static boolean invalidResponse ( char response ) { boolean responseIsInvalid = true ; for ( int i = 0 ; i < responses . length & & responseIsInvalid ; i + + ) { if ( responses [ i ] = = response ) { responseIsInvalid = false ; } } return responseIsInvalid ; } 
public static void printMenu ( ) { System . out . println ( " L)ist todos; A)dd todo; E)xit " ) ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; try { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public static void mainMenu ( ) { try { Print the current todo list 
public void happened ( Long connectionID , String name , Object obj ) { } 
public Todo [ ] toArray ( ) { Todo [ ] results = new Todo [ todoList . size ( ) ] ; int i = 0 ; Iterator iter = todoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { tresults [ i ] = ( Todo ) todoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo todo = new Todo ( id ) ; todoList . put ( new Integer ( id ) , todo ) ; return todo ; } 
public Todo get ( int id ) { return ( Todo ) todoList . get ( new Integer ( id ) ) ; } 
protected abstract Object lookup ( Object prevalentSystem ) throws Exception ; protected Object executeAndQuery ( Object prevalentSystem ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } } 
protected Object executeAndQuery ( Object prevalentSystem ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } 
public Object executeAndQuery ( Object prevalentSystem ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; Todo todo = todoList . newTodo ( ) ; todo . setDesc ( desc ) ; } 
protected Object executeAndQuery ( Object prevalentSystem ) throws Exception { treturn prevalentSystem ; } 
protected Object lookup ( Object prevalentSystem ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; return todoList . get ( id ) ; } 
public static void main ( String [ ] ignored ) throws Exception { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; tnew ClockActor ( prevayler ) ; tnew BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public void addTick ( ClockTick clockTick ) { t_count + + ; t_lastClockTick = clockTick ; } 
private void outputToLog ( Object object ) { ttry { _outputLog . writeObject ( object ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { t_nextTransaction = initialTransaction ; t_nextTransactionKnown = true ; } else { nSystem . out . println ( " TODO " ) ; } 
private void createNewOutputLog ( ) { tFile file = transactionLogFile ( _nextTransaction - _skippedTicks . getCount ( ) ) ; ttry { _outputLog = new SimpleOutputStream ( file ) ; 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) throws IOException , ClassNotFoundException { tlong recoveringTransaction = initialFile ; tSimpleInputStream inputLog = new SimpleInputStream ( transactionLogFile ( recoveringTransaction ) ) ; twhile ( recoveringTransaction < _nextTransaction ) { ttry { 
tstatic private long transactionCount ( File logFile ) throws IOException , ClassNotFoundException { tSimpleInputStream inputLog = new SimpleInputStream ( logFile ) ; tlong result = 0 ; twhile ( true ) { ttry { 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long transactionNumber ) { thang ( iox , " nThe exception above was thrown while trying to write transaction " + transactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( ClockTest . class ) ; tsuite . addTestSuite ( ClockTickLogOptimizationTest . class ) ; treturn suite ; } 
protected void clockTick ( long expectedTime ) throws Exception { out ( " Expecting clock time: " + expectedTime ) ; tprevayler . execute ( new ClockTick ( new Date ( expectedTime ) ) ) ; tcompare ( system ( ) . clock ( ) . time ( ) . getTime ( ) , expectedTime , " Clock time " ) ; } 
private void setSystemTime ( long expectedTime ) throws Exception { out ( " Expecting system time: " + expectedTime ) ; tprevayler . execute ( new Tick ( expectedTime ) ) ; verifySystem ( expectedTime ) ; } 
private void setSystemTimeToClock ( ) throws Exception { tlong expectedTime = system ( ) . clock ( ) . time ( ) . getTime ( ) ; out ( " Expecting system time: " + expectedTime ) ; tprevayler . execute ( new Tick ( expectedTime ) ) ; verifySystem ( expectedTime ) ; } 
private void verifyClock ( long expectedTime ) { out ( " Expecting clock time: " + expectedTime ) ; tcompare ( system ( ) . clock ( ) . time ( ) . getTime ( ) , expectedTime , " Clock time " ) ; } 
private void verifySystem ( long expectedTime ) { out ( " Expecting system time: " + expectedTime ) ; tcompare ( system ( ) . time ( ) . getTime ( ) , expectedTime , " System time " ) ; } 
private TickingSystem system ( ) { treturn ( TickingSystem ) prevayler . prevalentSystem ( ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = new SnapshotPrevayler ( new TickingSystem ( ) , prevalenceBase ( ) ) ; } 
private static void out ( Object obj ) { tSystem . out . println ( obj ) ; } 
protected void tearDown ( ) throws Exception { tRollbackTest . delete ( prevalenceBase ) ; } 
tstatic public void main ( String [ ] args ) throws Exception { tTestRunner . run ( AllTestSuite . suite ( ) ) ; } 
tstatic public void main ( String [ ] args ) throws Exception { tTestRunner . run ( NewFeaturesTestSuite . suite ( ) ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ReplicationTest . class ) ; return suite ; } 
public void testNormalConditions ( ) { tconnectionUp ( ) ; tserverUp ( ) ; tserverTransaction ( " a " ) ; tserverTransaction ( " b " ) ; tserverAssert ( " ab " ) ; tclientUp ( ) ; tclientAssert ( " ab " ) ; tserverTransaction ( " c " ) ; tbothAssert ( " abc " ) ; tclientTransaction ( " d " ) ; tbothAssert ( " abcd " ) ; tclientTransaction ( " e " ) ; tbothAssert ( " abcde " ) ; tserverTransaction ( " f " ) ; tserverTransaction ( " g " ) ; tclientTransaction ( " h " ) ; tclientTransaction ( " i " ) ; tserverTransaction ( " j " ) ; tclientTransaction ( " k " ) ; tbothAssert ( " abcdefghijk " ) ; } 
private void connectionUp ( ) { toDo ( ) ; } private void connectionDown ( ) { toDo ( ) ; } 
private void connectionDown ( ) { toDo ( ) ; } private void serverUp ( ) { toDo ( ) ; } 
private void serverUp ( ) { toDo ( ) ; } private void serverDown ( ) { toDo ( ) ; } 
private void serverDown ( ) { toDo ( ) ; } private void clientUp ( ) { toDo ( ) ; } 
private void clientUp ( ) { toDo ( ) ; } private void clientDown ( ) { toDo ( ) ; } 
private void serverTransaction ( String appendix ) { toDo ( ) ; } private void clientTransaction ( String appendix ) { toDo ( ) ; } 
private void clientTransaction ( String appendix ) { toDo ( ) ; } 
private void serverAssert ( String expected ) { toDo ( ) ; } private void clientAssert ( String expected ) { toDo ( ) ; } 
private void clientAssert ( String expected ) { toDo ( ) ; } private void bothAssert ( String expected ) { 
private void bothAssert ( String expected ) { tserverAssert ( expected ) ; tclientAssert ( expected ) ; } 
private void toDo ( ) { tthrow new RuntimeException ( " New test to be implemented. " ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( TickingSystem ) prevalentSystem ) . setTime ( _value ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { t_nextTransaction = initialTransaction ; t_nextTransactionKnown = true ; } else { nSystem . out . println ( " TODO " ) ; } 
public void receive ( Transaction transaction ) { ttry { t_toRemote . writeObject ( transaction = = _remoteTransaction 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; t_toServer . writeObject ( new Long ( initialTransaction ) ) ; } 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { tsynchronized ( _myTransactionMonitor ) { t_subscriber . receive ( _myTransaction ) ; t_myTransactionMonitor . notify ( ) ; } treturn ; } t_subscriber . receive ( ( Transaction ) transactionCandidate ) ; } 
public static void main ( String [ ] args ) throws Exception { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " ) ) ; tnew ClockActor ( prevayler ) ; tnew BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
private void register ( long amount ) { tbalance + = amount ; transactionHistory . add ( new AccountEntry ( amount , clock ) ) ; notifyListeners ( ) ; } 
protected Object readSnapshot ( InputStream in ) throws IOException { tObject system = null ; tStreamSource source = new StreamSource ( in ) ; ttry { tsystem = this . trans . deserialize ( source ) ; } tcatch ( DeserializerException se ) { tthrow new IOException ( " Unable to deserialize with Skaringa: " + se . getMessage ( ) ) ; } tfinally { tsource . getInputStream ( ) . close ( ) ; } treturn system ; } 
protected void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tStreamResult result = new StreamResult ( out ) ; ttry { tthis . trans . serialize ( prevalentSystem , result ) ; 
public synchronized void receive ( Transaction transaction ) { systemVersion + + ; transaction . executeOn ( prevalentSystem ) ; } 
public Object prevalentSystem ( ) { return prevalentSystem ; } 
public void execute ( Transaction transaction ) { publisher . publish ( transaction ) ; } 
private long latestVersion ( ) throws IOException { String [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) { throw new IOException ( " Error reading file list from directory " + directory ) ; } long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; "00000.snapshot" becomes "00000". } 
private String suffix ( ) { return " transactionLog " ; } 
public void checkpoint ( ) { synchronized ( subscriber ) { writeCheckpoint ( ) ; 
private void writeCheckpoint ( ) { } private class CheckPointTransactionLogger extends TransactionLogger { public CheckPointTransactionLogger ( String prevalenceBase ) throws ClassNotFoundException , IOException { super ( prevalenceBase ) ; } protected Transaction transactionFromLogEntry ( Object entry ) { if ( entry instanceof Transaction ) { return ( Transaction ) entry ; } prevalentSystem = entry ; return new Transaction ( ) { public void executeOn ( Object prevalentSystem ) { } } ; } public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } } } 
protected Transaction transactionFromLogEntry ( Object entry ) { if ( entry instanceof Transaction ) { return ( Transaction ) entry ; } prevalentSystem = entry ; return new Transaction ( ) { public void executeOn ( Object prevalentSystem ) { 
public void executeOn ( Object prevalentSystem ) { } } ; } public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } } } 
public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } 
protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } 
public void testSelfResolvment ( ) throws ClassNotFoundException , IOException { String prevalenceBase = " prevalence " + System . currentTimeMillis ( ) ; CheckpointPrevayler prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase ) ; TestSystem system = ( TestSystem ) prevayler . prevalentSystem ( ) ; prevayler . execute ( new TestTransaction ( system . list1 ) ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase ) ; system = ( TestSystem ) prevayler . prevalentSystem ( ) ; assertEquals ( 1 , system . list1 . size ( ) ) ; assertEquals ( 1 , system . list2 . size ( ) ) ; } 
public void testCheckPoint ( ) throws ClassNotFoundException , IOException { File prevalenceBase = new File ( " prevalence " + System . currentTimeMillis ( ) ) ; CheckpointPrevayler prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase . getAbsolutePath ( ) ) ; TestSystem system = ( TestSystem ) prevayler . prevalentSystem ( ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; system . list1 . add ( " 1 " ) ; assertEquals ( 1 , prevalenceBase . listFiles ( ) . length ) ; prevayler . checkpoint ( ) ; assertEquals ( 2 , prevalenceBase . listFiles ( ) . length ) ; prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase . getAbsolutePath ( ) ) ; system = ( TestSystem ) prevayler . prevalentSystem ( ) ; assertEquals ( 1 , system . list1 . size ( ) ) ; assertEquals ( 2 , prevalenceBase . listFiles ( ) . length ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; assertEquals ( 3 , prevalenceBase . listFiles ( ) . length ) ; assertEquals ( 2 , system . list2 . size ( ) ) ; } 
public void executeOn ( Object prevalentSystem ) { list . add ( " stuff " ) ; } 
protected void outputToLog ( Object object ) { ttry { _outputLog . writeObject ( object ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { t_nextTransaction = initialTransaction ; t_nextTransactionKnown = true ; } else { nSystem . out . println ( " TODO " ) ; } 
private File lastTransactionFile ( ) throws IOException { tFile [ ] files = _directory . listFiles ( this ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; if ( files . length = = 0 ) return null ; treturn ( File ) Collections . max ( Arrays . asList ( files ) ) ; } 
protected void createNewOutputLog ( ) { tFile file = transactionLogFile ( _nextTransaction - _skippedTicks . getCount ( ) ) ; ttry { _outputLog = new SimpleOutputStream ( file ) ; 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) throws IOException , ClassNotFoundException { tlong recoveringTransaction = initialFile ; tSimpleInputStream inputLog = new SimpleInputStream ( transactionLogFile ( recoveringTransaction ) ) ; twhile ( recoveringTransaction < _nextTransaction ) { ttry { 
protected Transaction transactionFromLogEntry ( Object logEntry ) { return ( Transaction ) logEntry ; } 
private static void out ( Object obj ) { }} 
public void checkpoint ( ) { synchronized ( subscriber ) { publisher . startNewCheckpointFile ( ) ; 
public final void executeOn ( Object prevalentSystem ) { ttry { t_result = executeAndQuery ( prevalentSystem ) ; 
protected void addFields ( Box fieldBox ) { tsuper . addFields ( fieldBox ) ; tfieldBox . add ( gap ( ) ) ; tfieldBox . add ( labelContainer ( " Transaction History " ) ) ; thistoryList = new JList ( ) ; thistoryList . setEnabled ( false ) ; tfieldBox . add ( new JScrollPane ( historyList ) ) ; tfieldBox . add ( gap ( ) ) ; tfieldBox . add ( labelContainer ( " Balance " ) ) ; tbalanceField = new JTextField ( ) ; tbalanceField . setEnabled ( false ) ; tfieldBox . add ( balanceField ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . setEnabled ( false ) ; fieldBox . add ( sourceField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; tfieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Amount " ) ) ; amountField = new JTextField ( ) ; fieldBox . add ( amountField ) ; } 
public void advanceClockTo ( Date newTime ) { t_brokenClock . advanceTo ( newTime ) ; } 
public Object executeUsing ( Prevayler prevayler ) throws Exception { return super . executeUsing ( prevayler ) ; } 
protected final Object executeAndQuery ( Object prevalentSystem ) throws Exception { ClockedSystem clockedSystem = ( ClockedSystem ) prevalentSystem ; clockedSystem . advanceClockTo ( timeOfExecution ! = null ? timeOfExecution : new Date ( ) ) ; return executeClocked ( clockedSystem ) ; } 
protected abstract Object executeClocked ( ClockedSystem clockedSystem ) throws Exception ; private void writeObject ( ObjectOutputStream out ) throws IOException { if ( timeOfExecution = = null ) { timeOfExecution = new Date ( ) ; } out . defaultWriteObject ( ) ; } } 
private void writeObject ( ObjectOutputStream out ) throws IOException { if ( timeOfExecution = = null ) { timeOfExecution = new Date ( ) ; } out . defaultWriteObject ( ) ; } 
public void execute ( Transaction transaction ) { transaction . executeOn ( system ) ; } 
public Object prevalentSystem ( ) { return system ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; newPrevayler ( ) ; } 
private void newPrevayler ( ) { prevalentSystem = new AbstractClockedSystem ( ) { } ; prevayler = new NullPrevayler ( prevalentSystem ) ; } 
public void testExecute ( ) throws Exception { ClockedTransaction clockedTransaction = new ClockedTransaction ( ) { public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . time ( ) ; return null ; } } ; assertNull ( clockedTransaction . timeOfExecution ) ; clockedTransaction . executeUsing ( prevayler ) ; assertNotNull ( clockedTransaction . timeOfExecution ) ; assertNotNull ( executedTime ) ; assertEquals ( clockedTransaction . timeOfExecution , executedTime ) ; newPrevayler ( ) ; Date previousExecutedTime = executedTime ; clockedTransaction . executeOn ( prevalentSystem ) ; assertEquals ( previousExecutedTime , executedTime ) ; } 
public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . time ( ) ; return null ; } 
tsynchronized void advanceTo ( Date newTime ) { tlong newMillis = newTime . getTime ( ) ; if ( newMillis < _millis ) throw new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; t_millis = newMillis ; t_time = newTime ; } 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
public void takeSnapshot ( ) throws IOException { synchronized ( _subscriber ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void execute ( Transaction transaction ) { _publisher . publish ( transaction ) ; } 
public synchronized void receive ( Transaction transaction ) { _systemVersion + + ; if ( _ignoreStartupErrors ) { try { 
public synchronized void receive ( Transaction transaction ) { _systemVersion + + ; try { transaction . executeOn ( _prevalentSystem ) ; 
public synchronized void receive ( Transaction transaction ) { _systemVersion + + ; if ( _ignoreExceptions ) { try { 
public void testIgnoreStartupExceptions ( ) throws IOException , ClassNotFoundException { String prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; try { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } try { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; prevayler = new SnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; try { prevayler . execute ( new FailingTransaction ( ) ) ; 
public void executeOn ( Object prevalentSystem ) { ( ( TestSystem ) prevalentSystem ) . list1 . add ( " test " ) ; throw new IllegalStateException ( " fail " ) ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
tsynchronized public void execute ( Transaction transaction ) { tserializeInMemory ( transaction ) . executeOn ( prevalentSystem ) ; } 
public Object prevalentSystem ( ) { return prevalentSystem ; } 
tstatic private Transaction serializeInMemory ( Transaction transaction ) { tByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ttry { tnew ObjectOutputStream ( buffer ) . writeObject ( transaction ) ; 
public void close ( ) throws IOException { _outputLog . close ( ) ; } 
public static Prevayler createTransient ( Object prevalentSystem ) { treturn new TransientPrevayler ( prevalentSystem ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( TransactionExecutionTest . class ) ; tsuite . addTest ( OldTestSuite . suite ( ) ) ; treturn suite ; } 
tstatic public void main ( String [ ] args ) throws Exception { tTestRunner . run ( OldTestSuite . suite ( ) ) ; } 
protected void setUp ( ) throws Exception { tprevayler = PrevaylerFactory . createTransient ( new AppendingSystem ( ) ) ; } 
public void testTransactionExecution ( ) { tassertState ( " " ) ; tappend ( " a " ) ; tassertState ( " a " ) ; tappend ( " b " ) ; tappend ( " c " ) ; tassertState ( " abc " ) ; } 
public void testBaptismProblem ( ) { tappendWithDirectReference ( ) ; tassertState ( " " ) ; } 
private void assertState ( String expected ) { tString result = ( ( AppendingSystem ) prevayler . prevalentSystem ( ) ) . value ( ) ; tassertEquals ( expected , result ) ; } 
private void append ( String appendix ) { tprevayler . execute ( new Appendix ( appendix ) ) ; } 
private void appendWithDirectReference ( ) { tprevayler . execute ( new DirectReferenceTransaction ( ( AppendingSystem ) prevayler . prevalentSystem ( ) ) ) ; } 
tvoid append ( String appendix ) { tvalue = value + appendix ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
public void executeOn ( Object ignored ) { tillegalDirectReference . append ( " anything " ) ; } 
private static void out ( Object obj ) { }} 
public static void deletePrevalenceFiles ( String directoryName ) { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; tFile [ ] files = directory . listFiles ( new PersistenceTest . PrevalenceFilter ( ) ) ; tfor ( int i = 0 ; i < files . length ; + + i ) { tassertTrue ( " Unable to delete " + files [ i ] , files [ i ] . delete ( ) ) ; 
private void newPrevayler ( ) { prevalentSystem = new AbstractClockedSystem ( ) { } ; prevayler = new TransientPrevayler ( prevalentSystem ) ; } 
public void testExecute ( ) throws Exception { ClockedTransaction clockedTransaction = new MyClockedTransaction ( ) ; assertNull ( clockedTransaction . timeOfExecution ) ; clockedTransaction . executeUsing ( prevayler ) ; assertNotNull ( clockedTransaction . timeOfExecution ) ; assertNotNull ( executedTime ) ; assertEquals ( clockedTransaction . timeOfExecution , executedTime ) ; newPrevayler ( ) ; Date previousExecutedTime = executedTime ; clockedTransaction . executeOn ( prevalentSystem ) ; assertEquals ( previousExecutedTime , executedTime ) ; } 
public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . time ( ) ; return null ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) ; } 
public void takeSnapshot ( ) throws IOException { synchronized ( _prevalentSystem ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { 
public void receive ( Transaction transaction ) { tsynchronized ( _prevalentSystem ) { _systemVersion + + ; 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
public void execute ( Transaction transaction ) { tTransaction copy = serializeInMemory ( transaction ) ; tsynchronized ( _prevalentSystem ) { tcopy . executeOn ( _prevalentSystem ) ; 
public void executeOn ( Object prevalentSystem , Date timestamp ) ; } 
public static void main ( String [ ] args ) throws Exception { tprintMessage ( ) ; tSnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; tnew PrimeCalculator ( prevayler ) . start ( ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( NumberKeeper ) prevalentSystem ) . keep ( _numberToKeep ) ; } 
public static void main ( String [ ] ignored ) throws Exception { tSnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; tnew BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public static void main ( String [ ] args ) throws Exception { tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; tnew BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
public void deposit ( long amount , Date timestamp ) throws InvalidAmount { verify ( amount ) ; register ( amount , timestamp ) ; } 
public void withdraw ( long amount , Date timestamp ) throws InvalidAmount { verify ( amount ) ; register ( - amount , timestamp ) ; } 
private void register ( long amount , Date timestamp ) { tbalance + = amount ; transactionHistory . add ( new AccountEntry ( amount , timestamp ) ) ; notifyListeners ( ) ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { tAccount account = new Account ( nextAccountNumber , holder ) ; taccountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; treturn account ; } 
public void transfer ( long sourceNumber , long destinationNumber , long amount , Date timestamp ) throws AccountNotFound , Account . InvalidAmount { tAccount source = findAccount ( sourceNumber ) ; tAccount destination = findAccount ( destinationNumber ) ; tsource . withdraw ( amount , timestamp ) ; if ( amount = = 666 ) throw new RuntimeException ( " Runtime Exception simulated for rollback demonstration purposes. " ) ; tdestination . deposit ( amount , timestamp ) ; } 
protected Object executeAndQuery ( Bank bank , Date ignored ) throws Account . InvalidHolder { treturn bank . createAccount ( _holder ) ; } 
protected Object executeAndQuery ( Bank bank , Date ignored ) throws Bank . AccountNotFound { tbank . deleteAccount ( _accountNumber ) ; treturn null ; } 
protected Object executeAndQuery ( Bank bank , Date timestamp ) throws Exception { texecuteAndQuery ( bank . findAccount ( _accountNumber ) , timestamp ) ; treturn null ; } 
protected abstract void executeAndQuery ( Account account , Date timestamp ) throws Exception ; } 
public Object executeAndQuery ( Object bank , Date timestamp ) throws Exception { treturn executeAndQuery ( ( Bank ) bank , timestamp ) ; } 
protected abstract Object executeAndQuery ( Bank bank , Date timestamp ) throws Exception ; } 
public void executeAndQuery ( Account account , Date timestamp ) throws Account . InvalidAmount { taccount . deposit ( _amount , timestamp ) ; } 
public void executeAndQuery ( Account account , Date ignored ) throws Account . InvalidHolder { taccount . holder ( _newHolder ) ; } 
public Object executeAndQuery ( Bank bank , Date timestamp ) throws Exception { tbank . transfer ( _originAccountNumber , _destinationAccountNumber , _amount , timestamp ) ; treturn null ; } 
public void executeAndQuery ( Account account , Date timestamp ) throws Account . InvalidAmount { taccount . withdraw ( _amount , timestamp ) ; } 
public long countObjectsLeft ( ) throws IOException , ClassNotFoundException { tlong result = 0 ; twhile ( true ) { ttry { 
public void execute ( Transaction transaction ) { try { nSystem . out . println ( " The RollbackPrevayler isn't ready to be used. " ) ; The correct timestamp must be passed below, instead of null. 
public void receive ( Transaction transaction , Date timestamp ) { tsynchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void receive ( Transaction transaction , Date timestamp ) ; } 
public void execute ( Transaction transaction ) { tTransaction copy = serializeInMemory ( transaction ) ; tsynchronized ( _prevalentSystem ) { tcopy . executeOn ( _prevalentSystem , _clock . time ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransactionIgnored ) throws IOException , ClassNotFoundException { tsynchronized ( _subscribers ) { _subscribers . add ( subscriber ) ; } } 
protected void notifySubscribers ( Transaction transaction , Date timestamp ) { tsynchronized ( _subscribers ) { tIterator i = _subscribers . iterator ( ) ; 
public synchronized void advanceTo ( Date newTime ) { tlong newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; if ( newMillis < _millis ) throw new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; t_millis = newMillis ; t_time = newTime ; } 
public synchronized void publish ( Transaction transaction ) { if ( ! _nextTransactionKnown ) throw new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; tDate timestamp = _clock . time ( ) ; outputToLog ( new TransactionLogEntry ( transaction , timestamp ) ) ; t_nextTransaction + + ; tsuper . notifySubscribers ( transaction , timestamp ) ; } 
protected void createNewOutputLog ( ) { tFile file = transactionLogFile ( _nextTransaction ) ; ttry { _outputLog = new SimpleOutputStream ( file ) ; 
tstatic private long transactionCount ( File logFile ) throws IOException , ClassNotFoundException { treturn new SimpleInputStream ( logFile ) . countObjectsLeft ( ) ; } 
public void receive ( Transaction transaction , Date timestamp ) { ttry { tsynchronized ( _toRemote ) { 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; tDate timestamp = ( Date ) _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { tsynchronized ( _myTransactionMonitor ) { t_subscriber . receive ( _myTransaction , timestamp ) ; t_myTransactionMonitor . notify ( ) ; } treturn ; } t_subscriber . receive ( ( Transaction ) transactionCandidate , timestamp ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem ) { treturn new TransientPrevayler ( prevalentSystem , new MachineClock ( ) ) ; } 
public static SnapshotPrevayler createSnapshotPrevayler ( Object newPrevalentSystem ) throws IOException , ClassNotFoundException { treturn createSnapshotPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static SnapshotPrevayler createSnapshotPrevayler ( Object newPrevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { treturn new SnapshotPrevayler ( newPrevalentSystem , new SnapshotManager ( prevalenceBase ) , new TransactionLogger ( prevalenceBase , new MachineClock ( ) ) ) ; } 
public final void executeOn ( Object prevalentSystem , Date timestamp ) { ttry { t_result = executeAndQuery ( prevalentSystem , timestamp ) ; 
protected abstract Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception ; } 
public void testIgnoreStartupExceptions ( ) throws IOException , ClassNotFoundException { String prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; try { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } try { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; prevayler = PrevaylerFactory . createSnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; try { prevayler . execute ( new FailingTransaction ( ) ) ; 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( TestSystem ) prevalentSystem ) . list1 . add ( " test " ) ; throw new IllegalStateException ( " fail " ) ; } 
private void connectionUp ( ) { toDo ( ) ; } private void serverUp ( ) { toDo ( ) ; } 
private void serverUp ( ) { toDo ( ) ; } private void clientUp ( ) { toDo ( ) ; } 
protected void setUp ( ) throws Exception { tprevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date ignoredToo ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
public void executeOn ( Object ignored , Date ignoredToo ) { tillegalDirectReference . append ( " anything " ) ; } 
public void executeOn ( Object prevalentSystem , Date timestamp ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; treturn suite ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = PrevaylerFactory . createSnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; throw new RuntimeException ( " Testing Rollback " ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; File tempFile = File . createTempFile ( " Prevalence " , " Base " ) ; tempFile . delete ( ) ; tempFile . mkdirs ( ) ; tempFile . deleteOnExit ( ) ; prevalenceBase = tempFile . getAbsolutePath ( ) ; } 
protected void tearDown ( ) throws Exception { delete ( prevalenceBase ) ; } 
public void testRollback ( ) throws Exception { prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; tadd ( 10 , 10 ) ; addRollback ( 1 , 10 ) ; tadd ( 1 , 11 ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( TransactionSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; tSnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; tstartSnapshots ( prevayler ) ; } 
tstatic void startSnapshots ( SnapshotPrevayler prevayler ) tthrows Exception { tstartGui ( prevayler ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
tstatic void startGui ( Prevayler prevayler ) { tnew BankFrame ( new QueryPrevayler ( prevayler ) ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; tTransactionPublisher publisher = new TransactionLogger ( " demo2Acid " , new MachineClock ( ) ) ; tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new SnapshotManager ( " demo2Acid " ) , publisher ) ; tnew PublishingServer ( publisher ) ; tMain . startGui ( prevayler ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tSnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; tMain . startSnapshots ( prevayler ) ; 
public void execute ( Transaction transaction ) { copy.executeOn(_prevalentSystem, _clock.time()); 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception ; } 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; t_prevayler . execute ( new Deposit ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) throws Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; t_prevayler . execute ( new Withdrawal ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) { new TransferFrame ( account , _prevayler , getDesktopPane ( ) ) ; } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; ttry { t_prevayler . execute ( new HolderChange ( account , holderText ( ) ) ) ; 
private Bank bank ( ) { treturn ( Bank ) _prevayler . prevalentSystem ( ) ; } 
public void actionPerformed ( ActionEvent e ) { tnew NewAccountFrame ( _prevayler , getDesktopPane ( ) ) ; } 
tabstract void action ( Account account ) throws Exception ; } tclass AccountEditAction extends SelectedAccountAction { tAccountEditAction ( ) { tsuper ( " Edit " ) ; } tvoid action ( Account account ) { tnew AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } } tclass AccountDeleteAction extends SelectedAccountAction { tAccountDeleteAction ( ) { tsuper ( " Delete " ) ; } tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; t_prevayler . execute ( new AccountDeletion ( account ) ) ; } } } 
tvoid action ( Account account ) { tnew AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } 
tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; t_prevayler . execute ( new AccountDeletion ( account ) ) ; } 
protected void action ( ) throws Exception { t_prevayler . execute ( new AccountCreation ( holderText ( ) ) ) ; tdispose ( ) ; } 
public void action ( ) throws Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; t_prevayler . execute ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) ; dispose ( ) ; } 
public Object performOn ( Object prevalentSystem ) throws Exception ; } 
public void execute ( Transaction transaction ) { t_prevayler . execute ( transaction ) ; } 
public Object performAlone ( Query query ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn query . performOn ( _prevalentSystem ) ; 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( transactionWithQuery ) ; t_prevayler . execute ( executer ) ; treturn executer . result ( ) ; } 
public final void executeOn ( Object prevalentSystem , Date timestamp ) { ttry { t_result = _transactionWithQuery . executeAndQuery ( prevalentSystem , timestamp ) ; 
tObject result ( ) throws Exception { if ( _exception ! = null ) throw _exception ; treturn _result ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; tsuite . addTest ( org . prevayler . util . Suite . suite ( ) ) ; treturn suite ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( TransactionExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; treturn suite ; } 
public void testBaptismProblem ( ) { tappendWithDirectReference ( ) ; 
public void testTransientPrevaylerCreation ( ) { tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testSnapshotPrevaylerCreation ( ) throws IOException , ClassNotFoundException { tSnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( POJO ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; tprevayler = PrevaylerFactory . createSnapshotPrevayler ( POJO , " anything " ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; tQueryPrevayler queryPrevayler = new QueryPrevayler ( prevayler ) ; tObject result = queryPrevayler . performAlone ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { treturn new Query ( ) { public Object performOn ( Object prevalentSystem ) throws Exception { 
public Object performOn ( Object prevalentSystem ) throws Exception { treturn new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; tQueryPrevayler queryPrevayler = new QueryPrevayler ( prevayler ) ; tObject result = queryPrevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " result " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery transactionWithQuery ( ) { treturn new TransactionWithQuery ( ) { public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) { 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; treturn " result " ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( QueryPrevaylerTest . class ) ; treturn suite ; } 
public synchronized void advanceTo ( Date newTime ) { tlong newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; t_millis = newMillis ; t_time = newTime ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) ; } 
public Clock clock ( ) ; public void execute ( Transaction transaction ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) ; } 
tstatic void startGui ( Prevayler prevayler ) { tnew BankFrame ( new QueryExecuter ( prevayler ) ) ; } 
protected Object executeOn ( Bank bank , Date ignored ) throws Account . InvalidHolder { treturn bank . createAccount ( _holder ) ; } 
protected Object executeOn ( Bank bank , Date ignored ) throws Bank . AccountNotFound { tbank . deleteAccount ( _accountNumber ) ; treturn null ; } 
protected Object executeOn ( Bank bank , Date timestamp ) throws Exception { texecuteOn ( bank . findAccount ( _accountNumber ) , timestamp ) ; treturn null ; } 
protected abstract void executeOn ( Account account , Date timestamp ) throws Exception ; } 
public Object executeOn ( Object bank , Date timestamp ) throws Exception { treturn executeOn ( ( Bank ) bank , timestamp ) ; } 
protected abstract Object executeOn ( Bank bank , Date timestamp ) throws Exception ; } 
public void executeOn ( Account account , Date timestamp ) throws Account . InvalidAmount { taccount . deposit ( _amount , timestamp ) ; } 
public void executeOn ( Account account , Date ignored ) throws Account . InvalidHolder { taccount . holder ( _newHolder ) ; } 
public Object executeOn ( Bank bank , Date timestamp ) throws Exception { tbank . transfer ( _originAccountNumber , _destinationAccountNumber , _amount , timestamp ) ; treturn null ; } 
public void executeOn ( Account account , Date timestamp ) throws Account . InvalidAmount { taccount . withdraw ( _amount , timestamp ) ; } 
private Bank bank ( ) { } 
public void receive ( Transaction transaction , Date executionTime ) { tsynchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public Clock clock ( ) ; } 
public void publish ( Transaction transaction ) ; public Clock clock ( ) ; } 
public void execute ( Transaction transaction ) { tsynchronized ( _prevalentSystem ) { ttransaction . executeOn ( _prevalentSystem , _clock . time ( ) ) ; 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long transactionNumber ) { thang ( iox , " nThe exception above was thrown while trying to write " + objectToWrite . getClass ( ) + " to file " + logFile + " (Transaction number " + transactionNumber + " ). Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public Clock clock ( ) { } 
public Object executeOn ( Object prevalentSystem , Date executionTime ) throws Exception ; } 
public Object executeAlone ( Query query ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn query . executeOn ( _prevalentSystem , _clock . time ( ) ) ; 
public Prevayler prevayler ( ) { } 
public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception ; } 
public final void executeOn ( Object prevalentSystem , Date timestamp ) { ttry { t_result = _delegate . executeOn ( prevalentSystem , timestamp ) ; 
private static void out ( Object obj ) { if ( false ) System . out . println ( obj ) ; } 
tstatic private void runPrevaylerTransaction ( ) throws Exception { tnew TransactionTestRun ( tnew PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) ) , 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; tQueryExecuter queryPrevayler = new QueryExecuter ( prevayler ) ; tObject result = queryPrevayler . executeAlone ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { treturn new Query ( ) { public Object executeOn ( Object prevalentSystem , Date ignored ) throws Exception { 
public Object executeOn ( Object prevalentSystem , Date ignored ) throws Exception { treturn new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; tQueryExecuter queryPrevayler = new QueryExecuter ( prevayler ) ; tObject result = queryPrevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery transactionWithQuery ( ) { treturn new TransactionWithQuery ( ) { public Object executeOn ( Object prevalentSystem , Date timestamp ) { 
public Object executeOn ( Object prevalentSystem , Date timestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; treturn " abc " ; } 
public void executeOn ( Object system , Date ignored ) { if ( project ! = null ) { tProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public void executeOn ( Object system , Date ignored ) { if ( task ! = null & & projectId ! = Integer . MIN_VALUE ) { tProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
private void register ( long amount , Date timestamp ) { tbalance + = amount ; transactionHistory . add ( new Transaction ( amount , timestamp ) ) ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { tAccount account = new Account ( nextAccountNumber , holder ) ; taccountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; treturn account ; } 
public void deleteAccount ( long number ) throws AccountNotFound { tAccount account = findAccount ( number ) ; taccountsByNumber . remove ( new Long ( number ) ) ; } 
public void transfer ( long sourceNumber , long destinationNumber , long amount , Date timestamp ) throws AccountNotFound , Account . InvalidAmount { tAccount source = findAccount ( sourceNumber ) ; tAccount destination = findAccount ( destinationNumber ) ; tsource . withdraw ( amount , timestamp ) ; tdestination . deposit ( amount , timestamp ) ; } 
public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception { tmementos = new HashMap ( ) ; ttry { treturn transaction . execute ( this , prevalentSystem ) ; 
private static Object execute ( MementoTransaction command ) { try { return new MementoManagerCommand ( command ) . executeOn ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . time ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . toString ( ) ) ; } return null ; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected Serializable execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public abstract Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception ; } 
protected abstract Object lookup ( Object prevalentSystem ) throws Exception ; public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } } 
public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; try { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new TransactionWithQueryExecuter(new CreateTodoBean(response)), "Unable to add Todo"); } 
public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; Todo todo = todoList . newTodo ( ) ; todo . setDesc ( desc ) ; } 
public Object executeOn ( Object prevalentSystem , Date timestamp ) throws Exception { treturn prevalentSystem ; } 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createSnapshotPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public Object prevalentSystem ( ) ; public void execute ( Transaction transaction ) ; public Object execute ( Query query ) throws Exception ; public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Clock clock ( ) ; public void execute ( Transaction transaction ) ; public Object execute ( Query query ) throws Exception ; public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public void execute ( Transaction transaction ) ; public Object execute ( Query query ) throws Exception ; public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Object execute ( Query query ) throws Exception ; public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Object executeOn ( Object prevalentSystem , Date executionTime ) throws Exception ; } 
public static void main ( String [ ] args ) throws Exception { tprintMessage ( ) ; tPrevayler prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; tnew PrimeCalculator ( prevayler ) . start ( ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; tPrevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2Acid " ) ; tstartSnapshots ( prevayler ) ; } 
tstatic void startSnapshots ( Prevayler prevayler ) tthrows Exception { tstartGui ( prevayler ) ; twhile ( true ) { tThread . sleep ( 1000 * 20 ) ; 
tstatic void startGui ( Prevayler prevayler ) { tnew BankFrame ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; tTransactionPublisher publisher = new TransactionLogger ( " demo2Acid " , new MachineClock ( ) ) ; tPrevaylerImpl prevayler = new PrevaylerImpl ( new Bank ( ) , new SnapshotManager ( " demo2Acid " ) , publisher ) ; tnew PublishingServer ( publisher ) ; tMain . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerImpl prevayler = new PrevaylerImpl ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; tMain . startSnapshots ( prevayler ) ; 
public void configurePrevalentSystem ( Object prevalentSystem ) { t_prevalentSystem = prevalentSystem ; } 
public void configurePrevalenceBase ( String prevalenceBase ) { t_prevalenceBase = prevalenceBase ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { treturn createPrevayler ( _prevalentSystem , _prevalenceBase ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem ) { ttry { treturn createPrevayler ( prevalentSystem , " PrevalenceBase " + System . currentTimeMillis ( ) ) ; 
public static Prevayler createPrevayler ( Object newPrevalentSystem ) throws IOException , ClassNotFoundException { treturn createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Object newPrevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { treturn new PrevaylerImpl ( newPrevalentSystem , new SnapshotManager ( prevalenceBase ) , new TransactionLogger ( prevalenceBase , new MachineClock ( ) ) ) ; } 
public void execute ( Transaction transaction ) { } 
public Object execute ( Query query ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn query . executeOn ( _prevalentSystem , clock ( ) . time ( ) ) ; 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( transactionWithQuery ) ; texecute ( executer ) ; treturn executer . result ( ) ; } 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { 
 public void receive ( Transaction transaction , Date executionTime ) { tsynchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void takeSnapshot ( ) throws IOException { synchronized ( _prevalentSystem ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , tlong initialTransaction ) throws IOException , ClassNotFoundException { t_delegate . addSubscriber ( subscriber , initialTransaction ) ; } 
public void publish ( Transaction transaction ) { ttry { ttransaction . executeOn ( royalFoodTaster ( ) , clock ( ) . time ( ) ) ; } 
private void letTheFoodTasterDie ( ) { t_royalFoodTaster = null ; } 
private Object royalFoodTaster ( ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( ) ; treturn _royalFoodTaster ; } 
private void produceNewFoodTaster ( ) { ttry { TODO Optimization: use a sort of producer-consumer stream so that serialization as deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; t_toServer . writeObject ( new Long ( initialTransaction ) ) ; TODO Reimplement the logic of waiting until subscriber is up-to-date before returning. 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; treturn suite ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = PrevaylerFactory . createPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
public void testSnapshotPrevaylerCreation ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = PrevaylerFactory . createPrevayler ( POJO ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; tprevayler = PrevaylerFactory . createPrevayler ( POJO , " anything " ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; tObject result = prevayler . execute ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; tObject result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void testRollback ( ) throws Exception { prevayler = PrevaylerFactory . createPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; tadd ( 10 , 10 ) ; addRollback ( 1 , 10 ) ; tadd ( 1 , 11 ) ; } 
private void addRollback ( int value , int expectedTotal ) throws Exception { tboolean isThrown = false ; ttry { if (!isThrown) throw new RuntimeException("RuntimeException expected and not thrown."); assertEquals(expectedTotal, system().total()); } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransactionExecutionTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; treturn suite ; } 
private static void list ( Prevayler prevayler , String xpathExp ) { tSystem . out . println ( " Executing XPath expression... " ) ; tProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; tJXPathContext context = JXPathContext . newContext ( pms ) ; tIterator i = context . iterate ( xpathExp ) ; twhile ( i . hasNext ( ) ) { 
private static void addProject ( tPrevayler prevayler , tString id , tString name ) tthrows Exception { tSystem . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; tProject p = new Project ( ) ; tp . setId ( Integer . parseInt ( id ) ) ; tp . setName ( name ) ; tAddProject cmd = new AddProject ( ) ; tcmd . setProject ( p ) ; tprevayler . execute ( cmd ) ; } 
private static void addTask ( tPrevayler prevayler , tString id , tString name , tString start , tString end , tString projectId ) tthrows Exception { tSystem . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; tTask = new Task ( ) ; tt . setId ( Integer . parseInt ( id ) ) ; tt . setName ( name ) ; tt . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; tt . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; tSystem . out . println ( " Start: " + . getStart ( ) ) ; tSystem . out . println ( " End: " + . getEnd ( ) ) ; tAddTask cmd = new AddTask ( ) ; tcmd . setTask ( ) ; tcmd . setProjectId ( Integer . parseInt ( projectId ) ) ; tprevayler . execute ( cmd ) ; } 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem ) { treturn createTransientPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem , String snapshotDirectory ) { ttry { treturn new PrevaylerImpl ( newPrevalentSystem , new SnapshotManager ( snapshotDirectory ) , new TransientPublisher ( new MachineClock ( ) ) ) ; 
public Object query ( Object prevalentSystem , Date executionTime ) throws Exception ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) throws Exception ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public Object execute ( Query query ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn query . query ( _prevalentSystem , clock ( ) . time ( ) ) ; 
tvoid writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = File . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " , _directory ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; } 
tlong latestVersion ( ) throws IOException { tString [ ] fileNames = _directory . list ( ) ; if ( fileNames = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; tlong result = 0 ; tfor ( int i = 0 ; i < fileNames . length ; i + + ) { tlong candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } treturn result ; } 
private File snapshotFile ( long version ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
public void publish ( Transaction transaction ) { ttry { ttransaction . executeOn ( royalFoodTaster ( ) , clock ( ) . time ( ) ) ; } 
private void letTheFoodTasterDie ( ) { t_royalFoodTaster = null ; } 
private Object royalFoodTaster ( ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( ) ; treturn _royalFoodTaster ; } 
private void produceNewFoodTaster ( ) { ttry { TODO Optimization: use some sort of producer-consumer stream so that serialization as deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public final void executeOn ( Object prevalentSystem , Date timestamp ) { ttry { t_result = _delegate . executeAndQuery ( prevalentSystem , timestamp ) ; 
public void publish ( Transaction transaction ) { notifySubscribers ( transaction , _clock . time ( ) ) ; } 
tvoid append ( String appendix ) { tvalue = value + appendix ; if ( appendix . equals ( " rollback " ) ) throw new RuntimeException ( " Testing Rollback " ) ; } 
public void testPersistence ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; tprevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void append ( String appendix , String expectedResult ) throws Exception { out ( " Appending " + appendix ) ; tprevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; tcompare ( system ( ) . value ( ) , expectedResult , " Result " ) ; } 
private AppendingSystem system ( ) { treturn ( AppendingSystem ) prevayler . prevalentSystem ( ) ; } 
private void newPrevalenceBase ( ) throws Exception { tprevalenceBase = _testDirectory + " \\ " + System . currentTimeMillis ( ) ; } 
private void compare ( String observed , String expected , String measurement ) { verify ( observed . equals ( expected ) , measurement + " : " + observed + " Expected: " + expected ) ; } 
protected void setUp ( ) throws Exception { tFile tempFile = File . createTempFile ( " Prevalence " , " Base " ) ; ttempFile . delete ( ) ; tassertTrue ( " Unable to create directory " + tempFile , tempFile . mkdirs ( ) ) ; t_testDirectory = tempFile . getAbsolutePath ( ) ; } 
protected void tearDown ( ) throws Exception { delete ( _testDirectory ) ; } 
tstatic public void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
tstatic private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
tstatic private void deleteDirectoryContents ( File directory ) { tFile [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public boolean accept ( File file ) { treturn file . getName ( ) . endsWith ( " transactionLog " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public void testTransientPrevaylerCreation ( ) { tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testSnapshotPrevaylerCreation ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem , _testDirectory ) ; tObject result = prevayler . execute ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { treturn new Query ( ) { public Object query ( Object prevalentSystem , Date ignored ) throws Exception { 
public Object query ( Object prevalentSystem , Date ignored ) throws Exception { treturn new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem , _testDirectory ) ; tObject result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; treturn " abc " ; } 
public void testRollback ( ) throws Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; tappend ( " a " , " a " ) ; tboolean thrown = false ; ttry { tappend ( " rollback " , " a " ) ; } catch ( RuntimeException rx ) { tthrown = true ; } if ( ! thrown ) throw new RuntimeException ( " RuntimeException expected and not thrown. " ) ; tappend ( " b " , " ab " ) ; t_prevayler = null ; } 
private void append ( String appendix , String expectedResult ) throws Exception { _prevayler . execute ( new Appendix ( appendix ) ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { return ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; treturn suite ; } 
protected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tprevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private static Object execute ( MementoTransaction command ) { try { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . time ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . toString ( ) ) ; } return null ; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { tmementos = new HashMap ( ) ; ttry { treturn transaction . execute ( this , prevalentSystem ) ; 
public abstract Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception ; public void executeOn ( Object prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( Object prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; 
protected abstract Object lookup ( Object prevalentSystem ) throws Exception ; public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; treturn null ; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; Todo todo = todoList . newTodo ( ) ; todo . setDesc ( desc ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { treturn prevalentSystem ; } 
public static Prevayler createPrevayler ( Object prevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( prevalentSystem ) ; tfactory . configurePrevalenceBase ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem , String snapshotDirectory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( prevalentSystem ) ; tfactory . configurePrevalenceBase ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
private void configureTransientMode ( boolean transientMode ) { t_transientMode = transientMode ; } 
private Clock clock ( ) { treturn _clock ! = null ? _clock : new MachineClock ( ) ; } 
public void configureClock ( Clock clock ) { t_clock = clock ; } 
public void configureReplicationClient ( String serverIpAddress ) { t_serverIpAddress = serverIpAddress ; } 
public void configureReplicationServer ( boolean serverMode ) { t_replicationServerMode = serverMode ; } 
public void configureSnapshotManager ( SnapshotManager snapshotManager ) { t_snapshotManager = snapshotManager ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _replicationServerMode ) new PublishingServer ( publisher ) ; treturn new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private String prevalenceBase ( ) { treturn _prevalenceBase ! = null ? _prevalenceBase : " PrevalenceBase " ; } 
private Object prevalentSystem ( ) { if ( _prevalentSystem = = null ) throw new IllegalStateException ( " The prevalent system must be configured. " ) ; treturn _prevalentSystem ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) throws IOException , ClassNotFoundException { tTransactionCensor censor = new TransactionCensor ( snapshotManager ) ; treturn new CentralPublisher ( clock ( ) , censor , logger ( ) ) ; } 
private TransactionLogger logger ( ) throws IOException , ClassNotFoundException { treturn _transientMode ? ( TransactionLogger ) new TransientLogger ( ) 
private SnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { treturn _snapshotManager ! = null ? _snapshotManager 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceBase ( " demo2AcidReplica " ) ; tfactory . configureReplicationClient ( args [ 0 ] ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startGui ( prevayler ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceBase ( " demo2Acid " ) ; tfactory . configureReplicationServer ( true ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceBase ( " demo2Xml " ) ; tfactory . configureSnapshotManager ( new XmlSnapshotManager ( new Bank ( ) , " demo2Xml " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) throws IOException , ClassNotFoundException { _subscribers . add ( subscriber ) ; } 
protected synchronized void notifySubscribers ( Transaction transaction , Date timestamp ) { tIterator i = _subscribers . iterator ( ) ; twhile ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transaction , timestamp ) ; } 
public synchronized void publish ( Transaction transaction ) { tDate executionTime = _clock . time ( ) ; t_censor . approve ( transaction , executionTime ) ; t_logger . log ( transaction , executionTime ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { t_logger . update ( subscriber , initialTransaction ) ; tsuper . addSubscriber ( subscriber ) ; } 
public void execute ( Transaction transaction ) { _publisher . publish ( transaction ) ; } 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
private TransactionSubscriber subscriber ( ) { treturn new TransactionSubscriber ( ) { 
public void receive ( Transaction transaction , Date executionTime ) { tsynchronized ( _prevalentSystem ) { t_systemVersion + + ; 
tObject recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { writeSnapshot ( prevalentSystem , out ) ; 
private long latestVersion ( ) throws IOException { tString [ ] fileNames = _directory . list ( ) ; if ( fileNames = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; tlong result = 0 ; tfor ( int i = 0 ; i < fileNames . length ; i + + ) { tlong candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } treturn result ; } 
private Object readSnapshot ( long version ) throws ClassNotFoundException , IOException { tFile snapshotFile = snapshotFile ( version ) ; treturn readSnapshot ( snapshotFile ) ; } 
private Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return readSnapshot ( in ) ; 
tvoid approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { ttransaction . executeOn ( royalFoodTaster ( ) , executionTime ) ; 
private void produceNewFoodTaster ( ) { ttry { TODO Optimization: use some sort of producer-consumer stream so that serialization and deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public Clock clock ( ) ; } 
public void publish ( Transaction transaction ) ; public Clock clock ( ) ; } 
protected Object readSnapshot ( InputStream in ) throws IOException { tStreamSource source = new StreamSource ( in ) ; ttry { treturn this . trans . deserialize ( source ) ; 
public synchronized void log ( Transaction transaction , Date executionTime ) { if ( ! _nextTransactionKnown ) throw new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; outputToLog ( new TransactionLogEntry ( transaction , executionTime ) ) ; t_nextTransaction + + ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { thang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long transactionNumber ) { thang ( iox , " nThe exception above was thrown while trying to write " + objectToWrite . getClass ( ) + " to file " + logFile + " (Transaction number " + transactionNumber + " ). Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { t_nextTransaction = initialTransaction ; 
public abstract void log ( Transaction transaction , Date executionTime ) ; public abstract void update ( tTransactionSubscriber subscriber , tlong initialTransaction ) tthrows IOException , ClassNotFoundException ; } 
public abstract void update ( tTransactionSubscriber subscriber , tlong initialTransaction ) tthrows IOException , ClassNotFoundException ; } 
public synchronized void log ( Transaction transaction , Date executionTime ) { tlog . add ( new TransactionLogEntry ( transaction , executionTime ) ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { tint i = ( int ) initialTransaction - 1 ; TransactionLogEntry entry = (TransactionLogEntry)log.get(i); 
public Clock clock ( ) { } 
public void testRollback ( ) throws Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; tappend ( " a " , " a " ) ; ttry { tappend ( " rollback " , " a " ) ; tthrow new Exception ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } tappend ( " b " , " ab " ) ; t_prevayler = null ; } 
protected void tearDown ( ) throws Exception { tprevayler = null ; tsuper . tearDown ( ) ; } 
public synchronized void publish ( Transaction transaction ) { t_pausableClock . pause ( ) ; ttry { tDate executionTime = _pausableClock . time ( ) ; 
public void pause ( ) { t_brokenClock . advanceTo ( _realClock . time ( ) ) ; t_activeClock = _brokenClock ; } 
public Object execute ( Query sensitiveQuery ) throws Exception ; public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void takeSnapshot ( ) throws IOException ; } 
public Object execute ( Query query ) throws Exception { return query.query(_prevalentSystem, clock().time()); 
public void configureTransientMode ( boolean transientMode ) { t_transientMode = transientMode ; } 
public void configureReplicationClient ( String remoteServerIpAddress , int remoteServerPort ) { t_remoteServerIpAddress = remoteServerIpAddress ; t_remoteServerPort = remoteServerPort ; } 
public void configureReplicationServer ( int port ) { t_serverPort = port ; } 
public void configureTransactionFiltering ( boolean transactionFiltering ) { t_transactionFiltering = transactionFiltering ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new PublishingServer ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) throws IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new RemotePublisher ( _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , logger ( ) ) ; } 
private TransactionCensor censor ( SnapshotManager snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager ) 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) throws Exception ; } 
public static void main ( String [ ] args ) throws Exception { tprintMessage ( ) ; tPrevayler prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; tnew PrimeCalculator ( prevayler ) . start ( ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; tPrevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2 " ) ; tstartSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceBase ( " demo2Replica " ) ; tfactory . configureReplicationClient ( args [ 0 ] , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceBase ( " demo2 " ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startGui ( prevayler ) ; } 
public synchronized void publish ( Transaction transaction ) { Date executionTime = _pausableClock.time(); 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { } } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { ttransaction . executeOn ( royalFoodTaster ( ) , executionTime ) ; 
private void letTheFoodTasterDie ( ) { t_royalFoodTaster = null ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error ; } 
public abstract void log ( Transaction transaction , Date executionTime ) ; public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
private void startListening ( ) { tThread listener = new Thread ( ) { public void run ( ) { ttry { twhile ( true ) receiveTransactionFromServer ( ) ; } catch ( Exception ex ) { tex . printStackTrace ( ) ; } } } ; tlistener . setDaemon ( true ) ; tlistener . start ( ) ; } 
public void run ( ) { ttry { twhile ( true ) receiveTransactionFromServer ( ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; tsynchronized ( _upToDateMonitor ) { t_toServer . writeObject ( new Long ( initialTransaction ) ) ; 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( RemoteConnection . SUBSCRIBER_UP_TO_DATE ) ) { tsynchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } treturn ; } tDate timestamp = ( Date ) _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { tsynchronized ( _myTransactionMonitor ) { } 
public Clock clock ( ) { } 
public void testPersistence ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; t_prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void snapshot ( ) throws IOException { out ( " Snapshot. " ) ; t_prevayler . takeSnapshot ( ) ; } 
private void append ( String appendix , String expectedResult ) throws Exception { out ( " Appending " + appendix ) ; t_prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private AppendingSystem system ( ) { treturn ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
private String prevalenceBase ( ) { treturn _prevalenceBase ; } 
private void newPrevalenceBase ( ) throws Exception { t_prevalenceBase = _testDirectory + " \\ " + System . currentTimeMillis ( ) ; } 
protected void setUp ( ) throws Exception { tFile tempFile = File . createTempFile ( " Prevalence " , " Base " ) ; ttempFile . delete ( ) ; } 
public void testServerFirst ( ) throws Exception { tserverCrashRecover ( 0 ) ; tclientCrashRecover ( 0 ) ; tserverAppend ( " a " , " a " ) ; tserverAppend ( " b " , " ab " ) ; tclientAppend ( " c " , " abc " ) ; tclientAppend ( " d " , " abcd " ) ; tserverAppend ( " e " , " abcde " ) ; tclientCrashRecover ( 0 ) ; tclientAppend ( " f " , " abcdef " ) ; tserverAppend ( " g " , " abcdefg " ) ; } 
public void testClientFirst ( ) throws Exception { tserverCrashRecover ( 1 ) ; tclientCrashRecover ( 1 ) ; tclientAppend ( " a " , " a " ) ; tclientAppend ( " b " , " ab " ) ; tserverAppend ( " c " , " abc " ) ; } 
private void serverAppend ( String appendix , String expectedResult ) { tappend ( _server , appendix , expectedResult ) ; } 
private void clientAppend ( String appendix , String expectedResult ) { tappend ( _client , appendix , expectedResult ) ; } 
private void append ( Prevayler prevayler , String appendix , String expectedResult ) { tprevayler . execute ( new Appendix ( appendix ) ) ; ttry { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { } tassertEquals ( expectedResult , serverValue ( ) ) ; tassertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + " \\ server " ) ; tfactory . configureTransientMode ( true ) ; t_server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + " \\ client " ) ; t_client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + " \\ clientWithServer " ) ; t_clientWithServer = factory . create ( ) ; } 
protected void tearDown ( ) throws Exception { t_server = null ; t_client = null ; t_clientWithServer = null ; tsuper . tearDown ( ) ; } 
private String serverValue ( ) { treturn ( ( AppendingSystem ) _server . prevalentSystem ( ) ) . value ( ) ; } 
private String clientValue ( ) { treturn ( ( AppendingSystem ) _client . prevalentSystem ( ) ) . value ( ) ; } 
public void testRollback ( ) throws Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; tappend ( " a " , " a " ) ; ttry { tappend ( " rollback " , " ignored " ) ; tthrow new Exception ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } tappend ( " b " , " ab " ) ; t_prevayler = null ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; treturn suite ; } 
tstatic private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
private void setupTransformer ( ) throws IOException { ttry { tthis . trans = ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
protected Object readSnapshot ( InputStream in ) throws IOException { tStreamSource source = new StreamSource ( in ) ; if ( this . trans = = null ) setupTransformer ( ) ; ttry { treturn this . trans . deserialize ( source ) ; 
public static Prevayler createPrevayler ( Object newPrevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceBase ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem , String prevalenceBase ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceBase ( prevalenceBase ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public boolean accept ( File file ) { tString name = file . getName ( ) ; if ( ! name . endsWith ( " .transactionLog " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; ttry { number ( file ) ; } catch ( RuntimeException r ) { return false ; } treturn true ; } 
public void log ( Transaction transaction , Date executionTime ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
public Object readSnapshot ( InputStream in ) throws IOException { tStreamSource source = new StreamSource ( in ) ; ttry { treturn transformer ( ) . deserialize ( source ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tStreamResult result = new StreamResult ( out ) ; ttry { ttransformer ( ) . serialize ( prevalentSystem , result ) ; 
private ObjectTransformer transformer ( ) throws IOException { ttry { treturn ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem ) throws IOException , ClassNotFoundException { treturn createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Serializable prevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( prevalentSystem ) ; tfactory . configurePrevalenceBase ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { treturn createTransientPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceBase ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public void configurePrevalentSystem ( Object newPrevalentSystem ) { t_prevalentSystem = newPrevalentSystem ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) throws IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , logger ( ) ) ; } 
private void refreshClock ( ) { tThread clockRefresher = new Thread ( ) { public void run ( ) { twhile ( true ) { tDateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; tsetTitle ( " Bank - " + format . format ( _prevayler . clock ( ) . time ( ) ) ) ; ttry { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } } ; tclockRefresher . setDaemon ( true ) ; tclockRefresher . start ( ) ; } 
public void run ( ) { twhile ( true ) { tDateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; 
private void throwEventualErrors ( ) throws RuntimeException , Error { ttry { if ( _myTransactionRuntimeException ! = null ) throw _myTransactionRuntimeException ; 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( ServerConnection . SUBSCRIBER_UP_TO_DATE ) ) { tsynchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } treturn ; } if ( transactionCandidate instanceof RuntimeException ) { t_myTransactionRuntimeException = ( RuntimeException ) transactionCandidate ; notifyMyTransactionMonitor ( ) ; treturn ; } if ( transactionCandidate instanceof Error ) { t_myTransactionError = ( Error ) transactionCandidate ; notifyMyTransactionMonitor ( ) ; treturn ; } tDate timestamp = ( Date ) _fromServer . readObject ( ) ; t_clock . advanceTo ( timestamp ) ; if ( transactionCandidate . equals ( ServerConnection . CLOCK_TICK ) ) return ; if ( transactionCandidate . equals ( ServerConnection . REMOTE_TRANSACTION ) ) { t_subscriber . receive ( _myTransaction , timestamp ) ; notifyMyTransactionMonitor ( ) ; treturn ; } t_subscriber . receive ( ( Transaction ) transactionCandidate , timestamp ) ; } 
private void notifyMyTransactionMonitor ( ) { tsynchronized ( _myTransactionMonitor ) { t_myTransactionMonitor . notify ( ) ; 
private void sendClockTicks ( ) { tThread clockTickSender = new Thread ( ) { public void run ( ) { ttry { twhile ( true ) { tsynchronized ( _toRemote ) { t_toRemote . writeObject ( CLOCK_TICK ) ; t_toRemote . writeObject ( _publisher . clock ( ) . time ( ) ) ; } tThread . sleep ( 1000 ) ; } } catch ( Exception ex ) { tex . printStackTrace ( ) ; } } } ; tclockTickSender . setDaemon ( true ) ; tclockTickSender . start ( ) ; } 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteTransaction = ( Transaction ) _fromRemote . readObject ( ) ; ttry { t_publisher . publish ( _remoteTransaction ) ; 
private void send ( Object object ) { tsynchronized ( _toRemote ) { ttry { 
public void run ( ) { ttry { twhile ( true ) new ServerConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public Object recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public long recoveredVersion ( ) { return _recoveredVersion ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = File . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " , _directory ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { ObjectOutputStream stream = new ObjectOutputStream ( out ) ; stream . writeObject ( prevalentSystem ) ; } 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; return ois . readObject ( ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; tassertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem , _testDirectory ) ; tObject result = prevayler . execute ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem , _testDirectory ) ; tObject result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void executeOn ( Object ignored , Date ignoredToo ) { t_illegalDirectReference . append ( " anything " ) ; } 
public void accountCreated ( Account account ) ; public void accountDeleted ( Account account ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceBase ( prevalenceBase ) ; treturn factory . create ( ) ; } 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory factory = new PrevaylerFactory(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceBase(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public synchronized void log ( Transaction transaction , Date executionTime ) { if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; outputToLog ( new TransactionLogEntry ( transaction , executionTime ) ) ; t_nextTransaction + + ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( initialTransaction > _nextTransaction ) throw new IOException ( " Unable to find transactions from " + _nextTransaction + " to " + ( initialTransaction - 1 ) + " . " ) ; if ( initialTransaction = = _nextTransaction ) return ; tlong initialFileCandidate = initialTransaction ; twhile ( ! transactionLogFile ( initialFileCandidate ) . exists ( ) ) { tinitialFileCandidate - - ; if ( initialFileCandidate < = 0 ) throwNotFound ( initialTransaction ) ; } tupdate ( subscriber , initialTransaction , initialFileCandidate ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException { tint i = ( int ) initialTransaction - 1 ; TransactionLogEntry entry = (TransactionLogEntry)log.get(i); 
Object getState ( ) ; void setState ( Object state ) ; Object receive ( Object message ) ; } 
void setState ( Object state ) ; Object receive ( Object message ) ; } 
public Object receive ( Object message ) { ClusteredTransaction transaction = ( ClusteredTransaction ) message ; return transaction . executeOn ( this ) ; } 
public Object prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public Clock clock ( ) { return prevayler . clock ( ) ; } 
public void execute ( Transaction transaction ) { ClusteredTransaction clusterTransaction = new ClusteredTransaction ( transaction , clock ( ) . time ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public Object execute ( Query sensitiveQuery ) throws Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public void takeSnapshot ( ) throws IOException { prevayler . takeSnapshot ( ) ; } 
private void backupOldLocalTransactionLogs ( ) { System . out . println ( " Moving away old local transaction logs " ) ; File oldPrevalenceBaseFile = new File ( oldPrevalenceBase ) ; File [ ] files = oldPrevalenceBaseFile . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { files [ i ] . delete ( ) ; } } oldPrevalenceBaseFile . delete ( ) ; new File ( newPrevalenceBase ) . renameTo ( oldPrevalenceBaseFile ) ; } 
public void executeBroadcastedTransaction ( Transaction transaction ) { prevayler . execute ( transaction ) ; } 
public Object executeOn ( ClusteredPrevayler prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
public void viewAccepted ( View view ) { System . out . println ( " Members " + view . size ( ) ) ; } 
public void waitForConnection ( ) throws InterruptedException { broadcast ( " Node Connecting " ) ; } 
public void broadcast ( Serializable message ) { try { acquireClusterWideLock ( ) ; 
private void releaseClusterWideLock ( ) throws ChannelException { System . out . println ( " Releasing cluster lock " ) ; boolean lockReleased = false ; while ( ! lockReleased ) { try { distributedLockManager . unlock ( LOCK_ID , lockChannel . getLocalAddress ( ) . toString ( ) ) ; lockReleased = true ; } catch ( LockNotReleasedException e ) { } } System . out . println ( " Broadcast lock released " ) ; } 
private void acquireClusterWideLock ( ) throws ChannelException { System . out . println ( " Grabbing cluster lock " ) ; boolean lockAcquired = false ; while ( ! lockAcquired ) { try { 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( message . getObject ( ) ) ; } return null ; } 
public boolean isMaster ( ) { return getAddress ( ) . equals ( getMasterAddress ( ) ) ; } 
public void shutdown ( ) { channel . close ( ) ; lockChannel . close ( ) ; dispatcher . stop ( ) ; try { Thread . sleep ( 1000 ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; prevalenceBase = createTempDirectory ( ) ; factory = new PrevaylerFactory ( ) ; factory . configureTransientMode ( true ) ; factory . configurePrevalentSystem ( new ListSystem ( ) ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; } 
protected void tearDown ( ) throws Exception { super . tearDown ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; } 
public void testReplicationOfTransactions ( ) throws Exception { Transaction transaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; } 
public void testMultipleTransactionExecutions ( ) throws Exception { Transaction transaction = new AddToList ( " And once more " ) ; prevayler2 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; } 
public void testSync ( ) throws Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; } 
public void testRestartingClusterWillKeepData ( ) throws Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void testLocking ( ) throws Exception { Thread t1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread t2 = createAddToListThread ( prevayler1 , " 2 " ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( 20 , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private Thread createAddToListThread ( final Prevayler prevayler , final String string ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { for ( int i = 0 ; i < 10 ; i + + ) { prevayler . execute ( new AddToList ( string ) ) ; 
private void assertAllSystemsEqual ( ) { assertEquals ( prevayler1 . prevalentSystem ( ) , prevayler2 . prevalentSystem ( ) ) ; assertEquals ( prevayler1 . clock ( ) . time ( ) , prevayler2 . clock ( ) . time ( ) ) ; assertObjectsInSystemNotSame ( ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text , ( ( ListSystem ) prevayler2 . prevalentSystem ( ) ) . text ) ; } 
private ClusteredPrevayler createPrevayler ( String name ) throws Exception { factory . configurePrevalentSystem ( new ListSystem ( ) ) ; return new ClusteredPrevayler ( factory , prevalenceBase ( " old " + name ) , prevalenceBase ( " new " + name ) ) ; } 
private String prevalenceBase ( String name ) { return new File ( prevalenceBase , name ) . getAbsolutePath ( ) ; } 
private File createTempDirectory ( ) throws IOException { File dir = File . createTempFile ( " prevalenceBase " , " .tmp " ) ; dir . delete ( ) ; dir . mkdirs ( ) ; return dir ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ListSystem list = ( ListSystem ) prevalentSystem ; list . add ( string , executionTime ) ; } 
public void add ( String string , Date executionTime ) { text . append ( string ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof ListSystem ) ) return false ; final ListSystem clockedList = ( ListSystem ) o ; if ( ! text . toString ( ) . equals ( clockedList . text . toString ( ) ) ) return false ; return true ; } 
public int hashCode ( ) { int result ; result = ( text ! = null ? text . hashCode ( ) : 0 ) ; return result ; } 
public String toString ( ) { return " ClockedList@ " + hashCode ( ) + " text: " + text ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; node = new Node ( ) ; receivedMessages = new ArrayList ( ) ; } 
protected void tearDown ( ) throws Exception { super . tearDown ( ) ; node . shutdown ( ) ; } 
public void testFindNodes ( ) throws Exception { assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( 2 , node . getNumberOfNodesInCluster ( ) ) ; node2 . shutdown ( ) ; assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; } 
public void testAssignMaster ( ) throws Exception { assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; assertFalse ( node . getAddress ( ) . equals ( node2 . getAddress ( ) ) ) ; node . shutdown ( ) ; assertEquals ( node2 . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void testMultipleNodes ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void testBroadCast ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; node2 . setListener ( createListAddListener ( ) ) ; String message = " Hello World " ; node . broadcast ( message ) ; assertEquals ( 1 , receivedMessages . size ( ) ) ; assertEquals ( message , receivedMessages . get ( 0 ) ) ; node2 . shutdown ( ) ; } 
public void testMultipleMessages ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( new Integer ( i ) ) ; } else { node2 . broadcast ( new Integer ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( new Integer ( i ) , receivedMessages . get ( i ) ) ; 
private ClusterListener createListAddListener ( ) { return new ClusterListener ( ) { public Object receive ( Object message ) { 
public Object receive ( Object message ) { receivedMessages . add ( message ) ; return null ; } 
private Node createNodeAndWait ( ) throws InterruptedException { Node node = new Node ( ) ; node . waitForConnection ( ) ; return node ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configureSnapshotManager ( new NullSnapshotManager ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { treturn createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static Prevayler createCheckpointPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceBase ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tthrow new IOException ( _snapshotAttemptErrorMessage ) ; } 
public void testQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem ) ; tObject result = prevayler . execute ( query ( ) ) ; tassertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tList prevalentSystem = new LinkedList ( ) ; tPrevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem ) ; tObject result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void testRollback ( ) throws Exception { ttestRollback ( PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ) ; ttestRollback ( PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ) ; } 
private void testRollback ( Prevayler prevayler ) throws Exception { t_prevayler = prevayler ; tappend ( " a " , " a " ) ; ttry { tappend ( " rollback " , " ignored " ) ; tfail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } tappend ( " b " , " ab " ) ; t_prevayler = null ; } 
private void append ( String appendix , String expectedResult ) throws Exception { _prevayler . execute ( new Appendix ( appendix ) ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
protected void setUp ( ) throws Exception { tsuper . setUp ( ) ; tprevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void testSnapshotAttempt ( ) { ttry { tprevayler . takeSnapshot ( ) ; 
public String toString ( ) { return " Project Id: " + id + " n 
public String toString ( ) { return " n Task Id: " + id + " n 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void close ( ) throws IOException ; } 
public void takeSnapshot ( ) throws IOException ; public void close ( ) throws IOException ; } 
tstatic private int numberOfObjects ( ) { tString property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; tthrow new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; 
tstatic private boolean isPrevaylerQueryChosen ( ) { treturn booleanProperty ( " RunPrevaylerQueryTest " ) ; 
tstatic private int prevaylerQueryThreadsMin ( ) { treturn intProperty ( " PrevaylerQueryThreadsMinimum " ) ; 
tstatic private int prevaylerQueryThreadsMax ( ) { treturn intProperty ( " PrevaylerQueryThreadsMaximum " ) ; 
tstatic private boolean isPrevaylerTransactionChosen ( ) { treturn booleanProperty ( " RunPrevaylerTransactionTest " ) ; 
tstatic private int prevaylerTransactionThreadsMin ( ) { treturn intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; 
tstatic private int prevaylerTransactionThreadsMax ( ) { treturn intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; 
tstatic private String prevaylerTransactionLogDirectory ( ) { tString result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; treturn result ; 
tstatic private boolean isJdbcQueryChosen ( ) { treturn booleanProperty ( " RunJdbcQueryTest " ) ; 
tstatic private int jdbcQueryThreadsMin ( ) { treturn intProperty ( " JdbcQueryThreadsMinimum " ) ; 
tstatic private int jdbcQueryThreadsMax ( ) { treturn intProperty ( " JdbcQueryThreadsMaximum " ) ; 
tstatic private boolean isJdbcTransactionChosen ( ) { treturn booleanProperty ( " RunJdbcTransactionTest " ) ; 
tstatic private int jdbcTransactionThreadsMin ( ) { treturn intProperty ( " JdbcTransactionThreadsMinimum " ) ; 
tstatic private int jdbcTransactionThreadsMax ( ) { treturn intProperty ( " JdbcTransactionThreadsMaximum " ) ; 
tstatic private String jdbcDriverClassName ( ) { treturn property ( " JdbcDriverClassName " ) ; 
tstatic private String jdbcConnectionURL ( ) { treturn property ( " JdbcConnectionURL " ) ; 
tstatic private String jdbcUser ( ) { treturn property ( " JdbcUser " ) ; 
tstatic private String jdbcPassword ( ) { treturn property ( " JdbcPassword " ) ; 
tstatic private String property ( String name ) { tString result = properties . getProperty ( name ) ; if ( result = = null ) throw new RuntimeException ( " Property " + name + " not found. " ) ; treturn result ; 
tstatic private boolean booleanProperty ( String name ) { tboolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return true ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; treturn false ; 
tstatic private void out ( Object message ) { tSystem . out . println ( message ) ; 
protected void prepare ( ) { tsubject . replaceAllRecords ( numberOfObjects ) ; tSystem . gc ( ) ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; } 
tvoid replaceAllRecords ( int records ) { tRecordIterator newRecords = new RecordIterator ( records ) ; ttry { tconnection . createStatement ( ) . execute ( " delete from " + table ( ) ) ; } catch ( SQLException sqlx ) { tdealWithSQLException ( sqlx , " deleting all records from " + table ( ) ) ; } twhile ( newRecords . hasNext ( ) ) { tinsert ( newRecords . next ( ) ) ; } ttry { tconnection . commit ( ) ; 
public void replaceAllRecords ( int records ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( records ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
public static void wait ( Object object ) { ttry { tobject . wait ( ) ; 
public void sync ( Object object , Turn myTurn ) throws IOException { tSyncBatch myBatch ; ttry { tmyTurn . start ( ) ; t_objectOutputStream . writeObject ( object ) ; tmyBatch = _nextBatchToSync ; } finally { tmyTurn . end ( ) ; } tmyBatch . sync ( ) ; if ( _exceptionWhileSynching ! = null ) throw _exceptionWhileSynching ; } 
private void syncToFile ( ) { if ( _exceptionWhileSynching ! = null ) return ; ttry { t_objectOutputStream . flush ( ) ; 
public void close ( ) throws IOException { _objectOutputStream . close ( ) ; } 
private void startSyncher ( ) { tThread syncher = new Thread ( ) { public void run ( ) { tsynchronized ( _syncherMonitor ) { twhile ( true ) { tSyncBatch currentBatch = _nextBatchToSync ; t_nextBatchToSync = new SyncBatch ( ) ; tsyncToFile ( ) ; tcurrentBatch . setSynched ( ) ; tCool . wait ( _syncherMonitor ) ; } } } } ; tsyncher . setDaemon ( true ) ; tsyncher . start ( ) ; } 
public void run ( ) { tsynchronized ( _syncherMonitor ) { twhile ( true ) { 
tsynchronized void sync ( ) { if ( _isSynched ) return ; if ( ! _isSynching ) { t_isSynching = true ; tsynchronized ( _syncherMonitor ) { _syncherMonitor . notify ( ) ; } } tCool . wait ( this ) ; } 
public static Turn first ( ) { return new Turn ( 1000000 ) ; } Arbitrarily large number. 
public Turn next ( ) { if ( _next = = null ) _next = new Turn ( 0 ) ; treturn _next ; } 
public synchronized void start ( ) { if ( _tickets = = 0 ) Cool . wait ( this ) ; t_tickets - - ; } 
private synchronized void haveSomeTickets ( int tickets ) { if ( _isAlwaysSkipped ) { tnext ( ) . haveSomeTickets ( tickets ) ; treturn ; } t_tickets + = tickets ; notify ( ) ; } 
public synchronized void alwaysSkip ( ) { tend ( ) ; t_isAlwaysSkipped = true ; tnext ( ) . haveSomeTickets ( _tickets ) ; } 
public void execute ( Transaction transaction ) { tpublish ( ( Transaction ) deepCopy ( transaction ) ) ; } 
private void publish ( Transaction transaction ) { t_publisher . publish ( transaction ) ; } 
public Object execute ( Query sensitiveQuery ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn sensitiveQuery . query ( _prevalentSystem , clock ( ) . time ( ) ) ; 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionWithQuery copy = ( TransactionWithQuery ) deepCopy ( transactionWithQuery ) ; tTransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( copy ) ; tpublish ( executer ) ; treturn executer . result ( ) ; } 
public void close ( ) throws IOException { _publisher . close ( ) ; } 
private Object deepCopy ( Object transaction ) { } 
public void pause ( ) { tadvanceTo ( _realClock . time ( ) ) ; t_activeClock = _brokenClock ; } 
public void advanceTo ( Date time ) { t_brokenClock . advanceTo ( time ) ; } 
public void log ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; tsynchronized ( _nextTransactionMonitor ) { if ( _outputLog = = null ) createNewOutputLog ( _nextTransaction ) ; _outputLog.sync(new TransactionTimestamp(transaction, executionTime), myTurn); 
private void createNewOutputLog ( long transactionNumber ) { tFile file = transactionLogFile ( transactionNumber ) ; ttry { _outputLog = new DurableOutputStream ( file ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { tlong initialLogFile = findInitialLogFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { tinitializeNextTransaction ( initialTransactionWanted , 1 ) ; treturn ; } tlong nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; tinitializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long findInitialLogFile ( long initialTransactionWanted ) { tlong initialFileCandidate = initialTransactionWanted ; twhile ( initialFileCandidate ! = 0 ) { } 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) throws IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) throw new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) throw new IOException ( " Unable to find transactionLog file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) throw new IllegalStateException ( ) ; treturn ; } t_nextTransactionInitialized = true ; t_nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tSimpleInputStream inputLog = new SimpleInputStream ( transactionLogFile ( recoveringTransaction ) ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction , entry . timestamp ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile logFile = transactionLogFile ( recoveringTransaction ) ; if ( ! logFile . exists ( ) ) break ; tinputLog = new SimpleInputStream ( logFile ) ; } } treturn recoveringTransaction ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile ) { thang ( iox , " nThe exception above was thrown while trying to write to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile). " ) ; } 
public void close ( ) throws IOException { if ( _outputLog ! = null ) _outputLog . close ( ) ; } 
public void log ( Transaction transaction , Date executionTime , Turn threadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void log ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; ttry { tmyTurn . start ( ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException { if ( ! _initialTransactionInitialized ) { t_initialTransactionInitialized = true ; t_initialTransaction = initialTransaction ; treturn ; } if ( initialTransaction < _initialTransaction ) throw new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; tint i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > log . size ( ) ) throw new IOException ( " The transaction log has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + log . size ( ) - 1 ) + " . " ) ; twhile ( i ! = log . size ( ) ) { tTransactionTimestamp entry = ( TransactionTimestamp ) log . get ( i ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) throws IOException , ClassNotFoundException { t_subscribers . add ( subscriber ) ; } 
public synchronized void removeSubscriber ( TransactionSubscriber subscriber ) { t_subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( Transaction transaction , Date timestamp ) { tIterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transaction , timestamp ) ; } 
public void publish ( Transaction transaction ) { tsynchronized ( _pendingSubscriptionMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transaction); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
private Turn nextTurn ( ) { tsynchronized ( _nextTurnMonitor ) { tTurn result = _nextTurn ; 
private Date realTime ( Turn myTurn ) { ttry { tmyTurn . start ( ) ; 
private void approve ( Transaction transaction , Date executionTime , Turn myTurn ) throws RuntimeException , Error { ttry { tmyTurn . start ( ) ; 
private void notifySubscribers ( Transaction transaction , Date executionTime , Turn myTurn ) { ttry { tmyTurn . start ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { tsynchronized ( _pendingSubscriptionMonitor ) { twhile ( _pendingPublications ! = 0 ) Thread . yield ( ) ; 
public void close ( ) throws IOException { _logger . close ( ) ; } 
public synchronized void receive ( Transaction transaction , Date timestamp ) { t_queue . add ( new TransactionTimestamp ( transaction , timestamp ) ) ; notify ( ) ; } 
public void run ( ) { twhile ( true ) { tTransactionTimestamp notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp waitForNotification ( ) { twhile ( _queue . size ( ) = = 0 ) waitWithoutInterruptions ( ) ; treturn ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
private void waitWithoutInterruptions ( ) { ttry { twait ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) throws IOException ; } 
public void publish ( Transaction transaction ) ; public void close ( ) throws IOException ; } 
public Clock clock ( ) ; public void close ( ) throws IOException ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { tTransaction transactionCopy = ( Transaction ) _snapshotManager . deepCopy ( transaction , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
private void produceNewFoodTaster ( ) { ttry { tByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; tsynchronized ( _upToDateMonitor ) { t_toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public void removeSubscriber ( TransactionSubscriber subscriber ) { tthrow new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Transaction transaction ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; tsynchronized ( _myTransactionMonitor ) { t_myTransaction = transaction ; 
public void close ( ) throws IOException { t_fromServer . close ( ) ; t_toServer . close ( ) ; } 
public Object deepCopy ( Object original , String errorMessage ) { ttry { tByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
public void testCheckpoint ( ) throws Exception { tcrashRecover ( ) ; verify("abcd"); 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; t_prevayler = PrevaylerFactory . createCheckpointPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; t_prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
tstatic private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; tassertTrue ( " Unable to delete " + file , file . delete ( ) ) ; } 
tstatic private void deleteDirectoryContents ( File directory ) { tFile [ ] files = directory . listFiles ( new PrevalenceFileFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public void testCheckpointPrevaylerCreation ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
private String clientValue ( ) { ttry { tThread . sleep ( 10 ) ; } 
private void testRollback ( Prevayler prevayler ) throws Exception { t_prevayler = prevayler ; tappend ( " a " , " a " ) ; ttry { tappend ( " rollback " , " ignored " ) ; tfail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } tappend ( " b " , " ab " ) ; t_prevayler . close ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; treturn suite ; } 
public void testFailFastBaptismProblem ( ) { tappend ( " a " ) ; tAppendingSystem directReference = ( AppendingSystem ) prevayler . prevalentSystem ( ) ; tprevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; tassertState ( " a " ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TaskList system = ( TaskList ) prevalentSystem ; system . addTask ( task ) ; } 
public static void main ( String [ ] args ) throws IOException , ClassNotFoundException { TaskList list = new TaskList ( ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( list , " /tasklist-base " ) ; Task dishes = new Task ( " do the dishes " , Task . MAX_PRIORITY ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; prevayler . execute ( new AddTask ( dishes ) ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; prevayler . execute ( new RemoveTask ( dishes ) ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TaskList system = ( TaskList ) prevalentSystem ; system . removeTask ( task ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof Task ) { Task = ( Task ) obj ; return ( String . valueOf ( description ) . equals ( String . valueOf ( . description ) ) ) & & ( priority = = . priority ) ; } return false ; } 
public void addTask ( Task task ) { tasks . add ( task ) ; } 
public void removeTask ( Task task ) { tasks . remove ( task ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) throws Exception { TaskList system = ( TaskList ) prevalentSystem ; system . addTask ( task ) ; return task ; } 
public void changeTask ( Task task , String description , int priority ) { if ( tasks . contains ( task ) ) { task . setDescription ( description ) ; 
public boolean equals ( Object obj ) { if ( obj instanceof Task ) { Task = ( Task ) obj ; return ( String . valueOf ( description ) . equals ( String . valueOf ( . description ) ) ) & & ( priority = = . priority ) ; } return false ; } 
public void log ( Transaction transaction , Date executionTime , Turn threadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } END SNIPPET: transactionLogger 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } END SNIPPET: transactionLogger 
public void close ( ) throws IOException ; } END SNIPPET: transactionLogger 
public Transaction transaction ( ) { return this . transaction ; } 
public Date timestamp ( ) { return new Date ( this . timestamp ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tSimpleInputStream inputLog = new SimpleInputStream ( transactionLogFile ( recoveringTransaction ) ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile logFile = transactionLogFile ( recoveringTransaction ) ; if ( ! logFile . exists ( ) ) break ; tinputLog = new SimpleInputStream ( logFile ) ; } } treturn recoveringTransaction ; } 
public void configureTransactionLogFileSizeThreshold ( long sizeInBytes ) { t_transactionLogSizeThreshold = sizeInBytes ; } 
public void configureTransactionLogFileAgeThreshold ( long ageInMilliseconds ) { t_transactionLogAgeThreshold = ageInMilliseconds ; } 
public void testFileRolling ( ) throws Exception { tcrashRecover ( " " ) ; } 
private void crashRecover ( String expectedResult ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureTransactionLogFileSizeThreshold ( 1 ) ; } 
private void newPrevalenceBase ( ) throws Exception { t_prevalenceBase = _testDirectory + File . separator + System . currentTimeMillis ( ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { delete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
tstatic public void delete ( String fileName ) { delete ( new File ( fileName ) ) ; } 
public void log ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; tprepareOutputLog ( ) ; ttry { _outputLog . sync ( new TransactionTimestamp ( transaction , executionTime ) , myTurn ) ; 
private void prepareOutputLog ( ) { tsynchronized ( _nextTransactionMonitor ) { if ( ! isOutputLogValid ( ) ) createNewOutputLog ( _nextTransaction ) ; TODO Create new output log when size threshold surpassed or age expires. 
private boolean isOutputLogValid ( ) { treturn _outputLog ! = null & & ! isOutputLogTooBig ( ) 
private boolean isOutputLogTooOld ( ) { treturn _logAgeThresholdInMillis ! = 0 & & _logAgeTimer . millisEllapsed ( ) > = _logAgeThresholdInMillis ; 
private boolean isOutputLogTooBig ( ) { treturn _logSizeThresholdInBytes ! = 0 & & _outputLog . file ( ) . length ( ) > = _logSizeThresholdInBytes ; 
private void createNewOutputLog ( long transactionNumber ) { tFile file = transactionLogFile ( transactionNumber ) ; ttry { if ( _outputLog ! = null ) _outputLog . close ( ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = transactionLogFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = transactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private void renameUnusedFile ( File logFile ) { tlogFile . renameTo ( new File ( logFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
private void crashRecover ( String expectedResult ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureTransactionLogFileSizeThreshold ( 225 ) ; } 
protected void setUp ( ) throws Exception { tFile tempFile = new File ( " PrevalenceBase " + System . currentTimeMillis ( ) + counter + + ) ; tassertTrue ( " Unable to create directory " + tempFile , tempFile . mkdirs ( ) ) ; t_testDirectory = tempFile . getAbsolutePath ( ) ; } 
tstatic private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
private String clientValue ( ) { ttry { tThread . sleep ( 100 ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( LogFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; treturn suite ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { calendar . setTimeInMillis ( this . millis ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { MyPrevalentSystem system = ( MyPrevalentSystem ) prevalentSystem ; Calendar c = system . lookupCalendar ( this . id ) ; c . setTimeInMillis ( this . millis ) ; } 
public Calendar lookupCalendar ( String id ) { return null ; } 
private TransactionLogger logger ( ) throws IOException { treturn _transientMode ? ( TransactionLogger ) new TransientLogger ( ) 
protected void addFields ( Box fieldBox ) { tfieldBox . add ( labelContainer ( " Holder " ) ) ; tfieldBox . add ( holderField ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) { t_subscribers . add ( subscriber ) ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error ; } END SNIPPET: censor 
private void clientCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + File . separator + " client " ) ; t_client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + File . separator + " clientWithServer " ) ; t_clientWithServer = factory . create ( ) ; } 
private void serverCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceBase ( _testDirectory + File . separator + " server " ) ; tfactory . configureTransientMode ( true ) ; t_server = factory . create ( ) ; } 
tstatic private void deleteDirectoryContents ( File directory ) { tFile [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected void tearDown ( ) throws Exception { }} 
protected void setUp ( ) throws Exception { tFile tempFile = new File ( " Test " + System . currentTimeMillis ( ) + counter + + ) ; tassertTrue ( " Unable to create directory " + tempFile , tempFile . mkdirs ( ) ) ; t_testDirectory = tempFile . getAbsolutePath ( ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceBase ( " demo2Skaringa " ) ; tfactory . configureSnapshotManager ( new SkaringaSnapshotManager ( new Bank ( ) , " demo2Skaringa " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceBase ( " demo2XStream " ) ; tfactory . configureSnapshotManager ( new XStreamSnapshotManager ( new Bank ( ) , " demo2XStream " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public abstract Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; }} 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { ObjectOutputStream oos = new ObjectOutputStream ( out ) ; try { oos . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; try { return ois . readObject ( ) ; 
protected String suffix ( ) { treturn " skaringasnapshot " ; } 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tXStream xstream = new XStream ( ) ; Writer writer = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; ttry { txstream . toXML ( prevalentSystem , writer ) ; 
public Object readSnapshot ( InputStream in ) throws IOException { tXStream xstream = new XStream ( ) ; Reader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; ttry { treturn xstream . fromXML ( reader ) ; 
protected String suffix ( ) { treturn " xstreamsnapshot " ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception ; public void close ( ) throws IOException ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) { ttry { treturn execute ( ( TransactionWithQuery ) sureTransactionWithQuery ) ; 
public static Object deepCopy ( Object original , SnapshotManager snapshotManager , String errorMessage ) { ByteArrayOutputStream out = new ByteArrayOutputStream(); 
public void execute ( Transaction transaction ) { tpublish ( ( Transaction ) deepCopy ( transaction ) ) ; } 
private Object deepCopy ( Object transaction ) { treturn DeepCopier . deepCopy ( transaction , _snapshotManager , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the log. " ) ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { tTransaction transactionCopy = ( Transaction ) DeepCopier . deepCopy ( transaction , _snapshotManager , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
public abstract Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; }} 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; } 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException ; public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; } 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
private void message ( Exception exception ) { texception . printStackTrace ( ) ; tSystem . err . println ( " n Thrown while reading file: " + _file + " ) " + 
private void startSyncher ( ) { tThread syncher = new Thread ( ) { public void run ( ) { tsyncher ( ) ; } } ; tsyncher . setDaemon ( true ) ; tsyncher . start ( ) ; } 
public void sync ( Object object , Turn myTurn ) throws IOException { tint thisWrite ; ttry { tmyTurn . start ( ) ; tthisWrite = writeObject ( object ) ; } finally { tmyTurn . end ( ) ; } twaitUntilSynced ( thisWrite ) ; } 
private synchronized int writeObject ( Object object ) throws IOException { if ( _closingState ! = NOT_CLOSED ) { tthrow new IOException ( " stream is closing " ) ; } t_objectOutputStream . writeObject ( object ) ; t_objectsWritten + + ; notifyAll ( ) ; treturn _objectsWritten ; } 
private synchronized void waitUntilSynced ( int thisWrite ) throws IOException { twhile ( _objectsSynced < thisWrite & & _exceptionWhileSynching = = null ) { tCool . wait ( this ) ; } if ( _objectsSynced < thisWrite ) { tthrow _exceptionWhileSynching ; 
public synchronized void close ( ) throws IOException { if ( _closingState = = NOT_CLOSED ) { t_closingState = CLOSE_CALLED ; notifyAll ( ) ; } twhile ( _closingState ! = REALLY_CLOSED ) { tCool . wait ( this ) ; } if ( _exceptionWhileClosing ! = null ) { tthrow _exceptionWhileClosing ; 
private synchronized void syncher ( ) { ttry { twhile ( true ) { 
public synchronized int fileSyncCount ( ) { treturn _fileSyncCount ; } 
public synchronized boolean reallyClosed ( ) { treturn _closingState = = REALLY_CLOSED ; } 
tstatic public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
public void testSingleThreaded ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void testMultiThreaded ( ) throws Exception { tfor ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void run ( ) { ttry { _out . sync ( _id + " .first " , _firstTurn ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( LogFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; treturn suite ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceBase ( " demo2XStream " ) ; tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; tfactory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { Writer writer = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; ttry { t_xstream . toXML ( prevalentSystem , writer ) ; 
public Object readSnapshot ( InputStream in ) throws IOException { Reader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; ttry { treturn _xstream . fromXML ( reader ) ; 
protected void nullInit ( Object recoveredPrevalentSystem ) { t_directory = null ; t_recoveredVersion = 0 ; t_recoveredPrevalentSystem = recoveredPrevalentSystem ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) throws IOException , ClassNotFoundException { t_directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; t_recoveredVersion = latestVersion ( ) ; t_recoveredPrevalentSystem = _recoveredVersion = = 0 ? newPrevalentSystem 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( LogFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; treturn suite ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tJavaSnapshotManager manager = new JavaSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tJavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tJavaSnapshotManager newManager = new JavaSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tSkaringaSnapshotManager manager = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tSkaringaSnapshotManager original = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tSkaringaSnapshotManager newManager = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tXStreamSnapshotManager manager = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tXStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tXStreamSnapshotManager newManager = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceBase ( " demo2XStream " ) ; tXStream xstream = new XStream ( new XppDriver ( ) ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; tfactory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public void configureClassLoader ( ClassLoader classLoader ) { t_classLoader = classLoader ; } 
private ClassLoader classLoader ( ) { treturn ( _classLoader ! = null ? _classLoader : getClass ( ) . getClassLoader ( ) ) ; } 
protected Class resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { treturn ( _loader ! = null ? _loader . loadClass ( v . getName ( ) ) : super . resolveClass ( v ) ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = transactionLogFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = transactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStreamWithClassLoader ( in , _loader ) ; try { return ois . readObject ( ) ; 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tJavaSnapshotManager manager = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; tassertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tJavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tJavaSnapshotManager newManager = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; tassertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void lastSnapshotRecovered ( long version ) { } } 
public void snapshotTaken ( long version ) { System . out . println ( " Snapshot " + version + " taken at " + new Date ( ) ) ; } 
public void handleExceptionWhileCreatingLogFile ( IOException iox , File logFile ) { iox . printStackTrace ( ) ; System . out . println ( " nThe exception above was thrown while trying to create file " 
public void handleExceptionWhileWritingLogFile ( IOException iox , File logFile ) { iox . printStackTrace ( ) ; System . out . println ( " nThe exception above was thrown while trying to write to file " 
public void ignoringStreamCorruption ( Exception exception , File file ) { exception . printStackTrace ( ) ; System . err . println ( " n Thrown while reading file: " + file + " ) " + " n The above is a stream corruption that can be caused by: " 
public void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { System . out . println ( " Logger initialized on " + directory . getName ( ) + " , with thresholds of " + sizeThresholdInBytes + " bytes, and " + ageThresholdInMillis + " milliseconds. " ) ; System . out . println ( " Using classloader: " + loader ) ; } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { System . out . println ( " Reading file: " + file . getName ( ) + " using " + loader ) ; } 
public void lastSnapshotRecovered ( long version ) { System . out . println ( " Last snapshot (version " + version + " ) recovered successfully. " ) ; } 
void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void handleExceptionWhileWritingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void ignoringStreamCorruption ( Exception exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) ; void lastSnapshotRecovered ( long version ) ; } 
void readingTransactionLogFile ( File file , ClassLoader loader ) ; void lastSnapshotRecovered ( long version ) ; } 
public void configureMonitor ( Monitor monitor ) { _monitor = monitor ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) ) ; } 
private Monitor monitor ( ) { treturn _monitor ! = null ? _monitor : new SimpleMonitor ( ) ; } 
private String prevalenceBase ( ) { treturn _prevalenceBase ! = null ? _prevalenceBase : " PrevalenceBase " ; } 
private ClassLoader classLoader ( ) { treturn ( _classLoader ! = null ? _classLoader : getClass ( ) . getClassLoader ( ) ) ; } public void configureClassLoader ( ClassLoader classLoader ) { 
} public void configureClassLoader ( ClassLoader classLoader ) { t_classLoader = classLoader ; } } 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { treturn _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public void execute ( Transaction transaction ) { publish ( ( Transaction ) deepCopy ( transaction ) ) ; } 
public void takeSnapshot ( ) throws IOException { try { synchronized ( _prevalentSystem ) { 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = transactionLogFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = transactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { _monitor . handleExceptionWhileCreatingLogFile ( iox , logFile ) ; thang ( ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile ) { _monitor . handleExceptionWhileWritingLogFile ( iox , logFile ) ; hang ( ) ; } 
tstatic private void hang ( ) { twhile ( true ) Thread . yield ( ) ; } 
void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void handleExceptionWhileWritingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void ignoringStreamCorruption ( Exception exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) ; void lastSnapshotRecovered ( long version ) ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { t_transactionLogSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { t_transactionLogAgeThreshold = ageInMilliseconds ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) throws IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private Journal journal ( ) throws IOException { treturn _transientMode ? ( Journal ) new TransientJournal ( ) 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
private Object deepCopy ( Object transaction ) { treturn DeepCopier . deepCopy ( transaction , _snapshotManager , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the journal. " ) ; } 
public void append ( Transaction transaction , Date executionTime , Turn threadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } END SNIPPET: transactionLogger 
public void append ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tprepareOutputJournal ( ) ; ttry { _outputJournal . sync ( new TransactionTimestamp ( transaction , executionTime ) , myTurn ) ; 
private void prepareOutputJournal ( ) { tsynchronized ( _nextTransactionMonitor ) { if ( ! isOutputJournalValid ( ) ) createNewOutputJournal ( _nextTransaction ) ; TODO Create new output log when size threshold surpassed or age expires. 
private boolean isOutputJournalValid ( ) { treturn _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private boolean isOutputJournalTooOld ( ) { treturn _journalAgeThresholdInMillis ! = 0 & & _journalAgeTimer . millisEllapsed ( ) > = _journalAgeThresholdInMillis ; 
private boolean isOutputJournalTooBig ( ) { treturn _journalSizeThresholdInBytes ! = 0 & & _outputJournal . file ( ) . length ( ) > = _journalSizeThresholdInBytes ; 
private void createNewOutputJournal ( long transactionNumber ) { tFile file = transactionJournalFile ( transactionNumber ) ; ttry { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { tlong initialLogFile = findInitialJournalFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { tinitializeNextTransaction ( initialTransactionWanted , 1 ) ; treturn ; } tlong nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; tinitializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long findInitialJournalFile ( long initialTransactionWanted ) { tlong initialFileCandidate = initialTransactionWanted ; twhile ( initialFileCandidate ! = 0 ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = transactionJournalFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = transactionJournalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private void renameUnusedFile ( File journalFile ) { tjournalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public boolean accept ( File file ) { tString name = file . getName ( ) ; if ( ! name . endsWith ( " .journal " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; ttry { number ( file ) ; } catch ( RuntimeException r ) { return false ; } treturn true ; } 
private File transactionJournalFile ( long transaction ) { tString fileName = " 0000000000000000000 " + transaction ; tfileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; treturn new File ( _directory , fileName ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File journal ) { _monitor . handleExceptionWhileCreatingLogFile ( iox , journal ) ; thang ( ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File journal ) { _monitor . handleExceptionWhileWritingLogFile ( iox , journal ) ; hang ( ) ; } 
public void close ( ) throws IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
public void append ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; ttry { tmyTurn . start ( ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException { if ( ! _initialTransactionInitialized ) { t_initialTransactionInitialized = true ; t_initialTransaction = initialTransaction ; treturn ; } if ( initialTransaction < _initialTransaction ) throw new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; tint i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) throw new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; twhile ( i ! = journal . size ( ) ) { tTransactionTimestamp entry = ( TransactionTimestamp ) journal . get ( i ) ; 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { System . out . println ( " Logger initialized on " + directory . getName ( ) + " , with thresholds of " + sizeThresholdInBytes + " bytes, and " + ageThresholdInMillis + " milliseconds. " ) ; System . out . println ( " Using classloader: " + loader ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
public void close ( ) throws IOException { _journal . close ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; treturn suite ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { t_journalSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { t_journalAgeThreshold = ageInMilliseconds ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the journal recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; tPrevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2 " ) ; tstartSnapshots ( prevayler ) ; } 
public boolean accept ( File file ) { treturn file . getName ( ) . endsWith ( " journal " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public void append ( Transaction transaction , Date executionTime , Turn threadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } END SNIPPET: journal 
public void close ( ) throws IOException ; } END SNIPPET: journal 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) throws IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) throw new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) throw new IOException ( " Unable to find journal file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) throw new IllegalStateException ( ) ; treturn ; } t_nextTransactionInitialized = true ; t_nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { } public void lastSnapshotRecovered ( long version ) { } } 
tstatic public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; tassertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
private Monitor monitor ( ) { treturn _monitor ! = null ? _monitor : new SimpleMonitor ( System . err ) ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { treturn _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
private void ignoreStreamCorruption ( Exception ex ) { tString message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; t_monitor . notify ( message , _file , ex ) ; } 
void notify ( String message ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , Exception ex ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , File file ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , File file , Exception ex ) ; } 
public void notify ( String message , File file , Exception exception ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message , Exception ex ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message ) { t_stream . println ( " " + message ) ; } 
public void notify ( String message , Exception ex ) { notify ( message ) ; notify ( ex ) ; } 
public void notify ( String message , File file ) { notify ( message + " /nFile: " + file ) ; } 
public void notify ( String message , File file , Exception ex ) { notify ( message , file ) ; notify ( ex ) ; } 
private void notify ( Exception ex ) { tex . printStackTrace ( _stream ) ; } 
private void createNewOutputJournal ( long transactionNumber ) { tFile file = journalFile ( transactionNumber ) ; ttry { tcloseOutputJournal ( ) ; 
private void closeOutputJournal ( ) throws IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
private long findInitialJournalFile ( long initialTransactionWanted ) { tlong initialFileCandidate = initialTransactionWanted ; twhile ( initialFileCandidate ! = 0 ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private File journalFile ( long transaction ) { tString fileName = " 0000000000000000000 " + transaction ; tfileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; treturn new File ( _directory , fileName ) ; } 
protected void handle ( IOException iox , File journal , String action ) { tString message = " All transaction processing is now blocked. A problem was found while " + action + " a .journal file. " ; _monitor . notify ( message , journal , iox ) ; thang ( ) ; } 
public void close ( ) throws IOException { tcloseOutputJournal ( ) ; } 
private void prepareOutputJournal ( ) { tsynchronized ( _nextTransactionMonitor ) { if ( ! isOutputJournalValid ( ) ) createNewOutputJournal ( _nextTransaction ) ; 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { treturn _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
private void ignoreStreamCorruption ( Exception ex ) { tString message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; t_monitor . notify ( this . getClass ( ) , message , _file , ex ) ; } 
protected void info ( Class clazz , String message ) { logger ( clazz ) . info ( message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { logger ( clazz ) . error ( message , ex ) ; } 
protected boolean isInfoEnabled ( Class clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class clazz ) { return Logger . getLogger ( clazz ) ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class clazz , String message , Exception ex ) { terror ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " /nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { terror ( clazz , message + " /nFile: " + file , ex ) ; } 
protected abstract void info ( Class clazz , String Message ) ; protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return true ; } } 
protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return true ; } } 
protected boolean isInfoEnabled ( Class clazz ) { return true ; } 
void notify ( Class clazz , String message ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , Exception ex ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class clazz , String message , File file , Exception exception ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , Exception ex ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , File file ) { } } 
protected void info ( Class clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected void handle ( IOException iox , File journal , String action ) { tString message = " All transaction processing is now blocked. A problem was found while " + action + " a .journal file. " ; _monitor . notify ( this . getClass ( ) , message , journal , iox ) ; thang ( ) ; } 
protected void info ( Class clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
private void log ( Class clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public void append ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tDurableOutputStream myOutputJournal ; tDurableOutputStream outputJournalToClose = null ; ttry { tmyTurn . start ( ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; t_journalAgeTimer = StopWatch . start ( ) ; } t_nextTransaction + + ; tmyOutputJournal = _outputJournal ; } finally { tmyTurn . end ( ) ; } ttry { tmyOutputJournal . sync ( new TransactionTimestamp ( transaction , executionTime ) , myTurn ) ; } catch ( IOException iox ) { thandle ( iox , _outputJournal . file ( ) , " writing to " ) ; } ttry { tmyTurn . start ( ) ; 
private boolean isOutputJournalStillValid ( ) { treturn _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = journalFile ( transactionNumber ) ; ttry { treturn new DurableOutputStream ( file ) ; 
protected void handle ( IOException iox , File journal , String action ) { tString message = " All transaction processing is now blocked. An IOException was thrown while " + action + " a .journal file. " ; _monitor . notify ( this . getClass ( ) , message , journal , iox ) ; thang ( ) ; } 
private long latestVersion ( ) throws IOException { treturn latestVersion ( _directory , suffix ( ) ) ; } 
private static long latestVersion ( File directory , String suffix ) throws IOException { tString [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tlong result = 0 ; tfor ( int i = 0 ; i < fileNames . length ; i + + ) { tlong candidate = version ( fileNames [ i ] , suffix ) ; if ( candidate > result ) result = candidate ; } treturn result ; } 
public abstract Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { treturn snapshotFile ( version , _directory , suffix ( ) ) ; } private static File snapshotFile ( long version , File directory , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ) ; } public static File latestSnapshotFile(File directory, String suffix) throws IOException {long version = latestVersion(directory, suffix);if (version == 0) {return null;} else {return snapshotFile(version, directory, suffix);}}} 
private File snapshotFile ( long version ) { treturn snapshotFile ( version , _directory , suffix ( ) ) ; } 
private static File snapshotFile ( long version , File directory , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ) ; } 
private static long version ( String fileName , String suffix ) { if ( ! fileName . endsWith ( " . " + suffix ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ) ) ) ; } 
public static File latestSnapshotFile ( File directory , String suffix ) throws IOException { tlong version = latestVersion ( directory , suffix ) ; if ( version = = 0 ) { treturn null ; 
public static File latestSnapshotFile ( File directory ) throws IOException { treturn latestSnapshotFile ( directory , SUFFIX ) ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; 
public void notify ( Class clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static Prevayler createCheckpointPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public void configurePrevalenceDirectory ( String prevalenceDirectory ) { t_prevalenceDirectory = prevalenceDirectory ; } 
private String prevalenceBase ( ) { treturn _prevalenceDirectory ! = null ? _prevalenceDirectory : " PrevalenceBase " ; } 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; treturn ; } tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceDirectory ( " demo2Replica " ) ; tfactory . configureReplicationClient ( args [ 0 ] , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] ignored ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceDirectory ( " demo2 " ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; tfactory . configureSnapshotManager ( new SkaringaSnapshotManager ( new Bank ( ) , " demo2Skaringa " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2XStream " ) ; tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; tfactory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; 
private void serverCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + " server " ) ; tfactory . configureTransientMode ( true ) ; t_server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + " client " ) ; t_client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + " clientWithServer " ) ; t_clientWithServer = factory . create ( ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { terror ( clazz , message + " nFile: " + file , ex ) ; } 
public static Object deepCopy ( Object original , String errorMessage ) { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); 
private Object deepCopy ( Object transaction ) { treturn DeepCopier . deepCopy ( transaction , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the journal. " ) ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { tTransaction transactionCopy = ( Transaction ) DeepCopier . deepCopy ( transaction , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
public static Object deepCopy ( Object original , String errorMessage ) { return new JavaSerializationStrategy().deepCopy(original); 
public void write ( byte [ ] b ) throws IOException { t_active . write ( b ) ; } 
public void write ( byte [ ] b , int off , int len ) throws IOException { t_active . write ( b , off , len ) ; } 
public void write ( int b ) throws IOException { t_active . write ( b ) ; } 
public void sync ( Object object , Turn myTurn ) throws IOException { tint thisWrite ; } 
private int writeObject ( Object object ) throws IOException { tsynchronized ( _writeLock ) { if ( _closed ) { 
public void close ( ) throws IOException { tsynchronized ( _syncLock ) { tsynchronized ( _writeLock ) { 
private void internalClose ( ) { tsynchronized ( _writeLock ) { t_closed = true ; 
public synchronized int fileSyncCount ( ) { tsynchronized ( _syncLock ) { treturn _fileSyncCount ; 
public boolean reallyClosed ( ) { tsynchronized ( _writeLock ) { treturn _closed ; 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { treturn _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public void close ( ) throws IOException { t_fileStream . close ( ) ; t_EOF = true ; } 
public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException { tByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; tSerializer objectOut = createSerializer ( byteOut ) ; tobjectOut . writeObject ( original ) ; tobjectOut . flush ( ) ; tByteArrayInputStream byteIn = new ByteArrayInputStream ( byteOut . toByteArray ( ) ) ; tDeserializer objectIn = createDeserializer ( byteIn ) ; treturn objectIn . readObject ( ) ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { treturn _stream . readObject ( ) ; } 
public Serializer createSerializer ( OutputStream stream ) throws IOException { treturn new JavaSerializer ( stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException { treturn new JavaDeserializer ( stream , _loader ) ; } 
public void writeObject ( Object object ) throws IOException { } 
public void flush ( ) throws IOException { t_stream . flush ( ) ; } 
public Serializer createSerializer ( OutputStream stream ) throws IOException ; public Deserializer createDeserializer ( InputStream stream ) throws IOException ; public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException ; public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException ; } 
public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException ; } 
public void writeObject ( Object object ) throws IOException ; public void flush ( ) throws IOException ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tSerializationStrategy strategy = new JavaSerializationStrategy ( _loader ) ; tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , strategy , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void configureClassLoader ( ClassLoader classLoader ) { t_classLoader = classLoader ; if ( _journalSerializationStrategy = = null ) { t_journalSerializationStrategy = new JavaSerializationStrategy ( _classLoader ) ; 
private SerializationStrategy journalSerializationStrategy ( ) { treturn _journalSerializationStrategy ! = null ? _journalSerializationStrategy : new JavaSerializationStrategy ( ) ; } 
public void configureJournalSerializationStrategy ( SerializationStrategy strategy ) { t_journalSerializationStrategy = strategy ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializationStrategy ( ) ) ; } 
private TransactionCensor censor ( SnapshotManager snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializationStrategy ( ) ) 
private Object deepCopy ( Object transaction ) { ttry { treturn _journalSerializationStrategy . deepCopy ( transaction ) ; 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = journalFile ( transactionNumber ) ; ttry { treturn new DurableOutputStream ( file , _journalSerializationStrategy ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _journalSerializationStrategy , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void approve ( Transaction transaction , Date executionTime ) throws RuntimeException , Error { ttry { tTransaction transactionCopy = deepCopy ( transaction ) ; 
private Transaction deepCopy ( Transaction transaction ) { ttry { treturn ( Transaction ) _journalSerializationStrategy . deepCopy ( transaction ) ; 
public static Object deepCopy ( Object original , String errorMessage ) { ttry { treturn new JavaSerializationStrategy ( ) . deepCopy ( original ) ; 
public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .journal " ) ; } 
private Prevayler createMyPrevayler ( ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializationStrategy ( new MySerializationStrategy ( ) ) ; treturn factory . create ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { tStringBuffer system = ( StringBuffer ) prevalentSystem ; tsystem . append ( toAdd ) ; } 
public Serializer createSerializer ( final OutputStream stream ) throws IOException { tfinal Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; treturn new Serializer ( ) { public void writeObject ( Object object ) throws IOException { 
public void writeObject ( Object object ) throws IOException { if ( object instanceof TransactionTimestamp ) { tTransactionTimestamp timestamp = ( TransactionTimestamp ) object ; 
public void flush ( ) throws IOException { twriter . flush ( ) ; } 
public Deserializer createDeserializer ( final InputStream stream ) throws IOException { tfinal BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; treturn new Deserializer ( ) { public Object readObject ( ) throws IOException { 
public Object readObject ( ) throws IOException { tString type = reader . readLine ( ) ; if ( " TransactionTimestamp " . equals ( type ) ) { tString toAdd = reader . readLine ( ) ; 
public Serializer createSerializer ( OutputStream stream ) throws IOException ; public Deserializer createDeserializer ( InputStream stream ) throws IOException ; public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException ; } 
public Object readObject ( ) throws IOException { ttry { treturn _xstream . fromXML ( _reader ) ; 
public Serializer createSerializer ( OutputStream stream ) throws IOException { treturn new XStreamSerializer ( _xstream , stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException { treturn new XStreamDeserializer ( _xstream , stream ) ; } 
public void writeObject ( Object object ) throws IOException { ttry { t_xstream . toXML ( object , _writer ) ; 
public void flush ( ) throws IOException { t_writer . flush ( ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tSerializer serializer = _strategy . createSerializer ( out ) ; ttry { tserializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { tDeserializer deserializer = _strategy . createDeserializer ( in ) ; treturn deserializer . readObject ( ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tSerializer serializer = _strategy . createSerializer ( out ) ; try { serializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { tDeserializer deserializer = _strategy . createDeserializer ( in ) ; return deserializer . readObject ( ) ; } 
private SerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) { treturn _journalSerializationStrategy ; 
public void configureSnapshotSerializationStrategy ( SerializationStrategy strategy ) { t_snapshotSerializationStrategy = strategy ; } 
private SnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) { treturn _snapshotManager ; 
public Object readObject ( ) throws IOException { ttry { treturn SkaringaSerializationStrategy . transformer ( ) . deserialize ( _source ) ; 
public Serializer createSerializer ( OutputStream stream ) throws IOException { treturn new SkaringaSerializer ( stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException { treturn new SkaringaDeserializer ( stream ) ; } 
tstatic ObjectTransformer transformer ( ) throws IOException { ttry { treturn ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public void writeObject ( Object object ) throws IOException { ttry { tSkaringaSerializationStrategy . transformer ( ) . serialize ( object , _result ) ; 
public void flush ( ) throws IOException { t_result . getOutputStream ( ) . flush ( ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new MySerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; tFile journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; tBufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( journal ) , " UTF-8 " ) ) ; tassertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; tassertEquals ( " first " , reader . readLine ( ) ) ; tassertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; tassertEquals ( " second " , reader . readLine ( ) ) ; tassertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; tassertEquals ( " third " , reader . readLine ( ) ) ; tassertNull ( reader . readLine ( ) ) ; treader . close ( ) ; trecover ( strategy ) ; } 
public void NOT_YET_WORKING_testXStreamJournal ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public void NOT_YET_WORKING_testSkaringaJournal ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
private void startAndCrash ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; tprevayler . execute ( new MyTransaction ( " first " ) ) ; tprevayler . execute ( new MyTransaction ( " second " ) ) ; tprevayler . execute ( new MyTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , ( ( StringBuffer ) prevayler . prevalentSystem ( ) ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; tassertEquals ( " the system first second third " , ( ( StringBuffer ) prevayler . prevalentSystem ( ) ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializationStrategy ( journalSerializationStrategy ) ; treturn factory . create ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; treturn suite ; } 
private String prevalenceDirectory ( ) { treturn _prevalenceDirectory ! = null ? _prevalenceDirectory : " Prevalence " ; } 
private SerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) return _journalSerializationStrategy ; treturn new JavaSerializationStrategy ( _classLoader ) ; } 
private SnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) return _snapshotManager ; if ( _snapshotSerializationStrategy ! = null ) return new GenericSnapshotManager ( _snapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; treturn new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static Object deepCopy ( Object original , String errorMessage ) { ttry { treturn new JavaSerializationStrategy ( null ) . deepCopy ( original ) ; 
public Object readObject ( ) throws IOException { ttry { t_reader . mark ( 1 ) ; 
public int read ( char cbuf [ ] , int off , int len ) throws IOException { tint copied = 0 ; twhile ( copied < len ) { tint c = _reader . read ( ) ; if ( c = = - 1 ) { tbreak ; } if ( c = = BOUNDARY . charAt ( 0 ) ) { if ( foundBoundary ( ) ) { tbreak ; } } tcbuf [ off + copied ] = ( char ) c ; tcopied + + ; } if ( copied = = 0 ) { treturn - 1 ; 
private boolean foundBoundary ( ) throws IOException { t_reader . mark ( BOUNDARY . length ( ) - 1 ) ; tfor ( int i = 1 ; i < BOUNDARY . length ( ) ; i + + ) { tint c = _reader . read ( ) ; if ( c ! = BOUNDARY . charAt ( i ) ) { t_reader . reset ( ) ; treturn false ; } } treturn true ; } 
public void testOneObject ( ) throws IOException , ClassNotFoundException { tcreateSerializer ( ) ; twriteObject ( " a string to be written " ) ; tassertSerializedAs ( " <string>a string to be written</string> " + " <!--PREVAYLER RULES!--> " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " a string to be written " ) ; } 
public void testManyObjects ( ) throws IOException , ClassNotFoundException { tcreateSerializer ( ) ; twriteObject ( " first string " ) ; twriteObject ( " second string " ) ; twriteObject ( " third string " ) ; tassertSerializedAs ( " <string>first string</string> " + " <!--PREVAYLER RULES!--> " + " <string>second string</string> " + " <!--PREVAYLER RULES!--> " + " <string>third string</string> " + " <!--PREVAYLER RULES!--> " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " first string " ) ; tassertNextObject ( " second string " ) ; tassertNextObject ( " third string " ) ; tassertEOF ( ) ; } 
private void createSerializer ( ) throws IOException { tstrategy = new XStreamSerializationStrategy ( ) ; out = new ByteArrayOutputStream ( ) ; tserializer = strategy . createSerializer ( out ) ; } 
private void writeObject ( String original ) throws IOException { tserializer . writeObject ( original ) ; tserializer . flush ( ) ; } 
private void createDeserializer ( ) throws IOException { tByteArrayInputStream in = new ByteArrayInputStream ( out . toByteArray ( ) ) ; tdeserializer = strategy . createDeserializer ( in ) ; } 
private void assertSerializedAs ( String serializedForm ) { tassertEquals ( serializedForm , new String ( out . toString ( ) ) ) ; } 
private void assertNextObject ( String original ) throws IOException , ClassNotFoundException { tassertEquals ( original , deserializer . readObject ( ) ) ; } 
private void assertEOF ( ) throws IOException , ClassNotFoundException { ttry { tdeserializer . readObject ( ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { tStringBuffer system = ( StringBuffer ) prevalentSystem ; tsystem . append ( toAdd ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new MySerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; tassertEquals ( " TransactionTimestamp " + " first " + " TransactionTimestamp " + " second " + " TransactionTimestamp " + " third " , journalContents ( ) ) ; trecover ( strategy ) ; } 
public void testXStreamJournal ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public void NOT_WORKING_YET_testSkaringaJournal ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
private void startAndCrash ( SerializationStrategy journalSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( SerializationStrategy journalSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy journalSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializationStrategy ( journalSerializationStrategy ) ; treturn factory . create ( ) ; } 
private String journalContents ( ) throws IOException { tFile journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; tFileReader file = new FileReader ( journal ) ; tStringWriter string = new StringWriter ( ) ; tint ; tchar [ ] c = new char [ 1024 ] ; twhile ( ( = file . read ( c ) ) ! = - 1 ) { tstring . write ( c , 0 , ) ; } tfile . close ( ) ; treturn string . toString ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; treturn suite ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) throws IOException , ClassNotFoundException { tcheckValidSuffix ( suffix ( ) ) ; t_directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; t_recoveredVersion = latestVersion ( ) ; t_recoveredPrevalentSystem = _recoveredVersion = = 0 ? newPrevalentSystem 
private long latestVersion ( ) throws IOException { treturn latestVersion ( _directory ) ; } 
private static long latestVersion ( File directory ) throws IOException { tString [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tlong result = 0 ; tfor ( int i = 0 ; i < fileNames . length ; i + + ) { tlong candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } treturn result ; } 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { tthrow new IllegalStateException ( " Snapshot filename suffix must match / " + SNAPSHOT_SUFFIX_PATTERN + " /, but ' " + suffix + " ' does not " ) ; 
private static File snapshotFile ( long version , File directory , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
private static long version ( String fileName ) { if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshotFile ( File directory , String suffix ) throws IOException { tlong version = latestVersion ( directory ) ; if ( version = = 0 ) { treturn null ; 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) throws IOException , ClassNotFoundException { tXStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; ttry { tnew JavaSnapshotManager ( " initial " , _testDirectory , null ) ; 
public void testConfigureSnapshotSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new MySerializationStrategy ( ) ; ttakeSnapshot ( strategy ) ; tassertEquals ( " Yes, this is MySerializationStrategy! " + " the system first second third " , snapshotContents ( ) ) ; trecover ( strategy ) ; } 
public void testXStreamSnapshot ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; ttakeSnapshot ( strategy ) ; trecover ( strategy ) ; } 
public void testSkaringaSnapshot ( ) throws IOException , ClassNotFoundException { tSerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; ttakeSnapshot ( strategy ) ; trecover ( strategy ) ; } 
private void takeSnapshot ( SerializationStrategy journalSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
private void recover ( SerializationStrategy snapshotSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( snapshotSerializationStrategy ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy snapshotSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializationStrategy ( snapshotSerializationStrategy ) ; treturn factory . create ( ) ; } 
private String snapshotContents ( ) throws IOException { tFile snapshot = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .snapshot " ) ; } } ) [ 0 ] ; tFileReader file = new FileReader ( snapshot ) ; tStringWriter string = new StringWriter ( ) ; tint ; tchar [ ] c = new char [ 1024 ] ; twhile ( ( = file . read ( c ) ) ! = - 1 ) { tstring . write ( c , 0 , ) ; } tfile . close ( ) ; treturn string . toString ( ) ; } 
public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .snapshot " ) ; } 
public void writeObject ( Object object ) throws IOException { tStringBuffer system = ( StringBuffer ) object ; twriter . write ( " Yes, this is MySerializationStrategy! " ) ; twriter . write ( system . toString ( ) ) ; twriter . write ( '' ) ; } 
public Object readObject ( ) throws IOException { tString prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { tString contents = reader . readLine ( ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; treturn suite ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) throws IOException , ClassNotFoundException { tcheckValidSuffix ( suffix ( ) ) ; t_directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; tFile latestSnapshot = latestSnapshot ( _directory ) ; t_recoveredVersion = latestSnapshot = = null ? 0 : version ( latestSnapshot ) ; t_recoveredPrevalentSystem = latestSnapshot = = null ? newPrevalentSystem 
private Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { if ( ! snapshotFile . getName ( ) . endsWith ( " . " + suffix ( ) ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read by " + this . getClass ( ) . getName ( ) ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return readSnapshot ( in ) ; 
private static long version ( File file ) { tString fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshot ( File directory ) throws IOException { tFile [ ] files = directory . listFiles ( ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tFile latestSnapshot = null ; tlong latestVersion = 0 ; tfor ( int i = 0 ; i < files . length ; i + + ) { tFile candidateSnapshot = files [ i ] ; tlong candidateVersion = version ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { tlatestVersion = candidateVersion ; tlatestSnapshot = candidateSnapshot ; } } treturn latestSnapshot ; } 
protected Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { if ( ! snapshotFile . getName ( ) . endsWith ( " . " + suffix ( ) ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read by " + this . getClass ( ) . getName ( ) ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return readSnapshot ( in ) ; 
private SerializationStrategy primaryStrategy ( ) { treturn ( SerializationStrategy ) _strategies . get ( _primaryStrategy ) ; } 
protected Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read by " + this . getClass ( ) . getName ( ) ) ; tSerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { tDeserializer deserializer = strategy . createDeserializer ( in ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tSerializer serializer = primaryStrategy ( ) . createSerializer ( out ) ; ttry { tserializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) throws IOException , ClassNotFoundException { tDeserializer deserializer = primaryStrategy ( ) . createDeserializer ( in ) ; treturn deserializer . readObject ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; treturn suite ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager manager = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; tassertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager original = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tGenericSnapshotManager newManager = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; tassertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) throws IOException , ClassNotFoundException { tXStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; ttry { tnew GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws IOException , ClassNotFoundException { tXStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tassertTrue ( new File ( _testDirectory , " 0000000000000000123.xstreamsnapshot " ) . exists ( ) ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws IOException , ClassNotFoundException { tJavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; toriginal . writeSnapshot ( " snapshotted " , 123 ) ; tassertTrue ( new File ( _testDirectory , " 0000000000000000123.snapshot " ) . exists ( ) ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager generic = makeWithMultipleStrategies ( ) ; tassertEquals ( " snapshotted " , generic . recoveredPrevalentSystem ( ) ) ; tgeneric . writeSnapshot ( " snapshotted again " , 124 ) ; tassertTrue ( new File ( _testDirectory , " 0000000000000000124.xstreamsnapshot " ) . exists ( ) ) ; } 
private GenericSnapshotManager makeWithMultipleStrategies ( ) throws IOException , ClassNotFoundException { tMap strategies = new HashMap ( ) ; tstrategies . put ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tstrategies . put ( " snapshot " , new JavaSerializationStrategy ( null ) ) ; treturn new GenericSnapshotManager ( strategies , " xstreamsnapshot " , " initial " , _testDirectory ) ; } 
public void testWritingWithPrimarySerializationStrategy ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager generic = makeWithMultipleStrategies ( ) ; tgeneric . writeSnapshot ( " snapshotted " , 123 ) ; tassertTrue ( new File ( _testDirectory , " 0000000000000000123.xstreamsnapshot " ) . exists ( ) ) ; tXStreamSnapshotManager xstream = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; tassertEquals ( " snapshotted " , xstream . recoveredPrevalentSystem ( ) ) ; } 
public Serializer createSerializer ( OutputStream stream ) throws IOException { treturn _underlying . createSerializer ( new MultiMemberGZIPOutputStream ( stream ) ) ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException { treturn _underlying . createDeserializer ( new MultiMemberGZIPInputStream ( stream ) ) ; } 
public int available ( ) throws IOException { treturn _gzip . available ( ) ; } 
public int read ( ) throws IOException { tbyte [ ] buf = new byte [ 1 ] ; tint = read ( buf ) ; treturn = = - 1 ? - 1 : buf [ 0 ] ; } 
public int read ( byte b [ ] ) throws IOException { treturn read ( b , 0 , b . length ) ; } 
public int read ( byte b [ ] , int off , int len ) throws IOException { tint = _gzip . read ( b , off , len ) ; if ( = = - 1 ) { ttry { t_gzip = new GZIPInputStream ( _stream , 1 ) ; } catch ( EOFException e ) { treturn - 1 ; } treturn _gzip . read ( b , off , len ) ; } treturn ; } 
public void close ( ) throws IOException { tthrow new UnsupportedOperationException ( ) ; } 
public void reset ( ) throws IOException { tthrow new UnsupportedOperationException ( ) ; } 
public void mark ( int readlimit ) { tthrow new UnsupportedOperationException ( ) ; } 
public long skip ( long ) throws IOException { tthrow new UnsupportedOperationException ( ) ; } 
public void write ( int b ) throws IOException { twrite ( new byte [ ] { ( byte ) b } ) ; } 
public void write ( byte b [ ] ) throws IOException { twrite ( b , 0 , b . length ) ; } 
public void write ( byte b [ ] , int off , int len ) throws IOException { if ( _gzip = = null ) { t_gzip = new GZIPOutputStream ( _stream ) ; } t_gzip . write ( b , off , len ) ; } 
public void flush ( ) throws IOException { if ( _gzip ! = null ) { t_gzip . close ( ) ; t_gzip = null ; } t_stream . flush ( ) ; } 
public void close ( ) throws IOException { } public void flush ( ) throws IOException { t_stream . flush ( ) ; } public void write ( int b ) throws IOException { t_stream . write ( b ) ; } public void write ( byte b [ ] ) throws IOException { t_stream . write ( b ) ; } public void write ( byte b [ ] , int off , int len ) throws IOException { t_stream . write ( b , off , len ) ; } } 
public void write ( int b ) throws IOException { t_stream . write ( b ) ; } 
public void write ( byte b [ ] ) throws IOException { t_stream . write ( b ) ; } 
public void write ( byte b [ ] , int off , int len ) throws IOException { t_stream . write ( b , off , len ) ; } 
protected SerializationStrategy createStrategy ( ) { treturn new GZIPSerializationStrategy ( new XStreamSerializationStrategy ( ) ) ; } 
public void testMultiMemberGZIPStreams ( ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; tOutputStream gzip = new MultiMemberGZIPOutputStream ( bytes ) ; tgzip . write ( 123 ) ; tgzip . flush ( ) ; tString expectedOneByteOutput = " 1f,8b,8,0,0,0,0,0,0,0,ab,6,0,39,47,d5,15,1,0,0,0 " ; tassertEquals ( expectedOneByteOutput , toHex ( bytes . toByteArray ( ) ) ) ; tgzip . flush ( ) ; tassertEquals ( expectedOneByteOutput , toHex ( bytes . toByteArray ( ) ) ) ; tgzip . write ( 123 ) ; tgzip . flush ( ) ; tbyte [ ] twoGZIPMembers = bytes . toByteArray ( ) ; tassertEquals ( expectedOneByteOutput + " , " + expectedOneByteOutput , toHex ( twoGZIPMembers ) ) ; tInputStream in = new MultiMemberGZIPInputStream ( new ByteArrayInputStream ( twoGZIPMembers ) ) ; tassertEquals ( 123 , in . read ( ) ) ; tassertEquals ( 123 , in . read ( ) ) ; tassertEquals ( - 1 , in . read ( ) ) ; } 
private String toHex ( byte [ ] beforeClose ) { tStringBuffer buf = new StringBuffer ( ) ; tfor ( int i = 0 ; i < beforeClose . length ; i + + ) { tbyte b = beforeClose [ i ] ; if ( i > 0 ) buf . append ( " , " ) ; tbuf . append ( Integer . toHexString ( ( ( int ) b ) & 0xFF ) ) ; } treturn buf . toString ( ) ; } 
public void testOneObject ( ) throws IOException , ClassNotFoundException { twriteObject ( " a string to be written " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " a string to be written " ) ; } 
public void testManyObjects ( ) throws IOException , ClassNotFoundException { twriteObject ( " first string " ) ; twriteObject ( " second string " ) ; twriteObject ( " third string " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " first string " ) ; tassertNextObject ( " second string " ) ; tassertNextObject ( " third string " ) ; tassertEOF ( ) ; } 
protected void setUp ( ) throws IOException { tstrategy = createStrategy ( ) ; out = new ByteArrayOutputStream ( ) ; tserializer = strategy . createSerializer ( out ) ; } 
protected abstract SerializationStrategy createStrategy ( ) ; protected void writeObject ( Object original ) throws IOException { tserializer . writeObject ( original ) ; tserializer . flush ( ) ; } protected void createDeserializer ( ) throws IOException { tByteArrayInputStream in = new ByteArrayInputStream ( out . toByteArray ( ) ) ; tdeserializer = strategy . createDeserializer ( in ) ; } protected void assertSerializedAs ( String serializedForm ) { tassertEquals ( serializedForm , new String ( out . toString ( ) ) ) ; } protected void assertNextObject ( Object original ) throws IOException , ClassNotFoundException { tassertEquals ( original , deserializer . readObject ( ) ) ; } protected void assertEOF ( ) throws IOException , ClassNotFoundException { ttry { tdeserializer . readObject ( ) ; tfail ( ) ; } catch ( EOFException eof ) { } } } 
protected void writeObject ( Object original ) throws IOException { tserializer . writeObject ( original ) ; tserializer . flush ( ) ; } 
protected void createDeserializer ( ) throws IOException { tByteArrayInputStream in = new ByteArrayInputStream ( out . toByteArray ( ) ) ; tdeserializer = strategy . createDeserializer ( in ) ; } 
protected void assertSerializedAs ( String serializedForm ) { tassertEquals ( serializedForm , new String ( out . toString ( ) ) ) ; } 
protected void assertNextObject ( Object original ) throws IOException , ClassNotFoundException { tassertEquals ( original , deserializer . readObject ( ) ) ; } 
protected void assertEOF ( ) throws IOException , ClassNotFoundException { ttry { tdeserializer . readObject ( ) ; 
protected SerializationStrategy createStrategy ( ) { treturn new XStreamSerializationStrategy ( ) ; } 
public void testOneObject ( ) throws IOException , ClassNotFoundException { twriteObject ( " a string to be written " ) ; tassertSerializedAs ( " <string>a string to be written</string> " + " <!--PREVAYLER RULES!--> " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " a string to be written " ) ; } 
public void testManyObjects ( ) throws IOException , ClassNotFoundException { twriteObject ( " first string " ) ; twriteObject ( " second string " ) ; twriteObject ( " third string " ) ; tassertSerializedAs ( " <string>first string</string> " + " <!--PREVAYLER RULES!--> " + " <string>second string</string> " + " <!--PREVAYLER RULES!--> " + " <string>third string</string> " + " <!--PREVAYLER RULES!--> " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " first string " ) ; tassertNextObject ( " second string " ) ; tassertNextObject ( " third string " ) ; tassertEOF ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JavaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; tsuite . addTestSuite ( GZIPSerializationTest . class ) ; treturn suite ; } 
public void writeObject ( Object object ) throws IOException { t_stream . writeObject ( object ) ; } 
public void flush ( ) throws IOException { } 
public void configureSnapshotSerializationStrategy ( JavaSerializationStrategy strategy ) { tconfigureSnapshotSerializationStrategy ( " snapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( XStreamSerializationStrategy strategy ) { tconfigureSnapshotSerializationStrategy ( " xstreamsnapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( SkaringaSerializationStrategy strategy ) { tconfigureSnapshotSerializationStrategy ( " skaringasnapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( String suffix , SerializationStrategy strategy ) { t_snapshotSerializationStrategies . put ( suffix , strategy ) ; if ( _primarySnapshotSerializationStrategy = = null ) { t_primarySnapshotSerializationStrategy = suffix ; 
private SnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) return _snapshotManager ; if ( ! _snapshotSerializationStrategies . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializationStrategies , _primarySnapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; treturn new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
protected Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; tSerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { tDeserializer deserializer = strategy . createDeserializer ( in ) ; 
private Prevayler createPrevayler ( SerializationStrategy snapshotSerializationStrategy ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializationStrategy ( " snapshot " , snapshotSerializationStrategy ) ; treturn factory . create ( ) ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; tassertEquals ( " initial " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
public void testReadExistingSnapshot ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; ttry { tcreatePrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testUsePrimaryForWritingSnapshot ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevaylerMulti ( ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevaylerMulti ( ) ; tassertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private Prevayler createPrevayler ( String suffix , SerializationStrategy strategy ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializationStrategy ( suffix , strategy ) ; treturn factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler prevayler ) throws IOException { tprevayler . execute ( new AppendTransaction ( " one " ) ) ; tprevayler . execute ( new AppendTransaction ( " two " ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
private void checkSnapshotAndDeleteJournal ( String snapshot , String journal ) { tassertTrue ( new File ( _testDirectory , snapshot ) . exists ( ) ) ; tdeleteFromTestDirectory ( journal ) ; } 
private Prevayler createPrevaylerMulti ( ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializationStrategy ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tfactory . configureSnapshotSerializationStrategy ( " snapshot " , new JavaSerializationStrategy ( ) ) ; treturn factory . create ( ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; tsuite . addTestSuite ( GZIPSerializationTest . class ) ; treturn suite ; } 
public void testRoundtripJava ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " snapshot " , new JavaSerializationStrategy ( ) ) ; } 
public void testRoundtripXStream ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; } 
public void testRoundtripSkaringa ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " skaringasnapshot " , new SkaringaSerializationStrategy ( ) ) ; } 
private void checkRoundtrip ( String suffix , SerializationStrategy strategy ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( suffix , strategy ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( suffix , strategy ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
public void testDetectExistingSnapshotFromUnknownSnapshotManager ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; ttry { tcreatePrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; 
private Prevayler createPrevayler ( String suffix , SerializationStrategy strategy ) throws IOException , tClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializationStrategy ( suffix , strategy ) ; treturn factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configureNullSnapshotManager ( new NullSnapshotManager ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
private void configureNullSnapshotManager ( NullSnapshotManager snapshotManager ) { t_nullSnapshotManager = snapshotManager ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializationStrategy ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) throws IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializationStrategy ( ) ) 
private GenericSnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; if ( ! _snapshotSerializationStrategies . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializationStrategies , _primarySnapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; treturn new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configureSnapshotSerializationStrategy ( new SkaringaSerializationStrategy ( ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2XStream " ) ; tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; tfactory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( xstream ) ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
private void produceNewFoodTaster ( ) { ttry { tsynchronized ( _king ) { 
public SerializationStrategy primaryStrategy ( ) { treturn ( SerializationStrategy ) _strategies . get ( _primarySuffix ) ; } 
public Object recoveredPrevalentSystem ( ) { treturn _recoveredPrevalentSystem ; } 
public long recoveredVersion ( ) { treturn _recoveredVersion ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = File . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " , _directory ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws IOException { tOutputStream out = new FileOutputStream ( snapshotFile ) ; ttry { twriteSnapshot ( prevalentSystem , out ) ; 
private void writeSnapshot ( Object prevalentSystem , OutputStream out ) throws IOException { tSerializer serializer = primaryStrategy ( ) . createSerializer ( out ) ; ttry { tserializer . writeObject ( prevalentSystem ) ; 
private File snapshotFile ( long version ) { treturn snapshotFile ( version , _directory , _primarySuffix ) ; } 
private Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( tsnapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; tSerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; tFileInputStream in = new FileInputStream ( snapshotFile ) ; ttry { tDeserializer deserializer = strategy . createDeserializer ( in ) ; 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { tthrow new IllegalStateException ( 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { tthrow new IllegalArgumentException ( 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2XStream " ) ; tfactory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( ) { protected XStream createXStream ( ) { tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; treturn xstream ; } } ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
protected XStream createXStream ( ) { tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; txstream . alias ( " account " , Account . class ) ; txstream . alias ( " accountEntry " , AccountEntry . class ) ; treturn xstream ; } 
public Serializer createSerializer ( OutputStream stream ) throws IOException { treturn new XStreamSerializer ( createXStream ( ) , stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) throws IOException { treturn new XStreamDeserializer ( createXStream ( ) , stream ) ; } 
protected XStream createXStream ( ) { treturn new XStream ( ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2XStream " ) ; tfactory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( ) { protected XStream createXStream ( ) { tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; } 
protected XStream createXStream ( ) { tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; } 
public byte [ ] readChunk ( ) throws IOException { tString header = readLine ( ) ; if ( header = = null ) { treturn null ; } if ( ! header . matches ( " (0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}) r " ) ) { tthrow new IOException ( " Chunk header corrupted " ) ; } tint length = Integer . parseInt ( header . trim ( ) , 16 ) ; tbyte [ ] chunk = new byte [ length ] ; tint total = 0 ; twhile ( total < length ) { tint read = stream . read ( chunk , total , length - total ) ; if ( read = = - 1 ) { tthrow new IOException ( " Unexpected end of stream in chunk data " ) ; } ttotal + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { tthrow new IOException ( " Chunk trailer corrupted " ) ; } treturn chunk ; } 
private String readLine ( ) throws IOException { tByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; twhile ( true ) { tint b = stream . read ( ) ; 
public void writeChunk ( byte [ ] bytes ) throws IOException { tstream . write ( Integer . toHexString ( bytes . length ) . toUpperCase ( ) . getBytes ( " US-ASCII " ) ) ; tstream . write ( CRLF ) ; tstream . write ( bytes ) ; tstream . write ( CRLF ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; tsuite . addTestSuite ( GZIPSerializationTest . class ) ; treturn suite ; } 
public void testChunkedOutput ( ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; tChunkedOutputStream chunked = new ChunkedOutputStream ( bytes ) ; tchunked . writeChunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ; tassertEquals ( " F r nabcdefghijklmno r " , bytes . toString ( " US-ASCII " ) ) ; } 
public void testChunkedInput ( ) throws IOException { tByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; tChunkedInputStream chunked = new ChunkedInputStream ( bytes ) ; tassertEquals ( " abcdefghijklmno " , new String ( chunked . readChunk ( ) , " US-ASCII " ) ) ; } 
public void testMultipleChunks ( ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; tChunkedOutputStream output = new ChunkedOutputStream ( bytes ) ; output . writeChunk ( " foo " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " bar " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " zot " . getBytes ( " US-ASCII " ) ) ; tChunkedInputStream input = new ChunkedInputStream ( new ByteArrayInputStream ( bytes . toByteArray ( ) ) ) ; tassertEquals ( " foo " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; tassertEquals ( " bar " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; tassertEquals ( " " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; tassertEquals ( " zot " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; tassertNull ( input . readChunk ( ) ) ; } 
public void testMalformed ( ) throws IOException { tcheckMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; tcheckMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; tcheckMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; tcheckMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; tcheckMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; tcheckMalformed ( " F r nabcdefghijklmno r " , " Chunk trailer corrupted " ) ; } 
private void checkMalformed ( String input , String message ) throws IOException { tByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; tChunkedInputStream chunked = new ChunkedInputStream ( bytes ) ; ttry { tchunked . readChunk ( ) ; 
tstatic boolean validToken ( String token ) { treturn TOKEN_PATTERN . matcher ( token ) . matches ( ) ; } 
public byte [ ] readChunk ( ) throws IOException { tString header = readLine ( ) ; if ( header = = null ) { treturn null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { tthrow new IOException ( " Chunk header corrupted " ) ; } tStringTokenizer tokenizer = new StringTokenizer ( header , " ;= r " ) ; tint size = Integer . parseInt ( tokenizer . nextToken ( ) , 16 ) ; tparameters = new LinkedHashMap ( ) ; twhile ( tokenizer . hasMoreTokens ( ) ) { tString name = tokenizer . nextToken ( ) ; tString value = tokenizer . nextToken ( ) ; tparameters . put ( name , value ) ; } tbyte [ ] chunk = new byte [ size ] ; tint total = 0 ; twhile ( total < size ) { tint read = stream . read ( chunk , total , size - total ) ; if ( read = = - 1 ) { tthrow new IOException ( " Unexpected end of stream in chunk data " ) ; } ttotal + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { tthrow new IOException ( " Chunk trailer corrupted " ) ; } treturn chunk ; } 
public void writeChunk ( byte [ ] bytes ) throws IOException { twriteChunk ( bytes , Collections . EMPTY_MAP ) ; } 
public void writeChunk ( byte [ ] bytes , Map parameters ) throws IOException { tstream . write ( Integer . toHexString ( bytes . length ) . toUpperCase ( ) . getBytes ( ASCII ) ) ; tIterator iterator = parameters . entrySet ( ) . iterator ( ) ; twhile ( iterator . hasNext ( ) ) { tMap . Entry entry = ( Map . Entry ) iterator . next ( ) ; tString name = ( String ) entry . getKey ( ) ; tString value = ( String ) entry . getValue ( ) ; if ( ! ChunkedInputStream . validToken ( name ) ) { tthrow new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! ChunkedInputStream . validToken ( value ) ) { tthrow new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } tstream . write ( ';' ) ; tstream . write ( name . getBytes ( ASCII ) ) ; tstream . write ( '=' ) ; tstream . write ( value . getBytes ( ASCII ) ) ; } tstream . write ( CRLF ) ; tstream . write ( bytes ) ; tstream . write ( CRLF ) ; } 
public void testParameters ( ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; tChunkedOutputStream output = new ChunkedOutputStream ( bytes ) ; tMap parameters = new LinkedHashMap ( ) ; tparameters . put ( " one " , " uno " ) ; tparameters . put ( " two " , " dos " ) ; output . writeChunk ( " foo " . getBytes ( " US-ASCII " ) , parameters ) ; tassertEquals ( " 3;one=uno;two=dos r nfoo r " , bytes . toString ( " US-ASCII " ) ) ; tChunkedInputStream input = new ChunkedInputStream ( new ByteArrayInputStream ( bytes . toByteArray ( ) ) ) ; tassertEquals ( " foo " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; tassertEquals ( parameters , input . getParameters ( ) ) ; } 
public InputStream remainingInput ( ) { tint afterTrailer = inf . getRemaining ( ) - 8 ; if ( afterTrailer > 0 ) { treturn new SequenceInputStream ( new ByteArrayInputStream ( buf , len - afterTrailer , afterTrailer ) , in ) ; 
public int read ( byte b [ ] , int off , int len ) throws IOException { tint = _gzip . read ( b , off , len ) ; if ( = = - 1 ) { ttry { t_gzip = new ContinuableGZIPInputStream ( _gzip . remainingInput ( ) ) ; } catch ( EOFException e ) { treturn - 1 ; } treturn _gzip . read ( b , off , len ) ; } treturn ; } 
private static boolean validToken ( String token ) { treturn TOKEN_PATTERN . matcher ( token ) . matches ( ) ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) throws IOException { tstream . write ( Integer . toHexString ( chunk . getBytes ( ) . length ) . toUpperCase ( ) . getBytes ( ASCII ) ) ; tIterator iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; twhile ( iterator . hasNext ( ) ) { tMap . Entry entry = ( Map . Entry ) iterator . next ( ) ; tString name = ( String ) entry . getKey ( ) ; tString value = ( String ) entry . getValue ( ) ; if ( ! validToken ( name ) ) { tthrow new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { tthrow new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } tstream . write ( ';' ) ; tstream . write ( name . getBytes ( ASCII ) ) ; tstream . write ( '=' ) ; tstream . write ( value . getBytes ( ASCII ) ) ; } tstream . write ( CRLF ) ; tstream . write ( chunk . getBytes ( ) ) ; tstream . write ( CRLF ) ; } 
public static Chunk readChunk ( InputStream stream ) throws IOException { tString header = readLine ( stream ) ; if ( header = = null ) { treturn null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { tthrow new IOException ( " Chunk header corrupted " ) ; } tStringTokenizer tokenizer = new StringTokenizer ( header , " ;= r " ) ; tint size = Integer . parseInt ( tokenizer . nextToken ( ) , 16 ) ; tMap parameters = new LinkedHashMap ( ) ; twhile ( tokenizer . hasMoreTokens ( ) ) { tString name = tokenizer . nextToken ( ) ; tString value = tokenizer . nextToken ( ) ; tparameters . put ( name , value ) ; } tbyte [ ] bytes = new byte [ size ] ; tint total = 0 ; twhile ( total < size ) { tint read = stream . read ( bytes , total , size - total ) ; if ( read = = - 1 ) { tthrow new IOException ( " Unexpected end of stream in chunk data " ) ; } ttotal + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { tthrow new IOException ( " Chunk trailer corrupted " ) ; } treturn new Chunk ( bytes , parameters ) ; } 
private static String readLine ( InputStream stream ) throws IOException { tByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; twhile ( true ) { tint b = stream . read ( ) ; 
public void testChunkedOutput ( ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; tChunking . writeChunk ( bytes , new Chunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ) ; tassertEquals ( " F r nabcdefghijklmno r " , bytes . toString ( " US-ASCII " ) ) ; } 
public void testChunkedInput ( ) throws IOException { tByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; tassertEquals ( " abcdefghijklmno " , new String ( Chunking . readChunk ( bytes ) . getBytes ( ) , " US-ASCII " ) ) ; } 
public void testMultipleChunks ( ) throws IOException { tByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; tChunking . writeChunk ( output , new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ) ; tChunking . writeChunk ( output , new Chunk ( " bar " . getBytes ( " US-ASCII " ) ) ) ; tChunking . writeChunk ( output , new Chunk ( " " . getBytes ( " US-ASCII " ) ) ) ; tChunking . writeChunk ( output , new Chunk ( " zot " . getBytes ( " US-ASCII " ) ) ) ; tByteArrayInputStream input = new ByteArrayInputStream ( output . toByteArray ( ) ) ; tassertEquals ( " foo " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; tassertEquals ( " bar " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; tassertEquals ( " " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; tassertEquals ( " zot " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; tassertNull ( Chunking . readChunk ( input ) ) ; } 
private void checkMalformed ( String input , String message ) throws IOException { tByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; ttry { tChunking . readChunk ( bytes ) ; 
public void testParameters ( ) throws IOException { tByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; tChunk chunkOut = new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ; tchunkOut . setParameter ( " one " , " uno " ) ; tchunkOut . setParameter ( " two " , " dos " ) ; tChunking . writeChunk ( output , chunkOut ) ; tassertEquals ( " 3;one=uno;two=dos r nfoo r " , output . toString ( " US-ASCII " ) ) ; tByteArrayInputStream input = new ByteArrayInputStream ( output . toByteArray ( ) ) ; tChunk chunkIn = Chunking . readChunk ( input ) ; tassertEquals ( " foo " , new String ( chunkIn . getBytes ( ) , " US-ASCII " ) ) ; tassertEquals ( " uno " , chunkIn . getParameter ( " one " ) ) ; tassertEquals ( " dos " , chunkIn . getParameter ( " two " ) ) ; } 
public void configureJournalSerializer ( Serializer serializer ) { t_journalSerializationStrategy = new JournalSerializationStrategy ( serializer ) ; } 
public void configureSnapshotSerializer ( JavaSerializer serializer ) { tconfigureSnapshotSerializer ( " snapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( XStreamSerializer serializer ) { tconfigureSnapshotSerializer ( " xstreamsnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( SkaringaSerializer serializer ) { tconfigureSnapshotSerializer ( " skaringasnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { t_snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { t_primarySnapshotSuffix = suffix ; 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private JournalSerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) return _journalSerializationStrategy ; treturn new JournalSerializationStrategy ( new JavaSerializer ( _classLoader ) ) ; } 
private GenericSnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; treturn new GenericSnapshotManager ( new JavaSerializer ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configureSnapshotSerializer ( new SkaringaSerializer ( ) ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalenceDirectory ( " demo2XStream " ) ; tfactory . configureSnapshotSerializer ( new XStreamSerializer ( ) { protected XStream createXStream ( ) { tXStream xstream = new XStream ( ) ; txstream . alias ( " bank " , Bank . class ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) throws IOException , ClassNotFoundException { tByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; tserializer . writeObject ( byteOut , original ) ; tByteArrayInputStream byteIn = new ByteArrayInputStream ( byteOut . toByteArray ( ) ) ; treturn serializer . readObject ( byteIn ) ; } 
public void write ( byte [ ] b , int off , int len ) { t_active . write ( b , off , len ) ; } 
public JournalSerializer createSerializer ( final OutputStream stream ) throws IOException { treturn new JournalSerializer ( ) { public void writeObject ( Object object ) throws IOException { 
public void writeObject ( Object object ) throws IOException { tByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; t_serializer . writeObject ( bytes , object ) ; tChunking . writeChunk ( stream , new Chunk ( bytes . toByteArray ( ) ) ) ; } 
public void flush ( ) throws IOException { tstream . flush ( ) ; } 
public JournalDeserializer createDeserializer ( final InputStream stream ) throws IOException { treturn new JournalDeserializer ( ) { public Object readObject ( ) throws IOException , ClassNotFoundException { 
public Object readObject ( ) throws IOException , ClassNotFoundException { tChunk chunk = Chunking . readChunk ( stream ) ; if ( chunk = = null ) { tthrow new EOFException ( ) ; } tByteArrayInputStream bytes = new ByteArrayInputStream ( chunk . getBytes ( ) ) ; treturn _serializer . readObject ( bytes ) ; } 
public Object deepCopy ( Object original ) throws IOException , ClassNotFoundException { treturn DeepCopier . deepCopy ( original , _serializer ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tObjectOutputStream objects = new ObjectOutputStream ( stream ) ; tobjects . writeObject ( object ) ; tobjects . close ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tObjectInputStream objects = new ObjectInputStreamWithClassLoader ( stream , _loader ) ; tObject object = objects . readObject ( ) ; tobjects . close ( ) ; treturn object ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException ; public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { ttry { tcreateTransformer ( ) . serialize ( object , new StreamResult ( stream ) ) ; 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { ttry { treturn createTransformer ( ) . deserialize ( new StreamSource ( stream ) ) ; 
protected ObjectTransformer createTransformer ( ) throws IOException { ttry { treturn ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tOutputStreamWriter writer = new OutputStreamWriter ( stream ) ; tcreateXStream ( ) . toXML ( object , writer ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { treturn createXStream ( ) . fromXML ( new InputStreamReader ( stream ) ) ; } 
public Serializer primarySerializer ( ) { treturn ( Serializer ) _strategies . get ( _primarySuffix ) ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws IOException { tOutputStream out = new FileOutputStream ( snapshotFile ) ; ttry { tprimarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private Object readSnapshot ( File snapshotFile ) throws ClassNotFoundException , IOException { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( tsnapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; tSerializer serializer = ( Serializer ) _strategies . get ( suffix ) ; tFileInputStream in = new FileInputStream ( snapshotFile ) ; ttry { treturn serializer . readObject ( in ) ; 
public void testSingleThreaded ( ) throws Exception { tJournalSerializationStrategy strategy = new JournalSerializationStrategy ( new JavaSerializer ( ) ) ; tfor ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void testMultiThreaded ( ) throws Exception { tJournalSerializationStrategy strategy = new JournalSerializationStrategy ( new JavaSerializer ( ) ) ; tfor ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
protected abstract JournalSerializationStrategy createStrategy ( ) ; protected void writeObject ( Object original ) throws IOException { tserializer . writeObject ( original ) ; tserializer . flush ( ) ; } protected void createDeserializer ( ) throws IOException { tByteArrayInputStream in = new ByteArrayInputStream ( out . toByteArray ( ) ) ; tdeserializer = strategy . createDeserializer ( in ) ; } protected void assertSerializedAs ( String serializedForm ) { tassertEquals ( serializedForm , new String ( out . toString ( ) ) ) ; } protected void assertNextObject ( Object original ) throws IOException , ClassNotFoundException { tassertEquals ( original , deserializer . readObject ( ) ) ; } protected void assertEOF ( ) throws IOException , ClassNotFoundException { ttry { tdeserializer . readObject ( ) ; tfail ( ) ; } catch ( EOFException eof ) { } } } 
protected JournalSerializationStrategy createStrategy ( ) { treturn new JournalSerializationStrategy ( new XStreamSerializer ( ) ) ; } 
public void testOneObject ( ) throws IOException , ClassNotFoundException { twriteObject ( " a string to be written " ) ; tassertSerializedAs ( " 27 r n<string>a string to be written</string> r " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " a string to be written " ) ; } 
public void testManyObjects ( ) throws IOException , ClassNotFoundException { twriteObject ( " first string " ) ; twriteObject ( " second string " ) ; twriteObject ( " third string " ) ; tassertSerializedAs ( " 1D r n<string>first string</string> r " + " 1E r n<string>second string</string> r " + " 1D r n<string>third string</string> r " ) ; tcreateDeserializer ( ) ; tassertNextObject ( " first string " ) ; tassertNextObject ( " second string " ) ; tassertNextObject ( " third string " ) ; tassertEOF ( ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( strategy ) ; tassertEquals ( " 1C r " + " TransactionTimestamp " + " first " + " r " + " 1D r " + " TransactionTimestamp " + " second " + " r " + " 1C r " + " TransactionTimestamp " + " third " + " r " , journalContents ( ) ) ; trecover ( strategy ) ; } 
public void testXStreamJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new XStreamSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( journalSerializer ) ; treturn factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tWriter writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; if ( object instanceof TransactionTimestamp ) { tTransactionTimestamp timestamp = ( TransactionTimestamp ) object ; tAppendTransaction transaction = ( AppendTransaction ) timestamp . transaction ( ) ; twriter . write ( " TransactionTimestamp " ) ; twriter . write ( transaction . toAdd ) ; twriter . write ( '' ) ; } else { tAppendTransaction transaction = ( AppendTransaction ) object ; twriter . write ( " AppendTransaction " ) ; twriter . write ( transaction . toAdd ) ; twriter . write ( '' ) ; } twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tBufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; tString type = reader . readLine ( ) ; if ( " TransactionTimestamp " . equals ( type ) ) { tString toAdd = reader . readLine ( ) ; 
public void testConfigureSnapshotSerializer ( ) throws IOException , ClassNotFoundException { tSerializer serializer = new MySerializer ( ) ; ttakeSnapshot ( serializer ) ; tassertEquals ( " Yes, this is MySerializationStrategy! " + " the system first second third " , snapshotContents ( ) ) ; trecover ( serializer ) ; } 
public void testXStreamSnapshot ( ) throws IOException , ClassNotFoundException { tSerializer serializer = new XStreamSerializer ( ) ; ttakeSnapshot ( serializer ) ; trecover ( serializer ) ; } 
public void testSkaringaSnapshot ( ) throws IOException , ClassNotFoundException { tSerializer serializer = new SkaringaSerializer ( ) ; ttakeSnapshot ( serializer ) ; trecover ( serializer ) ; } 
private void takeSnapshot ( Serializer snapshotSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( snapshotSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( snapshotSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer snapshotSerializer ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; treturn factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tStringBuffer system = ( StringBuffer ) object ; tWriter writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; twriter . write ( " Yes, this is MySerializationStrategy! " ) ; twriter . write ( system . toString ( ) ) ; twriter . write ( '' ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tBufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; tString prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { tString contents = reader . readLine ( ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializationStrategyTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( XStreamSerializationTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; treturn suite ; } 
public void testNoExistingSnapshot ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tassertEquals ( " initial " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
public void testRoundtripJava ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void testRoundtripXStream ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
public void testRoundtripSkaringa ( ) throws IOException , ClassNotFoundException { tcheckRoundtrip ( " skaringasnapshot " , new SkaringaSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( suffix , serializer ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( suffix , serializer ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
public void testDetectExistingSnapshotFromUnknownSnapshotManager ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; ttry { tcreatePrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testUsePrimaryForWritingSnapshot ( ) throws IOException , ClassNotFoundException { tPrevayler first = createPrevaylerMulti ( ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
private Prevayler createPrevaylerMulti ( ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tfactory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; treturn factory . create ( ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer serializer ) throws IOException , tClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( suffix , serializer ) ; treturn factory . create ( ) ; } 
public void configureJournalSerializer ( Serializer serializer ) { t_journalSerializer = serializer ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializer ( ) ) 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; treturn new JavaSerializer ( _classLoader ) ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { tChunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { treturn _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; } } catch ( EOFException eofx ) { } 
private Object deepCopy ( Object transaction ) { ttry { treturn DeepCopier . deepCopy ( transaction , _journalSerializer ) ; 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = journalFile ( transactionNumber ) ; ttry { treturn new DurableOutputStream ( file , _journalSerializer ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tSimpleInputStream inputLog = new SimpleInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private Transaction deepCopy ( Transaction transaction ) { ttry { treturn ( Transaction ) DeepCopier . deepCopy ( transaction , _journalSerializer ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; treturn suite ; } 
public static Chunk readChunk ( InputStream stream ) throws IOException { tString header = readLine ( stream ) ; if ( header = = null ) { treturn null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { tthrow new IOException ( " Chunk header corrupted " ) ; } tStringTokenizer tokenizer = new StringTokenizer ( header , " ;= r " ) ; tint size = Integer . parseInt ( tokenizer . nextToken ( ) , 16 ) ; tMap parameters = new LinkedHashMap ( ) ; twhile ( tokenizer . hasMoreTokens ( ) ) { tString name = tokenizer . nextToken ( ) ; tString value = tokenizer . nextToken ( ) ; tparameters . put ( name , value ) ; } tbyte [ ] bytes = new byte [ size ] ; tint total = 0 ; twhile ( total < size ) { tint read = stream . read ( bytes , total , size - total ) ; if ( read = = - 1 ) { tthrow new EOFException ( " Unexpected end of stream in chunk data " ) ; } ttotal + = read ; } tint cr = stream . read ( ) ; tint lf = stream . read ( ) ; if ( cr = = - 1 | | cr = = '\r' & & lf = = - 1 ) { tthrow new EOFException ( " Unexpected end of stream in chunk trailer " ) ; } else if ( cr ! = '\r' | | lf ! = '' ) { tthrow new IOException ( " Chunk trailer corrupted " ) ; } treturn new Chunk ( bytes , parameters ) ; } 
public void testMalformed ( ) throws IOException { tcheckMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; tcheckMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; tcheckMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; tcheckMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; tcheckMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; tcheckMalformed ( " F r nabcdefghijklmno r " , " Unexpected end of stream in chunk trailer " ) ; tcheckMalformed ( " F r nabcdefghijklmno " , " Unexpected end of stream in chunk trailer " ) ; } 
tstatic private void runPrevaylerTransaction ( ) throws Exception { tnew TransactionTestRun ( tnew PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) , 
tstatic private String prevaylerJournalSerializer ( ) { tString result = properties . getProperty ( " PrevaylerJournalSerializer " ) ; if ( result = = null ) result = JavaSerializer . class . getName ( ) ; out ( " nPrevayler Journal Serializer: " + result ) ; treturn result ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tDurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { tChunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { treturn ( TransactionTimestamp ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; } } catch ( EOFException eofx ) { } 
public void sync ( TransactionTimestamp timestamp , Turn myTurn ) throws IOException { tint thisWrite ; } 
private int writeObject ( TransactionTimestamp timestamp ) throws IOException { tsynchronized ( _writeLock ) { if ( _closed ) { 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tDurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { tTransactionTimestamp entry = inputLog . read ( ) ; if ( recoveringTransaction > = initialTransaction ) tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private TransactionTimestamp timestamp ( String value ) { treturn new TransactionTimestamp ( new AppendTransaction ( value ) , new Date ( ) ) ; } 
private String value ( TransactionTimestamp timestamp ) { treturn ( ( AppendTransaction ) timestamp . transaction ( ) ) . toAdd ; } 
public void run ( ) { ttry { _out . sync ( timestamp ( _id + " .first " ) , _firstTurn ) ; 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { if ( _EOF ) throw new EOFException ( ) ; ttry { tChunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { tTransaction transaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; treturn new TransactionTimestamp ( transaction , new Date ( Long . parseLong ( chunk . getParameter ( " timestamp " ) ) ) ) ; } } catch ( EOFException eofx ) { } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( strategy ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; trecover ( strategy ) ; } 
public void testJavaJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new JavaSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public void testSkaringaJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new SkaringaSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( journalSerializer ) ; tfactory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { treturn new Date ( + + time ) ; } } ) ; treturn factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tWriter writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; tAppendTransaction transaction = ( AppendTransaction ) object ; twriter . write ( transaction . toAdd ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tBufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; treturn new AppendTransaction ( reader . readLine ( ) ) ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tTransaction transaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; treturn new TransactionTimestamp ( transaction , new Date ( Long . parseLong ( chunk . getParameter ( " timestamp " ) ) ) ) ; } 
private Chunk readChunk ( ) throws IOException { if ( _EOF ) throw new EOFException ( ) ; ttry { tChunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = journalFile ( recoveringTransaction ) ; tDurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { if ( recoveringTransaction > = initialTransaction ) { tTransactionTimestamp entry = inputLog . read ( ) ; tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; } else { tinputLog . skip ( ) ; } trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; tPrevayler recovered = createPrevayler ( new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tBufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; tString toAdd = reader . readLine ( ) ; if ( afterSnapshot ) { tassertFalse ( " Shouldn't have recovered transaction from before snapshot " , ttoAdd . equals ( " first " ) | | toAdd . equals ( " second " ) ) ; } treturn new AppendTransaction ( toAdd ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; treturn suite ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tTransaction transaction = TransactionWithQueryExecuter . wrap ( _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ) ; treturn new TransactionTimestamp ( transaction , new Date ( Long . parseLong ( chunk . getParameter ( " timestamp " ) ) ) ) ; } 
public static Transaction wrap ( Object transactionPossiblyWithQuery ) { if ( transactionPossiblyWithQuery instanceof TransactionWithQuery ) { treturn new TransactionWithQueryExecuter ( ( TransactionWithQuery ) transactionPossiblyWithQuery ) ; 
public static Object strip ( Transaction possiblyWithQueryExecuter ) { if ( possiblyWithQueryExecuter instanceof TransactionWithQueryExecuter ) { treturn ( ( TransactionWithQueryExecuter ) possiblyWithQueryExecuter ) . _delegate ; 
private Transaction deepCopy ( Transaction transaction ) { ttry { treturn TransactionWithQueryExecuter . wrap ( DeepCopier . deepCopy ( TransactionWithQueryExecuter . strip ( transaction ) , _journalSerializer ) ) ; 
protected String journalContents ( ) throws IOException { tFile journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; tFileReader file = new FileReader ( journal ) ; tStringWriter string = new StringWriter ( ) ; tint ; tchar [ ] c = new char [ 1024 ] ; twhile ( ( = file . read ( c ) ) ! = - 1 ) { tstring . write ( c , 0 , ) ; } tfile . close ( ) ; treturn string . toString ( ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) throws Exception { tStringBuffer system = ( StringBuffer ) prevalentSystem ; tsystem . append ( toAdd ) ; treturn system . toString ( ) ; } 
public void testHideTransactionWithQueryExecuterFromSerializers ( ) throws Exception { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( strategy ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; trecover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) throws Exception { tPrevayler prevayler = createPrevayler ( journalSerializer ) ; tassertEquals ( " the system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; tassertEquals ( " the system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; tassertEquals ( " the system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tWriter writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; tAppendTransactionWithQuery transaction = ( AppendTransactionWithQuery ) object ; twriter . write ( transaction . toAdd ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tBufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; treturn new AppendTransactionWithQuery ( reader . readLine ( ) ) ; } 
public void testSkipOldTransactions ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; tPrevayler recovered = createPrevayler ( new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( HideTransactionWithQueryExecuterFromSerializersTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; treturn suite ; } 
private double performRound ( int threads ) { tlong initialOperationCount = operationCount ; tStopWatch stopWatch = StopWatch . start ( ) ; tstartThreads ( threads ) ; tsleep ( ) ; tstopThreads ( ) ; tdouble secondsEllapsed = stopWatch . secondsEllapsed ( ) ; tdouble operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; tsubject . reportResourcesUsed ( System . out ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + toResultString ( operationsPerSecond , threads ) ) ; treturn operationsPerSecond ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void reportResourcesUsed ( PrintStream out ) { tint totalSize = 0 ; tFile [ ] files = new File ( _journalDirectory ) . listFiles ( ) ; tfor ( int i = 0 ; i < files . length ; i + + ) { ttotalSize + = files [ i ] . length ( ) ; } out . println ( " Disk space used: " + totalSize ) ; } 
protected Object initialValue ( ) { treturn createXStream ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tOutputStreamWriter writer = new OutputStreamWriter ( stream ) ; tgetXStream ( ) . toXML ( object , writer ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { treturn getXStream ( ) . fromXML ( new InputStreamReader ( stream ) ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tOutputStreamWriter writer = _encoding = = null ? new OutputStreamWriter ( stream ) : new OutputStreamWriter ( stream , _encoding ) ; tgetXStream ( ) . toXML ( object , writer ) ; twriter . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { treturn getXStream ( ) . fromXML ( _encoding = = null ? new InputStreamReader ( stream ) : new InputStreamReader ( stream , _encoding ) ) ; } 
public static synchronized FileChannel acquire ( File file ) throws IOException { tfile = file . getCanonicalFile ( ) ; if ( _lockedFiles . containsKey ( file ) ) { treturn null ; } tfile . getParentFile ( ) . mkdirs ( ) ; tfile . createNewFile ( ) ; tRandomAccessFile stream = new RandomAccessFile ( file , " rw " ) ; tFileLock lock = stream . getChannel ( ) . tryLock ( ) ; if ( lock = = null ) { tstream . close ( ) ; treturn null ; } t_lockedFiles . put ( file , lock ) ; treturn stream . getChannel ( ) ; } 
public static synchronized void release ( File file ) throws IOException { tFileLock lock = ( FileLock ) _lockedFiles . remove ( file . getCanonicalFile ( ) ) ; tlock . release ( ) ; tlock . channel ( ) . close ( ) ; } 
public void testFileLock ( ) throws Exception { tFile lockFile = new File ( _testDirectory , " test.lock " ) ; } 
private void runProcess ( File lockFile , String expectedOutput ) throws IOException , InterruptedException { tString [ ] command = { " java " , " -classpath " , System . getProperty ( " java.class.path " ) , tLockingMain . class . getName ( ) , lockFile . getCanonicalPath ( ) } ; tProcess process = Runtime . getRuntime ( ) . exec ( command ) ; tBufferedReader output = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; tassertEquals ( expectedOutput , output . readLine ( ) ) ; tprocess . waitFor ( ) ; } 
public static void main ( String [ ] args ) throws IOException { tFile lockFile = new File ( args [ 0 ] ) ; if ( FileLocker . acquire ( lockFile ) ! = null ) { tSystem . out . println ( " Locked! " ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( HideTransactionWithQueryExecuterFromSerializersTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; treturn suite ; } 
tstatic private void runPrevaylerTransaction ( ) throws Exception { tPrevaylerTransactionSubject subject = new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) ; tnew TransactionTestRun ( tsubject , tnumberOfObjects ( ) , tprevaylerTransactionThreadsMin ( ) , tprevaylerTransactionThreadsMax ( ) ) ; if ( isPrevaylerTransactionConsistencyChecked ( ) ) { out ( " Checking transaction log consistency. " ) ; 
tstatic private boolean isPrevaylerTransactionConsistencyChecked ( ) { treturn booleanProperty ( " TransactionTestCheckConsistency " ) ; } 
public int hashCode ( ) { treturn ( int ) ( id + name . hashCode ( ) 
public Record next ( ) { tindicateProgress ( ) ; treturn new Record ( nextRecordId + + , _random ) ; } 
public boolean isConsistent ( ) throws Exception { tint expectedResult = prevayler . prevalentSystem ( ) . hashCode ( ) ; tinitializePrevayler ( ) ; } 
private void initializePrevayler ( ) throws IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tprevayler = factory . create ( ) ; No snapshot is generated by the test. 
public int hashCode ( ) { treturn recordsById . hashCode ( ) ; } 
public static File produceDirectory ( String directoryName ) throws IOException { tFile directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + directoryName ) ; treturn directory ; } 
public static File snapshotFile ( long version , File directory , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
public static void checkValidSnapshotSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { tthrow new IllegalArgumentException ( 
public static long snapshotVersion ( File file ) { tString fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshot ( File directory ) throws IOException { tFile [ ] files = directory . listFiles ( ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + directory ) ; tFile latestSnapshot = null ; tlong latestVersion = 0 ; tfor ( int i = 0 ; i < files . length ; i + + ) { tFile candidateSnapshot = files [ i ] ; tlong candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { tlatestVersion = candidateVersion ; tlatestSnapshot = candidateSnapshot ; } } treturn latestSnapshot ; } 
private File snapshotFile ( long version ) { treturn FileManager . snapshotFile ( version , _directory , _primarySuffix ) ; } 
public void produceDirectory ( ) throws IOException { if ( ! _directory . exists ( ) & & ! _directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + _directory ) ; if ( ! _directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + _directory ) ; } 
public File snapshotFile ( long version , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
public File latestSnapshot ( ) throws IOException { tFile [ ] files = _directory . listFiles ( ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; tFile latestSnapshot = null ; tlong latestVersion = 0 ; tfor ( int i = 0 ; i < files . length ; i + + ) { tFile candidateSnapshot = files [ i ] ; tlong candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { tlatestVersion = candidateVersion ; tlatestSnapshot = candidateSnapshot ; } } treturn latestSnapshot ; } 
public File journalFile ( long transaction ) { tString fileName = " 0000000000000000000 " + transaction ; tfileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; treturn new File ( _directory , fileName ) ; } 
public File createTempFile ( String prefix , String suffix ) throws IOException { treturn File . createTempFile ( prefix , suffix , _directory ) ; } 
private File journalFile ( long transaction ) { treturn _fileManager . journalFile ( transaction ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = _fileManager . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; 
private File snapshotFile ( long version ) { treturn _fileManager . snapshotFile ( version , _primarySuffix ) ; } 
public static void renameUnusedFile ( File journalFile ) { tjournalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public long findInitialJournalFile ( long initialTransactionWanted ) { tlong initialFileCandidate = initialTransactionWanted ; twhile ( initialFileCandidate ! = 0 ) { } 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = _fileManager . journalFile ( transactionNumber ) ; ttry { treturn new DurableOutputStream ( file , _journalSerializer ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { tlong initialLogFile = _fileManager . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { tinitializeNextTransaction ( initialTransactionWanted , 1 ) ; treturn ; } tlong nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; tinitializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = _fileManager . journalFile ( recoveringTransaction ) ; tDurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { if ( recoveringTransaction > = initialTransaction ) { tTransactionTimestamp entry = inputLog . read ( ) ; tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; } else { tinputLog . skip ( ) ; } trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = _fileManager . journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) FileManager . renameUnusedFile ( logFile ) ; } 
private Journal journal ( ) throws IOException { if ( _transientMode ) { treturn ( Journal ) new TransientJournal ( ) ; 
private GenericSnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) { treturn _nullSnapshotManager ; 
public File snapshotFile ( long version , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { tString fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public long findInitialJournalFile ( long initialTransactionWanted ) { tFile [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { treturn pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; tlong [ ] versions = new long [ journals . length ] ; tfor ( int i = 0 ; i < journals . length ; i + + ) { tversions [ i ] = journalVersion ( journals [ i ] ) ; } tArrays . sort ( versions ) ; tint match = Arrays . binarySearch ( versions , initialTransactionWanted ) ; if ( match > = 0 ) { Exact match was found. 
public boolean accept ( File pathname ) { treturn pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { tString fileName = file . getName ( ) ; if ( ! fileName . matches ( JOURNAL_FILENAME_PATTERN ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public File snapshotFile ( long version , String suffix ) { tcheckValidSnapshotSuffix ( suffix ) ; treturn file ( version , suffix ) ; } 
public File journalFile ( long transaction ) { treturn file ( transaction , JOURNAL_SUFFIX ) ; } 
private File file ( long version , String suffix ) { tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { treturn version ( file , SNAPSHOT_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { treturn version ( file , JOURNAL_FILENAME_PATTERN ) ; } 
private static long version ( File file , String filenamePattern ) { tString fileName = file . getName ( ) ; if ( ! fileName . matches ( filenamePattern ) ) return - 1 ; treturn Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public void configureJournalSerializer ( JavaSerializer serializer ) { tconfigureJournalSerializer ( " journal " , serializer ) ; } 
public void configureJournalSerializer ( XStreamSerializer serializer ) { tconfigureJournalSerializer ( " xstreamjournal " , serializer ) ; } 
public void configureJournalSerializer ( SkaringaSerializer serializer ) { tconfigureJournalSerializer ( " skaringajournal " , serializer ) ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { tFileManager . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { tthrow new IllegalStateException ( " Trying to read multiple journal formats and make sure behavior " + " is always the same is error-prone. Instead, take a snapshot before upgrading. " ) ; } t_journalSerializer = serializer ; t_journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { tFileManager . checkValidSnapshotSuffix ( suffix ) ; t_snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { t_primarySnapshotSuffix = suffix ; 
private String journalSuffix ( ) { if ( _journalSuffix ! = null ) return _journalSuffix ; treturn " journal " ; } 
private void initializePrevayler ( ) throws IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tprevayler = factory . create ( ) ; } 
public static void checkValidJournalSuffix ( String suffix ) { if ( ! suffix . matches ( JOURNAL_SUFFIX_PATTERN ) ) { tthrow new IllegalArgumentException ( 
public File journalFile ( long transaction , String suffix ) { tcheckValidJournalSuffix ( suffix ) ; treturn file ( transaction , suffix ) ; } 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = _fileManager . journalFile ( transactionNumber , _journalSuffix ) ; ttry { treturn new DurableOutputStream ( file , _journalSerializer ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) tthrows IOException , ClassNotFoundException { tlong recoveringTransaction = initialLogFile ; tFile logFile = _fileManager . journalFile ( recoveringTransaction , _journalSuffix ) ; tDurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; twhile ( true ) { ttry { if ( recoveringTransaction > = initialTransaction ) { tTransactionTimestamp entry = inputLog . read ( ) ; tsubscriber . receive ( entry . transaction ( ) , entry . timestamp ( ) ) ; } else { tinputLog . skip ( ) ; } trecoveringTransaction + + ; } catch ( EOFException eof ) { tFile nextFile = _fileManager . journalFile ( recoveringTransaction , _journalSuffix ) ; if ( logFile . equals ( nextFile ) ) FileManager . renameUnusedFile ( logFile ) ; } 
protected void tearDown ( ) throws Exception { tdelete ( _testDirectory ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { tdelete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
tstatic public void delete ( String fileName ) { tdelete ( new File ( fileName ) ) ; } 
tstatic public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; tassertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { tSystem . gc ( ) ; 
tstatic private void deleteDirectoryContents ( File directory ) { tFile [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; tfor ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected String journalContents ( final String suffix ) throws IOException { tFile [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " . " + suffix ) ; } } ) ; tassertEquals ( 1 , files . length ) ; tFile journal = files [ 0 ] ; tFileReader file = new FileReader ( journal ) ; tStringWriter string = new StringWriter ( ) ; tint ; tchar [ ] c = new char [ 1024 ] ; twhile ( ( = file . read ( c ) ) ! = - 1 ) { tstring . write ( c , 0 , ) ; } tfile . close ( ) ; treturn string . toString ( ) ; } 
public boolean accept ( File dir , String name ) { treturn name . endsWith ( " . " + suffix ) ; } 
public void testHideTransactionWithQueryExecuterFromSerializers ( ) throws Exception { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( strategy ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; trecover ( strategy ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( " MyJournal " , journalSerializer ) ; tfactory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { treturn new Date ( + + time ) ; } } ) ; treturn factory . create ( ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( " MyJournal " , strategy ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; trecover ( " MyJournal " , strategy ) ; } 
public void testBadSuffix ( ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; ttry { tfactory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void testTryToConfigureTwo ( ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; ttry { tfactory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void testJavaJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new JavaSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; trecover ( " journal " , strategy ) ; } 
public void testXStreamJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new XStreamSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; trecover ( " journal " , strategy ) ; } 
public void testSkaringaJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new SkaringaSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; trecover ( " journal " , strategy ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer journalSerializer ) tthrows IOException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( suffix , journalSerializer ) ; tfactory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { treturn new Date ( + + time ) ; } } ) ; treturn factory . create ( ) ; } 
public void testSkipOldTransactions ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler recovered = createPrevayler ( new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testBadSuffix ( ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; ttry { tfactory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public File findInitialJournalFile ( long initialTransactionWanted ) { tFile [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { treturn pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; tArrays . sort ( journals , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { tFile f1 = ( File ) o1 ; tFile f2 = ( File ) o2 ; treturn new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; tfor ( int i = journals . length - 1 ; i > = 0 ; i - - ) { tFile journal = journals [ i ] ; tlong version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { treturn journal ; } } treturn null ; } 
public int compare ( Object o1 , Object o2 ) { tFile f1 = ( File ) o1 ; tFile f2 = ( File ) o2 ; treturn new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { tFile initialJournal = _fileManager . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { tinitializeNextTransaction ( initialTransactionWanted , 1 ) ; treturn ; } tlong nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; tinitializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void testSkipOldTransactions ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ttry { tcreatePrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { tFileManager . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { tthrow new IllegalStateException ( " Read the javadoc to this method. " ) ; } t_journalSerializer = serializer ; t_journalSuffix = suffix ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tTransaction transaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; treturn new TransactionTimestamp ( transaction , new Date ( Long . parseLong ( chunk . getParameter ( " timestamp " ) ) ) ) ; } 
private Transaction deepCopy ( Transaction transaction ) { ttry { treturn ( Transaction ) DeepCopier . deepCopy ( transaction , _journalSerializer ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; treturn suite ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { tPrevaylerDirectory . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { tthrow new IllegalStateException ( " Read the javadoc to this method. " ) ; } t_journalSerializer = serializer ; t_journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { tPrevaylerDirectory . checkValidSnapshotSuffix ( suffix ) ; t_snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { t_primarySnapshotSuffix = suffix ; 
public static File produceDirectory ( String directoryPath ) throws IOException { tFile directory = new File ( directoryPath ) ; tproduceDirectory ( directory ) ; treturn directory ; } 
public static void produceDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + directory ) ; if ( ! directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + directory ) ; } 
public void produceDirectory ( ) throws IOException { tFileManager . produceDirectory ( _directory ) ; } 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; ttry { treturn new DurableOutputStream ( file , _journalSerializer ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { tFile initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { tinitializeNextTransaction ( initialTransactionWanted , 1 ) ; treturn ; } tlong nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; tinitializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = _directory . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; 
private File snapshotFile ( long version ) { treturn _directory . snapshotFile ( version , _primarySuffix ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; treturn suite ; } 
public void testJavaJournal ( ) throws Exception { tSerializer strategy = new JavaSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public void testXStreamJournal ( ) throws Exception { tSerializer strategy = new XStreamSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public void NOT_WORKING_testSkaringaJournal ( ) throws Exception { tSerializer strategy = new SkaringaSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
private void recover ( Serializer journalSerializer ) throws Exception { tPrevayler prevayler = createPrevayler ( journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( " journal " , journalSerializer ) ; treturn factory . create ( ) ; } 
private String propertyName ( ) throws IOException { treturn FileLocker . class . getName ( ) + " - " + _file . getCanonicalPath ( ) ; } 
public void release ( ) throws IOException { ttry { ttry { 
private synchronized void shareLocker ( FileLocker locker ) { t_sharedLocker = locker ; notifyAll ( ) ; } 
private synchronized FileLocker waitForLocker ( ) throws InterruptedException { twhile ( _sharedLocker = = null ) { twait ( ) ; } treturn _sharedLocker ; } 
private synchronized void waitForDone ( ) throws InterruptedException { twhile ( ! _done ) { twait ( ) ; 
private synchronized void stashException ( Exception e ) { t_exception = e ; } 
public void run ( ) { ttry { tshareLocker ( new FileLocker ( lockFile ) ) ; 
public void run ( ) { ttry { tFileLocker locker = waitForLocker ( ) ; 
public static void main ( String [ ] args ) { tFile lockFile = new File ( args [ 0 ] ) ; ttry { tnew FileLocker ( lockFile ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
private void dealWithError ( Turn myTurn ) { tsynchronized ( _transactionsToJournalMonitor ) { twhile ( _transactionsToJournal ! = 0 ) Cool . wait ( _transactionsToJournalMonitor ) ; } tmyTurn . alwaysSkip ( ) ; } 
private void letTheFoodTasterDie ( ) { t_royalFoodTaster = null ; } 
private void letTheFoodTasterDie ( ) { t_royalFoodTaster = null ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
private void journal ( Transaction transaction , Turn myTurn , Date executionTime ) { t_journal . append ( transaction , executionTime , myTurn ) ; tsynchronized ( _transactionsToJournalMonitor ) { t_transactionsToJournal - - ; 
public void testFoodTasting ( ) throws Exception { if ( true ) return ; } 
public void run ( ) { tfor ( int i = 0 ; ! _failed & & i < TRANSACTIONS_PER_THREAD ; i + + ) { ttry { 
private String stackTrace ( CountException exception ) { tByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; texception . printStackTrace ( new PrintStream ( stream ) ) ; treturn stream . toString ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { tCountingSystem countingSystem = ( CountingSystem ) prevalentSystem ; if ( countingSystem . counter = = WHEN_TO_START_THROWING ) { tthrow new CountException ( ) ; } tcountingSystem . counter + + ; } 
private void dealWithError ( Turn myTurn ) { t_foodTasterIsDead = true ; tmyTurn . alwaysSkip ( ) ; } 
public void testFoodTasting ( ) throws Exception { t_prevayler = PrevaylerFactory . createPrevayler ( new CountingSystem ( ) , _testDirectory ) ; t_failed = false ; tThread [ ] threads = new Thread [ NUMBER_OF_THREADS ] ; tfor ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { tthreads [ i ] = new CountThread ( ) ; } tfor ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { tthreads [ i ] . start ( ) ; } tfor ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { tthreads [ i ] . join ( ) ; } t_prevayler . close ( ) ; tassertFalse ( _failed ) ; } 
private static synchronized void clearExecutions ( ) { t_executions = " " ; } 
private static synchronized void addExecution ( String message ) { t_executions = _executions + message + " " ; tConfusedFoodTasterTest . class . notifyAll ( ) ; } 
private static synchronized boolean didExecute ( String message ) { treturn _executions . indexOf ( message ) ! = - 1 ; } 
private static synchronized void waitFor ( String message ) { twhile ( ! didExecute ( message ) ) { tCool . wait ( ConfusedFoodTasterTest . class ) ; 
public void testConfusion ( ) throws IOException , ClassNotFoundException , InterruptedException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( " ignored " ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( " MyJournal " , new ConfusingSerializer ( ) ) ; t_prevayler = factory . create ( ) ; tclearExecutions ( ) ; tnew Thread ( ) { public void run ( ) { t_prevayler . execute ( new FirstTransaction ( ) ) ; } } . start ( ) ; twaitFor ( " first was tasted " ) ; ttry { t_prevayler . execute ( new SecondTransaction ( ) ) ; tfail ( ) ; } catch ( RuntimeException e ) { tassertEquals ( " I taste bad! " , e . getMessage ( ) ) ; } tnew Thread ( ) { public void run ( ) { t_prevayler . execute ( new ThirdTransaction ( ) ) ; } } . start ( ) ; tThread . sleep ( 1000 ) ; tassertFalse ( didExecute ( " third was tasted " ) ) ; taddExecution ( " go ahead with first " ) ; twaitFor ( " first was kinged " ) ; twaitFor ( " third was kinged " ) ; } 
public void run ( ) { t_prevayler . execute ( new FirstTransaction ( ) ) ; } 
public void run ( ) { t_prevayler . execute ( new ThirdTransaction ( ) ) ; } 
protected void tearDown ( ) throws Exception { if ( _prevayler ! = null ) _prevayler . close ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( didExecute ( " first was tasted " ) ) { taddExecution ( " first was kinged " ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { tthrow new RuntimeException ( " I taste bad! " ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( didExecute ( " third was tasted " ) ) { taddExecution ( " third was kinged " ) ; 
public void writeObject ( OutputStream stream , Object object ) throws IOException { if ( object instanceof FirstTransaction ) { if ( didExecute ( " first was tasted " ) ) { 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { tswitch ( stream . read ( ) ) { tcase 1 : return new FirstTransaction ( ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; treturn suite ; } 
public void testAllowOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; toriginal . takeSnapshot ( ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; tPrevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void subscribeTo ( TransactionPublisher publisher ) throws IOException , ClassNotFoundException { t_ignoreRuntimeExceptions = true ; } 
public void receive ( Transaction transaction , Date executionTime ) { tsynchronized ( _prevalentSystem ) { t_systemVersion + + ; 
public Object executeQuery ( Query sensitiveQuery , Date executionTime ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn sensitiveQuery . query ( _prevalentSystem , executionTime ) ; 
public void takeSnapshot ( GenericSnapshotManager snapshotManager ) throws IOException { tsynchronized ( _prevalentSystem ) { tsnapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public Object prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public Object execute ( Query sensitiveQuery ) throws Exception { treturn _guard . executeQuery ( sensitiveQuery , clock ( ) . time ( ) ) ; } 
public void takeSnapshot ( ) throws IOException { t_guard . takeSnapshot ( _snapshotManager ) ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tTransaction transaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; treturn new TransactionTimestamp ( transaction , systemVersion , new Date ( executionTime ) ) ; } 
public void subscribeTo ( TransactionPublisher publisher ) throws IOException , ClassNotFoundException { tlong initialTransaction ; tsynchronized ( this ) { t_ignoreRuntimeExceptions = true ; _ignoreRuntimeExceptions = false; 
public void receive ( Transaction transaction , long systemVersion , Date executionTime ) { tsynchronized ( this ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public Object executeQuery ( Query sensitiveQuery , Clock clock ) throws Exception { tsynchronized ( _prevalentSystem ) { treturn sensitiveQuery . query ( _prevalentSystem , clock . time ( ) ) ; 
public void takeSnapshot ( GenericSnapshotManager snapshotManager ) throws IOException { tsynchronized ( this ) { tsynchronized ( _prevalentSystem ) { 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) throws IOException , ClassNotFoundException { tsynchronized ( this ) { twhile ( _systemVersion < systemVersion ) { 
public Object execute ( Query sensitiveQuery ) throws Exception { treturn _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public Transaction transaction ( ) { return _transaction ; } 
public Date timestamp ( ) { return new Date ( _executionTime ) ; } 
public void append ( Transaction transaction , Date executionTime , Turn threadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( Transaction transaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tDurableOutputStream myOutputJournal ; tDurableOutputStream outputJournalToClose = null ; tlong systemVersion ; ttry { tmyTurn . start ( ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; t_journalAgeTimer = StopWatch . start ( ) ; } tsystemVersion = _nextTransaction + + ; tmyOutputJournal = _outputJournal ; } finally { tmyTurn . end ( ) ; } ttry { tmyOutputJournal . sync ( new TransactionTimestamp ( transaction , systemVersion , executionTime ) , myTurn ) ; } catch ( IOException iox ) { thandle ( iox , _outputJournal . file ( ) , " writing to " ) ; } ttry { tmyTurn . start ( ) ; 
public long nextTransaction ( ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; treturn _nextTransaction ; } 
public void close ( ) { } public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; treturn _initialTransaction + journal . size ( ) ; } } 
public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; treturn _initialTransaction + journal . size ( ) ; } 
protected synchronized void notifySubscribers ( Transaction transaction , long systemVersion , Date executionTime ) { tIterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transaction , systemVersion , executionTime ) ; } 
public void publish ( Transaction transaction ) { tsynchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transaction); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
private long approve ( Transaction transaction , Date executionTime , Turn myTurn ) throws RuntimeException , Error { ttry { tmyTurn . start ( ) ; 
private void notifySubscribers ( Transaction transaction , long systemVersion , Date executionTime , Turn myTurn ) { ttry { tmyTurn . start ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { tsynchronized ( _pendingPublicationsMonitor ) { twhile ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public synchronized void receive ( Transaction transaction , long systemVersion , Date executionTime ) { t_queue . add ( new TransactionTimestamp ( transaction , systemVersion , executionTime ) ) ; notify ( ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { twhile ( _queue . size ( ) = = 0 ) waitWithoutInterruptions ( ) ; treturn ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void receive ( Transaction transaction , long systemVersion , Date executionTime ) ; } 
public void approve ( Transaction transaction , long systemVersion , Date executionTime ) throws RuntimeException , Error { } } 
public void approve ( Transaction transaction , long systemVersion , Date executionTime ) throws RuntimeException , Error { ttry { tTransaction transactionCopy = deepCopy ( transaction ) ; 
private PrevalentSystemGuard royalFoodTaster ( long systemVersion ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( systemVersion ) ; treturn _royalFoodTaster ; } 
private void produceNewFoodTaster ( long systemVersion ) { ttry { t_royalFoodTaster = _king . deepCopy ( systemVersion , _snapshotSerializer ) ; 
public void approve ( Transaction transaction , long systemVersion , Date executionTime ) throws RuntimeException , Error ; } END SNIPPET: censor 
private void receiveTransactionFromServer ( ) throws IOException , ClassNotFoundException { tObject transactionCandidate = _fromServer . readObject ( ) ; if ( transactionCandidate . equals ( ServerConnection . SUBSCRIBER_UP_TO_DATE ) ) { tsynchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } treturn ; } if ( transactionCandidate instanceof RuntimeException ) { t_myTransactionRuntimeException = ( RuntimeException ) transactionCandidate ; notifyMyTransactionMonitor ( ) ; treturn ; } if ( transactionCandidate instanceof Error ) { t_myTransactionError = ( Error ) transactionCandidate ; notifyMyTransactionMonitor ( ) ; treturn ; } tDate timestamp = ( Date ) _fromServer . readObject ( ) ; t_clock . advanceTo ( timestamp ) ; if ( transactionCandidate . equals ( ServerConnection . CLOCK_TICK ) ) return ; tlong systemVersion = _fromServer . readLong ( ) ; if ( transactionCandidate . equals ( ServerConnection . REMOTE_TRANSACTION ) ) { t_subscriber . receive ( _myTransaction , systemVersion , timestamp ) ; notifyMyTransactionMonitor ( ) ; treturn ; } t_subscriber . receive ( ( Transaction ) transactionCandidate , systemVersion , timestamp ) ; } 
public void receive ( Transaction transaction , long systemVersion , Date executionTime ) { ttry { tsynchronized ( _toRemote ) { 
public PrevalentSystemGuard recoveredPrevalentSystem ( ) { treturn _recoveredPrevalentSystem ; } 
private TransactionTimestamp timestamp ( String value ) { treturn new TransactionTimestamp ( new AppendTransaction ( value ) , _systemVersion + + , new Date ( ) ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( " MyJournal " , strategy ) ; tassertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; trecover ( " MyJournal " , strategy ) ; } 
public void testSkipOldTransactions ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ttry { tcreatePrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void testAllowOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; toriginal . takeSnapshot ( ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; tPrevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void sync ( TransactionGuide guide ) throws IOException { tint thisWrite ; } 
public void receive ( TransactionTimestamp transactionTimstamp ) { tTransaction transaction = transactionTimstamp . transaction ( ) ; tlong systemVersion = transactionTimstamp . systemVersion ( ) ; tDate executionTime = transactionTimstamp . executionTime ( ) ; tsynchronized ( this ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public TransactionTimestamp timestamp ( ) { treturn _transactionTimestamp ; } 
public void checkSystemVersion ( long expectedSystemVersion ) { if ( _transactionTimestamp . systemVersion ( ) ! = expectedSystemVersion ) { tthrow new IllegalStateException ( " Attempted to process " + _transactionTimestamp . systemVersion ( ) + " when ready for " + expectedSystemVersion ) ; 
public Date executionTime ( ) { treturn _transactionTimestamp . executionTime ( ) ; } 
public Date executionTime ( ) { return new Date ( _executionTime ) ; } 
public void append ( TransactionGuide guide ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tDurableOutputStream myOutputJournal ; tDurableOutputStream outputJournalToClose = null ; ttry { tguide . startTurn ( ) ; tguide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; t_journalAgeTimer = StopWatch . start ( ) ; } t_nextTransaction + + ; tmyOutputJournal = _outputJournal ; } finally { tguide . endTurn ( ) ; } ttry { tmyOutputJournal . sync ( guide ) ; } catch ( IOException iox ) { thandle ( iox , _outputJournal . file ( ) , " writing to " ) ; } ttry { tguide . startTurn ( ) ; 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; ttry { tguide . startTurn ( ) ; 
protected synchronized void notifySubscribers ( TransactionTimestamp transactionTimestamp ) { tIterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transactionTimestamp ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTurn myTurn = nextTurn ( ) ; tDate executionTime = realTime ( myTurn ) ; } 
private void notifySubscribers ( TransactionGuide guide ) { ttry { tguide . startTurn ( ) ; 
public synchronized void receive ( TransactionTimestamp transactionTimestamp ) { t_queue . add ( transactionTimestamp ) ; notify ( ) ; } 
public void receive ( TransactionTimestamp transactionTimestamp ) ; } 
public void receive ( TransactionTimestamp transactionTimstamp ) { tTransaction transaction = transactionTimstamp . transaction ( ) ; tlong systemVersion = transactionTimstamp . systemVersion ( ) ; tDate executionTime = transactionTimstamp . executionTime ( ) ; ttry { tsynchronized ( _toRemote ) { 
public void run ( ) { ttry { _out . sync ( new TransactionGuide ( timestamp ( _id + " .first " ) , _firstTurn ) ) ; 
public void sync ( TransactionGuide guide ) throws IOException { tint thisWrite ; } 
public Transaction transaction ( ) { treturn _transaction ; } 
public Date executionTime ( ) { treturn new Date ( _executionTime ) ; } 
public TransactionTimestamp deepCopy ( Serializer journalSerializer ) { ttry { tTransaction transactionCopy = ( Transaction ) DeepCopier . deepCopy ( _transaction , journalSerializer ) ; 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tDurableOutputStream myOutputJournal ; tDurableOutputStream outputJournalToClose = null ; tguide . startTurn ( ) ; ttry { tguide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; t_journalAgeTimer = StopWatch . start ( ) ; } t_nextTransaction + + ; tmyOutputJournal = _outputJournal ; } finally { tguide . endTurn ( ) ; } ttry { tmyOutputJournal . sync ( guide ) ; } catch ( IOException iox ) { thandle ( iox , _outputJournal . file ( ) , " writing to " ) ; } tguide . startTurn ( ) ; ttry { ttry { 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; tguide . startTurn ( ) ; ttry { tguide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction transaction ) { tTransactionGuide guide = approve ( transaction ) ; t_journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( Transaction transaction ) { tsynchronized ( _nextTurnMonitor ) { tTransactionTimestamp timestamp = new TransactionTimestamp ( transaction , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide guide ) { tguide . startTurn ( ) ; ttry { t_pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void close ( ) throws IOException { t_journal . close ( ) ; } 
public void approve ( TransactionTimestamp transactionTimestamp ) throws RuntimeException , Error { } } 
public void approve ( TransactionTimestamp transactionTimestamp ) throws RuntimeException , Error { ttry { tTransactionTimestamp timestampCopy = transactionTimestamp . deepCopy ( _journalSerializer ) ; 
public void approve ( TransactionTimestamp transactionTimestamp ) throws RuntimeException , Error ; } END SNIPPET: censor 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; tSerializer journalSerializer = journalSerializer ( ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort , journalSerializer ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort , journalSerializer ( ) ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; treturn new TransactionTimestamp ( new TransactionCapsule ( withQuery , chunk . getBytes ( ) , _serializer ) , systemVersion , new Date ( executionTime ) ) ; } 
public void receive ( TransactionTimestamp transactionTimestamp ) { tTransactionCapsule capsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; tsynchronized ( this ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public void execute ( Transaction transaction ) { publish ( new TransactionCapsule ( transaction , _journalSerializer ) ) ; } 
private void publish ( TransactionCapsule transactionCapsule ) { t_publisher . publish ( transactionCapsule ) ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionCapsule capsule = new TransactionCapsule ( transactionWithQuery , _journalSerializer ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( _withQuery ) { tTransactionWithQuery transactionWithQuery = ( TransactionWithQuery ) deserialize ( ) ; 
public Object deserialize ( ) { ttry { treturn _journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public Object result ( ) throws Exception { if ( ! _withQuery ) throw new IllegalStateException ( " Was not a TransactionWithQuery " ) ; if ( _queryException ! = null ) throw _queryException ; treturn _queryResult ; } 
public TransactionCapsule cleanCopy ( ) { treturn new TransactionCapsule ( _withQuery , _serialized , _journalSerializer ) ; } 
public TransactionCapsule withSerializer ( Serializer journalSerializer ) { treturn new TransactionCapsule ( _withQuery , _serialized , journalSerializer ) ; } 
public TransactionCapsule capsule ( ) { treturn _transactionCapsule ; } 
public TransactionTimestamp cleanCopy ( Serializer journalSerializer ) { treturn new TransactionTimestamp ( _transactionCapsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
private DurableOutputStream createOutputJournal ( long transactionNumber ) { tFile file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; ttry { treturn new DurableOutputStream ( file ) ; 
public void publish ( TransactionCapsule transactionCapsule ) { tsynchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transactionCapsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( TransactionCapsule transactionCapsule ) { tTransactionGuide guide = approve ( transactionCapsule ) ; t_journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( TransactionCapsule transactionCapsule ) { tsynchronized ( _nextTurnMonitor ) { tTransactionTimestamp timestamp = new TransactionTimestamp ( transactionCapsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) throws IOException ; } 
public void publish ( TransactionCapsule transactionCapsule ) ; public void close ( ) throws IOException ; } 
public void approve ( TransactionTimestamp transactionTimestamp ) throws RuntimeException , Error { ttry { tTransactionTimestamp timestampCopy = transactionTimestamp . cleanCopy ( _journalSerializer ) ; 
public synchronized void publish ( TransactionCapsule transactionCapsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; tsynchronized ( _myTransactionMonitor ) { t_myTransactionCapsule = transactionCapsule ; 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteTransactionCapsule = ( ( TransactionCapsule ) _fromRemote . readObject ( ) ) . withSerializer ( _journalSerializer ) ; ttry { t_publisher . publish ( _remoteTransactionCapsule ) ; 
public void receive ( TransactionTimestamp transactionTimestamp ) { tTransactionCapsule transactionCapsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; ttry { tsynchronized ( _toRemote ) { 
public void run ( ) { ttry { twhile ( true ) new ServerConnection ( _publisher , _serverSocket . accept ( ) , _journalSerializer ) ; 
private TransactionTimestamp timestamp ( String value ) { treturn new TransactionTimestamp ( new TransactionCapsule ( new AppendTransaction ( value ) , new JavaSerializer ( ) ) , _systemVersion + + , new Date ( ) ) ; } 
private String value ( TransactionTimestamp timestamp ) { treturn ( ( AppendTransaction ) timestamp . capsule ( ) . deserialize ( ) ) . toAdd ; } 
public void testConfigureJournalSerializationStrategy ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( " MyJournal " , strategy ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; trecover ( " MyJournal " , strategy ) ; } 
public void testSkipOldTransactions ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ttry { tcreatePrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void testAllowOldJournalSuffix ( ) throws IOException , ClassNotFoundException { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; toriginal . takeSnapshot ( ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; tPrevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; treturn suite ; } 
public void testSkaringaJournal ( ) throws Exception { tSerializer strategy = new SkaringaSerializer ( ) ; tstartAndCrash ( strategy ) ; trecover ( strategy ) ; } 
public static Object deepCopyParallel ( Object original , Serializer serializer ) throws IOException , ClassNotFoundException { tPipedOutputStream outputStream = new PipedOutputStream ( ) ; tPipedInputStream inputStream = new PipedInputStream ( outputStream ) ; tReceiver receiver = new Receiver ( inputStream , serializer ) ; treceiver . start ( ) ; ttry { tserializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } ttry { treceiver . join ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Unexpected InterruptedException " , e ) ; } if ( receiver . _error ! = null ) throw new RuntimeException ( " Error during deserialization " , receiver . _error ) ; if ( receiver . _runtimeException ! = null ) throw receiver . _runtimeException ; if ( receiver . _classNotFoundException ! = null ) throw receiver . _classNotFoundException ; if ( receiver . _ioException ! = null ) throw receiver . _ioException ; if ( receiver . _result ! = null ) return receiver . _result ; tthrow new RuntimeException ( " Deep copy failed in an unknown way " ) ; } 
public void run ( ) { ttry { t_result = _serializer . readObject ( _inputStream ) ; 
public void testNormal ( ) throws IOException , ClassNotFoundException { tObject original = " foo " ; tObject copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; tassertEquals ( original , copy ) ; tassertNotSame ( original , copy ) ; } 
public void testParallel ( ) throws IOException , ClassNotFoundException { tObject original = " foo " ; tObject copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; tassertEquals ( original , copy ) ; tassertNotSame ( original , copy ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( DeepCopierTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; treturn suite ; } 
private void refreshClock ( ) { tThread clockRefresher = new Thread ( ) { public void run ( ) { twhile ( true ) { tDateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; tsetTitle ( " Bank - " + format . format ( _prevayler . clock ( ) . time ( ) ) ) ; tCool . sleep ( 500 ) ; } } } ; tclockRefresher . setDaemon ( true ) ; tclockRefresher . start ( ) ; } 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { tsynchronized ( connectionCache ) { treturn connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { tisRoundFinished = true ; twhile ( activeRoundThreads ! = 0 ) { tThread . yield ( ) ; } } tstatic private String toResultString ( double operationsPerSecond , int threads ) { tString operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; treturn " " + operations + " operations/second ( " + threads + " threads) " ; } tstatic void outOfMemory ( ) { tSystem . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } tstatic private void sleep ( ) { tCool . sleep ( ROUND_DURATION_MILLIS ) ; } tstatic private void out ( Object obj ) { tSystem . out . println ( obj ) ; } } 
tstatic private void sleep ( ) { tCool . sleep ( ROUND_DURATION_MILLIS ) ; } 
public static void sleep ( long milliseconds ) { ttry { tThread . sleep ( milliseconds ) ; 
public static Object deepCopyParallel ( Object original , Serializer serializer ) throws IOException , ClassNotFoundException { tPipedOutputStream outputStream = new PipedOutputStream ( ) ; tPipedInputStream inputStream = new PipedInputStream ( outputStream ) ; tReceiver receiver = new Receiver ( inputStream , serializer ) ; ttry { tserializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } treturn receiver . getResult ( ) ; } 
public void run ( ) { ttry { t_result = _serializer . readObject ( _inputStream ) ; } catch ( IOException e ) { t_ioException = e ; } catch ( ClassNotFoundException e ) { t_classNotFoundException = e ; } catch ( RuntimeException e ) { t_runtimeException = e ; } catch ( Error e ) { t_error = e ; tthrow e ; } ttry { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) throws ClassNotFoundException , IOException { ttry { tjoin ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Unexpected InterruptedException " , e ) ; } } 
public void testParallelPathological ( ) throws IOException , ClassNotFoundException { tObject original = new Byte ( ( byte ) 17 ) ; tObject copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) throws IOException { tstream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; tstream . flush ( ) ; tCool . sleep ( 10 ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { tstream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; tstream . flush ( ) ; tCool . sleep ( 10 ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { treturn new Byte ( ( byte ) stream . read ( ) ) ; } 
private void append ( Prevayler prevayler , String appendix , String expectedResult ) { tprevayler . execute ( new Appendix ( appendix ) ) ; tCool . sleep ( 10 ) ; tassertEquals ( expectedResult , serverValue ( ) ) ; tassertEquals ( expectedResult , clientValue ( ) ) ; } 
private String clientValue ( ) { tCool . sleep ( 100 ) ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; treturn new TransactionTimestamp ( new TransactionCapsule ( withQuery , chunk . getBytes ( ) ) , systemVersion , new Date ( executionTime ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { if ( _withQuery ) { tTransactionWithQuery transactionWithQuery = ( TransactionWithQuery ) deserialize ( journalSerializer ) ; 
public Object deserialize ( Serializer journalSerializer ) { ttry { treturn journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public TransactionCapsule cleanCopy ( ) { treturn new TransactionCapsule ( _withQuery , _serialized ) ; } 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteTransactionCapsule = ( TransactionCapsule ) _fromRemote . readObject ( ) ; ttry { t_publisher . publish ( _remoteTransactionCapsule ) ; 
private TransactionTimestamp timestamp ( String value ) { treturn new TransactionTimestamp ( new TransactionCapsule ( new AppendTransaction ( value ) , _journalSerializer ) , _systemVersion + + , new Date ( ) ) ; } 
private String value ( TransactionTimestamp timestamp ) { treturn ( ( AppendTransaction ) timestamp . capsule ( ) . deserialize ( _journalSerializer ) ) . toAdd ; } 
public TransactionTimestamp read ( ) throws IOException , ClassNotFoundException { tChunk chunk = readChunk ( ) ; tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; tCapsule capsule ; if ( withQuery ) { tcapsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { tcapsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } treturn new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public abstract void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) ; public abstract Capsule cleanCopy ( ) ; } 
public void receive ( TransactionTimestamp transactionTimestamp ) { tCapsule capsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; tsynchronized ( this ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public void execute ( Transaction transaction ) { publish ( new TransactionCapsule ( transaction , _journalSerializer ) ) ; } 
private void publish ( Capsule capsule ) { t_publisher . publish ( capsule ) ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule capsule = new TransactionWithQueryCapsule ( transactionWithQuery , _journalSerializer ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tTransaction transaction = ( Transaction ) deserialize ( journalSerializer ) ; tsynchronized ( prevalentSystem ) { ttransaction . executeOn ( prevalentSystem , executionTime ) ; 
public Capsule cleanCopy ( ) { } 
public TransactionTimestamp cleanCopy ( Serializer journalSerializer ) { treturn new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tTransactionWithQuery transactionWithQuery = ( TransactionWithQuery ) deserialize ( journalSerializer ) ; ttry { tsynchronized ( prevalentSystem ) { 
public Object result ( ) throws Exception { if ( _queryException ! = null ) throw _queryException ; treturn _queryResult ; } 
public Capsule cleanCopy ( ) { treturn new TransactionWithQueryCapsule ( serialized ( ) ) ; } 
public void publish ( Capsule capsule ) { tsynchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { tTransactionGuide guide = approve ( capsule ) ; t_journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( Capsule capsule ) { tsynchronized ( _nextTurnMonitor ) { tTransactionTimestamp timestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) throws IOException ; } 
public void publish ( Capsule capsule ) ; public void close ( ) throws IOException ; } 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; tsynchronized ( _myCapsuleMonitor ) { t_myCapsule = capsule ; 
private void notifyMyTransactionMonitor ( ) { tsynchronized ( _myCapsuleMonitor ) { t_myCapsuleMonitor . notify ( ) ; 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteCapsule = ( TransactionCapsule ) _fromRemote . readObject ( ) ; ttry { t_publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp transactionTimestamp ) { tCapsule capsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; ttry { tsynchronized ( _toRemote ) { 
public void sync ( Guided guide ) throws IOException { tint thisWrite ; } 
private int writeObject ( Guided guide ) throws IOException { tsynchronized ( _writeLock ) { if ( _closed ) { 
public abstract void writeTo ( OutputStream stream ) throws IOException ; } 
public void writeTo ( OutputStream stream ) throws IOException { tChunk chunk = new Chunk ( _transactionTimestamp . capsule ( ) . serialized ( ) ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( _transactionTimestamp . capsule ( ) instanceof TransactionWithQueryCapsule ) ) ; tchunk . setParameter ( " systemVersion " , String . valueOf ( _transactionTimestamp . systemVersion ( ) ) ) ; tchunk . setParameter ( " executionTime " , String . valueOf ( _transactionTimestamp . executionTime ( ) . getTime ( ) ) ) ; tChunking . writeChunk ( stream , chunk ) ; } 
public Chunk readChunk ( ) throws IOException { if ( _EOF ) throw new EOFException ( ) ; ttry { tChunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { } 
private TransactionTimestamp timestamp ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; tCapsule capsule ; if ( withQuery ) { tcapsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { tcapsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } treturn new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public void writeTo ( OutputStream stream ) throws IOException { tstream . write ( _value . getBytes ( ) ) ; tstream . write ( '' ) ; } 
public void run ( ) { ttry { _out . sync ( new DummyGuide ( _id + " .first " , _firstTurn ) ) ; 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; tsynchronized ( _myTransactionMonitor ) { t_myTransaction = transaction ; 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; tsynchronized ( _myCapsuleMonitor ) { t_myCapsule = capsule ; 
public synchronized Date time ( ) { tupdate ( ) ; treturn super . time ( ) ; } 
private synchronized void update ( ) { tlong newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public synchronized Date time ( ) { return _activeClock . time ( ) ; } 
public synchronized void pause ( ) { tadvanceTo ( _realClock . time ( ) ) ; t_activeClock = _brokenClock ; } 
public synchronized void resume ( ) { _activeClock = _realClock ; } 
public void subscribeTo ( TransactionPublisher publisher ) throws IOException , ClassNotFoundException { tlong initialTransaction ; tsynchronized ( this ) { t_ignoreRuntimeExceptions = true ; _ignoreRuntimeExceptions = false; 
public synchronized void cancelSubscription ( TransactionSubscriber subscriber ) { t_subscribers . remove ( subscriber ) ; } 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { tsynchronized ( _pendingPublicationsMonitor ) { twhile ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void cancelSubscription ( TransactionSubscriber subscriber ) ; public void close ( ) throws IOException ; } 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; tsynchronized ( _upToDateMonitor ) { t_toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber subscriber ) { tthrow new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { twhile ( _queue . size ( ) = = 0 ) Cool . wait ( this ) ; treturn ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void testServerFirst ( ) throws Exception { tserverCrashRecover ( 0 ) ; tclientCrashRecover ( 0 ) ; tserverAppend ( " a " , " a " ) ; tserverAppend ( " b " , " ab " ) ; tclientAppend ( " c " , " abc " ) ; tclientAppend ( " d " , " abcd " ) ; tserverAppend ( " e " , " abcde " ) ; tclientCrashRecover ( 0 ) ; tclientAppend ( " f " , " abcdef " ) ; tserverAppend ( " g " , " abcdefg " ) ; tnetworkCrash ( ) ; tthreadToRestartNetworkAfterAWhile ( ) . start ( ) ; t_server . execute ( new Appendix ( " h " ) ) ; tclientAppend ( " i " , " abcdefghi " ) ; } 
private Thread threadToRestartNetworkAfterAWhile ( ) { treturn new Thread ( ) { public void run ( ) { 
public void run ( ) { tCool . sleep ( 300 ) ; TODO Simulate a network recovery. 
private void refreshClock ( ) { Thread clockRefresher = new Thread ( ) { public void run ( ) { DateFormat format = DateFormat . getTimeInstance ( ) ; while ( true ) { StringBuffer sb = new StringBuffer ( 18 ) ; sb . append ( " Bank - " ) ; setTitle ( format . format ( _prevayler . clock ( ) . time ( ) , sb , new java . text . FieldPosition ( DateFormat . SECOND_FIELD ) ) . toString ( ) ) ; Cool . sleep ( 1000 ) ; } } } ; clockRefresher . setDaemon ( true ) ; clockRefresher . start ( ) ; } 
public void run ( ) { DateFormat format = DateFormat . getTimeInstance ( ) ; while ( true ) { StringBuffer sb = new StringBuffer ( 18 ) ; 
private void initUI ( ) { setBounds ( 100 , 70 , 400 , 250 ) ; getContentPane ( ) . setLayout ( new BorderLayout ( 0 , 0 ) ) ; JPanel buttonPanel = new JPanel ( ) ; buttonPanel . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 0 , 0 ) ) ; refreshButton = new JButton ( " Refresh " ) ; refreshButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { refreshTable ( ) ; } } ) ; buttonPanel . add ( refreshButton ) ; getContentPane ( ) . add ( buttonPanel , BorderLayout . SOUTH ) ; matchTableModel = new DefaultTableModel ( ) ; matchTableModel . setColumnIdentifiers ( new String [ ] { " Match " , " Account " , " Balance " , " #Entries " } ) ; matchTable = new JTable ( matchTableModel ) ; getContentPane ( ) . add ( new JScrollPane ( matchTable ) , BorderLayout . CENTER ) ; } 
public void actionPerformed ( ActionEvent event ) { refreshTable ( ) ; } 
private void refreshTable ( ) { matchTableModel . setRowCount ( 0 ) ; Bank bank = ( Bank ) prevayler . prevalentSystem ( ) ; java . util . List accounts = bank . accounts ( ) ; try { create the match engine 
tObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException ; tObjectServerSocket openObjectServerSocket ( int port ) throws IOException ; } 
tObjectServerSocket openObjectServerSocket ( int port ) throws IOException ; } 
public ObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException { treturn new ObjectSocketImpl ( serverIpAddress , serverPort ) ; } 
public ObjectServerSocket openObjectServerSocket ( int port ) throws IOException { treturn new ObjectServerSocketImpl ( port ) ; } 
public ObjectSocket accept ( ) throws IOException { treturn new ObjectSocketImpl ( _serverSocket . accept ( ) ) ; } 
tvoid writeObject ( Object object ) throws IOException ; tObject readObject ( ) throws IOException , ClassNotFoundException ; tvoid close ( ) throws IOException ; } 
tObject readObject ( ) throws IOException , ClassNotFoundException ; tvoid close ( ) throws IOException ; } 
public void writeObject ( Object object ) throws IOException { _outputStream . writeObject ( object ) ; _outputStream . flush ( ) ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { treturn _inputStream . readObject ( ) ; } 
public void close ( ) throws IOException { _outputStream . close ( ) ; t_inputStream . close ( ) ; t_socket . close ( ) ; } 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; t_subscriber = subscriber ; tsynchronized ( _upToDateMonitor ) { t_server . writeObject ( new Long ( initialTransaction ) ) ; 
public void close ( ) throws IOException { t_server . close ( ) ; } 
public void run ( ) { ttry { tlong initialTransaction = ( ( Long ) _remote . readObject ( ) ) . longValue ( ) ; 
private void sendClockTicks ( ) { tThread clockTickSender = new Thread ( ) { public void run ( ) { ttry { twhile ( true ) { tsynchronized ( _remote ) { t_remote . writeObject ( CLOCK_TICK ) ; t_remote . writeObject ( _publisher . clock ( ) . time ( ) ) ; } tThread . sleep ( 1000 ) ; } } catch ( Exception ex ) { tex . printStackTrace ( ) ; } } } ; tclockTickSender . setDaemon ( true ) ; tclockTickSender . start ( ) ; } 
tvoid publishRemoteTransaction ( ) throws Exception { t_remoteCapsule = ( TransactionCapsule ) _remote . readObject ( ) ; ttry { t_publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp transactionTimestamp ) { tCapsule capsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; ttry { tsynchronized ( _remote ) { 
private void send ( Object object ) { tsynchronized ( _remote ) { ttry { 
public void writeObject ( Object object ) throws IOException { } 
public void configureNetwork ( Network network ) { t_network = network ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , network ( ) , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( network ( ) , _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private String journalSuffix ( ) { treturn _journalSuffix ! = null ? _journalSuffix : " journal " ; } 
private Network network ( ) { treturn _network ! = null ? _network : new NetworkImpl ( ) ; } 
private GenericSnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) treturn _nullSnapshotManager ; tPrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) treturn new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; tString snapshotSuffix = " snapshot " ; tJavaSerializer snapshotSerializer = new JavaSerializer ( _classLoader ) ; treturn new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException { if ( ! serverIpAddress . equals ( " localhost " ) ) throw new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; tObjectServerSocketMock server = server ( serverPort ) ; if ( server = = null ) throw new IOException ( " No server is listening on this port. " ) ; ttry { treturn server . openClientSocket ( ) ; 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) throws IOException { tObjectServerSocketMock old = server ( serverPort ) ; if ( old ! = null ) throw new IOException ( " Port already in use. " ) ; tObjectServerSocketMock result = new ObjectServerSocketMock ( ) ; t_serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; treturn result ; } 
private ObjectServerSocketMock server ( int serverPort ) { treturn ( ObjectServerSocketMock ) _serverSocketByPort . get ( new Integer ( serverPort ) ) ; } 
public synchronized ObjectSocket accept ( ) throws IOException { if ( _isWaiting ) throw new IOException ( " Port already in use. " ) ; t_isWaiting = true ; tCool . wait ( this ) ; t_isWaiting = false ; tObjectSocket result = _counterpart ; t_counterpart = null ; treturn result ; } 
tsynchronized ObjectSocket openClientSocket ( ) throws IOException { if ( ! _isWaiting ) throw new IOException ( " No thread is accepting connections on this port. " ) ; tObjectSocketMock result = new ObjectSocketMock ( ) ; t_counterpart = result . counterpart ( ) ; notify ( ) ; treturn result ; } 
public void writeObject ( Object object ) throws IOException { t_counterpart . receive ( object ) ; } 
private synchronized void receive ( Object object ) { t_receivedObjects . add ( object ) ; notify ( ) ; } 
public synchronized Object readObject ( ) throws IOException , ClassNotFoundException { if ( _receivedObjects . isEmpty ( ) ) Cool . wait ( this ) ; treturn _receivedObjects . remove ( 0 ) ; } 
public void close ( ) throws IOException { private List _receivedObjects = new LinkedList();} 
public ObjectSocket counterpart ( ) { treturn _counterpart ; } 
private void serverCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = factory ( " server " ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configureTransientMode ( true ) ; t_server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory factory = factory ( " client " ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; t_client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) throws IOException , ClassNotFoundException { tPrevaylerFactory factory = factory ( " clientWithServer " ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; t_clientWithServer = factory . create ( ) ; } 
private PrevaylerFactory factory ( String directory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; tfactory . configureNetwork ( NETWORK_MOCK ) ; treturn factory ; } 
protected void tearDown ( ) throws Exception { t_server = null ; t_client = null ; t_clientWithServer = null ; tsuper . tearDown ( ) ; } 
private void sendClockTicks ( ) { t_clockTickSender . setDaemon ( true ) ; t_clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { treturn new Thread ( ) { public void run() { 
tvoid publishRemoteTransaction ( ) throws IOException , ClassNotFoundException { t_remoteCapsule = ( TransactionCapsule ) _remote . readObject ( ) ; ttry { t_publisher . publish ( _remoteCapsule ) ; 
private synchronized void close ( ) { t_clockTickSender . interrupt ( ) ; tthis . interrupt ( ) ; t_publisher . cancelSubscription ( this ) ; } 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) throws IOException { tObjectServerSocketMock old = server ( serverPort ) ; if ( old ! = null ) throw new IOException ( " Port already in use. " ) ; tObjectServerSocketMock result = new ObjectServerSocketMock ( _permit ) ; t_serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; treturn result ; } 
public synchronized ObjectSocket accept ( ) throws IOException { t_permit . check ( ) ; if ( _isWaiting ) throw new IOException ( " Port already in use. " ) ; t_isWaiting = true ; tCool . wait ( this ) ; t_isWaiting = false ; t_permit . check ( ) ; tObjectSocket result = _counterpart ; t_counterpart = null ; treturn result ; } 
tsynchronized ObjectSocket openClientSocket ( ) throws IOException { t_permit . check ( ) ; if ( ! _isWaiting ) throw new IOException ( " No thread is accepting connections on this port. " ) ; tObjectSocketMock result = new ObjectSocketMock ( _permit ) ; t_counterpart = result . counterpart ( ) ; notify ( ) ; treturn result ; } 
private void initialize ( Permit permit , ObjectSocketMock counterpart ) { t_permit = permit ; t_permit . addObjectToNotify ( this ) ; t_counterpart = counterpart ; } 
public void writeObject ( Object object ) throws IOException { t_permit . check ( ) ; t_counterpart . receive ( object ) ; } 
public synchronized Object readObject ( ) throws IOException , ClassNotFoundException { t_permit . check ( ) ; if ( _receivedObjects . isEmpty ( ) ) Cool . wait ( this ) ; t_permit . check ( ) ; treturn _receivedObjects . remove ( 0 ) ; } 
public void close ( ) throws IOException { } 
public void check ( ) throws IOException { if ( ! _isValid ) tthrow new IOException ( " Network crash simulated. " ) ; 
public void expire ( ) { t_isValid = false ; tIterator it = _objectsToNotify . iterator ( ) ; twhile ( it . hasNext ( ) ) { tObject oNotify = it . next ( ) ; 
public void addObjectToNotify ( Object object ) { _objectsToNotify . add ( object ) ; } 
public void run ( ) { tCool . sleep ( 300 ) ; TODO NETWORK_MOCK.recover(); 
public void configureNetwork ( OldNetwork network ) { t_network = network ; } 
private OldNetwork network ( ) { treturn _network ! = null ? _network : new OldNetworkImpl ( ) ; } 
tObjectReceiver openRemoteReceiver ( String serverIpAddress , int serverPort , ObjectReceiver localReceiver ) throws IOException ; tObjectReceiver listenForRemoteReceiver ( int portToListen , ObjectReceiver localReceiver ) throws IOException ; } 
tObjectReceiver listenForRemoteReceiver ( int portToListen , ObjectReceiver localReceiver ) throws IOException ; } 
public void writeObject ( Object object ) throws IOException { 
public TransactionTimestamp cleanCopy ( ) { treturn new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { twhile ( _queue . size ( ) = = 0 ) { tsynchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } tCool . wait ( this ) ; } treturn ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void waitToEmpty ( ) { tsynchronized ( _emptynessMonitor ) { twhile ( _queue . size ( ) ! = 0 ) Cool . wait ( _emptynessMonitor ) ; 
public void approve ( TransactionTimestamp transactionTimestamp ) throws RuntimeException , Error { ttry { tTransactionTimestamp timestampCopy = transactionTimestamp . cleanCopy ( ) ; 
public void receive ( TransactionTimestamp tt ) { if ( tt . capsule ( ) = = _remoteCapsule ) ttt = new TransactionTimestamp ( null , tt . systemVersion ( ) , tt . executionTime ( ) ) ; synchronized (_remote) { 
public void testServerFirst ( ) throws Exception { tserverCrashRecover ( 0 ) ; tclientCrashRecover ( 0 ) ; tserverAppend ( " a " , " a " ) ; tserverAppend ( " b " , " ab " ) ; tclientAppend ( " c " , " abc " ) ; tclientAppend ( " d " , " abcd " ) ; tserverAppend ( " e " , " abcde " ) ; tclientCrashRecover ( 0 ) ; tassertEquals ( " abcde " , clientValue ( ) ) ; tclientAppend ( " f " , " abcdef " ) ; tserverAppend ( " g " , " abcdefg " ) ; tnetworkCrash ( ) ; tthreadToRestartNetworkAfterAWhile ( ) . start ( ) ; t_server . execute ( new Appendix ( " h " ) ) ; tclientAppend ( " i " , " abcdefghi " ) ; } 
public void receive ( Object object ) throws IOException ; } 
tObjectSocket accept ( ) throws IOException ; tvoid close ( ) throws IOException ; } 
public void close ( ) throws IOException { t_serverSocket . close ( ) ; } 
public void close ( ) throws IOException { }} 
tvoid start ( Service service , int port ) throws IOException ; tObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
tObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
public void receive ( Object object ) throws IOException ; public void close ( ) throws IOException ; } 
tObjectReceiver serverFor ( ObjectReceiver client ) ; public void close ( ) throws IOException ; } 
tObjectSocket openClientSocket ( ) throws IOException { twhile ( ! _isWaiting ) Cool . sleep ( 50 ) ; treturn openClientSocketImmediately ( ) ; } 
tsynchronized private ObjectSocket openClientSocketImmediately ( ) throws IOException { t_permit . check ( ) ; if ( ! _isWaiting ) throw new IOException ( " No thread is accepting connections on this port. " ) ; tObjectSocketMock result = new ObjectSocketMock ( _permit ) ; t_counterpart = result . counterpart ( ) ; notify ( ) ; treturn result ; } 
tvoid publishRemoteTransaction ( ) throws IOException , ClassNotFoundException { t_remoteCapsule = ( Capsule ) _remote . readObject ( ) ; ttry { t_publisher . publish ( _remoteCapsule ) ; 
private void startSendingClockTicks ( ) { t_clockTickSender . setDaemon ( true ) ; t_clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { treturn new Thread ( ) { public void run() { 
tvoid startService ( Service service , int port ) throws IOException ; tvoid stopService ( int port ) throws IOException ; tObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
tvoid stopService ( int port ) throws IOException ; tObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
public static Object deepCopy ( Object original ) throws IOException , ClassNotFoundException { treturn deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static void unexpected ( Exception e ) { throw new RuntimeException ( " Unexpected Exception was thrown. " , e ) ; } 
public static Object deepCopy ( Object original ) { return deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) { ttry { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; 
public void writeObject ( Object object ) throws IOException { t_permit . check ( ) ; t_counterpart . receive ( DeepCopier . deepCopy ( object ) ) ; } 
public static void startDaemon ( Runnable runnable ) { Thread daemon = new Thread ( runnable ) ; daemon . setDaemon ( true ) ; daemon . start ( ) ; } 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException { if ( ! serverIpAddress . equals ( " localhost " ) ) throw new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; tObjectServerSocketMock server = server ( serverPort ) ; if ( server = = null ) throw new IOException ( " No server is listening on this port. " ) ; treturn server . openClientSocket ( ) ; } 
public synchronized ObjectSocket accept ( ) throws IOException { t_permit . check ( ) ; if ( _clientSide ! = null ) throw new IOException ( " Port already in use. " ) ; tObjectSocketMock result = new ObjectSocketMock ( _permit ) ; t_clientSide = result . counterpart ( ) ; notifyAll ( ) ; } 
tsynchronized ObjectSocket openClientSocket ( ) throws IOException { t_permit . check ( ) ; twhile ( _clientSide = = null ) Cool . wait ( this ) ; t_permit . check ( ) ; ObjectSocket result = _clientSide ; _clientSide = null ; notifyAll ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tObject transaction = deserialize ( journalSerializer ) ; tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; } 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction ) transaction ) . executeOn ( prevalentSystem , executionTime ) ; } 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { ttry { t_queryResult = ( ( TransactionWithQuery ) transaction ) . executeAndQuery ( prevalentSystem , executionTime ) ; 
public void configureJournalSerializer ( PLSerializer serializer ) { tconfigureJournalSerializer ( " pljournal " , serializer ) ; } 
public void configureSnapshotSerializer ( PLSerializer serializer ) { tconfigureSnapshotSerializer ( " plsnapshot " , serializer ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " A snapshot using PL's plist serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2PL " ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configureJournalSerializer ( new PLSerializer ( ) ) ; factory . configureSnapshotSerializer ( new PLSerializer ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
private static void out ( String message ) { System . out . println ( message ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { new PLObjectOutput ( stream ) . writeObject ( object ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { return new PLObjectInput ( stream ) . readObject ( ) ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( true ) receiveFromNetwork ( ) ; } } ; reader . setDaemon ( true ) ; reader . start ( ) ; } 
public void run ( ) { while ( true ) receiveFromNetwork ( ) ; } 
private void receiveFromNetwork ( ) { Object object = null ; try { object = _provider . readObject ( ) ; 
private void passToClient ( Object object ) { try { _client . receive ( object ) ; 
public void receive ( Object object ) throws IOException { _provider . writeObject ( object ) ; } 
public void close ( ) throws IOException { _provider . close ( ) ; } 
public void startService ( Service service , int port ) throws IOException { checkNotInUse ( port ) ; NetworkServerObjectReceiverImpl provider = new NetworkServerObjectReceiverImpl ( service , port ) ; _providerByPort . put ( new Integer ( port ) , provider ) ; } 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException { return new NetworkClientObjectReceiverImpl ( ipAddress , port , client ) ; } 
public void stopService ( int port ) throws IOException { NetworkServerObjectReceiverImpl provider = removeServer ( port ) ; if ( provider = = null ) { throw new IOException ( " illegal port number used " ) ; } provider . shutdown ( ) ; } 
private void checkNotInUse ( int serverPort ) throws IOException { Object old = _providerByPort . get ( new Integer ( serverPort ) ) ; if ( old ! = null ) throw new IOException ( " Port already in use. " ) ; } 
private NetworkServerObjectReceiverImpl removeServer ( int serverPort ) { return ( NetworkServerObjectReceiverImpl ) _providerByPort . remove ( new Integer ( serverPort ) ) ; } 
public void run ( ) { try { while ( true ) new ServerConnection ( _service , _provider . accept ( ) ) ; 
public void shutdown ( ) { try { this . _provider . close ( ) ; 
public void setUp ( ) { network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public void tearDown ( ) throws Exception { Thread . sleep ( NETWORK_SOCKET_CLOSE_MSEC_DELAY ) ; 
public void testMessageSendBothWays ( ) throws Exception { network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; server . send ( testObject1 ) ; client1 . received ( testObject1 ) ; client1 . send ( testObject2 ) ; server . received ( testObject2 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; } 
public void test2Clients ( ) throws Exception { port++; network.startService(mockService,port); client1.connect(port); client2.connect(port); Server server2 = new Server(2,mockService); Server server1 = new Server(1,mockService); sendTheMessages(server1, server2); network.stopService(port); } 
public void testDuplicateStartCaught ( ) throws Exception { network . startService ( mockService , port ) ; try { network . startService ( mockService , port ) ; fail ( " IOException for duplicate port not thrown " ) ; } catch ( IOException expected ) { } network . stopService ( port ) ; } 
public void testCloseUnopenedService ( ) { try { network . stopService ( port ) ; fail ( " IOException for unused port not thrown " ) ; } catch ( IOException expected ) { } ; } 
public void test2Services ( ) throws Exception { network . startService ( mockService , port ) ; ServiceMock mockService2 = new ServiceMock ( ) ; network . startService ( mockService2 , ( port + 1 ) ) ; client1 . connect ( port ) ; client2 . connect ( port + 1 ) ; Server server1 = new Server ( 1 , mockService ) ; Server server2 = new Server ( 1 , mockService2 ) ; sendTheMessages ( server1 , server2 ) ; network . stopService ( port ) ; network . stopService ( port + 1 ) ; } 
public void testRestartService ( ) throws Exception { testMessageSendBothWays ( ) ; tearDown ( ) ; mockService . reset ( ) ; testMessageSendBothWays ( ) ; } 
private void sendTheMessages ( Server server1 , Server server2 ) throws Exception { server1 . send ( testObject1 ) ; server2 . send ( testObject2 ) ; client1 . received ( testObject1 ) ; client2 . received ( testObject2 ) ; client1 . close ( ) ; client2 . close ( ) ; server1 . close ( ) ; server2 . close ( ) ; } 
public void send ( Object o ) throws Exception { networkReceiver . receive ( o ) ; Thread . sleep ( NETWORK_MSG_MSEC_DELAY ) ; } 
public void received ( Object o ) { assertTrue ( mock . check ( o ) ) ; } 
public void connect ( int port ) throws Exception { mock = new ObjectReceiverMock ( ) ; networkReceiver = network . findServer ( " localhost " , port , mock ) ; Thread . sleep ( NETWORK_CONNECT_SETUP_MSEC_TIME ) ; } 
public void close ( ) throws Exception { networkReceiver . close ( ) ; } 
public void close ( ) throws Exception { this . mockService . close ( service ) ; } 
protected void crashIfNotLocal ( String serverIpAddress ) { if ( ! serverIpAddress . equals ( " localhost " ) ) throw new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; } 
public void recover ( ) { _permit = new Permit ( ) ; } 
protected ObjectServerSocketMock findServer ( int serverPort ) { return ( ObjectServerSocketMock ) _serverSocketByPort . get ( new Integer ( serverPort ) ) ; } 
protected ObjectSocket startClient ( int serverPort ) throws IOException { ObjectServerSocketMock server = findServer ( serverPort ) ; if ( server = = null ) throw new IOException ( " No server is listening on this port. " ) ; return server . openClientSocket ( ) ; } 
protected ObjectServerSocket startServer ( int serverPort ) throws IOException { ObjectServerSocketMock old = findServer ( serverPort ) ; if ( old ! = null ) throw new IOException ( " Port already in use. " ) ; ObjectServerSocketMock result = new ObjectServerSocketMock ( _permit ) ; _serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; return result ; 
public void startService ( Service service , int port ) throws IOException { checkNotInUse ( port ) ; ObjectServerSocket server = startServer ( port ) ; _providerByPort . put ( new Integer ( port ) , new NetworkServerObjectReceiverImpl ( service , server ) ) ; 
public void stopService ( int port ) throws IOException { NetworkServerObjectReceiverImpl provider = removeServer ( port ) ; if ( provider = = null ) { throw new IOException ( " illegal port number used " ) ; } provider . shutdown ( ) ; } 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException { crashIfNotLocal ( ipAddress ) ; ObjectSocket provider = startClient ( port ) ; return new NetworkClientObjectReceiverImpl ( provider , client ) ; } 
private NetworkServerObjectReceiverImpl removeServer ( int serverPort ) { _serverSocketByPort . remove ( new Integer ( serverPort ) ) ; return ( NetworkServerObjectReceiverImpl ) _providerByPort . remove ( new Integer ( serverPort ) ) ; 
public void receive ( Object object ) throws IOException { received = object ; } 
public void close ( ) throws IOException { closed = true ; } 
public boolean isClosed ( ) { return closed ; } 
public boolean check ( Object expected ) { while ( this . received = = null ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( this . received ) ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { Integer key = new Integer ( index ) ; ObjectReceiver mock = new ObjectReceiverMock ( ) ; serverMock . put ( key , mock ) ; clients . put ( key , client ) ; index + + ; return mock ; } 
public void close ( int service ) throws IOException { ( ( ObjectReceiver ) clients . remove ( new Integer ( service ) ) ) . close ( ) ; } 
public ObjectReceiver getServerNetwork ( int key ) { Integer theKey = new Integer ( key ) ; Object receiver = clients . get ( theKey ) ; while ( receiver = = null ) { Cool . sleep ( 1 ) ; receiver = clients . get ( theKey ) ; } return ( ObjectReceiver ) receiver ; } 
public Object execute ( TransactionWithQuery transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule capsule = new TransactionWithQueryCapsule ( transactionWithQuery ) ; texecute ( capsule ) ; treturn capsule . result ( ) ; } 
public void writeTo ( OutputStream stream ) throws IOException { tChunk chunk = new Chunk ( _transactionTimestamp . capsule ( ) . serialized ( ) ) ; tchunk . setParameter ( " systemVersion " , String . valueOf ( _transactionTimestamp . systemVersion ( ) ) ) ; tchunk . setParameter ( " executionTime " , String . valueOf ( _transactionTimestamp . executionTime ( ) . getTime ( ) ) ) ; tChunking . writeChunk ( stream , chunk ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TransactionWithQueryCapsule original = ( TransactionWithQueryCapsule ) _instancesById . get ( _id ) ; original._queryResult = _contents.executeAndQuery(prevalentSystem, executionTime); 
tObject result ( ) throws Exception { if ( _queryException ! = null ) throw _queryException ; treturn _queryResult ; } 
private TransactionTimestamp timestamp ( Chunk chunk ) { tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; tCapsule capsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; treturn new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ( ( StringBuffer ) prevalentSystem ) . append ( toAdd ) ; } 
public void testPLJournal ( ) throws IOException , ClassNotFoundException { tSerializer strategy = new PLSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; trecover ( " journal " , strategy ) ; } 
public void testPLSnapshot ( ) throws IOException , ClassNotFoundException { tSerializer serializer = new PLSerializer ( ) ; 
private void startReading ( ) { Cool . startDaemon ( new Runnable ( ) { public void run ( ) { 
public void writeTo ( OutputStream stream ) throws IOException { tChunking . writeChunk ( stream , _transactionTimestamp . toChunk ( ) ) ; } 
public Chunk toChunk ( ) { tChunk chunk = new Chunk ( _capsule . serialized ( ) ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( _capsule instanceof TransactionWithQueryCapsule ) ) ; tchunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; tchunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; treturn chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; tCapsule capsule ; if ( withQuery ) { tcapsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { tcapsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } treturn new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
protected abstract void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; tChunk toChunk ( ) { tChunk chunk = new Chunk ( _serialized ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; treturn chunk ; } tstatic Capsule fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { treturn new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { treturn new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule cleanCopy ( ) ; tChunk toChunk ( ) { tChunk chunk = new Chunk ( _serialized ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; treturn chunk ; } tstatic Capsule fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { treturn new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { treturn new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
tChunk toChunk ( ) { tChunk chunk = new Chunk ( _serialized ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; treturn chunk ; } 
tstatic Capsule fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { treturn new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; 
public Chunk toChunk ( ) { tChunk chunk = _capsule . toChunk ( ) ; tchunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; tchunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; treturn chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { tCapsule capsule = Capsule . fromChunk ( chunk ) ; tlong systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; tlong executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; treturn new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
public void setUp ( ) { if ( ! mockTest ) { port = determinePort ( ) ; } network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
private int determinePort ( ) { int portToUse = 0 ; try { ServerSocket _serverSocket = new ServerSocket ( portToUse ) ; portToUse = _serverSocket . getLocalPort ( ) ; System . out . println ( " Using port : " + portToUse ) ; _serverSocket . close ( ) ; } catch ( IOException exception ) { fail ( " No available server port " ) ; } return portToUse ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; tsuite . addTest ( org . prevayler . foundation . Suite . suite ( ) ) ; treturn suite ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( DeepCopierTest . class ) ; tsuite . addTestSuite ( ChunkingTest . class ) ; tsuite . addTestSuite ( DurableOutputStreamTest . class ) ; tsuite . addTestSuite ( MultiMemberGZIPTest . class ) ; tsuite . addTestSuite ( FileLockerTest . class ) ; tsuite . addTestSuite ( NetworkTest . class ) ; treturn suite ; } 
public void setUp ( ) { port + + ; network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public void test2Clients ( ) throws Exception { network . startService ( mockService , port ) ; client1 . connect ( port ) ; client2 . connect ( port ) ; Server server2 = new Server ( 2 , mockService ) ; Server server1 = new Server ( 1 , mockService ) ; sendTheMessages ( server1 , server2 ) ; network . stopService ( port ) ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; treturn suite ; } 
private void initializePrevayler ( ) throws IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tfactory . configureTransactionFiltering ( false ) ; tprevayler = factory . create ( ) ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( true ) receiveFromNetwork ( ) ; } } ; reader . setName ( " Prevayler Network Client Receiver " ) ; reader . setDaemon ( true ) ; reader . start ( ) ; } 
public void networkRequestToReceive ( Object object ) throws IOException { if ( sessionIsConnected ( ) ) { this . _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { this . _sessionKey = ( ( Integer ) sessionKey ) . intValue ( ) ; } 
private synchronized void wakeUpSleepingClient ( ) { this . _sessionState = CONNECTED ; notify ( ) ; } 
private void closeForReconnect ( ) { try { this . _provider . close ( ) ; 
public void networkRequestsClose ( ) { System . out . println ( " Network (client) requests close " ) ; } 
public void receive ( Object object ) throws IOException { waitIfNotOpen ( ) ; forwardToProvider ( object ) ; } 
private synchronized void waitIfNotOpen ( ) { try { if ( ! sessionIsConnected ( ) ) { 
private void forwardToProvider ( Object object ) { try { this . _provider . receive ( object ) ; 
public void close ( ) throws IOException { this . _wantedOpen = false ; shutdown ( ) ; } 
private void shutdown ( ) { if ( sessionIsOpen ( ) ) { this . shutdownMonitor . wakeUp ( ) ; 
private boolean sessionIsOpen ( ) { return ( _sessionState > CLOSED ) ; } 
private boolean sessionIsConnected ( ) { return ( _sessionState = = CONNECTED ) ; } 
public void run ( ) { while ( _wantedOpen ) try { 
private void sendSessionKey ( ) { this . _sessionState = OPEN ; forwardToProvider ( new Integer ( _sessionKey ) ) ; } 
private void sleepMyself ( ) { this . shutdownMonitor . goToSleep ( ) ; } 
public void receive ( Object object ) throws IOException { this . _controller . networkRequestToReceive ( object ) ; } 
public void close ( ) throws IOException { this . _controller . networkRequestsClose ( ) ; } 
public synchronized void goToSleep ( ) { Cool . wait ( this ) ; } 
public synchronized void wakeUp ( ) { notify ( ) ; } 
public void startService ( Service service , int port ) throws IOException { checkPortNotUsed ( port ) ; Service stubbornService = createService ( service , port ) ; markPortAsUsed ( port , stubbornService ) ; } 
public void stopService ( int port ) throws IOException { try { Service stubbornService = locateService ( port ) ; 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException { return new StubbornClientReceiverImpl ( _unreliableDelegate , ipAddress , port , client ) ; 
private void markPortAsUsed ( int port , Service stubbornService ) { _servicesInUse . put ( new Integer ( port ) , stubbornService ) ; } 
private Service createService ( Service service , int port ) { return new StubbornServiceImpl ( _unreliableDelegate , service , port ) ; } 
private void checkPortNotUsed ( int port ) throws IOException { if ( _servicesInUse . get ( new Integer ( port ) ) ! = null ) { throw new IOException ( " Port In Service " ) ; 
private void releasePortForReuse ( int port ) { _servicesInUse . remove ( new Integer ( port ) ) ; } 
private void terminateService ( Service stubbornService ) { ( ( StubbornServiceImpl ) stubbornService ) . shutdown ( ) ; } 
private Service locateService ( int port ) throws IOException { Service service = ( Service ) _servicesInUse . get ( new Integer ( port ) ) ; if ( service = = null ) { throw new IOException ( " Port Not in Service " ) ; } return service ; } 
public void receive ( Object object ) throws IOException { if ( _isOpen ) { _client . receive ( object ) ; return ; } int sessionId = ( ( Integer ) object ) . intValue ( ) ; if ( sessionId = = 0 ) { establishNewSession ( ) ; 
private void establishNewSession ( ) { _client = _clientService . serverFor ( new ClientProxy ( this ) ) ; int sessionId = _stubbornService . add ( _client ) ; send ( sessionId ) ; } 
private void reestablishSession ( int sessionId ) { this . _client = _stubbornService . find ( sessionId ) ; if ( _client = = null ) { establishNewSession ( ) ; 
private void send ( int sessionId ) { try { _provider . receive ( new Integer ( sessionId ) ) ; 
private void send ( Object object ) { try { _provider . receive ( object ) ; 
public void clientRequestsReceive ( Object object ) { waitTillOpen ( ) ; send ( object ) ; } 
private synchronized void waitTillOpen ( ) { if ( ! _isOpen ) { Cool . wait ( this ) ; 
private synchronized void open ( ) { _isOpen = true ; notify ( ) ; } 
public void clientRequestsClose ( ) { System . out . println ( " Client (Server Replicator) Requested Close " ) ; 
public void close ( ) throws IOException { System . out . println ( " Network (server) Requested Close " ) ; } 
public void receive ( Object object ) throws IOException { this . _controller . clientRequestsReceive ( object ) ; } 
public void close ( ) throws IOException { this . _controller . clientRequestsClose ( ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new StubbornServerReceiverImpl ( client , _service , this ) ; } 
public synchronized ObjectReceiver find ( int sessionId ) { return ( ObjectReceiver ) _sessions . get ( new Integer ( sessionId ) ) ; } 
public synchronized int add ( ObjectReceiver receiver ) { int key = _masterSessionId + + ; _sessions . put ( new Integer ( key ) , receiver ) ; return key ; } 
public void run ( ) { while ( _wantedOpen ) { try { 
private synchronized void sleepTillShutdown ( ) { Cool . wait ( this ) ; stopProviderService ( ) ; closeSessions ( ) ; _sessions . clear ( ) ; } 
private void stopProviderService ( ) { try { _provider . stopService ( _port ) ; 
public synchronized void shutdown ( ) { _wantedOpen = false ; this . notify ( ) ; } 
private void closeSessions ( ) { Collection sessions = _sessions . values ( ) ; Iterator iter = sessions . iterator ( ) ; while ( iter . hasNext ( ) ) { ObjectReceiver localClient = ( ObjectReceiver ) iter . next ( ) ; 
private void closeClient ( ObjectReceiver localClient ) { try { localClient . close ( ) ; 
public void setUp ( ) { Network oldNetwork = setNetworkToTest ( ) ; network = new StubbornNetwork ( oldNetwork ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public synchronized void test2Clients ( ) throws Exception { port++; network.startService(mockService,port); client1.connect(port); client2.connect(port); Server server2 = new Server(2,mockService); Server server1 = new Server(1,mockService); try { this.wait(100); } catch (InterruptedException ex) { } sendTheMessages(server1, server2); network.stopService(port); } 
private void sendTheMessages ( Server server1 , Server server2 ) throws Exception { server1 . send ( testObject1 ) ; server2 . send ( testObject1 ) ; client1 . received ( testObject1 ) ; client2 . received ( testObject1 ) ; server1 . send ( testObject2 ) ; server2 . send ( testObject2 ) ; client1 . received ( testObject2 ) ; client2 . received ( testObject2 ) ; client1 . close ( ) ; client2 . close ( ) ; server1 . close ( ) ; server2 . close ( ) ; } 
public void received ( Object o ) { assertTrue ( mock . check ( o ) ) ; } 
protected ObjectSocket startClient ( int serverPort ) throws IOException { ObjectServerSocketMock server = findServer ( serverPort ) ; if ( server = = null ) throw new IOException ( " No server is listening on this port. " ) ; try { return server . openClientSocket ( ) ; 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException { crashIfNotLocal ( serverIpAddress ) ; return startClient ( serverPort ) ; 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) throws IOException { return startServer ( serverPort ) ; } 
public synchronized ObjectReceiver serverFor ( ObjectReceiver client ) { Integer key = new Integer ( index ) ; ObjectReceiver mock = new ObjectReceiverMock ( ) ; serverMock . put ( key , mock ) ; clients . put ( key , client ) ; index + + ; return mock ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( ! _closing ) receiveFromNetwork ( ) ; } } ; reader . setName ( " Prevayler Network Client Receiver " ) ; reader . setDaemon ( true ) ; reader . start ( ) ; } 
public void run ( ) { while ( ! _closing ) receiveFromNetwork ( ) ; } 
private void receiveFromNetwork ( ) { try { Object object = _provider . readObject ( ) ; 
public void close ( ) throws IOException { _closing = true ; _provider . close ( ) ; } 
public void run ( ) { while ( _wantedOpen ) { try { 
public void shutdown ( ) { try { _wantedOpen = false ; 
protected void networkRequestToReceive ( Object object ) throws IOException { if ( object instanceof IOException ) { closeForReconnect ( ) ; _shutdownMonitor . wakeUp ( ) ; return ; } if ( sessionIsConnected ( ) ) { _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { _sessionKey = ( ( Integer ) sessionKey ) . intValue ( ) ; } 
private synchronized void wakeUpSleepingClient ( ) { _sessionState = CONNECTED ; notify ( ) ; } 
private void closeForReconnect ( ) { try { _provider . close ( ) ; 
protected void networkRequestsClose ( ) { System . out . println ( " Network (client) requests close " ) ; } 
private void forwardToProvider ( Object object ) { try { _provider . receive ( object ) ; 
private synchronized void waitToResend ( Object object ) { try { wait ( ) ; 
public void close ( ) throws IOException { _wantedOpen = false ; shutdown ( ) ; } 
private void shutdown ( ) { if ( sessionIsOpen ( ) ) { closeForReconnect ( ) ; 
private void sendSessionKey ( ) throws IOException { _provider . receive ( new Integer ( _sessionKey ) ) ; _sessionState = OPEN ; } 
private void sleepMyself ( ) { _shutdownMonitor . goToSleep ( ) ; } 
public void receive ( Object object ) throws IOException { _controller . networkRequestToReceive ( object ) ; } 
public void close ( ) throws IOException { _controller . networkRequestsClose ( ) ; } 
public void receive ( Object object ) throws IOException { if ( object instanceof IOException ) { closeSession ( ) ; return ; } if ( _isOpen ) { _client . receive ( object ) ; return ; } int sessionId = ( ( Integer ) object ) . intValue ( ) ; if ( sessionId = = 0 ) { establishNewSession ( ) ; 
private void reestablishSession ( int sessionId ) { _client = _stubbornService . find ( sessionId ) ; if ( _client = = null ) { establishNewSession ( ) ; 
private void closeSession ( ) { try { _provider . close ( ) ; 
public void receive ( Object object ) throws IOException { _controller . clientRequestsReceive ( object ) ; } 
public void close ( ) throws IOException { _controller . clientRequestsClose ( ) ; } 
protected synchronized ObjectReceiver find ( int sessionId ) { return ( ObjectReceiver ) _sessions . get ( new Integer ( sessionId ) ) ; } 
protected synchronized int add ( ObjectReceiver receiver ) { int key = _masterSessionId + + ; _sessions . put ( new Integer ( key ) , receiver ) ; return key ; } 
protected synchronized void shutdown ( ) { _wantedOpen = false ; this . notify ( ) ; } 
public void setObjectsToSend ( String objectsToSend ) { this . objectsToSend = objectsToSend ; } 
public void commenceService ( Network network , int port ) throws Exception { this . network = network ; this . port = port ; network . startService ( this , port ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new MockObjectReceiver ( objectsToSend , frequency , client ) ; } 
public void closeDown ( ) throws Exception { network . stopService ( port ) ; } 
public void run ( ) { openForBusiness = true ; for ( sent = 0 ; sent < objectsToSend . length ( ) ; sent + + ) { rest ( ) ; send ( ) ; } openForBusiness = false ; } 
private void rest ( ) { try { sleep ( frequency ) ; } catch ( InterruptedException unEx ) { } ; } 
private void send ( ) { try { networkClient . receive ( objectsToSend . substring ( sent , sent + 1 ) ) ; 
public void receive ( Object object ) throws IOException { fail ( " receive called on server " ) ; } 
public void close ( ) throws IOException { if ( openForBusiness ) { fail ( " close called unexpectedly " ) ; 
public void checkReceived ( String sent ) { assertEquals ( " Received " + received + " Expected " + sent , sent . length ( ) , received . length ( ) ) ; for ( int i = 0 ; i < sent . length ( ) ; i + + ) { assertEquals ( " Received " + received + " Expected " + sent , 
public void commenceReceiving ( Network network , int port , int expectedLth ) { this . expectedLth = expectedLth ; this . port = port ; this . network = network ; this . setName ( threadName ) ; this . setDaemon ( true ) ; start ( ) ; } 
public void run ( ) { connect ( ) ; sleepTillFinished ( ) ; shutdown ( ) ; } 
private void connect ( ) { try { networkProvider = network . findServer ( " localhost " , port , this ) ; 
private void shutdown ( ) { try { networkProvider . close ( ) ; 
private synchronized void sleepTillFinished ( ) { try { wait ( ) ; 
public void receive ( Object object ) throws IOException { if ( object instanceof String ) { String s = ( String ) object ; 
private synchronized void finished ( ) { notify ( ) ; } 
public void startProxy ( int listeningPort , int targetPort ) throws IOException { this . targetPort = targetPort ; network . startService ( this , listeningPort ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new ProxyReceiver ( network , targetPort , client ) ; } 
private synchronized void waitConnected ( ) { try { wait ( ) ; 
public void run ( ) { connect ( ) ; finishConnect ( ) ; monitorMessages ( ) ; } 
private synchronized void finishConnect ( ) { notify ( ) ; } 
private synchronized void monitorMessages ( ) { while ( true ) { try { 
public void connect ( ) { try { proxyClient = network . findServer ( " localhost " , port , new MockClient ( this ) ) ; 
public void receive ( Object object ) throws IOException { messageFromClientForServer ( object ) ; 
public void close ( ) throws IOException { TODO Auto-generated method stub } public void messageFromServerForClient(Object object) { try { proxyServer.receive(object); } catch (IOException ioex) { } } public void messageFromClientForServer(Object object) { try { proxyClient.receive(object); } catch (IOException ioex) { } } } public class MockClient implements ObjectReceiver { private ProxyReceiver proxy; MockClient(ProxyReceiver proxy) { this.proxy = proxy; } public void receive(Object object) throws IOException { proxy.messageFromServerForClient(object); } public void close() throws IOException { } }} 
public void messageFromServerForClient ( Object object ) { try { proxyServer . receive ( object ) ; 
public void messageFromClientForServer ( Object object ) { try { proxyClient . receive ( object ) ; 
public void receive ( Object object ) throws IOException { proxy . messageFromServerForClient ( object ) ; } 
public void close ( ) throws IOException { } } } 
public void donttestFailure ( ) throws Exception { if ( ! mockTest ) { return ; } System . out . println ( " Starting TestFailure " ) ; network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; networkMock . crash ( ) ; networkMock . recover ( ) ; server . send ( testObject1 ) ; client1 . received ( testObject1 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; System . out . println ( " Stopping TestFailure " ) ; } 
public void send ( Object o ) throws Exception { System . out . println ( " sending " + o ) ; networkReceiver . receive ( o ) ; Thread . sleep ( NETWORK_MSG_MSEC_DELAY ) ; } 
public void received ( Object o ) { assertTrue ( " Expecting: ? Actual: " + o , mock . check ( o ) ) ; } 
public void setUp ( ) throws Exception { provider = new MockObjectSocket ( ) ; client = new ObjectReceiverMock ( ) ; ncor = new NetworkClientObjectReceiverImpl ( provider , client ) ; Thread . yield ( ) ; } 
public void testGoodReceiving ( ) throws Exception { String object1 = " A " ; provider . addToReceiveQueue ( object1 ) ; client . check ( object1 ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void testReceiveIOException ( ) throws Exception { provider . crash ( ) ; Thread . yield ( ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void testSending ( ) throws Exception { String object1 = " A " ; ncor . receive ( object1 ) ; provider . check ( object1 ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void testSendIOException ( ) throws Exception { provider . sendCrash ( ) ; String object1 = " A " ; try { ncor . receive ( object1 ) ; fail ( " Should've thrown IO Exception " ) ; } catch ( IOException expected ) { } Thread . yield ( ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void writeObject ( Object object ) throws IOException { if ( ! permit ) { throw new IOException ( " Send Crash " ) ; } sentQueue . add ( object ) ; } 
public synchronized Object readObject ( ) throws IOException , ClassNotFoundException { while ( receiveQueue . isEmpty ( ) ) { try { monitoringRules = monitoringRules + " ;Read Waiting " ; wait ( ) ; monitoringRules = monitoringRules + " ;Read Interrupted " ; if ( closed ) { throw new IOException ( " Close Received " ) ; } if ( ! permit ) { throw new IOException ( " Crash " ) ; } } catch ( InterruptedException expected ) { } } return receiveQueue . remove ( 0 ) ; } 
public synchronized void close ( ) throws IOException { closed = true ; monitoringRules = monitoringRules + " ;close notify " ; notify ( ) ; } 
public synchronized void addToReceiveQueue ( Object o ) { receiveQueue . add ( o ) ; monitoringRules = monitoringRules + " ;read notify " ; notify ( ) ; } 
public synchronized void check ( Object o ) { while ( sentQueue . isEmpty ( ) ) { try { monitoringRules = monitoringRules + " ;check waiting " ; wait ( ) ; monitoringRules = monitoringRules + " ;check interrupted " ; } catch ( InterruptedException expected ) { } } assertSame ( o , sentQueue . remove ( 0 ) ) ; } 
public void checkClosed ( ) { assertTrue ( closed ) ; } 
public void printRules ( ) { System . out . println ( monitoringRules ) ; } 
public synchronized void crash ( ) { permit = false ; notify ( ) ; } 
public synchronized void sendCrash ( ) { permit = false ; } 
public void receive ( Object object ) throws IOException { System . out . println ( " received " + object ) ; if ( ! permit ) { permit = true ; throw new IOException ( " network failure " ) ; } received . add ( object ) ; } 
public boolean check ( Object expected ) { while ( this . received . isEmpty ( ) ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( this . received . remove ( 0 ) ) ) ; } 
public Object selfCheck ( ) { while ( this . received . isEmpty ( ) ) { Thread . yield ( ) ; } return received . remove ( 0 ) ; } 
public void receiveCrash ( ) { permit = false ; 
public void setUp ( ) throws Exception { provider = new ObjectReceiverMock ( ) ; client = new ObjectReceiverMock ( ) ; network = new SimpleNetworkMock ( ) ; network . setProvider ( provider ) ; scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; } 
private void endConnection ( ) throws Exception { scri . close ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; 
private void checkForSessionId ( int id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof Integer ) { assertEquals ( new Integer ( id ) , received ) ; 
private void startSession ( int sessionId ) { network . releaseServer ( ) ; Thread . yield ( ) ; checkForSessionId ( sessionId ) ; } 
private void completeSession ( int sessionId ) throws Exception { scri . networkRequestToReceive ( new Integer ( sessionId ) ) ; Thread . yield ( ) ; } 
private void establishSession ( int initialSessionId ) throws Exception { startSession ( initialSessionId ) ; completeSession ( 100 ) ; } 
public void testSessionStart ( ) throws Exception { startSession ( 0 ) ; endConnection ( ) ; } 
public void testSessionAbort ( ) throws Exception { provider . receiveCrash ( ) ; network . releaseServer ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void testSessionFailResponse ( ) throws Exception { startSession ( 0 ) ; scri . networkRequestToReceive ( new IOException ( " Network Lost " ) ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void testFailAfterSessionEstablished ( ) throws Exception { establishSession ( 0 ) ; scri . networkRequestToReceive ( new IOException ( " Network Lost " ) ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; startSession ( 100 ) ; endConnection ( ) ; } 
public void testGoodReceiving ( ) throws Exception { establishSession ( 0 ) ; String object1 = " A " ; scri . networkRequestToReceive ( object1 ) ; client . check ( object1 ) ; endConnection ( ) ; } 
public void testSending ( ) throws Exception { establishSession ( 0 ) ; String object1 = " A " ; scri . receive ( object1 ) ; provider . check ( object1 ) ; endConnection ( ) ; } 
public void testSendIOException ( ) throws Exception { MockClientSender sender = new MockClientSender ( scri ) ; Thread . yield ( ) ; establishSession ( 0 ) ; String object1 = " A " ; provider . receiveCrash ( ) ; sender . send ( object1 ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . yield ( ) ; establishSession ( 100 ) ; Thread . yield ( ) ; provider . check ( object1 ) ; endConnection ( ) ; sender . shutdown ( ) ; } 
public synchronized ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException { try { wait ( ) ; } catch ( InterruptedException unexpected ) { } return mockProvider ; } 
public synchronized void releaseServer ( ) { notify ( ) ; } 
public void run ( ) { while ( ! shutdownRequested ) { sendAnObject ( ) ; 
private synchronized void sendAnObject ( ) { if ( sendQ . isEmpty ( ) ) { try { 
public synchronized void shutdown ( ) { shutdownRequested = true ; notify ( ) ; } 
public synchronized void send ( Object o ) { sendQ . add ( o ) ; notify ( ) ; } 
public void startService ( Service service , int port ) throws IOException { checkPortNotUsed ( port ) ; NetworkServerObjectReceiver sessionServices = createService ( service , port ) ; markPortAsUsed ( port , sessionServices ) ; } 
public void stopService ( int port ) throws IOException { try { NetworkServerObjectReceiver stubbornService = locateService ( port ) ; 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) throws IOException { return newReceiver ( ipAddress , port , client ) ; } 
private void markPortAsUsed ( int port , NetworkServerObjectReceiver sessionService ) { _servicesInUse . put ( new Integer ( port ) , sessionService ) ; } 
protected NetworkServerObjectReceiver createService ( Service service , int port ) throws IOException { return new NetworkServerObjectReceiverImpl ( this , service , port ) ; } 
private void terminateService ( NetworkServerObjectReceiver stubbornService ) { stubbornService . shutdown ( ) ; } 
private NetworkServerObjectReceiver locateService ( int port ) throws IOException { NetworkServerObjectReceiver service = ( NetworkServerObjectReceiver ) _servicesInUse . get ( new Integer ( port ) ) ; if ( service = = null ) { throw new IOException ( " Port Not in Service " ) ; } return service ; } 
public abstract ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) throws IOException ; public abstract ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
public abstract ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) throws IOException ; } 
private void closeDown ( ) { try { close ( ) ; } catch ( IOException ignorable ) { } try { _client . close ( ) ; 
public ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) throws IOException { return new NetworkClientObjectReceiverImpl ( ipAddress , port , client ) ; } 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) throws IOException { return new NetworkClientObjectReceiverImpl ( socket , service ) ; } 
ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) throws IOException ; } 
public boolean equals ( Object other ) { if ( other = = null ) { return false ; } if ( ! ( other instanceof NetworkSessionId ) ) { return false ; } if ( ( ( NetworkSessionId ) other ) . timeStamp ! = timeStamp ) { return false ; } if ( ( ( NetworkSessionId ) other ) . id ! = id ) { return false ; } return true ; } 
public String toString ( ) { return " NetworkSessionId for " + id + " , timestamped.. " + timeStamp ; } 
StubbornNetworkProxy find ( NetworkSessionId sessionId ) ; NetworkSessionId add ( StubbornNetworkProxy receiver ) ; void remove ( NetworkSessionId sessionId ) ; } 
NetworkSessionId add ( StubbornNetworkProxy receiver ) ; void remove ( NetworkSessionId sessionId ) ; } 
public synchronized StubbornNetworkProxy find ( NetworkSessionId sessionId ) { return ( StubbornNetworkProxy ) _sessions . get ( sessionId ) ; } 
public synchronized NetworkSessionId add ( StubbornNetworkProxy receiver ) { NetworkSessionId key = new NetworkSessionId ( timeStamp , _masterSessionId + + ) ; _sessions . put ( key , receiver ) ; return key ; } 
public synchronized void remove ( NetworkSessionId sessionId ) { _sessions . remove ( sessionId ) ; } 
protected void networkRequestToReceive ( Object object ) throws IOException { if ( sessionIsConnected ( ) ) { _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { _sessionKey = ( NetworkSessionId ) sessionKey ; } 
private void closeForReconnect ( ) { try { _socketProvider . close ( ) ; 
private void forwardToProvider ( Object object ) { try { _socketProvider . writeObject ( object ) ; 
private void sendSessionKey ( ) throws IOException { _socketProvider . writeObject ( _sessionKey ) ; _sessionState = OPEN ; } 
private void startReading ( ) throws IOException { while ( _wantedOpen ) { try { 
ObjectSocket newInstance ( String ipAddress , int port ) throws IOException ; } 
public ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) throws IOException { return new StubbornClientReceiverImpl ( this , ipAddress , port , client ) ; } 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) throws IOException { SessionsManager sessionsManager = getSessionManager ( service ) ; return new StubbornServerReceiverImpl ( service , socket , sessionsManager ) ; } 
public ObjectSocket newInstance ( String ipAddress , int port ) throws IOException { return new ObjectSocketImpl ( ipAddress , port ) ; } 
protected synchronized void connect ( ObjectReceiver network , StubbornNetworkClientConnector inboundChannel ) { _network = network ; _inboundChannel = inboundChannel ; openClientChannel ( ) ; } 
protected synchronized void disconnect ( ) { _inboundChannel = null ; _network = null ; } 
public void receive ( Object object ) { if ( isOpen ( ) ) { attemptToForward ( object ) ; 
private synchronized boolean forwarded ( Object object ) { try { if ( _network = = null ) { 
private void attemptToForward ( Object object ) { while ( ! forwarded ( object ) ) { closeClientChannel ( ) ; 
private synchronized void waitTillOpen ( ) { try { wait ( ) ; 
private synchronized boolean isOpen ( ) { return ( _network ! = null ) ; } 
public void close ( ) throws IOException { closeClientChannel ( ) ; _client = null ; } 
private synchronized void openClientChannel ( ) { notify ( ) ; } 
private void closeClientChannel ( ) { try { _inboundChannel . disconnect ( ) ; 
public void receive ( Object object ) throws IOException { if ( _isOpen ) { _client . receive ( object ) ; 
public synchronized void close ( ) throws IOException { _isOpen = false ; _proxy . disconnect ( ) ; } 
private void handleSession ( Object object ) { if ( ! ( object instanceof NetworkSessionId ) ) { closeSession ( ) ; } StubbornNetworkProxy proxy = reestablishSession ( ( NetworkSessionId ) object ) ; _isOpen = true ; send ( _sessionId ) ; if ( ! _isOpen ) { return ; } _proxy = proxy ; _proxy . connect ( _provider , this ) ; } 
private StubbornNetworkProxy establishNewSession ( ) { StubbornNetworkProxy proxy = new StubbornNetworkProxy ( ) ; _client = _clientService . serverFor ( proxy ) ; proxy . setClient ( _client ) ; _sessionId = _sessionsManager . add ( proxy ) ; return proxy ; } 
private StubbornNetworkProxy reestablishSession ( NetworkSessionId sessionId ) { StubbornNetworkProxy proxy = _sessionsManager . find ( sessionId ) ; if ( proxy = = null ) { proxy = establishNewSession ( ) ; } else { _sessionId = sessionId ; } return proxy ; } 
public void disconnect ( ) { _sessionsManager . remove ( _sessionId ) ; _sessionId = null ; _proxy = null ; _isOpen = false ; } 
public void setUp ( ) { Network oldNetwork = setNetworkToTest(); network = new StubbornNetworkImpl(); mockService = new ServiceMock(); client1 = new Client(); client2 = new Client(); } 
public void testReceiveIOException ( ) throws Exception { provider . crash ( ) ; Thread . yield ( ) ; assertTrue ( client . isClosed ( ) ) ; provider . checkClosed ( ) ; Thread . yield ( ) ; checkThreadGone ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void testClosing ( ) throws Exception { ncor . close ( ) ; provider . checkClosed ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; checkThreadGone ( ) ; } 
public void printRules ( ) { if ( print ) { System . out . println ( monitoringRules ) ; 
public void testConnection ( ) throws Exception { proxy . connect ( network , receiver1 ) ; proxy . receive ( a ) ; assertSame ( a , network . selfCheck ( ) ) ; assertFalse ( network . isClosed ( ) ) ; } 
public void testDisconnection ( ) throws Exception { Thread . yield ( ) ; testConnection ( ) ; proxy . disconnect ( ) ; sender . send ( b ) ; assertTrue ( network . checkEmpty ( ) ) ; proxy . connect ( network2 , receiver2 ) ; assertSame ( b , network2 . selfCheck ( ) ) ; assertFalse ( network2 . isClosed ( ) ) ; } 
public void testCloseWorking ( ) throws Exception { Thread . yield ( ) ; testConnection ( ) ; proxy . close ( ) ; assertTrue ( network . isClosed ( ) ) ; assertNull ( proxy . getClient ( ) ) ; assertTrue ( receiver1 . disconnected ) ; } 
public void testCloseFailing ( ) throws Exception { Thread . yield ( ) ; testConnection ( ) ; network . receiveCrash ( ) ; proxy . close ( ) ; assertTrue ( network . isClosed ( ) ) ; assertNull ( proxy . getClient ( ) ) ; assertTrue ( receiver1 . disconnected ) ; 
public void disconnect ( ) { disconnected = true ; } 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( NetworkClientReceiverTest . class ) ; tsuite . addTestSuite ( NetworkProxyTest . class ) ; tsuite . addTestSuite ( StubbornNetworkReceiverTest . class ) ; tsuite . addTestSuite ( StubbornNetworkServerTest . class ) ; tsuite . addTestSuite ( NetworkTest . class ) ; treturn suite ; } 
public void testMessageSendBothWays ( ) throws Exception { Thread . yield ( ) ; network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; server . send ( testObject1 ) ; client1 . received ( testObject1 ) ; client1 . send ( testObject2 ) ; server . received ( testObject2 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; } 
public void testDuplicateStartCaught ( ) throws Exception { Thread . yield ( ) ; network . startService ( mockService , port ) ; try { network . startService ( mockService , port ) ; fail ( " IOException for duplicate port not thrown " ) ; } catch ( IOException expected ) { } network . stopService ( port ) ; } 
public void startService ( Service service , int port ) throws IOException { checkNotInUse ( port ) ; ObjectServerSocket server = startServer ( port ) ; _providerByPort . put ( new Integer ( port ) , new NetworkServerObjectReceiverImpl ( this , service , server ) ) ; 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) throws IOException { return new NetworkClientObjectReceiverImpl ( socket , service ) ; } 
public void receive ( Object object ) throws IOException { if ( ! permit ) { permit = true ; throw new IOException ( " network failure " ) ; } received . add ( object ) ; } 
public void close ( ) throws IOException { closed = true ; if ( ! permit ) { permit = true ; 
public void receiveCrash ( ) { permit = false ; } 
public boolean checkEmpty ( ) { return received . isEmpty ( ) ; } 
public void setUp ( ) throws Exception { System.out.println("Starting " + this.getName()); client = new ObjectReceiverMock(); network = new SimpleNetworkMock(); provider = prepareNetwork("Initial Provider"); Thread.yield(); } 
private MockObjectSocket prepareNetwork ( String providerName ) { MockObjectSocket tempProvider = new MockObjectSocket ( providerName ) ; network . setProvider ( tempProvider ) ; return tempProvider ; } 
private void checkForSessionId ( int id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof NetworkSessionId ) { assertEquals ( new NetworkSessionId ( 0 , id ) , received ) ; 
private void startSession ( int sessionId ) { Thread . yield ( ) ; checkForSessionId ( sessionId ) ; } 
private void completeSession ( int sessionId ) throws Exception { provider . read ( new NetworkSessionId ( 0 , sessionId ) ) ; Thread . yield ( ) ; } 
public void testSessionStart ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void testSessionAbort ( ) throws Exception { provider . failWriteToNetwork ( ) ; scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void testSessionFailResponse ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; startSession ( 0 ) ; provider . failReadFromNetwork ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void testFailAfterSessionEstablished ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; Thread . yield ( ) ; provider . failReadFromNetwork ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; checkForSessionId ( 100 ) ; endConnection ( ) ; } 
public void testGoodReceiving ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; String object1 = " A " ; provider . read ( object1 ) ; client . check ( object1 ) ; endConnection ( ) ; } 
public void testSending ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; String object1 = " A " ; scri . receive ( object1 ) ; provider . check ( object1 ) ; endConnection ( ) ; } 
public void testSendIOException ( ) throws Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; MockClientSender sender = new MockClientSender ( scri ) ; MockObjectSocket provider2 = prepareNetwork ( " Provider 2 " ) ; Thread . yield ( ) ; establishSession ( 0 ) ; provider . failWriteToNetwork ( ) ; String object1 = " A " ; sender . send ( object1 ) ; Thread . yield ( ) ; assertTrue ( provider . checkEmpty ( ) ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; provider = provider2 ; establishSession ( 100 ) ; Thread . yield ( ) ; provider . check ( object1 ) ; endConnection ( ) ; sender . shutdown ( ) ; } 
public ObjectSocket newInstance ( String ipAddress , int port ) throws IOException { return mockProvider ; } 
public synchronized void failReadFromNetwork ( ) { permitRead . clear ( ) ; notify ( ) ; } 
public synchronized void failWriteToNetwork ( ) { permitWrite . clear ( ) ; } 
public synchronized void failClose ( ) { permitClose . clear ( ) ; } 
public void checkPermission ( Permit permit ) throws IOException { if ( ! permit . check ( ) ) { throw new IOException ( " network failure " ) ; 
public void writeObject ( Object object ) throws IOException { checkPermission ( permitWrite ) ; received . add ( object ) ; } 
public Object readObject ( ) throws IOException , ClassNotFoundException { checkPermission ( permitRead ) ; return readAnObject ( ) ; } 
private synchronized Object readAnObject ( ) throws IOException { while ( readQ . isEmpty ( ) ) { try { wait ( ) ; if ( closed ) { throw new IOException ( " Socket CLosed " ) ; } checkPermission ( permitRead ) ; } catch ( InterruptedException uhOh ) { throw new RuntimeException ( uhOh ) ; } } Object o = readQ . remove ( 0 ) ; return o ; } 
public synchronized void read ( Object o ) { readQ . add ( o ) ; notify ( ) ; } 
public synchronized void close ( ) throws IOException { closed = true ; notify ( ) ; checkPermission ( permitClose ) ; } 
public boolean isClosed ( ) { return closed ; } 
public boolean check ( Object expected ) { while ( this . received . isEmpty ( ) ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( this . received . remove ( 0 ) ) ) ; } 
public Object selfCheck ( ) { while ( this . received . isEmpty ( ) ) { Thread . yield ( ) ; } return received . remove ( 0 ) ; } 
public boolean checkEmpty ( ) { return received . isEmpty ( ) ; } 
public synchronized boolean check ( ) { if ( state ) { return true ; } state = true ; return false ; } 
public synchronized void clear ( ) { state = false ; } 
public void setUp ( ) throws Exception { provider = new ObjectReceiverMock ( ) ; sessionsManager = new SessionsManagerImpl ( timeStamp ) ; service = new ServiceMock ( ) ; serverReceiver = new StubbornServerReceiverImpl ( provider , service , sessionsManager ) ; Thread . yield ( ) ; } 
private void endConnection ( NetworkSessionId sessionId ) throws Exception { serverReceiver . disconnect ( ) ; Thread . yield ( ) ; assertFalse ( provider . isClosed ( ) ) ; assertNull ( sessionsManager . find ( sessionId ) ) ; } 
private void checkForSessionId ( NetworkSessionId id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof NetworkSessionId ) { assertEquals ( id , received ) ; 
private void startSession ( NetworkSessionId sessionId ) throws Exception { serverReceiver . receive ( id0 ) ; checkForSessionId ( sessionId ) ; } 
public void testSessionStart ( ) throws Exception { startSession ( id100 ) ; assertNotNull ( service . getServerMock ( 1 ) ) ; assertNotNull ( sessionsManager . find ( id100 ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; endConnection ( id100 ) ; } 
public void testSessionAbort ( ) throws Exception { provider . receiveCrash ( ) ; serverReceiver . receive ( id0 ) ; assertTrue ( provider . isClosed ( ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; } 
public void testReceive ( ) throws Exception { startSession ( id100 ) ; String object = " B " ; serverReceiver . receive ( object ) ; assertFalse ( provider . isClosed ( ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; service . getServerMock ( 1 ) . check ( object ) ; } 
public void testSocketDies ( ) throws Exception { startSession ( id100 ) ; serverReceiver . close ( ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; } 
public static void main ( String [ ] args ) throws Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; tString serverURI ; if ( args . length = = 1 ) { tserverURI = args [ 0 ] ; } else { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " + " nTrying to find server on localhost... " ) ; tserverURI = " localhost " ; } tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new Bank ( ) ) ; tfactory . configurePrevalenceDirectory ( " demo2Replica " ) ; tfactory . configureReplicationClient ( serverURI , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; tPrevayler prevayler = factory . create ( ) ; tMain . startSnapshots ( prevayler ) ; } 
public void testNormal ( ) throws Exception { String testSequence = " ABCDEFGHIJKL " ; int serverPort = 8765 ; int proxyPort = 5678 ; networkProxy . startProxy ( proxyPort , serverPort ) ; serverService . setObjectsToSend ( testSequence ) ; serverService . setFrequency ( 100 ) ; serverService . commenceService ( serverNetwork , serverPort ) ; client1Receiver . commenceReceiving ( clientNetwork1 , proxyPort , testSequence . length ( ) ) ; client2Receiver . commenceReceiving ( clientNetwork2 , proxyPort , testSequence . length ( ) ) ; while ( client1Receiver . isAlive ( ) | | client2Receiver . isAlive ( ) ) { Thread . sleep ( 1000 ) ; } client1Receiver . checkReceived ( testSequence ) ; client2Receiver . checkReceived ( testSequence ) ; serverService . closeDown ( ) ; } 
protected Object execute ( Object p_prevalentSystem , Date p_timestamp ) throws Exception { try { 
private Method getMethod ( ) throws Exception { return m_methodInfo . getMethod ( ) ; } 
public Method getMethod ( ) throws Exception { Class [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static Object create ( Class p_intf , Prevayler p_prevayler ) { return create ( p_intf , p_prevayler , 
public static Object create ( final Class p_intf , final Prevayler p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object invoke ( Object p_proxy , Method p_method , Object [ ] p_args ) throws Throwable { return p_determiner . determineTransactionType ( p_method ) . execute ( p_prevayler , p_method , p_args , p_hint ) ; 
public Object query ( Object p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Object p_prevalentSystem , Date p_timestamp ) { try { 
public Object executeAndQuery ( Object p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? TransactionType . QUERY 
public TransactionType determineTransactionType ( Method p_method ) { return TransactionType . TRANSACTION_WITH_QUERY ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { } } ; public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public String toString ( ) { return " TransactionType{ " + m_name + " } " ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return p_prevayler . execute ( new ProxyQuery ( p_method , p_args , p_hint ) ) ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery ( p_method , p_args , p_hint ) ) ; 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { p_prevayler . execute ( new ProxyTransaction ( p_method , p_args , p_hint ) ) ; return null ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return null ; } 
private void addSite ( CampGuide guide , String name , int playground , int supermarket , int swimmingPool , int disco , int quiet , int beauty , int size , int price ) { CampSite site = new CampSite ( name ) ; site . setDistanceToPlayground ( playground ) ; site . setDistanceToSupermarket ( supermarket ) ; site . setDistanceToSwimmingPool ( swimmingPool ) ; site . setDistanceToDisco ( disco ) ; site . setQuietIndication ( quiet ) ; site . setBeautyIndication ( beauty ) ; site . setSize ( size ) ; site . setPriceIndication ( price ) ; site . setSomeDate ( date ) ; guide . addCampSite ( site ) ; System.out.println(site.getUpdated()); 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date timestamp ) ; } 
public Set getCampSites ( ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void addCampSite ( CampSite site ) { stampCampSite ( site ) ; campSites . put ( site . objectCode ( ) , site ) ; } 
public void updateCampSite ( CampSite site ) { if ( ! campSites . containsKey ( site . objectCode ( ) ) ) throw new RuntimeException ( " Can't update non-existent camp site! Try adding it first. " ) ; addCampSite ( site ) ; } 
public void removeCampSite ( CampSite site ) { campSites . remove ( site . objectCode ( ) ) ; } 
private void stampCampSite ( CampSite site ) { if ( this . transaction_time ! = 0 ) { site . setTimestamp ( this . transaction_time ) ; 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { ( ( CampGuide ) p_prevalentSystem ) . setTransactionTime ( p_timestamp ) ; } 
public String objectCode ( ) { return this . guid ; } 
public int hashCode ( ) { int hashCode = 1 ; hashCode = 31 * hashCode + ( int ) ( + serialVersionUID ^ ( serialVersionUID > > > 32 ) ) ; hashCode = 31 * hashCode + NOT_AVAILABLE ; hashCode = 31 * hashCode + ON_SITE ; hashCode = 31 * hashCode + ( name = = null ? 0 : name . hashCode ( ) ) ; hashCode = 31 * hashCode + playground ; hashCode = 31 * hashCode + supermarket ; hashCode = 31 * hashCode + swimmingPool ; hashCode = 31 * hashCode + disco ; hashCode = 31 * hashCode + quiet ; hashCode = 31 * hashCode + beauty ; hashCode = 31 * hashCode + size ; hashCode = 31 * hashCode + price ; hashCode = 31 * hashCode + ( int ) ( + created ^ ( created > > > 32 ) ) ; hashCode = 31 * hashCode + ( int ) ( + updated ^ ( updated > > > 32 ) ) ; hashCode = 31 * hashCode + ( guid = = null ? 0 : guid . hashCode ( ) ) ; hashCode = 31 * hashCode + ( someDate = = null ? 0 : someDate . hashCode ( ) ) ; return hashCode ; } 
public void testSimple ( ) throws Exception { Method m = String . class . getMethod ( " length " , new Class [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public void storeSomething ( String p_data ) { m_data = p_data ; } 
public void oopsRuntime ( String p_data ) { m_data = p_data ; throw new RuntimeOops ( ) ; } 
public void oopsChecked ( String p_data ) throws CheckedOops { m_data = p_data ; throw new CheckedOops ( ) ; } 
public String toString ( ) { String raw = valueAfterMD5 . toUpperCase ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( raw . substring ( 0 , 8 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 8 , 12 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 12 , 16 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 16 , 20 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 20 ) ) ; return sb . toString ( ) ; } 
public static void main ( String args [ ] ) { for ( int i = 0 ; i < 100 ; i + + ) { RandomGUID myGUID = new RandomGUID ( ) ; 
tabstract void action ( Account account ) throws Exception ; } tclass AccountEditAction extends SelectedAccountAction { private static final long serialVersionUID = 5901968097767524191L ; tAccountEditAction ( ) { tsuper ( " Edit " ) ; } tvoid action ( Account account ) { tnew AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } } tclass AccountDeleteAction extends SelectedAccountAction { private static final long serialVersionUID = - 1320330350155595965L ; tAccountDeleteAction ( ) { tsuper ( " Delete " ) ; } tvoid action ( Account account ) throws Exception { tint option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; t_prevayler . execute ( new AccountDeletion ( account ) ) ; } } } 
private static TransactionWithQuery transactionWithQuery ( ) { treturn new TransactionWithQuery ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , network ( ) , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager ) 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; treturn new JavaSerializer ( ) ; } 
private GenericSnapshotManager snapshotManager ( ) throws ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) treturn _nullSnapshotManager ; tPrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) treturn new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; tString snapshotSuffix = " snapshot " ; tJavaSerializer snapshotSerializer = new JavaSerializer ( ) ; treturn new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
private void closeClientChannel ( ) { try { if ( _inboundChannel ! = null ) _inboundChannel . disconnect ( ) ; 
public synchronized void close ( ) throws IOException { _isOpen = false ; if ( _proxy ! = null ) _proxy . disconnect ( ) ; } 
public Object prevalentSystem ( ) { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public void receive ( TransactionTimestamp transactionTimestamp ) { tCapsule capsule = transactionTimestamp . capsule ( ) ; tlong systemVersion = transactionTimestamp . systemVersion ( ) ; tDate executionTime = transactionTimestamp . executionTime ( ) ; tsynchronized ( this ) { if ( _prevalentSystem = = null ) { 
public Object executeQuery ( Query sensitiveQuery , Clock clock ) throws Exception { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public void takeSnapshot ( GenericSnapshotManager snapshotManager ) throws IOException { tsynchronized ( this ) { if ( _prevalentSystem = = null ) { 
public static synchronized void armBomb ( ) { tbombArmed = true ; } 
private static synchronized void triggerBomb ( ) { if ( bombArmed ) { tbombArmed = false ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ttriggerBomb ( ) ; tsuper . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Object prevalentSystem , Date executionTime ) throws Exception { treturn null ; } 
public void tearDown ( ) throws Exception { if ( _prevayler ! = null ) { _prevayler . close ( ) ; } super . tearDown ( ) ; } 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; _prevayler = factory . create ( ) ; } 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) throws IOException , ClassNotFoundException { tsynchronized ( this ) { twhile ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public void tearDown ( ) throws Exception { if ( _prevayler ! = null ) { t_prevayler . close ( ) ; } tsuper . tearDown ( ) ; } 
public void testDeadKing ( ) throws Exception { tnewPrevalenceBase ( ) ; tcrashRecover ( ) ; tappend ( " a " , " a " ) ; tappend ( " b " , " ab " ) ; verify ( " ab " ) ; tNondeterministicErrorTransaction . armBomb ( 2 ) ; ttry { t_prevayler . execute ( new NondeterministicErrorTransaction ( " c " ) ) ; tfail ( ) ; } catch ( AssertionFailedError failed ) { tthrow failed ; } catch ( Error expected ) { tassertEquals ( Error . class , expected . getClass ( ) ) ; tassertEquals ( " BOOM! " , expected . getMessage ( ) ) ; } ttry { t_prevayler . execute ( new Appendix ( " rollback " ) ) ; tfail ( ) ; } catch ( AssertionFailedError failed ) { tthrow failed ; } catch ( RuntimeException expected ) { tassertEquals ( RuntimeException . class , expected . getClass ( ) ) ; tassertEquals ( " Testing Rollback " , expected . getMessage ( ) ) ; } ttry { t_prevayler . execute ( new Appendix ( " z " ) ) ; tfail ( ) ; } catch ( AssertionFailedError failed ) { tthrow failed ; } catch ( Error expected ) { tassertEquals ( Error . class , expected . getClass ( ) ) ; tassertEquals ( " Prevayler is no longer accepting transactions due to an Error thrown from an earlier transaction. " , expected . getMessage ( ) ) ; } tcrashRecover ( ) ; verify ( " abc " ) ; } 
private void crashRecover ( ) throws Exception { if ( _prevayler ! = null ) t_prevayler . close ( ) ; t_prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void append ( String appendix , String expectedResult ) throws Exception { t_prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { tassertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { treturn ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
public static synchronized void armBomb ( int timeToDetonation ) { t_timeToDetonation = timeToDetonation ; } 
private static synchronized void triggerBomb ( ) { if ( _timeToDetonation > 0 & & - - _timeToDetonation = = 0 ) { tthrow new Error ( " BOOM! " ) ; 
public static Test suite ( ) { tTestSuite suite = new TestSuite ( ) ; tsuite . addTestSuite ( PrevaylerFactoryTest . class ) ; tsuite . addTestSuite ( TransientPrevaylerTest . class ) ; tsuite . addTestSuite ( QueryExecutionTest . class ) ; tsuite . addTestSuite ( PersistenceTest . class ) ; tsuite . addTestSuite ( JournalFileRollingTest . class ) ; tsuite . addTestSuite ( SkipOldTransactionsTest . class ) ; tsuite . addTestSuite ( CheckpointTest . class ) ; tsuite . addTestSuite ( RollbackTest . class ) ; tsuite . addTestSuite ( ReplicationTest . class ) ; tsuite . addTestSuite ( GenericSnapshotManagerTest . class ) ; tsuite . addTestSuite ( TransactionWithQueryTest . class ) ; tsuite . addTestSuite ( JournalSerializerTest . class ) ; tsuite . addTestSuite ( SnapshotSerializerTest . class ) ; tsuite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; tsuite . addTestSuite ( DeadKingDeepCopyTest . class ) ; treturn suite ; } 
public TransactionType determineTransactionType ( Method p_method ) { return TRANSACTION_WITH_QUERY ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? QUERY 
private PrevaylerFactory factory ( String directory ) { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; treturn factory ; } 
protected void tearDown ( ) throws Exception { t_server = null ; t_client = null ; tsuper . tearDown ( ) ; } 
private String clientValue ( ) { tCool . sleep ( 100 ) ; } 
public Prevayler create ( ) throws IOException , ClassNotFoundException { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
public void abortTurn ( String message , Throwable cause ) { _turn . abort ( message , cause ) ; } 
public static Turn first ( ) { return new Turn ( true ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { throw new TurnAbortedException ( ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( this ) ; } if ( _allowed < 0 ) { throw new TurnAbortedException ( ) ; } _allowed - - ; } 
private synchronized void allow ( ) { _allowed + + ; notifyAll ( ) ; } 
public void abort ( String message , Throwable cause ) { Turn turn = this ; while ( turn ! = null ) { turn = turn . die ( ) ; } throw new TurnAbortedException ( message , cause ) ; } 
private synchronized Turn die ( ) { _allowed = Integer . MIN_VALUE ; notifyAll ( ) ; return _next ; } 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; tDurableOutputStream myOutputJournal ; tDurableOutputStream outputJournalToClose = null ; tguide . startTurn ( ) ; ttry { tguide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; t_journalAgeTimer = StopWatch . start ( ) ; } t_nextTransaction + + ; tmyOutputJournal = _outputJournal ; } finally { tguide . endTurn ( ) ; } ttry { tmyOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } tguide . startTurn ( ) ; ttry { ttry { 
private DurableOutputStream createOutputJournal ( long transactionNumber , Guided guide ) { tFile file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; ttry { treturn new DurableOutputStream ( file ) ; 
private void abort ( Exception exception , File journal , String action , Guided guide ) { guide . abortTurn ( " All transaction processing is now aborted. An IOException was thrown while " + action + " a .journal file. " , exception ) ; } 
public static Object get ( Object root , String path ) throws Exception { int dot = path . indexOf ( '.' ) ; String first = dot = = - 1 ? path : path . substring ( 0 , dot ) ; String rest = dot = = - 1 ? null : path . substring ( dot + 1 ) ; Field field = root . getClass ( ) . getDeclaredField ( first ) ; field . setAccessible ( true ) ; Object value = field . get ( root ) ; return rest = = null ? value : get ( value , rest ) ; } 
public void testJournalPanic ( ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; try { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( TurnAbortedException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } try { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( TurnAbortedException aborted ) { assertNull ( aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
private void sneakilyCloseUnderlyingJournalStream ( ) throws Exception { FileOutputStream journalStream = ( FileOutputStream ) Sneaky . get ( _prevayler , " _publisher._journal._outputJournal._fileOutputStream " ) ; journalStream . close ( ) ; } 
protected Class resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { treturn ( _loader ! = null ? Class . forName ( v . getName ( ) , false , _loader ) : super . resolveClass ( v ) ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public File takeSnapshot ( ) throws IOException ; public void close ( ) throws IOException ; } 
public File takeSnapshot ( GenericSnapshotManager snapshotManager ) throws IOException { tsynchronized ( this ) { if ( _prevalentSystem = = null ) { 
public File takeSnapshot ( ) throws IOException { treturn _guard . takeSnapshot ( _snapshotManager ) ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tFile tempFile = _directory . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) throws IOException { tthrow new IOException ( _snapshotAttemptErrorMessage ) ; } 
private void snapshot ( String expectedSnapshotFilename ) throws IOException { out ( " Snapshot. " ) ; tFile snapshotFile = _prevayler . takeSnapshot ( ) ; tassertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; } 
public File latestSnapshot ( ) throws IOException { tFile [ ] files = _directory . listFiles ( ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; tFile latestSnapshot = null ; tlong latestVersion = - 1 ; tfor ( int i = 0 ; i < files . length ; i + + ) { tFile candidateSnapshot = files [ i ] ; tlong candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { tlatestVersion = candidateVersion ; tlatestSnapshot = candidateSnapshot ; } } treturn latestSnapshot ; } 
public void testSnapshotVersion0 ( ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. append("a", "a"); append("b", "ab"); append("c", "abc"); verify("abc"); File snapshot = snapshot("0000000000000000003.snapshot"); _prevayler.close(); assertTrue(snapshot.renameTo(new File(prevalenceBase(), "0000000000000000000.snapshot"))); assertTrue(new File(_prevalenceBase, "0000000000000000001.journal").delete()); crashRecover(); verify("abc"); append("d", "abcd"); snapshot("0000000000000000001.snapshot"); } 
private File snapshot ( String expectedSnapshotFilename ) throws IOException { out ( " Snapshot. " ) ; tFile snapshotFile = _prevayler . takeSnapshot ( ) ; tassertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; treturn snapshotFile ; } 
private File file ( long version , String suffix ) { if ( version < 0 ) { throw new IllegalArgumentException ( " Snapshot and journal version numbers must be non-negative: " + version ) ; } tString fileName = " 0000000000000000000 " + version ; treturn new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public Set necessaryFiles ( ) throws IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { throw new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set neededFiles = new TreeSet ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
private void checkNecessaryFiles ( PrevaylerDirectory directory , String [ ] filenames ) throws IOException { assertEquals ( setOfFiles ( filenames ) , directory . necessaryFiles ( ) ) ; } 
private DurableOutputStream createOutputJournal ( long transactionNumber , Guided guide ) { tFile file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; ttry { treturn new DurableOutputStream ( file , _journalDiskSync ) ; 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public void testPersistenceWithDiskSync ( ) throws Exception { doTestPersistence ( true ) ; } 
public void estPersistenceWithoutDiskSync ( ) throws Exception { doTestPersistence ( false ) ; } 
public void testDiskSyncPerformance ( ) throws Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long true1 = doDiskSyncPerformanceRun ( true ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long true2 = doDiskSyncPerformanceRun ( true ) ; long bestTrue = Math . min ( true1 , true2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; assertTrue ( bestTrue + " should be worse than " + worstFalse , bestTrue > worstFalse ) ; } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . currentTimeMillis ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . currentTimeMillis ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
private void crashRecover ( ) throws Exception { crashRecover ( true ) ; } 
private void crashRecover ( boolean journalDiskSync ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public File takeSnapshot ( ) throws Exception ; public void close ( ) throws IOException ; } 
public static Object deepCopyParallel ( Object original , Serializer serializer ) throws Exception { tPipedOutputStream outputStream = new PipedOutputStream ( ) ; tPipedInputStream inputStream = new PipedInputStream ( outputStream ) ; tReceiver receiver = new Receiver ( inputStream , serializer ) ; ttry { tserializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } treturn receiver . getResult ( ) ; } 
public void run ( ) { ttry { t_result = _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { t_error = e ; tthrow e ; } ttry { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) throws Exception { ttry { tjoin ( ) ; } catch ( InterruptedException e ) { tthrow new RuntimeException ( " Unexpected InterruptedException " , e ) ; } } 
protected Object initialValue ( ) { try { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
public void writeObject ( OutputStream stream , Object object ) throws Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . ENCRYPT_MODE , _key ) ; CipherOutputStream encrypt = new CipherOutputStream ( stream , cipher ) ; _delegate . writeObject ( encrypt , object ) ; encrypt . close ( ) ; } 
public Object readObject ( InputStream stream ) throws Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . DECRYPT_MODE , _key ) ; CipherInputStream decrypt = new CipherInputStream ( stream , cipher ) ; return _delegate . readObject ( decrypt ) ; } 
private Cipher getCipher ( ) throws GeneralSecurityException { try { return ( Cipher ) _ciphers . get ( ) ; 
public void writeObject ( OutputStream stream , Object object ) throws Exception { GZIPOutputStream gzip = new GZIPOutputStream ( stream , _bufferSize ) ; _delegate . writeObject ( gzip , object ) ; gzip . close ( ) ; } 
public Object readObject ( InputStream stream ) throws Exception { GZIPInputStream gunzip = new GZIPInputStream ( stream , _bufferSize ) ; return _delegate . readObject ( gunzip ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws Exception ; public Object readObject ( InputStream stream ) throws Exception ; } 
public Object readObject ( InputStream stream ) throws Exception ; } 
public File takeSnapshot ( GenericSnapshotManager snapshotManager ) throws Exception { tsynchronized ( this ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) throws Exception { tsynchronized ( this ) { twhile ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public File takeSnapshot ( ) throws Exception { treturn _guard . takeSnapshot ( _snapshotManager ) ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) throws Exception { tFile tempFile = _directory . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) throws Exception { tOutputStream out = new FileOutputStream ( snapshotFile ) ; ttry { tprimarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private Object readSnapshot ( File snapshotFile ) throws Exception { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( tsnapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; tSerializer serializer = ( Serializer ) _strategies . get ( suffix ) ; tFileInputStream in = new FileInputStream ( snapshotFile ) ; ttry { treturn serializer . readObject ( in ) ; 
private void initializePrevayler ( ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tfactory . configureTransactionFiltering ( false ) ; tprevayler = factory . create ( ) ; } 
public static void run ( ) throws Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = ( Account ) execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = ( Account ) execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . takeSnapshot ( ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem ) throws Exception { treturn createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public Prevayler create ( ) throws Exception { tGenericSnapshotManager snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; treturn new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private GenericSnapshotManager snapshotManager ( ) throws Exception { if ( _nullSnapshotManager ! = null ) treturn _nullSnapshotManager ; tPrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) treturn new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; tString snapshotSuffix = " snapshot " ; tJavaSerializer snapshotSerializer = new JavaSerializer ( ) ; treturn new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
protected String journalContents ( final String suffix ) throws IOException { tFile journal = findJournal ( suffix ) ; tFileInputStream file = new FileInputStream ( journal ) ; tByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; tint ; tbyte [ ] b = new byte [ 1024 ] ; twhile ( ( = file . read ( b ) ) ! = - 1 ) { tbuffer . write ( b , 0 , ) ; } tfile . close ( ) ; treturn buffer . toString ( " ISO-8859-1 " ) ; } 
protected File findJournal ( final String suffix ) { File [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { treturn name . endsWith ( " . " + suffix ) ; } } ) ; tassertEquals ( 1 , files . length ) ; treturn files [ 0 ] ; } 
public void testNormal ( ) { tObject original = " foo " ; tObject copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; tassertEquals ( original , copy ) ; tassertNotSame ( original , copy ) ; } 
public void testParallel ( ) throws Exception { tObject original = " foo " ; tObject copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; tassertEquals ( original , copy ) ; tassertNotSame ( original , copy ) ; } 
public void testParallelPathological ( ) throws Exception { tObject original = new Byte ( ( byte ) 17 ) ; tObject copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) throws Exception { tstream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; tstream . flush ( ) ; tCool . sleep ( 10 ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws Exception { tstream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; tstream . flush ( ) ; tCool . sleep ( 10 ) ; } 
public Object readObject ( InputStream stream ) throws Exception { treturn new Byte ( ( byte ) stream . read ( ) ) ; } 
private void snapshot ( ) throws Exception { out ( " Snapshot. " ) ; t_prevayler . takeSnapshot ( ) ; } 
public void testConfigureJournalSerializationStrategy ( ) throws Exception { tSerializer strategy = new MySerializer ( ) ; tstartAndCrash ( " MyJournal " , strategy ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; trecover ( " MyJournal " , strategy ) ; } 
public void testJavaJournal ( ) throws Exception { tSerializer strategy = new JavaSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; tassertEquals ( " 69;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 first r " + " 6A;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 007 second r " + " 69;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 third r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void testXStreamJournal ( ) throws Exception { tSerializer strategy = new XStreamSerializer ( ) ; tstartAndCrash ( " journal " , strategy ) ; assertEquals ( " 7A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> first</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> second</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> third</toAdd> n</org.prevayler.implementation.AppendTransaction> r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void testCompressedJournal ( ) throws Exception { GZIPSerializer serializer = new GZIPSerializer ( new MySerializer ( ) ) ; startAndCrash ( " journal " , serializer ) ; assertEquals ( " 1A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 037 213 b 0 0 0 0 0 0 0SH 313,*. 001 0 337 275= 342 006 0 0 0 r " + " 1B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 037 213 b 0 0 0 0 0 0 0S(NM 316 317K 001 0(V fU 007 0 0 0 r " + " 1A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 037 213 b 0 0 0 0 0 0 0S( 311 310,J 001 0 354s~T 006 0 0 0 r " , journalContents ( " journal " ) ) ; recover ( " journal " , serializer ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( suffix , journalSerializer ) ; tfactory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { treturn new Date ( + + time ) ; } } ) ; treturn factory . create ( ) ; } 
private File snapshot ( String expectedSnapshotFilename ) throws Exception { out ( " Snapshot. " ) ; tFile snapshotFile = _prevayler . takeSnapshot ( ) ; tassertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; treturn snapshotFile ; } 
public void testSnapshotPrevaylerCreation ( ) throws Exception { tPrevayler prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testCheckpointPrevaylerCreation ( ) { tPrevayler prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testSkipOldTransactions ( ) throws Exception { tPrevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws Exception { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ttry { tcreatePrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void testAllowOldJournalSuffix ( ) throws Exception { tPrevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; toriginal . takeSnapshot ( ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; tPrevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testConfigureSnapshotSerializer ( ) throws Exception { tSerializer serializer = new MySerializer ( ) ; ttakeSnapshot ( serializer ) ; tassertEquals ( " Yes, this is MySerializationStrategy! " + " the system first second third " , snapshotContents ( ) ) ; trecover ( serializer ) ; } 
public void testXStreamSnapshot ( ) throws Exception { tSerializer serializer = new XStreamSerializer ( ) ; ttakeSnapshot ( serializer ) ; trecover ( serializer ) ; } 
public void testSkaringaSnapshot ( ) throws Exception { tSerializer serializer = new SkaringaSerializer ( ) ; ttakeSnapshot ( serializer ) ; trecover ( serializer ) ; } 
private void takeSnapshot ( Serializer snapshotSerializer ) throws Exception { tPrevayler prevayler = createPrevayler ( snapshotSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) throws Exception { tPrevayler prevayler = createPrevayler ( snapshotSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer snapshotSerializer ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; treturn factory . create ( ) ; } 
public void testSnapshotAttempt ( ) throws Exception { ttry { tprevayler . takeSnapshot ( ) ; 
public void testNoExistingSnapshot ( ) throws Exception { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tassertEquals ( " initial " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
public void testRoundtripJava ( ) throws Exception { tcheckRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void testRoundtripXStream ( ) throws Exception { tcheckRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
public void testRoundtripSkaringa ( ) throws Exception { tcheckRoundtrip ( " skaringasnapshot " , new SkaringaSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) throws Exception { tPrevayler first = createPrevayler ( suffix , serializer ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( suffix , serializer ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
public void testDetectExistingSnapshotFromUnknownSnapshotManager ( ) throws Exception { tPrevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; ttry { tcreatePrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws Exception { tPrevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws Exception { tPrevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testUsePrimaryForWritingSnapshot ( ) throws Exception { tPrevayler first = createPrevaylerMulti ( ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tPrevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) throws Exception { tPrevayler prevayler = createPrevaylerMulti ( ) ; tassertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private Prevayler createPrevaylerMulti ( ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tfactory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; treturn factory . create ( ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer serializer ) throws Exception { tPrevaylerFactory factory = new PrevaylerFactory ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( suffix , serializer ) ; treturn factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler prevayler ) throws Exception { tprevayler . execute ( new AppendTransaction ( " one " ) ) ; tprevayler . execute ( new AppendTransaction ( " two " ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { throw new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( this ) ; } if ( _allowed < 0 ) { throw new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } _allowed - - ; } 
public void abort ( String message , Throwable cause ) { Turn turn = this ; while ( turn ! = null ) { turn = turn . die ( ) ; } throw new IllegalStateException ( message , cause ) ; } 
public void testJournalPanic ( ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; try { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } try { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted, probably due to an earlier IOException. " , aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public R query ( P prevalentSystem , Date executionTime ) throws Exception ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) ; } 
public void executeOn ( P prevalentSystem , Date executionTime ) ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) throws Exception ; } 
protected abstract void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; tChunk toChunk ( ) { tChunk chunk = new Chunk ( _serialized ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; treturn chunk ; } tstatic Capsule fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { treturn new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { treturn new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public P prevalentSystem ( ) { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public < R > R executeQuery ( Query < P , R > sensitiveQuery , Clock clock ) throws Exception { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public File takeSnapshot ( GenericSnapshotManager < P > snapshotManager ) throws Exception { tsynchronized ( this ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard < P > deepCopy ( long systemVersion , Serializer snapshotSerializer ) throws Exception { tsynchronized ( this ) { twhile ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public P prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer ) ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) throws Exception { treturn _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { ttry { treturn execute ( ( TransactionWithQuery < P , R > ) sureTransactionWithQuery ) ; 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction < P > ) transaction ) . executeOn ( ( P ) prevalentSystem , executionTime ) ; } 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { ttry { t_queryResult = ( ( TransactionWithQuery < P , R > ) transaction ) . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public R result ( ) throws Exception { if ( _queryException ! = null ) throw _queryException ; treturn _queryResult ; } 
public Capsule cleanCopy ( ) { treturn new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
private PrevalentSystemGuard < P > royalFoodTaster ( long systemVersion ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( systemVersion ) ; treturn _royalFoodTaster ; } 
public PrevalentSystemGuard < P > recoveredPrevalentSystem ( ) { treturn _recoveredPrevalentSystem ; } 
public File writeSnapshot ( P prevalentSystem , long version ) throws Exception { tFile tempFile = _directory . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; twriteSnapshot ( prevalentSystem , tempFile ) ; tFile permanent = snapshotFile ( version ) ; tpermanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( P prevalentSystem , File snapshotFile ) throws Exception { tOutputStream out = new FileOutputStream ( snapshotFile ) ; ttry { tprimarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private P readSnapshot ( File snapshotFile ) throws Exception { tString suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( tsnapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; tSerializer serializer = ( Serializer ) _strategies . get ( suffix ) ; tFileInputStream in = new FileInputStream ( snapshotFile ) ; ttry { treturn ( P ) ( serializer . readObject ( in ) ) ; 
public File writeSnapshot ( P prevalentSystem , long version ) throws IOException { tthrow new IOException ( _snapshotAttemptErrorMessage ) ; } 
public static void main ( String [ ] args ) throws Exception { tprintMessage ( ) ; tPrevayler < NumberKeeper > prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; tnew PrimeCalculator ( prevayler ) . start ( ) ; } 
public void executeOn ( NumberKeeper prevalentSystem , Date ignored ) { tprevalentSystem . keep ( _numberToKeep ) ; } 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( project ! = null ) { tsystem . getProjects ( ) . add ( project ) ; 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( task ! = null & & projectId ! = Integer . MIN_VALUE ) { 
public void executeOn ( ScalabilitySystem system , Date ignored ) { tsystem . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
private void initializePrevayler ( ) throws Exception { tPrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tfactory . configureTransactionFiltering ( false ) ; tprevayler = factory . create ( ) ; } 
public void executeOn ( TransactionSystem system , Date ignored ) { tsystem . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public void executeOn ( MyPrevalentSystem prevalentSystem , Date executionTime ) { calendar . setTimeInMillis ( this . millis ) ; } 
public void executeOn ( MyPrevalentSystem prevalentSystem , Date executionTime ) { Calendar c = prevalentSystem . lookupCalendar ( this . id ) ; c . setTimeInMillis ( this . millis ) ; } 
public Task executeAndQuery ( TaskList prevalentSystem , Date executionTime ) throws Exception { tprevalentSystem . addTask ( task ) ; return task ; } 
public void executeOn ( TaskList prevalentSystem , Date executionTime ) { prevalentSystem . removeTask ( task ) ; } 
public Object query ( Serializable p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Serializable p_prevalentSystem , Date p_timestamp ) { try { 
public Object executeAndQuery ( Serializable p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public static void run ( ) throws Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . takeSnapshot ( ) ; } 
private static Account execute ( MementoTransaction command ) { try { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . time ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . toString ( ) ) ; } return null ; } 
protected void findObjects ( Bank prevalentSystem ) { bank = prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected Account execute ( MementoCollector collector ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } } 
protected Account execute ( MementoCollector collector ) throws Bank . AccountNotFound { tbank . deleteAccount ( accountNumber ) ; treturn null ; } 
protected void findObjects ( Bank prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected Account execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected void findObjects ( Bank prevalentSystem ) throws Exception { bank = prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected Account execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public Account executeAndQuery ( Bank prevalentSystem , Date timestamp ) throws Exception { tmementos = new HashMap ( ) ; ttry { treturn transaction . execute ( this , prevalentSystem ) ; 
public Account execute ( MementoCollector collector , Bank prevalentSystem ) throws Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Bank prevalentSystem ) throws Exception ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void checkPrecondition ( ) throws Exception ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
public static < P extends Serializable > Prevayler < P > createPrevayler ( P newPrevalentSystem ) throws Exception { treturn createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P extends Serializable > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) throws Exception { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static < P extends Serializable > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public static < P extends Serializable > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { treturn createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static < P extends Serializable > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public void configurePrevalentSystem ( P newPrevalentSystem ) { t_prevalentSystem = newPrevalentSystem ; } 
private void configureNullSnapshotManager ( NullSnapshotManager < P > snapshotManager ) { t_nullSnapshotManager = snapshotManager ; } 
public Prevayler < P > create ( ) throws Exception { tGenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; treturn new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) throw new IllegalStateException ( " The prevalent system must be configured. " ) ; treturn _prevalentSystem ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private GenericSnapshotManager < P > snapshotManager ( ) throws Exception { if ( _nullSnapshotManager ! = null ) treturn _nullSnapshotManager ; tPrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) treturn new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; tString snapshotSuffix = " snapshot " ; tJavaSerializer snapshotSerializer = new JavaSerializer ( ) ; treturn new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
public P prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > transaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( transaction , clock ( ) . time ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) throws Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > transactionWithQuery ) throws Exception { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public void executeBroadcastedTransaction ( Transaction < P > transaction ) { prevayler . execute ( transaction ) ; } 
public Object executeOn ( ClusteredPrevayler < P > prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
private void append ( Prevayler < AppendingSystem > prevayler , String appendix , String expectedResult ) { tprevayler . execute ( new Appendix ( appendix ) ) ; tCool . sleep ( 10 ) ; tassertEquals ( expectedResult , serverValue ( ) ) ; tassertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory < AppendingSystem > factory = factory ( " server " ) ; tfactory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; tfactory . configureTransientMode ( true ) ; t_server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) throws Exception { tPrevaylerFactory < AppendingSystem > factory = factory ( " client " ) ; tfactory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; t_client = factory . create ( ) ; } 
private PrevaylerFactory < AppendingSystem > factory ( String directory ) { tPrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; tfactory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; treturn factory ; } 
private String serverValue ( ) { treturn _server . prevalentSystem ( ) . value ( ) ; } 
private String clientValue ( ) { tCool . sleep ( 100 ) ; } 
public void executeOn ( StringBuffer prevalentSystem , Date executionTime ) { tprevalentSystem . append ( toAdd ) ; } 
public String executeAndQuery ( StringBuffer prevalentSystem , Date executionTime ) throws Exception { tprevalentSystem . append ( toAdd ) ; treturn prevalentSystem . toString ( ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date ignored ) { tprevalentSystem . append ( appendix ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date executionTime ) { ttriggerBomb ( ) ; tsuper . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Serializable prevalentSystem , Date executionTime ) throws Exception { treturn null ; } 
private TransactionCensor censor ( GenericSnapshotManager < P > snapshotManager ) { treturn _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor < P > ( snapshotManager ) 
private AppendingSystem system ( ) { treturn _prevayler . prevalentSystem ( ) ; } 
public void executeOn ( CountingSystem prevalentSystem , Date executionTime ) { if ( prevalentSystem . counter = = WHEN_TO_START_THROWING ) { tthrow new CountException ( ) ; } tprevalentSystem . counter + + ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer journalSerializer ) tthrows Exception { tPrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( suffix , journalSerializer ) ; tfactory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { treturn new Date ( + + time ) ; } } ) ; treturn factory . create ( ) ; } 
private void crashRecover ( boolean journalDiskSync ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
public void testTransientPrevaylerCreation ( ) { tPrevayler < Serializable > prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testSnapshotPrevaylerCreation ( ) throws Exception { tPrevayler < Serializable > prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testCheckpointPrevaylerCreation ( ) { tPrevayler < Serializable > prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; tassertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testQuery ( ) throws Exception { tLinkedList prevalentSystem = new LinkedList ( ) ; tPrevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; tInteger result = prevayler . execute ( query ( ) ) ; tassertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList , Integer > query ( ) { treturn new Query < LinkedList , Integer > ( ) { public Integer query ( LinkedList prevalentSystem , Date ignored ) throws Exception { 
public Integer query ( LinkedList prevalentSystem , Date ignored ) throws Exception { treturn new Integer ( prevalentSystem . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tLinkedList prevalentSystem = new LinkedList ( ) ; tPrevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; tObject result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList , String > transactionWithQuery ( ) { treturn new TransactionWithQuery < LinkedList , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList prevalentSystem , Date timestamp ) { tprevalentSystem . add ( " added element " ) ; treturn " abc " ; } 
private void testRollback ( Prevayler < AppendingSystem > prevayler ) throws Exception { t_prevayler = prevayler ; tappend ( " a " , " a " ) ; ttry { tappend ( " rollback " , " ignored " ) ; tfail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } tappend ( " b " , " ab " ) ; t_prevayler . close ( ) ; } 
private AppendingSystem system ( ) { return _prevayler . prevalentSystem ( ) ; } 
public void testSkipOldTransactions ( ) throws Exception { tPrevayler < StringBuffer > original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; tPrevayler < StringBuffer > recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws Exception { tPrevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . takeSnapshot ( ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ttry { tcreatePrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void testAllowOldJournalSuffix ( ) throws Exception { tPrevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; toriginal . execute ( new AppendTransaction ( " first " ) ) ; toriginal . execute ( new AppendTransaction ( " second " ) ) ; toriginal . execute ( new AppendTransaction ( " third " ) ) ; toriginal . takeSnapshot ( ) ; tassertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; toriginal . close ( ) ; tassertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; tPrevayler < StringBuffer > recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; tassertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
private void takeSnapshot ( Serializer snapshotSerializer ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; tprevayler . execute ( new AppendTransaction ( " first " ) ) ; tprevayler . execute ( new AppendTransaction ( " second " ) ) ; tprevayler . execute ( new AppendTransaction ( " third " ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer snapshotSerializer ) throws Exception { tPrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; treturn factory . create ( ) ; } 
private void startAndCrash ( Serializer journalSerializer ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; tassertEquals ( " the system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; tassertEquals ( " the system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; tassertEquals ( " the system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; tassertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer journalSerializer ) throws Exception { tPrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureJournalSerializer ( " journal " , journalSerializer ) ; treturn factory . create ( ) ; } 
public void testFailFastBaptismProblem ( ) { tappend ( " a " ) ; tAppendingSystem directReference = prevayler . prevalentSystem ( ) ; tprevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; tassertState ( " a " ) ; } 
private void assertState ( String expected ) { tString result = prevayler . prevalentSystem ( ) . value ( ) ; tassertEquals ( expected , result ) ; } 
public void executeOn ( AppendingSystem ignored , Date ignoredToo ) { t_illegalDirectReference . append ( " anything " ) ; } 
public void testNoExistingSnapshot ( ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tassertEquals ( " initial " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) throws Exception { tPrevayler < StringBuffer > first = createPrevayler ( suffix , serializer ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; tPrevayler < StringBuffer > second = createPrevayler ( suffix , serializer ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
public void testDetectExistingSnapshotFromUnknownSnapshotManager ( ) throws Exception { tPrevayler < StringBuffer > first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( first ) ; ttry { tcreatePrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; tappendTakeSnapshotAndClose ( prevayler ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; tcheckCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testUsePrimaryForWritingSnapshot ( ) throws Exception { tPrevayler < StringBuffer > first = createPrevaylerMulti ( ) ; tappendTakeSnapshotAndClose ( first ) ; tcheckSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; tPrevayler < StringBuffer > second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tassertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; tsecond . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) throws Exception { tPrevayler < StringBuffer > prevayler = createPrevaylerMulti ( ) ; tassertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . toString ( ) ) ; tprevayler . close ( ) ; } 
private Prevayler < StringBuffer > createPrevaylerMulti ( ) throws Exception { tPrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; tfactory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; treturn factory . create ( ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer serializer ) throws Exception { tPrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; tfactory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; tfactory . configurePrevalenceDirectory ( _testDirectory ) ; tfactory . configureSnapshotSerializer ( suffix , serializer ) ; treturn factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler < StringBuffer > prevayler ) throws Exception { tprevayler . execute ( new AppendTransaction ( " one " ) ) ; tprevayler . execute ( new AppendTransaction ( " two " ) ) ; tprevayler . takeSnapshot ( ) ; tprevayler . close ( ) ; } 
public void testTransactionWithQuery ( ) throws Exception { tLinkedList prevalentSystem = new LinkedList ( ) ; tPrevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; tString result = prevayler . execute ( transactionWithQuery ( ) ) ; tassertEquals ( " abc " , result ) ; tassertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tObject transaction ; if ( _transaction ! = null ) { ttransaction = _transaction ; } telse { ttransaction = deserialize ( journalSerializer ) ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; tChunk toChunk ( ) { tChunk chunk = new Chunk ( _serialized ) ; tchunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; treturn chunk ; } tstatic Capsule fromChunk ( Chunk chunk ) { tboolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { treturn new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { treturn new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public void execute ( Transaction < P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer , _deserializeThenExecuteMode ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer , _deserializeThenExecuteMode ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public void configureDeserializeThenExecute ( boolean deserializeThenExecuteMode ) { t_deserializeThenExecuteMode = deserializeThenExecuteMode ; } 
public Prevayler < P > create ( ) throws Exception { tGenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; treturn new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _deserializeThenExecuteMode ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem ) throws Exception { treturn createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) throws Exception { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( prevalenceBase ) ; treturn factory . create ( ) ; } 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { treturn createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static < P > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { tPrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; tfactory . configurePrevalentSystem ( newPrevalentSystem ) ; tfactory . configurePrevalenceDirectory ( snapshotDirectory ) ; tfactory . configureTransientMode ( true ) ; ttry { treturn factory . create ( ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeDeserializeThenExecute ) { tObject transaction ; if ( guaranteeDeserializeThenExecute | | _transaction = = null ) { ttransaction = deserialize ( journalSerializer ) ; } telse { ttransaction = _transaction ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
public void guaranteeDeserializeThenExecute ( ) { t_guaranteeDeserializeThenExecute = true ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeDeserializeThenExecute ) { tObject transaction ; if ( guaranteeDeserializeThenExecute | | _transaction = = null ) { ttransaction = deserialize ( journalSerializer ) ; } telse { ttransaction = _transaction ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public < R > R executeQuery ( Query < ? super P , R > sensitiveQuery , Clock clock ) throws Exception { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public void execute ( Transaction < ? super P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer , _deserializeThenExecuteMode ) ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) throws Exception { treturn _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer , _deserializeThenExecuteMode ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { ttry { treturn execute ( ( TransactionWithQuery < ? super P , R > ) sureTransactionWithQuery ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeTransactionDeepCopy ) { tObject transaction ; if ( guaranteeTransactionDeepCopy | | _transaction = = null ) { ttransaction = deserialize ( journalSerializer ) ; } telse { ttransaction = _transaction ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
public void guaranteeTransactionDeepCopy ( ) { t_guaranteeTransactionDeepCopy = true ; } 
public void execute ( Transaction < ? super P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer , _transactionDeepCopyMode ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > transactionWithQuery ) throws Exception { tTransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; tpublish ( capsule ) ; treturn capsule . result ( ) ; } 
public void configureTransactionDeepCopy ( boolean transactionDeepCopyMode ) { t_transactionDeepCopyMode = transactionDeepCopyMode ; } 
public Prevayler < P > create ( ) throws Exception { tGenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; tTransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; treturn new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
public void guaranteeTransactionDeepCopy ( ) { t_guaranteeTransactionDeepCopy = true ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; treturn new CentralPublisher ( clock ( ) , journal ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tObject transaction ; if ( _transaction ! = null ) { ttransaction = _transaction ; } telse { ttransaction = deserialize ( journalSerializer ) ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
private void initializePrevayler ( ) throws Exception { tPrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; tfactory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; tfactory . configurePrevalenceDirectory ( _journalDirectory ) ; tfactory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; tprevayler = factory . create ( ) ; } 
private void crashRecover ( boolean journalDiskSync ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { tTransactionGuide guide = receive ( capsule ) ; t_journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide receive ( Capsule capsule ) { tsynchronized ( _nextTurnMonitor ) { tTransactionTimestamp timestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { tTransactionGuide guide = guideFor ( capsule ) ; t_journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide guideFor ( Capsule capsule ) { tsynchronized ( _nextTurnMonitor ) { tTransactionTimestamp timestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { tObject transaction ; if ( _directTransaction ! = null ) { ttransaction = _directTransaction ; } telse { ttransaction = deserialize ( journalSerializer ) ; } tsynchronized ( prevalentSystem ) { tjustExecute ( transaction , prevalentSystem , executionTime ) ; 
public R executeAndQuery ( P prevalentObject , Date executionTime ) ; } 
public void testDiskSyncPerformance ( ) throws Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long true1 = doDiskSyncPerformanceRun ( true ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long true2 = doDiskSyncPerformanceRun ( true ) ; long bestTrue = Math . min ( true1 , true2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; todo: This fails when executing the test from within IntelliJ IDEA todo: but not when executed from command line. assertTrue(bestTrue + " should be worse than " + worstFalse + " (This test has been seen failing when executed from within IntelliJ IDEA, but should never fail when executed from command line using 'mvn install'.)", bestTrue > worstFalse); } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . nanoTime ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . nanoTime ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
public Person executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Person entity = new Person ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getPersons ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public Person executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getPersons ( ) . remove ( identity ) ; } 
public void test ( ) throws Exception { Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), "target/PrevalenceBase_" + System.currentTimeMillis()); try { 
public Boolean query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getPersons ( ) . isEmpty ( ) ; } 
public Person query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getPersons ( ) . get ( identity ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Person person = ( Person ) o ; if ( identity ! = null ? ! identity . equals ( person . identity ) : person . identity ! = null ) return false ; return true ; } 
public int hashCode ( ) { return identity ! = null ? identity . hashCode ( ) : 0 ; } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getPersons ( ) . get ( identity ) . setName ( name ) ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void testFailing ( ) throws Exception { this will fail as a new random UUID will be assigned to the entity within the transaction and will thus change every time journal is replayed! runTest(new NonDeterministicCreateEntityTransaction()); 
public void testPassing ( ) throws Exception { this will not fail as a new random UUID is passed down to and is serialized with the transaction and will thus be used every time the journal is replayed. runTest(new DeterministicCreateEntityTransaction(UUID.randomUUID().toString())); 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) throws Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { Entity entity = prevayler.execute(createEntityTransaction); 
public Entity query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . get ( identityOfEntityWhenInitiallyCreated ) ; } 
public Integer query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . size ( ) ; } 
public String query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . values ( ) . iterator ( ) . next ( ) . getIdentity ( ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Entity entity = ( Entity ) o ; if ( identity ! = null ? ! identity . equals ( entity . identity ) : entity . identity ! = null ) return false ; return true ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( UUID . randomUUID ( ) . toString ( ) ) ; This line of code is non deterministic since a new identity will be assigned to the object every time the journal is replayed at startup. This will severely mess with your system. prevalentSystem.getEntities().put(entity.getIdentity(), entity); return entity; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; entity . setCreated ( System . currentTimeMillis ( ) ) ; This line of code in bad as it will set #created to time of when journal is replayed rather than the initial execution time of the transaction. prevalentSystem.getEntities().put(entity.getIdentity(), entity); return entity; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; entity . setCreated ( executionTime . getTime ( ) ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void testFailing ( ) throws Exception { runTest ( new BadTimestampCreateEntityTransaction ( UUID . randomUUID ( ) . toString ( ) ) ) ; } 
public void testPassing ( ) throws Exception { runTest ( new CreateEntityTransaction ( UUID . randomUUID ( ) . toString ( ) ) ) ; } 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) throws Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final Entity entity = prevayler.execute(createEntityTransaction); 
public Long query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . get ( entity . getIdentity ( ) ) . getCreated ( ) ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) throws Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void testFailing ( ) throws Exception { this test will fail, and the reason is that the aggregate entity passed down to the transaction is a business object that will be serialized, i.e. the aggregate instance will become a deep clone of the business object rather than referencing the business object in the prevalent system. new AbstractTest() { @Override 
protected void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) { prevayler . execute ( new PrevalentInitiationProblemUpdateEntityAggregate ( firstEntity . getIdentity ( ) , secondEntity ) ) ; } 
public void testPassing ( ) throws Exception { this will not fail as we pass down the identities of the entities, look them up in the root and then reference to the instance we found in root. new AbstractTest() { @Override 
protected void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) { prevayler . execute ( new UpdateEntityAggregate ( firstEntity . getIdentity ( ) , secondEntity . getIdentity ( ) ) ) ; } 
protected void runTest ( ) throws Exception { Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), "target/PrevalenceBase_" + System.currentTimeMillis()); try { Entity firstEntity = prevayler.execute(new CreateEntityTransaction(UUID.randomUUID().toString())); 
protected abstract void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) ; } } 
public Entity query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . get ( identity ) ; } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( entityIdentity ) . setAggregate ( aggregate ) ; This line of code is bad since it will set #aggregate to be a deep clone of the business object 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( entityIdentity ) . setAggregate ( prevalentSystem . getEntities ( ) . get ( aggregateIdentity ) 
public void testFailing ( ) throws Exception { This will update Entity#text outside of a transaction, hence the change will NOT be written to the journal and is lost when closing Prevayler. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) throws Exception { entity . setText ( value ) ; } 
public void testPassing ( ) throws Exception { This will update Entity#text from within a transaction, i.e. the change will be written to the journal and thus available after closing and restarting Prevayler. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) throws Exception { prevayler . execute ( new UpdateEntityTextTransaction ( entity . getIdentity ( ) , value ) ) ; } 
public void testPassingDueToSnapshot ( ) throws Exception { This will update Entity#text outside of a transaction and then take a snapshot of the complete prevalent system. Hence changes will NOT be written the the journal but still available in the latest snapshot and thus still available after closing Prevayler. THIS IS NEITHER ENDORSED NOR RECOMMENDED USE OF PREVAYLER DON'T EVEN CONSIDER DOING THIS UNLESS YOU KNOW WHAT YOU ARE DOING, IT IS HERE SIMPLY TO DEMONSTRATE THAT IT'S POSSIBLE. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) throws Exception { entity . setText ( value ) ; prevayler . takeSnapshot ( ) ; } 
protected void runTest ( ) throws Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final String identity = UUID.randomUUID().toString(); 
public Entity query ( Root prevalentSystem , Date executionTime ) throws Exception { return prevalentSystem . getEntities ( ) . get ( identity ) ; } 
protected abstract void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) throws Exception ; } } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( identity ) . setText ( text ) ; } 
public void executeOn ( Root root , Date executionTime ) { root . setCreated ( executionTime . getTime ( ) ) ; 
public static void main ( String [ ] args ) throws Exception { Service . getInstance ( ) . open ( ) ; try { todo execute your application 
public void close ( ) throws Exception { prevayler . close ( ) ; } 
public Member member ( int number ) { treturn members . get ( number ) ; } 
public Member createMember ( String name ) { tint number = members . size ( ) ; tMember ret = new Member ( number , name ) ; tmembers . add ( ret ) ; treturn ret ; } 
public Member executeAndQuery ( Club club , Date executionTime ) { treturn club . createMember ( name ) ; } 
public void executeOn ( Club club , Date executionTime ) { tclub . member ( number ) . setName ( newName ) ; } 
public void testInitiationProblem ( ) throws Exception { tMember member = createMember ( " John " ) ; tprevayler . execute ( new NameChange ( member , " John S " ) ) ; tassertEquals ( " John S " , member . name ( ) ) ; tprevayler . execute ( new NameChangeWithProblem ( member , " John Smith " ) ) ; tassertEquals ( " John S " , member . name ( ) ) ; } 
private Member createMember ( String name ) throws Exception { treturn prevayler . execute ( new MemberCreation ( name ) ) ; } 
private static Prevayler < Club > initPrevayler ( ) { tString dataPath = " target/PrevalenceBase_ " + System . currentTimeMillis ( ) ; ttry { treturn PrevaylerFactory . createPrevayler ( new Club ( ) , dataPath ) ; 
public void executeOn ( Club club , Date executionTime ) { } 
public List < Transaction > transactionHistory ( ) { return transactionHistory ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public File takeSnapshot ( ) throws Exception ; public void close ( ) throws IOException ; } 
public R query ( P prevalentSystem , Date executionTime ) throws Exception ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) ; } 
public void executeOn ( P prevalentSystem , Date executionTime ) ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) throws Exception ; } 
private static boolean validToken ( String token ) { return TOKEN_PATTERN . matcher ( token ) . matches ( ) ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) throws IOException { stream . write ( Integer . toHexString ( chunk . getBytes ( ) . length ) . toUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String name = ( String ) entry . getKey ( ) ; String value = ( String ) entry . getValue ( ) ; if ( ! validToken ( name ) ) { throw new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { throw new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( chunk . getBytes ( ) ) ; stream . write ( CRLF ) ; } 
private static String readLine ( InputStream stream ) throws IOException { ByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; while ( true ) { int b = stream . read ( ) ; 
public static void wait ( Object object ) { try { object . wait ( ) ; 
public static void sleep ( long milliseconds ) { try { Thread . sleep ( milliseconds ) ; 
public static void unexpected ( Exception e ) { throw new RuntimeException ( " Unexpected Exception was thrown. " , e ) ; } 
public static void startDaemon ( Runnable runnable ) { Thread daemon = new Thread ( runnable ) ; daemon . setDaemon ( true ) ; daemon . start ( ) ; } 
public static Object deepCopy ( Object original ) { return deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) { try { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; 
public static Object deepCopyParallel ( Object original , Serializer serializer ) throws Exception { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver receiver = new Receiver ( inputStream , serializer ) ; try { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { try { _result = _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { _error = e ; throw e ; } try { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) throws Exception { try { join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Unexpected InterruptedException " , e ) ; } join() guarantees that all shared memory is synchronized between the two threads if (_error != null) throw new RuntimeException("Error during deserialization", _error); if (_exception != null) throw _exception; if (_result == null) throw new RuntimeException("Deep copy failed in an unknown way"); return _result; } 
public Chunk readChunk ( ) throws IOException { if ( _EOF ) throw new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { Do nothing. } catch (ObjectStreamException scx) { ignoreStreamCorruption(scx); } catch (UTFDataFormatException utfx) { ignoreStreamCorruption(utfx); } catch (RuntimeException rx) { Some stream corruptions cause runtime exceptions in JDK1.3.1! ignoreStreamCorruption(rx); } _fileStream.close(); _EOF = true; throw new EOFException(); } 
private void ignoreStreamCorruption ( Exception ex ) { String message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; _monitor . notify ( this . getClass ( ) , message , _file , ex ) ; } 
public void close ( ) throws IOException { _fileStream . close ( ) ; _EOF = true ; } 
public void sync ( Guided guide ) throws IOException { int thisWrite ; When a thread arrives here, all we care about at first is that it gets properly sequenced according to its turn. guide.startTurn(); try { thisWrite = writeObject(guide); } finally { guide.endTurn(); } Now, having ended the turn, the next thread is allowed to come in and try to write its object before we get to the sync. waitUntilSynced(thisWrite); } 
private int writeObject ( Guided guide ) throws IOException { synchronized ( _writeLock ) { if ( _closed ) { 
public void close ( ) throws IOException { synchronized ( _syncLock ) { synchronized ( _writeLock ) { 
private void internalClose ( ) { synchronized ( _writeLock ) { _closed = true ; 
public synchronized int fileSyncCount ( ) { synchronized ( _syncLock ) { return _fileSyncCount ; 
public boolean reallyClosed ( ) { synchronized ( _writeLock ) { return _closed ; 
public static File produceDirectory ( String directoryPath ) throws IOException { File directory = new File ( directoryPath ) ; produceDirectory ( directory ) ; return directory ; } 
public static void produceDirectory ( File directory ) throws IOException { if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) throw new IOException ( " Directory doesn't exist and could not be created: " + directory ) ; if ( ! directory . isDirectory ( ) ) throw new IOException ( " Path exists but is not a directory: " + directory ) ; } 
public void abortTurn ( String message , Throwable cause ) { _turn . abort ( message , cause ) ; } 
public abstract void writeTo ( OutputStream stream ) throws IOException ; } 
protected Class resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { return ( _loader ! = null ? Class . forName ( v . getName ( ) , false , _loader ) : super . resolveClass ( v ) ) ; } 
static public StopWatch start ( ) { return new StopWatch ( ) ; } 
public long millisEllapsed ( ) { return System . currentTimeMillis ( ) - t0 ; } 
public double secondsEllapsed ( ) { return millisEllapsed ( ) / 1000.0 ; } 
public static Turn first ( ) { return new Turn ( true ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { throw new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( this ) ; } if ( _allowed < 0 ) { throw new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } _allowed - - ; } 
private synchronized void allow ( ) { _allowed + + ; notifyAll ( ) ; } 
public void abort ( String message , Throwable cause ) { Turn turn = this ; while ( turn ! = null ) { turn = turn . die ( ) ; } throw new IllegalStateException ( message , cause ) ; } 
private synchronized Turn die ( ) { _allowed = Integer . MIN_VALUE ; notifyAll ( ) ; return _next ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
protected abstract void info ( Class clazz , String Message ) ; protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return true ; } } 
protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return true ; } } 
protected boolean isInfoEnabled ( Class clazz ) { return true ; } 
void notify ( Class clazz , String message ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , Exception ex ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class clazz , String message , File file , Exception exception ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , Exception ex ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , File file ) { } } 
protected void info ( Class clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected Object initialValue ( ) { try { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
public void writeObject ( OutputStream stream , Object object ) throws Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . ENCRYPT_MODE , _key ) ; CipherOutputStream encrypt = new CipherOutputStream ( stream , cipher ) ; _delegate . writeObject ( encrypt , object ) ; encrypt . close ( ) ; } 
public Object readObject ( InputStream stream ) throws Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . DECRYPT_MODE , _key ) ; CipherInputStream decrypt = new CipherInputStream ( stream , cipher ) ; return _delegate . readObject ( decrypt ) ; } 
private Cipher getCipher ( ) throws GeneralSecurityException { try { return ( Cipher ) _ciphers . get ( ) ; 
public void writeObject ( OutputStream stream , Object object ) throws Exception { GZIPOutputStream gzip = new GZIPOutputStream ( stream , _bufferSize ) ; _delegate . writeObject ( gzip , object ) ; gzip . close ( ) ; } 
public Object readObject ( InputStream stream ) throws Exception { GZIPInputStream gunzip = new GZIPInputStream ( stream , _bufferSize ) ; return _delegate . readObject ( gunzip ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { ObjectOutputStream objects = new ObjectOutputStream ( stream ) ; objects . writeObject ( object ) ; objects . close ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { ObjectInputStream objects = new ObjectInputStreamWithClassLoader ( stream , _loader ) ; Object object = objects . readObject ( ) ; objects . close ( ) ; return object ; } 
public void writeObject ( OutputStream stream , Object object ) throws Exception ; public Object readObject ( InputStream stream ) throws Exception ; } 
public Object readObject ( InputStream stream ) throws Exception ; } 
public Object deserialize ( Serializer journalSerializer ) { try { return journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object transaction ; if ( _directTransaction ! = null ) { transaction = _directTransaction ; } else { transaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( transaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; Chunk toChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule cleanCopy ( ) ; Chunk toChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
Chunk toChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } 
static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; 
public P prevalentSystem ( ) { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public void subscribeTo ( TransactionPublisher publisher ) throws IOException , ClassNotFoundException { long initialTransaction ; synchronized ( this ) { _ignoreRuntimeExceptions = true ; During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution. initialTransaction = _systemVersion + 1; } publisher.subscribe(this, initialTransaction); synchronized (this) { _ignoreRuntimeExceptions = false; 
public void receive ( TransactionTimestamp transactionTimestamp ) { Capsule capsule = transactionTimestamp . capsule ( ) ; long systemVersion = transactionTimestamp . systemVersion ( ) ; Date executionTime = transactionTimestamp . executionTime ( ) ; synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public < R > R executeQuery ( Query < ? super P , R > sensitiveQuery , Clock clock ) throws Exception { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public File takeSnapshot ( GenericSnapshotManager < P > snapshotManager ) throws Exception { synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard < P > deepCopy ( long systemVersion , Serializer snapshotSerializer ) throws Exception { synchronized ( this ) { while ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public void produceDirectory ( ) throws IOException { FileManager . produceDirectory ( _directory ) ; } 
public static void checkValidSnapshotSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { throw new IllegalArgumentException ( 
public static void checkValidJournalSuffix ( String suffix ) { if ( ! suffix . matches ( JOURNAL_SUFFIX_PATTERN ) ) { throw new IllegalArgumentException ( 
public File snapshotFile ( long version , String suffix ) { checkValidSnapshotSuffix ( suffix ) ; return file ( version , suffix ) ; } 
public File journalFile ( long transaction , String suffix ) { checkValidJournalSuffix ( suffix ) ; return file ( transaction , suffix ) ; } 
private File file ( long version , String suffix ) { if ( version < 0 ) { throw new IllegalArgumentException ( " Snapshot and journal version numbers must be non-negative: " + version ) ; } String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { return version ( file , SNAPSHOT_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { return version ( file , JOURNAL_FILENAME_PATTERN ) ; } 
private static long version ( File file , String filenamePattern ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( filenamePattern ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public File latestSnapshot ( ) throws IOException { File [ ] files = _directory . listFiles ( ) ; if ( files = = null ) throw new IOException ( " Error reading file list from directory " + _directory ) ; File latestSnapshot = null ; long latestVersion = - 1 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } 
public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public File createTempFile ( String prefix , String suffix ) throws IOException { return File . createTempFile ( prefix , suffix , _directory ) ; } 
public static void renameUnusedFile ( File journalFile ) { journalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public Set necessaryFiles ( ) throws IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { throw new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set neededFiles = new TreeSet ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
public P prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public void execute ( Transaction < ? super P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer , _transactionDeepCopyMode ) ) ; TODO Optimization: The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array, even if "_transactionDeepCopyMode" is "true" } 
private void publish ( Capsule capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) throws Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > transactionWithQuery ) throws Exception { TransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { try { return execute ( ( TransactionWithQuery < ? super P , R > ) sureTransactionWithQuery ) ; 
public File takeSnapshot ( ) throws Exception { return _guard . takeSnapshot ( _snapshotManager ) ; } 
public void close ( ) throws IOException { _publisher . close ( ) ; } 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction < P > ) transaction ) . executeOn ( ( P ) prevalentSystem , executionTime ) ; } 
public Capsule cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
public TransactionTimestamp timestamp ( ) { return _transactionTimestamp ; } 
public void checkSystemVersion ( long expectedSystemVersion ) { if ( _transactionTimestamp . systemVersion ( ) ! = expectedSystemVersion ) { throw new IllegalStateException ( " Attempted to process " + _transactionTimestamp . systemVersion ( ) + " when ready for " + expectedSystemVersion ) ; 
public Date executionTime ( ) { return _transactionTimestamp . executionTime ( ) ; } 
public void writeTo ( OutputStream stream ) throws IOException { Chunking . writeChunk ( stream , _transactionTimestamp . toChunk ( ) ) ; } 
public long systemVersion ( ) { return _systemVersion ; } 
public Date executionTime ( ) { return new Date ( _executionTime ) ; } 
public TransactionTimestamp cleanCopy ( ) { return new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public Chunk toChunk ( ) { Chunk chunk = _capsule . toChunk ( ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; return chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { Capsule capsule = Capsule . fromChunk ( chunk ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
protected void justExecute ( Object transaction , Object prevalentSystem , Date executionTime ) { try { _queryResult = ( ( TransactionWithQuery < P , R > ) transaction ) . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public R result ( ) throws Exception { if ( _queryException ! = null ) throw _queryException ; return _queryResult ; } 
public Capsule cleanCopy ( ) { return new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
public synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; _millis = newMillis ; _time = newTime ; } 
public synchronized Date time ( ) { update ( ) ; return super . time ( ) ; } 
private synchronized void update ( ) { long newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public synchronized Date time ( ) { return _activeClock . time ( ) ; } 
public synchronized void pause ( ) { advanceTo ( _realClock . time ( ) ) ; _activeClock = _brokenClock ; } 
public void advanceTo ( Date time ) { _brokenClock . advanceTo ( time ) ; } 
public synchronized void resume ( ) { _activeClock = _realClock ; } 
public Date realTime ( ) { return _realClock . time ( ) ; } 
public void append ( TransactionGuide guide ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; try { try { 
private boolean isOutputJournalStillValid ( ) { return _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private boolean isOutputJournalTooOld ( ) { return _journalAgeThresholdInMillis ! = 0 & & _journalAgeTimer . millisEllapsed ( ) > = _journalAgeThresholdInMillis ; 
private boolean isOutputJournalTooBig ( ) { return _journalSizeThresholdInBytes ! = 0 & & _outputJournal . file ( ) . length ( ) > = _journalSizeThresholdInBytes ; 
private DurableOutputStream createOutputJournal ( long transactionNumber , Guided guide ) { File file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file , _journalDiskSync ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { File initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) throws IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) throw new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) throw new IOException ( " Unable to find journal file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) throw new IllegalStateException ( ) ; return ; } _nextTransactionInitialized = true ; _nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
private void abort ( Exception exception , File journal , String action , Guided guide ) { guide . abortTurn ( " All transaction processing is now aborted. An IOException was thrown while " + action + " a .journal file. " , exception ) ; } 
public void close ( ) throws IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
public long nextTransaction ( ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; return _nextTransaction ; } 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = true ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) throw new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) throw new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp entry = ( TransactionTimestamp ) journal . get ( i ) ; 
public void close ( ) { } public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } } 
public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) { _subscribers . add ( subscriber ) ; } 
public synchronized void cancelSubscription ( TransactionSubscriber subscriber ) { _subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( TransactionTimestamp transactionTimestamp ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( transactionTimestamp ) ; } 
public void publish ( Capsule capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _pausableClock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { TransactionGuide guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide guideFor ( Capsule capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp timestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide guide ) { guide . startTurn ( ) ; try { _pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public void close ( ) throws IOException { _journal . close ( ) ; } 
public synchronized void receive ( TransactionTimestamp transactionTimestamp ) { _queue . add ( transactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( true ) { TransactionTimestamp notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( this ) ; } return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void waitToEmpty ( ) { synchronized ( _emptynessMonitor ) { while ( _queue . size ( ) ! = 0 ) Cool . wait ( _emptynessMonitor ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void cancelSubscription ( TransactionSubscriber subscriber ) ; public void close ( ) throws IOException ; } 
public void publish ( Capsule capsule ) ; public void close ( ) throws IOException ; } 
public Clock clock ( ) ; public void close ( ) throws IOException ; } 
public void receive ( TransactionTimestamp transactionTimestamp ) ; } 
public Serializer primarySerializer ( ) { return ( Serializer ) _strategies . get ( _primarySuffix ) ; } 
public PrevalentSystemGuard < P > recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public File writeSnapshot ( P prevalentSystem , long version ) throws Exception { File tempFile = _directory . createTempFile ( " snapshot " + version + " temp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , tempFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! tempFile . renameTo ( permanent ) ) throw new IOException ( " Temporary snapshot file generated: " + tempFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( P prevalentSystem , File snapshotFile ) throws Exception { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { primarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private File snapshotFile ( long version ) { return _directory . snapshotFile ( version , _primarySuffix ) ; } 
private P readSnapshot ( File snapshotFile ) throws Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; Serializer serializer = ( Serializer ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return ( P ) ( serializer . readObject ( in ) ) ; 
public File writeSnapshot ( P prevalentSystem , long version ) throws IOException { throw new IOException ( _snapshotAttemptErrorMessage ) ; } 
public static void main ( String [ ] args ) throws Exception { printMessage ( ) ; Prevayler < NumberKeeper > prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
static private void printMessage ( ) throws Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) . readLine ( ) ; } 
int lastNumber ( ) { return numbers . isEmpty ( ) ? 0 
public void executeOn ( NumberKeeper prevalentSystem , Date ignored ) { prevalentSystem . keep ( _numberToKeep ) ; } 
void start ( ) throws Exception { int largestPrime = 0 ; int primesFound = 0 ; int primeCandidate = _numberKeeper . lastNumber ( ) = = 0 ? 2 : _numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return true ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return true ; } 
public static void usage ( ) { System . out . println ( " Usage: Main <list|proj|task|snap> <parameters> " + " Parameters: " + " list: <xpath expression> " + " proj: <id> <name> " + " task: <id> <name> <start> <end> <projectId> " + " snap " + " Note: dates should be entered in a locale-sensitive format (your locale is " + System . getProperty ( " user.language " ) + " _ " + System . getProperty ( " user.country " ) + " ). " ) ; System . exit ( 0 ) ; } 
private static void list ( Prevayler prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( Prevayler prevayler , String id , String name ) throws Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( Prevayler prevayler , String id , String name , String start , String end , String projectId ) throws Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; . setId ( Integer . parseInt ( id ) ) ; . setName ( name ) ; . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( project ! = null ) { system . getProjects ( ) . add ( project ) ; 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( task ! = null & & projectId ! = Integer . MIN_VALUE ) { 
public String toString ( ) { return " Project Id: " + id + " n 
public String toString ( ) { return " n Task Id: " + id + " n 
static public void main ( String [ ] args ) { out ( " n============================================================= " ) ; out ( " Prevayler vs JDBC Scalability Tests " ) ; out ( " ============================================================= " ) ; out ( " If you have any trouble running the tests, just write to " ) ; out ( " prevayler-scalability@lists.sourceforge.net and we will be glad to help. " ) ; try { out ( " Reading the properties file: " + propertiesFile ( ) . getAbsolutePath ( ) ) ; 
static private void runPrevaylerQuery ( ) throws Exception { new QueryTestRun ( new PrevaylerQuerySubject ( ) , 
static private void runPrevaylerTransaction ( ) throws Exception { PrevaylerTransactionSubject subject = new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) ; new TransactionTestRun ( subject , numberOfObjects ( ) , prevaylerTransactionThreadsMin ( ) , prevaylerTransactionThreadsMax ( ) ) ; if ( isPrevaylerTransactionConsistencyChecked ( ) ) { out ( " Checking transaction log consistency. " ) ; 
static private void runJdbcQuery ( ) { new QueryTestRun ( new JDBCQuerySubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private void runJdbcTransaction ( ) { new TransactionTestRun ( new JDBCTransactionSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private File propertiesFile ( ) throws IOException { File result = new File ( " ScalabilityTest.properties " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; createPropertiesFile ( result ) ; } return result ; } 
static private void createPropertiesFile ( File file ) throws IOException { PrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; stream . println ( " ########################################################### " + 
static private int numberOfObjects ( ) { String property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; throw new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; } 
static private boolean isPrevaylerQueryChosen ( ) { return booleanProperty ( " RunPrevaylerQueryTest " ) ; } 
static private int prevaylerQueryThreadsMin ( ) { return intProperty ( " PrevaylerQueryThreadsMinimum " ) ; } 
static private int prevaylerQueryThreadsMax ( ) { return intProperty ( " PrevaylerQueryThreadsMaximum " ) ; } 
static private boolean isPrevaylerTransactionChosen ( ) { return booleanProperty ( " RunPrevaylerTransactionTest " ) ; } 
static private int prevaylerTransactionThreadsMin ( ) { return intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; } 
static private int prevaylerTransactionThreadsMax ( ) { return intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; } 
static private boolean isPrevaylerTransactionConsistencyChecked ( ) { return booleanProperty ( " TransactionTestCheckConsistency " ) ; } 
static private String prevaylerTransactionLogDirectory ( ) { String result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; return result ; } 
static private String prevaylerJournalSerializer ( ) { String result = properties . getProperty ( " PrevaylerJournalSerializer " ) ; if ( result = = null ) result = JavaSerializer . class . getName ( ) ; out ( " nPrevayler Journal Serializer: " + result ) ; return result ; } 
static private boolean isJdbcQueryChosen ( ) { return booleanProperty ( " RunJdbcQueryTest " ) ; } 
static private int jdbcQueryThreadsMin ( ) { return intProperty ( " JdbcQueryThreadsMinimum " ) ; } 
static private int jdbcQueryThreadsMax ( ) { return intProperty ( " JdbcQueryThreadsMaximum " ) ; } 
static private boolean isJdbcTransactionChosen ( ) { return booleanProperty ( " RunJdbcTransactionTest " ) ; } 
static private int jdbcTransactionThreadsMin ( ) { return intProperty ( " JdbcTransactionThreadsMinimum " ) ; } 
static private int jdbcTransactionThreadsMax ( ) { return intProperty ( " JdbcTransactionThreadsMaximum " ) ; } 
static private String jdbcDriverClassName ( ) { return property ( " JdbcDriverClassName " ) ; } 
static private String jdbcConnectionURL ( ) { return property ( " JdbcConnectionURL " ) ; } 
static private String jdbcUser ( ) { return property ( " JdbcUser " ) ; } 
static private String jdbcPassword ( ) { return property ( " JdbcPassword " ) ; } 
static private String property ( String name ) { String result = properties . getProperty ( name ) ; if ( result = = null ) throw new RuntimeException ( " Property " + name + " not found. " ) ; return result ; } 
static private int intProperty ( String name ) { try { return Integer . valueOf ( property ( name ) ) . intValue ( ) ; 
static private boolean booleanProperty ( String name ) { boolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return true ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; return false ; } 
protected void executeOperation ( Object connection , long operationSequence ) { ( ( QueryConnection ) connection ) . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
public int hashCode ( ) { return ( int ) ( id + name . hashCode ( ) 
static private String generateLargeString ( ) { char [ ] chars = new char [ 980 ] ; Arrays . fill ( chars , 'A' ) ; return new String ( chars ) ; } 
public boolean hasNext ( ) { return nextRecordId < numberOfRecords ; } 
public Record next ( ) { indicateProgress ( ) ; return new Record ( nextRecordId + + , _random ) ; } 
private void indicateProgress ( ) { if ( nextRecordId = = 0 ) { out ( " Creating " + numberOfRecords + " objects... " ) ; return ; } if ( nextRecordId % 100000 = = 0 ) out ( " " + nextRecordId + " ... " ) ; } 
protected void prepare ( ) { subject . replaceAllRecords ( numberOfObjects ) ; System . gc ( ) ; } 
private void performTest ( int minThreads , int maxThreads ) { int threads = minThreads ; while ( threads < = maxThreads ) { double operationsPerSecond = performRound ( threads ) ; 
private double performRound ( int threads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( threads ) ; sleep ( ) ; stopThreads ( ) ; double secondsEllapsed = stopWatch . secondsEllapsed ( ) ; double operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; subject . reportResourcesUsed ( System . out ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + toResultString ( operationsPerSecond , threads ) ) ; return operationsPerSecond ; } 
private void startThreads ( int threads ) { isRoundFinished = false ; int i = 1 ; while ( i < = threads ) { startThread ( lastOperation + i , threads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { try { Object connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { try { Object connection = acquireConnection ( ) ; 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = true ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String toResultString ( double operationsPerSecond , int threads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + threads + " threads) " ; } static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) 
private void stopThreads ( ) { isRoundFinished = true ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; 
static private String toResultString ( double operationsPerSecond , int threads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + threads + " threads) " ; } 
static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + 
static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) ; } 
protected String name ( ) { return " Transaction Test " ; } 
protected void prepare ( ) { super . prepare ( ) ; halfTheObjects = numberOfObjects / 2 ; } 
protected void executeOperation ( Object connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( TransactionConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
private long spreadId ( long id ) { return ( id / halfTheObjects ) * halfTheObjects Step function. + ((id * 16807) % halfTheObjects); 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 50000, 500000 and 5000000. This guarantees that all ids in the range will be covered. 
public List queryByName ( String name ) { ArrayList list = new ArrayList ( ) ; try { selectStatement . setString ( 1 , name ) ; ResultSet resultSet = selectStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { dealWithSQLException ( sqlex , " selecting record from " + table ( ) ) ; } return list ; } 
public Object createTestConnection ( ) { return new JDBCQueryConnection ( createConnection ( ) ) ; } 
protected void insert ( Record recordToInsert ) { try { insertStatement . setLong ( 1 , recordToInsert . getId ( ) ) ; 
protected PreparedStatement prepare ( String statement ) { try { return connection . prepareStatement ( statement ) ; 
void replaceAllRecords ( int records ) { RecordIterator newRecords = new RecordIterator ( records ) ; try { connection . createStatement ( ) . execute ( " delete from " + table ( ) ) ; } catch ( SQLException sqlx ) { dealWithSQLException ( sqlx , " deleting all records from " + table ( ) ) ; } while ( newRecords . hasNext ( ) ) { insert ( newRecords . next ( ) ) ; } try { connection . commit ( ) ; 
static protected void dealWithSQLException ( SQLException sqlx , String duringOperation ) { sqlx . printStackTrace ( ) ; throw new RuntimeException ( " SQLException " + duringOperation + " . " ) ; } 
public void replaceAllRecords ( int records ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( records ) ; } 
public void reportResourcesUsed ( PrintStream out ) { } } 
protected String table ( ) { return " TRANSACTION_TEST " ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { insert ( recordToInsert ) ; update ( recordToUpdate ) ; delete ( idToDelete ) ; try { connection . commit ( ) ; 
private void update ( Record recordToUpdate ) { try { updateStatement . setString ( 1 , recordToUpdate . getName ( ) ) ; 
private void delete ( long idToDelete ) { try { deleteStatement . setLong ( 1 , idToDelete ) ; 
public Object createTestConnection ( ) { return new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( ScalabilitySystem system , Date ignored ) { system . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
static public void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public boolean accept ( File file ) { return file . getName ( ) . endsWith ( " journal " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public List queryByName ( String name ) { return querySystem . queryByName ( name ) ; } 
public Object createTestConnection ( ) { return new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . prevalentSystem ( ) ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { try { 
public Object createTestConnection ( ) { return new PrevaylerTransactionConnection ( prevayler ) ; } 
public void reportResourcesUsed ( PrintStream out ) { int totalSize = 0 ; File [ ] files = new File ( _journalDirectory ) . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i + + ) { totalSize + = files [ i ] . length ( ) ; } out . println ( " Disk space used: " + totalSize ) ; } 
public boolean isConsistent ( ) throws Exception { int expectedResult = prevayler . prevalentSystem ( ) . hashCode ( ) ; initializePrevayler ( ) ; Will reload all transactions from the log files. return prevayler.prevalentSystem().hashCode() == expectedResult; } 
private void initializePrevayler ( ) throws Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; No snapshot is generated by the test. } 
public List queryByName ( String name ) { return ( List ) recordsByName . get ( name ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsByName . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; } makeReadOnly ( ) ; } 
private void put ( Record newRecord ) { List records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { records = new ArrayList ( ) ; recordsByName . put ( newRecord . getName ( ) , records ) ; } records . add ( newRecord ) ; } 
private void makeReadOnly ( ) { Iterator entries = recordsByName . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) entries . next ( ) ; 
public void executeOn ( TransactionSystem system , Date ignored ) { system . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { synchronized ( recordsById ) { put ( recordToInsert ) ; 
private Object put ( Record newRecord ) { Object key = new Long ( newRecord . getId ( ) ) ; return recordsById . put ( key , newRecord ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsById . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; 
public int hashCode ( ) { return recordsById . hashCode ( ) ; } 
public Member member ( int number ) { return members . get ( number ) ; } 
public Member createMember ( String name ) { int number = members . size ( ) ; Member ret = new Member ( number , name ) ; members . add ( ret ) ; return ret ; } 
public Member executeAndQuery ( Club club , Date executionTime ) { return club . createMember ( name ) ; } 
public void executeOn ( Club club , Date executionTime ) { club . member ( number ) . setName ( newName ) ; } 
public void testInitiationProblem ( ) throws Exception { Member member = createMember ( " John " ) ; prevayler . execute ( new NameChange ( member , " John S " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; prevayler . execute ( new NameChangeWithProblem ( member , " John Smith " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; The name change did not work because transactions are serialized and deserialized by Prevayler, producing a deep clone. The person object in the transaction is no longer the object we passed in but a clone! prevayler.close(); } 
private Member createMember ( String name ) throws Exception { return prevayler . execute ( new MemberCreation ( name ) ) ; } 
private static Prevayler < Club > initPrevayler ( ) { String dataPath = " target/PrevalenceBase_ " + System . currentTimeMillis ( ) ; try { return PrevaylerFactory . createPrevayler ( new Club ( ) , dataPath ) ; 
public void executeOn ( Club club , Date executionTime ) { The member field is now a deep clone because this transaction as serialized and deserialized by Prevayler. member.setName(newName); The clone is being modified instead of the actual member inside the club. } 
protected Object execute ( Object p_prevalentSystem , Date p_timestamp ) throws Exception { try { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
private Method getMethod ( ) throws Exception { return m_methodInfo . getMethod ( ) ; } 
public Method getMethod ( ) throws Exception { Class [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static Object create ( Class p_intf , Prevayler p_prevayler ) { return create ( p_intf , p_prevayler , 
public static Object create ( final Class p_intf , final Prevayler p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object invoke ( Object p_proxy , Method p_method , Object [ ] p_args ) throws Throwable { return p_determiner . determineTransactionType ( p_method ) . execute ( p_prevayler , p_method , p_args , p_hint ) ; 
public Object query ( Serializable p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Serializable p_prevalentSystem , Date p_timestamp ) { try { execute ( p_prevalentSystem , p_timestamp ) ; 
public Object executeAndQuery ( Serializable p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { } } ; public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public TransactionType determineTransactionType ( Method p_method ) { return TRANSACTION_WITH_QUERY ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? QUERY 
public String toString ( ) { return " TransactionType{ " + m_name + " } " ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return p_prevayler . execute ( new ProxyQuery ( p_method , p_args , p_hint ) ) ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery ( p_method , p_args , p_hint ) ) ; 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { p_prevayler . execute ( new ProxyTransaction ( p_method , p_args , p_hint ) ) ; return null ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) throws Exception { return null ; } 
private void addSite ( CampGuide guide , String name , int playground , int supermarket , int swimmingPool , int disco , int quiet , int beauty , int size , int price ) { CampSite site = new CampSite ( name ) ; site . setDistanceToPlayground ( playground ) ; site . setDistanceToSupermarket ( supermarket ) ; site . setDistanceToSwimmingPool ( swimmingPool ) ; site . setDistanceToDisco ( disco ) ; site . setQuietIndication ( quiet ) ; site . setBeautyIndication ( beauty ) ; site . setSize ( size ) ; site . setPriceIndication ( price ) ; site . setSomeDate ( date ) ; guide . addCampSite ( site ) ; System.out.println(site.getUpdated()); 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date timestamp ) ; } 
public Set getCampSites ( ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void addCampSite ( CampSite site ) { stampCampSite ( site ) ; campSites . put ( site . objectCode ( ) , site ) ; } 
public void updateCampSite ( CampSite site ) { if ( ! campSites . containsKey ( site . objectCode ( ) ) ) throw new RuntimeException ( " Can't update non-existent camp site! Try adding it first. " ) ; addCampSite ( site ) ; } 
public void removeCampSite ( CampSite site ) { campSites . remove ( site . objectCode ( ) ) ; } 
private void stampCampSite ( CampSite site ) { if ( this . transaction_time ! = 0 ) { site . setTimestamp ( this . transaction_time ) ; 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { ( ( CampGuide ) p_prevalentSystem ) . setTransactionTime ( p_timestamp ) ; } 
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " [CampSite: " ) ; buffer . append ( " serialVersionUID: " ) ; buffer . append ( serialVersionUID ) ; buffer . append ( " NOT_AVAILABLE: " ) ; buffer . append ( NOT_AVAILABLE ) ; buffer . append ( " ON_SITE: " ) ; buffer . append ( ON_SITE ) ; buffer . append ( " name: " ) ; buffer . append ( name ) ; buffer . append ( " playground: " ) ; buffer . append ( playground ) ; buffer . append ( " supermarket: " ) ; buffer . append ( supermarket ) ; buffer . append ( " swimmingPool: " ) ; buffer . append ( swimmingPool ) ; buffer . append ( " disco: " ) ; buffer . append ( disco ) ; buffer . append ( " quiet: " ) ; buffer . append ( quiet ) ; buffer . append ( " beauty: " ) ; buffer . append ( beauty ) ; buffer . append ( " size: " ) ; buffer . append ( size ) ; buffer . append ( " price: " ) ; buffer . append ( price ) ; buffer . append ( " created: " ) ; buffer . append ( created ) ; buffer . append ( " updated: " ) ; buffer . append ( updated ) ; buffer . append ( " guid: " ) ; buffer . append ( guid ) ; buffer . append ( " someDate: " ) ; buffer . append ( someDate ) ; buffer . append ( " ] " ) ; return buffer . toString ( ) ; } 
public int hashCode ( ) { int hashCode = 1 ; hashCode = 31 * hashCode + ( int ) ( + serialVersionUID ^ ( serialVersionUID > > > 32 ) ) ; hashCode = 31 * hashCode + NOT_AVAILABLE ; hashCode = 31 * hashCode + ON_SITE ; hashCode = 31 * hashCode + ( name = = null ? 0 : name . hashCode ( ) ) ; hashCode = 31 * hashCode + playground ; hashCode = 31 * hashCode + supermarket ; hashCode = 31 * hashCode + swimmingPool ; hashCode = 31 * hashCode + disco ; hashCode = 31 * hashCode + quiet ; hashCode = 31 * hashCode + beauty ; hashCode = 31 * hashCode + size ; hashCode = 31 * hashCode + price ; hashCode = 31 * hashCode + ( int ) ( + created ^ ( created > > > 32 ) ) ; hashCode = 31 * hashCode + ( int ) ( + updated ^ ( updated > > > 32 ) ) ; hashCode = 31 * hashCode + ( guid = = null ? 0 : guid . hashCode ( ) ) ; hashCode = 31 * hashCode + ( someDate = = null ? 0 : someDate . hashCode ( ) ) ; return hashCode ; } 
public void testSimple ( ) throws Exception { Method m = String . class . getMethod ( " length " , new Class [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public String toString ( ) { String raw = valueAfterMD5 . toUpperCase ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( raw . substring ( 0 , 8 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 8 , 12 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 12 , 16 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 16 , 20 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 20 ) ) ; return sb . toString ( ) ; } 
public static void main ( String args [ ] ) { for ( int i = 0 ; i < 100 ; i + + ) { RandomGUID myGUID = new RandomGUID ( ) ; 
public void storeSomething ( String p_data ) { m_data = p_data ; } 
public void oopsRuntime ( String p_data ) { m_data = p_data ; throw new RuntimeOops ( ) ; } 
public void oopsChecked ( String p_data ) throws CheckedOops { m_data = p_data ; throw new CheckedOops ( ) ; } 
protected void info ( Class clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
protected boolean isInfoEnabled ( Class clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class clazz ) { return Logger . getLogger ( clazz ) ; } 
private void log ( Class clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public String toString ( ) { Returns something like "00123 - John Smith" return numberString() + " - " + holder + " - " + balance; } 
public String numberString ( ) { return numberString ( number ) ; } 
static String numberString ( long number ) { return ( new java . text . DecimalFormat ( " 00000 " ) . format ( number ) ) ; } 
public void holder ( String holder ) throws InvalidHolder { verify ( holder ) ; this . holder = holder ; } 
public void deposit ( long amount , Date timestamp ) throws InvalidAmount { verify ( amount ) ; register ( amount , timestamp ) ; } 
public void withdraw ( long amount , Date timestamp ) throws InvalidAmount { verify ( amount ) ; register ( - amount , timestamp ) ; } 
private void register ( long amount , Date timestamp ) { balance + = amount ; transactionHistory . add ( new Transaction ( amount , timestamp ) ) ; } 
private void verify ( long amount ) throws InvalidAmount { if ( amount < = 0 ) throw new InvalidAmount ( " Amount must be greater than zero. " ) ; if ( amount > 10000 ) throw new InvalidAmount ( " Amount maximum (10000) exceeded. " ) ; } 
public List < Transaction > transactionHistory ( ) { return transactionHistory ; } 
private void verify ( String holder ) throws InvalidHolder { if ( holder = = null | | holder . equals ( " " ) ) throw new InvalidHolder ( ) ; } 
public String toString ( ) { return timestampString ( ) + " Amount: " + amount ; } 
private String timestampString ( ) { return new java . text . SimpleDateFormat ( " yyyy/MM/dd hh:mm:ss.SSS " ) . format ( timestamp ) ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; return account ; } 
public void deleteAccount ( long number ) throws AccountNotFound { Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; } 
public List accounts ( ) { List accounts = new ArrayList ( accountsByNumber . values ( ) ) ; Collections . sort ( accounts , new Comparator ( ) { public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } } ) ; return accounts ; } 
public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } 
public Account findAccount ( long number ) throws AccountNotFound { Account account = searchAccount ( number ) ; if ( account = = null ) throw new AccountNotFound ( number ) ; return account ; } 
public void transfer ( long sourceNumber , long destinationNumber , long amount , Date timestamp ) throws AccountNotFound , Account . InvalidAmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( amount , timestamp ) ; destination . deposit ( amount , timestamp ) ; } 
private Account searchAccount ( long number ) { return ( Account ) accountsByNumber . get ( new Long ( number ) ) ; } 
public String toString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . toString ( ) ; } 
public static void run ( ) throws Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . takeSnapshot ( ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) throws Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) throws Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) throws Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Account execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) throws Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } if ( account . balance ( ) < amount ) { throw account . new InvalidAmount ( " Can not withdraw more than the balance " ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Account execute ( MementoCollector collector ) throws Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { throw new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public Account executeAndQuery ( Bank prevalentSystem , Date timestamp ) throws Exception { mementos = new HashMap ( ) ; try { return transaction . execute ( this , prevalentSystem ) ; 
public Account execute ( MementoCollector collector , Bank prevalentSystem ) throws Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Bank prevalentSystem ) throws Exception ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void checkPrecondition ( ) throws Exception ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Account execute ( MementoCollector collector ) throws Exception ; } 
protected Object initialValue ( ) { return createXStream ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { OutputStreamWriter writer = _encoding = = null ? new OutputStreamWriter ( stream ) : new OutputStreamWriter ( stream , _encoding ) ; getXStream ( ) . toXML ( object , writer ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { return getXStream ( ) . fromXML ( _encoding = = null ? new InputStreamReader ( stream ) : new InputStreamReader ( stream , _encoding ) ) ; } 
protected XStream createXStream ( ) { return new XStream ( ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) throws Exception { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem ) throws Exception { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( snapshotDirectory ) ; factory . configureTransientMode ( true ) ; try { return factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( true ) ; try { return factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { return createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
private Clock clock ( ) { return _clock ! = null ? _clock : new MachineClock ( ) ; } 
public void configurePrevalentSystem ( P newPrevalentSystem ) { _prevalentSystem = newPrevalentSystem ; } 
public void configurePrevalenceDirectory ( String prevalenceDirectory ) { _prevalenceDirectory = prevalenceDirectory ; } 
public void configureTransactionDeepCopy ( boolean transactionDeepCopyMode ) { _transactionDeepCopyMode = transactionDeepCopyMode ; } 
public void configureClock ( Clock clock ) { _clock = clock ; } 
public void configureMonitor ( Monitor monitor ) { _monitor = monitor ; } 
public void configureTransientMode ( boolean transientMode ) { _transientMode = transientMode ; } 
public void configureReplicationClient ( String remoteServerIpAddress , int remoteServerPort ) { _remoteServerIpAddress = remoteServerIpAddress ; _remoteServerPort = remoteServerPort ; } 
public void configureReplicationServer ( int port ) { _serverPort = port ; } 
private void configureNullSnapshotManager ( NullSnapshotManager < P > snapshotManager ) { _nullSnapshotManager = snapshotManager ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { _journalSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { _journalAgeThreshold = ageInMilliseconds ; } 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public void configureJournalSerializer ( JavaSerializer serializer ) { configureJournalSerializer ( " journal " , serializer ) ; } 
public void configureJournalSerializer ( XStreamSerializer serializer ) { configureJournalSerializer ( " xstreamjournal " , serializer ) ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { throw new IllegalStateException ( " Read the javadoc to this method. " ) ; } _journalSerializer = serializer ; _journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( JavaSerializer serializer ) { configureSnapshotSerializer ( " snapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( XStreamSerializer serializer ) { configureSnapshotSerializer ( " xstreamsnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidSnapshotSuffix ( suffix ) ; _snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { _primarySnapshotSuffix = suffix ; 
public Prevayler < P > create ( ) throws Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
private String prevalenceDirectory ( ) { return _prevalenceDirectory ! = null ? _prevalenceDirectory : " Prevalence " ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) throw new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , journal ( ) ) ; } 
private Journal journal ( ) throws IOException { if ( _transientMode ) { return ( Journal ) new TransientJournal ( ) ; 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( ) ; } 
private String journalSuffix ( ) { return _journalSuffix ! = null ? _journalSuffix : " journal " ; } 
private GenericSnapshotManager < P > snapshotManager ( ) throws Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
private Monitor monitor ( ) { return _monitor ! = null ? _monitor : new SimpleMonitor ( System . err ) ; } 
Object getState ( ) ; void setState ( Object state ) ; Object receive ( Object message ) ; } 
void setState ( Object state ) ; Object receive ( Object message ) ; } 
public Object receive ( Object message ) { ClusteredTransaction transaction = ( ClusteredTransaction ) message ; return transaction . executeOn ( this ) ; } 
public P prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > transaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( transaction , clock ( ) . time ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) throws Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > transactionWithQuery ) throws Exception { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public void takeSnapshot ( ) throws IOException { prevayler . takeSnapshot ( ) ; } 
private void backupOldLocalTransactionLogs ( ) { System . out . println ( " Moving away old local transaction logs " ) ; File oldPrevalenceBaseFile = new File ( oldPrevalenceBase ) ; File [ ] files = oldPrevalenceBaseFile . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { files [ i ] . delete ( ) ; } } oldPrevalenceBaseFile . delete ( ) ; new File ( newPrevalenceBase ) . renameTo ( oldPrevalenceBaseFile ) ; } 
public void executeBroadcastedTransaction ( Transaction < P > transaction ) { prevayler . execute ( transaction ) ; } 
public Object executeOn ( ClusteredPrevayler < P > prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
public void viewAccepted ( View view ) { System . out . println ( " Members " + view . size ( ) ) ; } 
public void waitForConnection ( ) throws InterruptedException { broadcast ( " Node Connecting " ) ; } 
public void broadcast ( Serializable message ) { try { acquireClusterWideLock ( ) ; 
private void releaseClusterWideLock ( ) throws ChannelException { System . out . println ( " Releasing cluster lock " ) ; boolean lockReleased = false ; while ( ! lockReleased ) { try { distributedLockManager . unlock ( LOCK_ID , lockChannel . getLocalAddress ( ) . toString ( ) ) ; lockReleased = true ; } catch ( LockNotReleasedException e ) { } } System . out . println ( " Broadcast lock released " ) ; } 
private void acquireClusterWideLock ( ) throws ChannelException { System . out . println ( " Grabbing cluster lock " ) ; boolean lockAcquired = false ; while ( ! lockAcquired ) { try { 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( message . getObject ( ) ) ; } return null ; } 
public boolean isMaster ( ) { return getAddress ( ) . equals ( getMasterAddress ( ) ) ; } 
public void shutdown ( ) { channel . close ( ) ; lockChannel . close ( ) ; dispatcher . stop ( ) ; try { Thread . sleep ( 1000 ) ; 
protected void setUp ( ) throws Exception { super . setUp ( ) ; prevalenceBase = createTempDirectory ( ) ; factory = new PrevaylerFactory ( ) ; factory . configureTransientMode ( true ) ; factory . configurePrevalentSystem ( new ListSystem ( ) ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; } 
protected void tearDown ( ) throws Exception { super . tearDown ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; } 
public void testReplicationOfTransactions ( ) throws Exception { Transaction transaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; } 
public void testMultipleTransactionExecutions ( ) throws Exception { Transaction transaction = new AddToList ( " And once more " ) ; prevayler2 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; } 
public void testSync ( ) throws Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; } 
public void testRestartingClusterWillKeepData ( ) throws Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void testLocking ( ) throws Exception { Thread t1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread t2 = createAddToListThread ( prevayler1 , " 2 " ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( 20 , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private Thread createAddToListThread ( final Prevayler prevayler , final String string ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { for ( int i = 0 ; i < 10 ; i + + ) { prevayler . execute ( new AddToList ( string ) ) ; 
private void assertAllSystemsEqual ( ) { assertEquals ( prevayler1 . prevalentSystem ( ) , prevayler2 . prevalentSystem ( ) ) ; assertEquals ( prevayler1 . clock ( ) . time ( ) , prevayler2 . clock ( ) . time ( ) ) ; assertObjectsInSystemNotSame ( ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . text , ( ( ListSystem ) prevayler2 . prevalentSystem ( ) ) . text ) ; } 
private ClusteredPrevayler createPrevayler ( String name ) throws Exception { factory . configurePrevalentSystem ( new ListSystem ( ) ) ; return new ClusteredPrevayler ( factory , prevalenceBase ( " old " + name ) , prevalenceBase ( " new " + name ) ) ; } 
private String prevalenceBase ( String name ) { return new File ( prevalenceBase , name ) . getAbsolutePath ( ) ; } 
private File createTempDirectory ( ) throws IOException { File dir = File . createTempFile ( " prevalenceBase " , " .tmp " ) ; dir . delete ( ) ; dir . mkdirs ( ) ; return dir ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ListSystem list = ( ListSystem ) prevalentSystem ; list . add ( string , executionTime ) ; } 
public void add ( String string , Date executionTime ) { text . append ( string ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof ListSystem ) ) return false ; final ListSystem clockedList = ( ListSystem ) o ; if ( ! text . toString ( ) . equals ( clockedList . text . toString ( ) ) ) return false ; return true ; } 
public int hashCode ( ) { int result ; result = ( text ! = null ? text . hashCode ( ) : 0 ) ; return result ; } 
public String toString ( ) { return " ClockedList@ " + hashCode ( ) + " text: " + text ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; node = new Node ( ) ; receivedMessages = new ArrayList ( ) ; } 
protected void tearDown ( ) throws Exception { super . tearDown ( ) ; node . shutdown ( ) ; } 
public void testFindNodes ( ) throws Exception { assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( 2 , node . getNumberOfNodesInCluster ( ) ) ; node2 . shutdown ( ) ; assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; } 
public void testAssignMaster ( ) throws Exception { assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; assertFalse ( node . getAddress ( ) . equals ( node2 . getAddress ( ) ) ) ; node . shutdown ( ) ; assertEquals ( node2 . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void testMultipleNodes ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void testBroadCast ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; node2 . setListener ( createListAddListener ( ) ) ; String message = " Hello World " ; node . broadcast ( message ) ; assertEquals ( 1 , receivedMessages . size ( ) ) ; assertEquals ( message , receivedMessages . get ( 0 ) ) ; node2 . shutdown ( ) ; } 
public void testMultipleMessages ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( new Integer ( i ) ) ; } else { node2 . broadcast ( new Integer ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( new Integer ( i ) , receivedMessages . get ( i ) ) ; 
private ClusterListener createListAddListener ( ) { return new ClusterListener ( ) { public Object receive ( Object message ) { 
public Object receive ( Object message ) { receivedMessages . add ( message ) ; return null ; } 
private Node createNodeAndWait ( ) throws InterruptedException { Node node = new Node ( ) ; node . waitForConnection ( ) ; return node ; } 
public void testServerFirst ( ) throws Exception { serverCrashRecover ( 0 ) ; clientCrashRecover ( 0 ) ; serverAppend ( " a " , " a " ) ; serverAppend ( " b " , " ab " ) ; clientAppend ( " c " , " abc " ) ; clientAppend ( " d " , " abcd " ) ; serverAppend ( " e " , " abcde " ) ; clientCrashRecover ( 0 ) ; assertEquals ( " abcde " , clientValue ( ) ) ; clientAppend ( " f " , " abcdef " ) ; serverAppend ( " g " , " abcdefg " ) ; networkCrash ( ) ; threadToRestartNetworkAfterAWhile ( ) . start ( ) ; _server . execute ( new Appendix ( " h " ) ) ; clientAppend ( " i " , " abcdefghi " ) ; Blocks until the network is restarted. serverAppend("j", "abcdefghij"); clientAppend("k", "abcdefghijk"); } 
private Thread threadToRestartNetworkAfterAWhile ( ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { Cool . sleep ( 300 ) ; TODO NETWORK_MOCK.recover(); 
public void testClientFirst ( ) throws Exception { serverCrashRecover ( 1 ) ; clientCrashRecover ( 1 ) ; clientAppend ( " a " , " a " ) ; clientAppend ( " b " , " ab " ) ; serverAppend ( " c " , " abc " ) ; } 
private void serverAppend ( String appendix , String expectedResult ) { append ( _server , appendix , expectedResult ) ; } 
private void clientAppend ( String appendix , String expectedResult ) { append ( _client , appendix , expectedResult ) ; } 
private void append ( Prevayler < AppendingSystem > prevayler , String appendix , String expectedResult ) { prevayler . execute ( new Appendix ( appendix ) ) ; Cool . sleep ( 10 ) ; assertEquals ( expectedResult , serverValue ( ) ) ; assertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) throws Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " server " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configureTransientMode ( true ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) throws Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " client " ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; _client = factory . create ( ) ; } 
private PrevaylerFactory < AppendingSystem > factory ( String directory ) { PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; return factory ; } 
protected void tearDown ( ) throws Exception { _server = null ; _client = null ; super . tearDown ( ) ; } 
private String serverValue ( ) { return _server . prevalentSystem ( ) . value ( ) ; } 
private String clientValue ( ) { Cool . sleep ( 100 ) ; The client is notified asynchronously. return _client.prevalentSystem().value(); } 
ObjectSocket accept ( ) throws IOException ; void close ( ) throws IOException ; } 
public ObjectSocket accept ( ) throws IOException { return new ObjectSocketImpl ( _serverSocket . accept ( ) ) ; } 
public void close ( ) throws IOException { _serverSocket . close ( ) ; } 
void writeObject ( Object object ) throws IOException ; Object readObject ( ) throws IOException , ClassNotFoundException ; void close ( ) throws IOException ; } 
Object readObject ( ) throws IOException , ClassNotFoundException ; void close ( ) throws IOException ; } 
public void writeObject ( Object object ) throws IOException { TODO Consider eliminating the POBox and putting a buffer here. _outputStream.writeObject(object); _outputStream.reset(); _outputStream.flush(); 
public Object readObject ( ) throws IOException , ClassNotFoundException { return _inputStream . readObject ( ) ; } 
public void close ( ) throws IOException { _outputStream . close ( ) ; _inputStream . close ( ) ; _socket . close ( ) ; } 
public ObjectSocket openSocket ( String serverIpAddress , int serverPort ) throws IOException { return new ObjectSocketImpl ( serverIpAddress , serverPort ) ; } 
public ObjectServerSocket openObjectServerSocket ( int port ) throws IOException { return new ObjectServerSocketImpl ( port ) ; } 
private void startListening ( ) { Thread listener = new Thread ( ) { public void run ( ) { try { while ( true ) receiveTransactionFromServer ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; listener . setDaemon ( true ) ; listener . start ( ) ; } 
public void run ( ) { try { while ( true ) receiveTransactionFromServer ( ) ; 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber subscriber ) { throw new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
private void throwEventualErrors ( ) throws RuntimeException , Error { try { if ( _myTransactionRuntimeException ! = null ) throw _myTransactionRuntimeException ; 
private static void wait ( Object monitor ) { try { monitor . wait ( ) ; 
private void notifyMyTransactionMonitor ( ) { synchronized ( _myCapsuleMonitor ) { _myCapsuleMonitor . notify ( ) ; 
public void close ( ) throws IOException { _server . close ( ) ; } 
public void run ( ) { try { long initialTransaction = ( ( Long ) _remote . readObject ( ) ) . longValue ( ) ; 
private void startSendingClockTicks ( ) { _clockTickSender . setDaemon ( true ) ; _clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { return new Thread ( ) { TODO Consider using TimerTask. public void run() { 
public void run ( ) { try { while ( true ) { 
void publishRemoteTransaction ( ) throws IOException , ClassNotFoundException { _remoteCapsule = ( Capsule ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp tt ) { if ( tt . capsule ( ) = = _remoteCapsule ) tt = new TransactionTimestamp ( null , tt . systemVersion ( ) , tt . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
private synchronized void close ( ) { _clockTickSender . interrupt ( ) ; this . interrupt ( ) ; _publisher . cancelSubscription ( this ) ; } 
private void send ( Object object ) { synchronized ( _remote ) { try { 
public void run ( ) { try { while ( true ) new ServerConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public void snapshotStarted ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the exception was: " + exception ) ; } 
public void snapshotError ( Prevayler prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void run ( ) { snapshotStarted ( ) ; try { prevayler . takeSnapshot ( ) ; } catch ( Exception e ) { This is likely a temporary problem, so keep running. snapshotException(e); } catch (Error e) { snapshotError(e); This is likely fatal, so reassert. See Java documentation for classes Error and Throwable. throw e; } snapshotTaken(); } 
public boolean cancel ( ) { snapshotShutdown ( ) ; return super . cancel ( ) ; } 
public void removeListener ( Listener listener ) { listenerList . remove ( listener ) ; } 
public void addListener ( Listener listener ) { listenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
public synchronized Object registerCallback ( String message , IModelCallback callback ) { CallbackNode c = new CallbackNode ( message , callback ) ; callbacks . addLast ( c ) ; return c ; } 
public synchronized void unregisterCallback ( Object callback ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( ( CallbackNode ) i . next ( ) = = ( CallbackNode ) callback ) { i . remove ( ) ; } } ( ( CallbackNode ) callback ) . freed = true ; } 
public void checkCallbackFreed ( Object callback ) throws CallbackAlreadyFreedException { CallbackNode c = ( CallbackNode ) callback ; if ( c . freed ) throw new CallbackAlreadyFreedException ( " Callback has already been freed: " + c . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = ( CallbackNode ) i . next ( ) ; 
public abstract void happened ( Long connectionID , String name , Object obj ) ; } 
public static void connect ( String host , int port ) throws IOException , ClassNotFoundException { conn = new Remote ( host , port ) ; } 
public synchronized Serializable exec ( Transaction transaction ) throws Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( transaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException thrownException = ( ThrownException ) result ; throw thrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction transaction , String errorMsg ) { Serializable result = null ; try { result = exec ( transaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public Object registerCallback ( String message , IModelCallback callback ) throws IOException { Tell the client to be prepared to receive the message Object result; result = callbackThread.registerCallback(message, callback); If it's not a wildcard callback, tell the server it's okay to send the message if (!message.equals("")) { out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new RegisterCallback(message)); } return result; } 
public void unregisterCallback ( Object callback ) throws IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public void close ( ) throws Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( new Disconnect ( ) ) ; socket . close ( ) ; } 
public abstract Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception ; public void executeOn ( Object prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( Object prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; 
private void init ( ) { Init the default property values Properties props = getDefaultProps(); Create root app properties object properties = new Properties(props); Try to load it from disk propertyFile = System.getProperty("user.dir") + "/" + propertyFile; try { properties.load(new FileInputStream(propertyFile)); } catch (IOException e) { try { props.store(new FileOutputStream(propertyFile), getConfigHeader()); properties.load(new FileInputStream(propertyFile)); } catch (IOException e2) { Log.error(e, "Could not save default properties"); } } configFile = this; } 
public abstract String getConfigHeader ( ) ; public void store ( ) throws IOException { properties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } } 
public void store ( ) throws IOException { properties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } 
public static void error ( Exception e , String message ) { System . err . println ( message ) ; e . printStackTrace ( ) ; } 
public static void message ( String message ) { System . out . println ( message ) ; } 
public static void debug ( String message ) { System . out . println ( message ) ; } 
protected abstract Object lookup ( Object prevalentSystem ) throws Exception ; public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
protected Object lookup ( Object prevalentSystem ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; return todoList . get ( id ) ; } 
public static synchronized void printList ( Object todoList ) { TodoList theList = ( TodoList ) todoList ; Todo [ ] items = theList . toArray ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { System . out . println ( items [ i ] . getId ( ) + " " + items [ i ] . getDesc ( ) ) ; } System . out . println ( ) ; } 
private static char toUpperCase ( char ch ) { String result = " " ; result + = ch ; result = result . toUpperCase ( ) ; return result . toCharArray ( ) [ 0 ] ; } 
private static boolean invalidResponse ( char response ) { boolean responseIsInvalid = true ; for ( int i = 0 ; i < responses . length & & responseIsInvalid ; i + + ) { if ( responses [ i ] = = response ) { responseIsInvalid = false ; } } return responseIsInvalid ; } 
public static void printMenu ( ) { System . out . println ( " L)ist todos; A)dd todo; E)xit " ) ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; try { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public static void mainMenu ( ) { try { Print the current todo list 
public static void main ( String [ ] args ) { Config . propertyFile = " Todo.ini " ; new ClientConfig ( ) ; Get the config options int basePort = Integer.parseInt(Config.properties.getProperty("BasePort")); String remoteHost = Config.properties.getProperty("RemoteHost"); Connect to the server try { Remote.connect(remoteHost, basePort); } catch (Exception e) { Log.error(e, "Error connecting to remote host: " + remoteHost); return; } Listen to interesting events try { Remote.conn.registerCallback("ListChanged", new IModelCallback() { public void happened(Long connectionID, String name, Object obj) { We'll just re-print the list when a change happens. Note that this will happen in a background thread. System.out.println(); Main.printList(obj); Main.printMenu(); } }); } catch (Exception e) { Log.error(e, "Unable to register callback"); return; } Run the main loop mainMenu(); Close the connection try { Remote.conn.close(); 
public void happened ( Long connectionID , String name , Object obj ) { We'll just re-print the list when a change happens. Note that this will happen in a background thread. System.out.println(); Main.printList(obj); Main.printMenu(); } 
public Todo [ ] toArray ( ) { Todo [ ] results = new Todo [ todoList . size ( ) ] ; int i = 0 ; Iterator iter = todoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = ( Todo ) todoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo todo = new Todo ( id ) ; todoList . put ( new Integer ( id ) , todo ) ; return todo ; } 
public Todo get ( int id ) { return ( Todo ) todoList . get ( new Integer ( id ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { TodoList todoList = ( TodoList ) prevalentSystem ; Todo todo = todoList . newTodo ( ) ; todo . setDesc ( desc ) ; Notify interested clients that the list just changed Note that much more complex notification schemes can be devised than this. Notification.submit(senderID, "ListChanged", todoList); return todo; } 
public Object executeAndQuery ( Object prevalentSystem , Date timestamp ) throws Exception { return prevalentSystem ; } 
private void handleRequests ( ) throws Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(new Long(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory factory = new PrevaylerFactory(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
private static void runNotificationServer ( ) { new Notification ( port + 1 ) . start ( ) ; } 
private static void runCommandServer ( ) throws Exception { ServerSocket ss = null ; boolean listening = true ; Listen dynamically try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread(prevayler, ss.accept()).start(); ss.close(); } 
public static void main ( String [ ] args ) { try { new ServerConfig ( ) ; 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } else { callbacks = new HashMap(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = true ; Listen for a client connection and dispatch a thread to handle it try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open notification server port"); System.exit(-1); } while (listening) { try { NotificationThread client = new NotificationThread(ss.accept()); clients.addLast(client); client.start(); } catch (Exception e) { Log.error(e, "Notification server error"); } } try { ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . addLast ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
private synchronized void checkWait ( ) throws Exception { if ( messageQueue . isEmpty ( ) ) wait ( ) ; 
private void handleNotifications ( ) throws Exception { This loop is broken when thread.interrupt() is called by the Reaper while (true) { checkWait(); 
public void run ( ) { try { handleNotifications ( ) ; 
public static long registerCommandThread ( ) { long id = getNextID ( ) ; return id ; } 
public static void registerNotificationThread ( Long id , NotificationThread thread ) { notificationThreads . put ( id , thread ) ; } 
public static void reap ( Long id ) { NotificationThread thread = ( NotificationThread ) notificationThreads . get ( id ) ; if ( thread ! = null ) { if ( thread . isAlive ( ) ) thread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
public void run ( ) { super . run ( ) ; Log . message ( " A system snapshot will be taken every 24h... " ) ; try { while ( true ) { 
protected void setUp ( ) throws Exception { File tempFile = new File ( " Test " + System . currentTimeMillis ( ) + counter + + ) ; assertTrue ( " Unable to create directory " + tempFile , tempFile . mkdirs ( ) ) ; _testDirectory = tempFile . getAbsolutePath ( ) ; } 
protected void tearDown ( ) throws Exception { delete ( _testDirectory ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { delete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
static public void delete ( String fileName ) { delete ( new File ( fileName ) ) ; } 
static public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; assertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected String journalContents ( final String suffix ) throws IOException { File journal = findJournal ( suffix ) ; FileInputStream file = new FileInputStream ( journal ) ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int ; byte [ ] b = new byte [ 1024 ] ; while ( ( = file . read ( b ) ) ! = - 1 ) { buffer . write ( b , 0 , ) ; } file . close ( ) ; return buffer . toString ( " ISO-8859-1 " ) ; } 
protected File findJournal ( final String suffix ) { File [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } } ) ; assertEquals ( 1 , files . length ) ; return files [ 0 ] ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } 
public void executeOn ( StringBuffer prevalentSystem , Date executionTime ) { prevalentSystem . append ( toAdd ) ; } 
public String executeAndQuery ( StringBuffer prevalentSystem , Date executionTime ) throws Exception { prevalentSystem . append ( toAdd ) ; return prevalentSystem . toString ( ) ; } 
void append ( String appendix ) { value = value + appendix ; if ( appendix . equals ( " rollback " ) ) throw new RuntimeException ( " Testing Rollback " ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date ignored ) { prevalentSystem . append ( appendix ) ; } 
public static synchronized void armBomb ( int timeToDetonation ) { _timeToDetonation = timeToDetonation ; } 
private static synchronized void triggerBomb ( ) { if ( _timeToDetonation > 0 & & - - _timeToDetonation = = 0 ) { throw new Error ( " BOOM! " ) ; 
public void executeOn ( AppendingSystem prevalentSystem , Date executionTime ) { triggerBomb ( ) ; super . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Object prevalentSystem , Date executionTime ) throws Exception { return null ; } 
public static Object get ( Object root , String path ) throws Exception { int dot = path . indexOf ( '.' ) ; String first = dot = = - 1 ? path : path . substring ( 0 , dot ) ; String rest = dot = = - 1 ? null : path . substring ( dot + 1 ) ; Field field = root . getClass ( ) . getDeclaredField ( first ) ; field . setAccessible ( true ) ; Object value = field . get ( root ) ; return rest = = null ? value : get ( value , rest ) ; } 
public void testChunkedOutput ( ) throws IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( bytes , new Chunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ) ; assertEquals ( " F r nabcdefghijklmno r " , bytes . toString ( " US-ASCII " ) ) ; } 
public void testChunkedInput ( ) throws IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; assertEquals ( " abcdefghijklmno " , new String ( Chunking . readChunk ( bytes ) . getBytes ( ) , " US-ASCII " ) ) ; } 
public void testMultipleChunks ( ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( output , new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " bar " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " zot " . getBytes ( " US-ASCII " ) ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . toByteArray ( ) ) ; assertEquals ( " foo " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " bar " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " zot " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertNull ( Chunking . readChunk ( input ) ) ; } 
public void testMalformed ( ) throws IOException { checkMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; checkMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; checkMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; checkMalformed ( " F r nabcdefghijklmno r " , " Unexpected end of stream in chunk trailer " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Unexpected end of stream in chunk trailer " ) ; } 
private void checkMalformed ( String input , String message ) throws IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; try { Chunking . readChunk ( bytes ) ; 
public void testParameters ( ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunk chunkOut = new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ; chunkOut . setParameter ( " one " , " uno " ) ; chunkOut . setParameter ( " two " , " dos " ) ; Chunking . writeChunk ( output , chunkOut ) ; assertEquals ( " 3;one=uno;two=dos r nfoo r " , output . toString ( " US-ASCII " ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . toByteArray ( ) ) ; Chunk chunkIn = Chunking . readChunk ( input ) ; assertEquals ( " foo " , new String ( chunkIn . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " uno " , chunkIn . getParameter ( " one " ) ) ; assertEquals ( " dos " , chunkIn . getParameter ( " two " ) ) ; } 
public void testNormal ( ) { Object original = " foo " ; Object copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void testParallel ( ) throws Exception { Object original = " foo " ; Object copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void testParallelPathological ( ) throws Exception { Object original = new Byte ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) throws Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } public Object readObject(InputStream stream) throws Exception { return new Byte((byte) stream.read()); } }); assertEquals(original, copy); assertNotSame(original, copy); } 
public void writeObject ( OutputStream stream , Object object ) throws Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } 
public Object readObject ( InputStream stream ) throws Exception { return new Byte ( ( byte ) stream . read ( ) ) ; } 
public void testSingleThreaded ( ) throws Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void testMultiThreaded ( ) throws Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void writeTo ( OutputStream stream ) throws IOException { stream . write ( _value . getBytes ( ) ) ; stream . write ( '' ) ; } 
public void run ( ) { try { _out . sync ( new DummyGuide ( _id + " .first " , _firstTurn ) ) ; 
public void testCheckpoint ( ) throws Exception { crashRecover ( ) ; There is nothing to recover at first. A new system will be created. crashRecover(); append("a", "a"); append("b", "ab"); verify("ab"); crashRecover(); verify(""); append("a", "a"); append("b", "ab"); snapshot(); snapshot(); verify("ab"); crashRecover(); snapshot(); append("c", "abc"); snapshot(); append("d", "abcd"); append("e", "abcde"); verify("abcde"); crashRecover(); append("d", "abcd"); verify("abcd"); 
private void crashRecover ( ) throws Exception { out ( " CrashRecovery. " ) ; _prevayler = PrevaylerFactory . createCheckpointPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private void snapshot ( ) throws Exception { out ( " Snapshot. " ) ; _prevayler . takeSnapshot ( ) ; } 
private void append ( String appendix , String expectedResult ) throws Exception { out ( " Appending " + appendix ) ; _prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { return _prevayler . prevalentSystem ( ) ; } 
private static void out ( Object obj ) { if ( false ) System . out . println ( obj ) ; Change this line to see what the test is doing. } 
public void testConfigureJournalSerializationStrategy ( ) throws Exception { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void testBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; try { factory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void testTryToConfigureTwo ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; try { factory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void testJavaJournal ( ) throws Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 69;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 first r " + " 6A;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 007 second r " + " 69;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 third r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void testXStreamJournal ( ) throws Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 7A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> first</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> second</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> third</toAdd> n</org.prevayler.implementation.AppendTransaction> r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void testCompressedJournal ( ) throws Exception { GZIPSerializer serializer = new GZIPSerializer ( new MySerializer ( ) ) ; startAndCrash ( " journal " , serializer ) ; assertEquals ( " 1A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 037 213 b 0 0 0 0 0 0 0SH 313,*. 001 0 337 275= 342 006 0 0 0 r " + " 1B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 037 213 b 0 0 0 0 0 0 0S(NM 316 317K 001 0(V fU 007 0 0 0 r " + " 1A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 037 213 b 0 0 0 0 0 0 0S( 311 310,J 001 0 354s~T 006 0 0 0 r " , journalContents ( " journal " ) ) ; recover ( " journal " , serializer ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer journalSerializer ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( suffix , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long time = 1000000 ; public Date time ( ) { return new Date ( + + time ) ; } } ) ; return factory . create ( ) ; } 
public Date time ( ) { return new Date ( + + time ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; AppendTransaction transaction = ( AppendTransaction ) object ; writer . write ( transaction . toAdd ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; return new AppendTransaction ( reader . readLine ( ) ) ; } 
public void tearDown ( ) throws Exception { if ( _prevayler ! = null ) { _prevayler . close ( ) ; } super . tearDown ( ) ; } 
public void testPersistenceWithDiskSync ( ) throws Exception { doTestPersistence ( true ) ; } 
public void estPersistenceWithoutDiskSync ( ) throws Exception { doTestPersistence ( false ) ; } 
public void testDiskSyncPerformance ( ) throws Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long true1 = doDiskSyncPerformanceRun ( true ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long true2 = doDiskSyncPerformanceRun ( true ) ; long bestTrue = Math . min ( true1 , true2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; todo: This fails when executing the test from within IntelliJ IDEA todo: but not when executed from command line. assertTrue(bestTrue + " should be worse than " + worstFalse + " (This test has been seen failing when executed from within IntelliJ IDEA, but should never fail when executed from command line using 'mvn install'.)", bestTrue > worstFalse); } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . nanoTime ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . nanoTime ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
public void testSnapshotVersion0 ( ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. append("a", "a"); append("b", "ab"); append("c", "abc"); verify("abc"); File snapshot = snapshot("0000000000000000003.snapshot"); _prevayler.close(); assertTrue(snapshot.renameTo(new File(prevalenceBase(), "0000000000000000000.snapshot"))); assertTrue(new File(_prevalenceBase, "0000000000000000001.journal").delete()); crashRecover(); verify("abc"); append("d", "abcd"); snapshot("0000000000000000001.snapshot"); } 
public void testJournalPanic ( ) throws Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; try { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } try { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted, probably due to an earlier IOException. " , aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
private void sneakilyCloseUnderlyingJournalStream ( ) throws Exception { FileOutputStream journalStream = ( FileOutputStream ) Sneaky . get ( _prevayler , " _publisher._journal._outputJournal._fileOutputStream " ) ; journalStream . close ( ) ; } 
private void checkNecessaryFiles ( PrevaylerDirectory directory , String [ ] filenames ) throws IOException { assertEquals ( setOfFiles ( filenames ) , directory . necessaryFiles ( ) ) ; } 
private void crashRecover ( ) throws Exception { crashRecover ( true ) ; } 
private void crashRecover ( boolean journalDiskSync ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
private File snapshot ( String expectedSnapshotFilename ) throws Exception { out ( " Snapshot. " ) ; File snapshotFile = _prevayler . takeSnapshot ( ) ; assertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; return snapshotFile ; } 
private String prevalenceBase ( ) { return _prevalenceBase ; } 
private void newPrevalenceBase ( ) throws Exception { _prevalenceBase = _testDirectory + File . separator + System . currentTimeMillis ( ) ; } 
public void testTransientPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testSnapshotPrevaylerCreation ( ) throws Exception { Prevayler < Serializable > prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testCheckpointPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void testQuery ( ) throws Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Integer result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList , Integer > query ( ) { return new Query < LinkedList , Integer > ( ) { public Integer query ( LinkedList prevalentSystem , Date ignored ) throws Exception { 
public Integer query ( LinkedList prevalentSystem , Date ignored ) throws Exception { return new Integer ( prevalentSystem . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; String result = prevayler . execute ( transactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList , String > transactionWithQuery ( ) { return new TransactionWithQuery < LinkedList , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList prevalentSystem , Date timestamp ) { prevalentSystem . add ( " added element " ) ; return " abc " ; } 
public void testSkipOldTransactions ( ) throws Exception { Prevayler < StringBuffer > original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . takeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " MyJournal " , new MySerializer ( true ) ) ; assertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public void testDetectOldJournalSuffix ( ) throws Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . takeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; 
public void testAllowOldJournalSuffix ( ) throws Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . takeSnapshot ( ) ; assertEquals ( " the system first second third " , original . prevalentSystem ( ) . toString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " NewJournal " , new MySerializer ( true ) ) ; assertEquals ( " the system first second third " , recovered . prevalentSystem ( ) . toString ( ) ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String toAdd = reader . readLine ( ) ; if ( afterSnapshot ) { assertFalse ( " Shouldn't have recovered transaction from before snapshot " , toAdd . equals ( " first " ) | | toAdd . equals ( " second " ) ) ; } return new AppendTransaction ( toAdd ) ; } 
public void testConfigureSnapshotSerializer ( ) throws Exception { Serializer serializer = new MySerializer ( ) ; takeSnapshot ( serializer ) ; assertEquals ( " Yes, this is MySerializationStrategy! " + " the system first second third " , snapshotContents ( ) ) ; recover ( serializer ) ; } 
public void testBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; try { factory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public void testXStreamSnapshot ( ) throws Exception { Serializer serializer = new XStreamSerializer ( ) ; takeSnapshot ( serializer ) ; recover ( serializer ) ; } 
private void takeSnapshot ( Serializer snapshotSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; prevayler . takeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer snapshotSerializer ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; return factory . create ( ) ; } 
private String snapshotContents ( ) throws IOException { File snapshot = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } } ) [ 0 ] ; FileReader file = new FileReader ( snapshot ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . toString ( ) ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } 
public void writeObject ( OutputStream stream , Object object ) throws IOException { StringBuffer system = ( StringBuffer ) object ; Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; writer . write ( " Yes, this is MySerializationStrategy! " ) ; writer . write ( system . toString ( ) ) ; writer . write ( '' ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) throws IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { String contents = reader . readLine ( ) ; 
public void testJavaJournal ( ) throws Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void testXStreamJournal ( ) throws Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " the system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; assertEquals ( " the system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; assertEquals ( " the system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " the system first second third " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer journalSerializer ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " the system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " journal " , journalSerializer ) ; return factory . create ( ) ; } 
protected void setUp ( ) throws Exception { super . setUp ( ) ; prevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void testTransactionExecution ( ) { assertState ( " " ) ; append ( " a " ) ; assertState ( " a " ) ; append ( " b " ) ; append ( " c " ) ; assertState ( " abc " ) ; } 
public void testSnapshotAttempt ( ) throws Exception { try { prevayler . takeSnapshot ( ) ; 
public void testFailFastBaptismProblem ( ) { append ( " a " ) ; AppendingSystem directReference = prevayler . prevalentSystem ( ) ; prevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; assertState ( " a " ) ; } 
protected void tearDown ( ) throws Exception { prevayler = null ; super . tearDown ( ) ; } 
private void assertState ( String expected ) { String result = prevayler . prevalentSystem ( ) . value ( ) ; assertEquals ( expected , result ) ; } 
private void append ( String appendix ) { prevayler . execute ( new Appendix ( appendix ) ) ; } 
public void executeOn ( AppendingSystem ignored , Date ignoredToo ) { _illegalDirectReference . append ( " anything " ) ; } 
public void testNoExistingSnapshot ( ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . toString ( ) ) ; } 
public void testRoundtripJava ( ) throws Exception { checkRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void testRoundtripXStream ( ) throws Exception { checkRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) throws Exception { Prevayler < StringBuffer > first = createPrevayler ( suffix , serializer ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( suffix , serializer ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; second . close ( ) ; } 
public void testDetectExistingSnapshotFromUnknownSnapshotManager ( ) throws Exception { Prevayler < StringBuffer > first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void testMultipleSerializationStrategiesFromXStream ( ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testMultipleSerializationStrategiesFromJava ( ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void testUsePrimaryForWritingSnapshot ( ) throws Exception { Prevayler < StringBuffer > first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . toString ( ) ) ; second . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevaylerMulti ( ) ; assertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . toString ( ) ) ; prevayler . close ( ) ; } 
private Prevayler < StringBuffer > createPrevaylerMulti ( ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; factory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; return factory . create ( ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer serializer ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( suffix , serializer ) ; return factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler < StringBuffer > prevayler ) throws Exception { prevayler . execute ( new AppendTransaction ( " one " ) ) ; prevayler . execute ( new AppendTransaction ( " two " ) ) ; prevayler . takeSnapshot ( ) ; prevayler . close ( ) ; } 
private void checkSnapshotAndDeleteJournal ( String snapshot , String journal ) { assertTrue ( new File ( _testDirectory , snapshot ) . exists ( ) ) ; deleteFromTestDirectory ( journal ) ; } 
private void preallocate ( ) throws IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } while ( need > 0 ) { ByteBuffer buf = ByteBuffer . allocateDirect ( _preallocateLength ) ; int written = _fileChannel . write ( buf , size ) ; assert written = = _preallocateLength : " incomplete write " ; need - = written ; } _fileDescriptor . sync ( ) ; } 
private DurableOutputStream createOutputJournal ( long transactionNumber , Guided guide ) { File file = _directory . journalFile ( transactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file , _journalDiskSync , _journalSizeThresholdInBytes ) ; 
public void executeOn ( Map < String , Serializable > prevalentSystem , Date executionTime ) { Map < String , Serializable > map = castTo ( prevalentSystem ) ; map . put ( key , value ) ; } 
public String toString ( ) { return " ( " + key + " , " + value + " ) " ; } 
public Serializable query ( Map < String , Serializable > prevalentSystem , Date executionTime ) throws Exception { Map < String , Serializable > map = castTo ( prevalentSystem ) ; return map . get ( key ) ; } 
public static void setUpBeforeClass ( ) throws Exception { deletePrevaylerDirectory ( ) ; prevayler = createPrevayler ( true ) ; Map < String , Serializable > map = castTo ( prevayler . prevalentSystem ( ) ) ; assertEquals ( " Prevayler size " , 0 , map . size ( ) ) ; LOG . info ( " Created empty prevayler " ) ; } 
public static void tearDownAfterClass ( ) throws Exception { if ( prevayler ! = null ) prevayler . close ( ) ; deletePrevaylerDirectory(); LOG.info("Closed prevayler"); } 
static Prevayler < Map < String , Serializable > > createPrevayler ( boolean journalDiskSync ) throws Exception { PrevaylerFactory < Map < String , Serializable > > factory = new PrevaylerFactory < Map < String , Serializable > > ( ) ; factory . configurePrevalentSystem ( new ConcurrentHashMap < String , Serializable > ( ) ) ; factory . configurePrevalenceDirectory ( TEST_DATA_DIRECTORY ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; factory . configureTransactionDeepCopy ( false ) ; return factory . create ( ) ; } 
public void testSingleThreaded ( ) throws Exception { AddOp bench = new AddOp ( Arrays . asList ( new String [ ] { " -op " , " add " , " -threads " , " 1 " , " -numTx " , " 100 " } ) ) ; bench . benchmark ( ) ; bench . printResults ( ) ; verify for(int i = 0; i < NUM_TRANSACTIONS; i++) { String key = "key_" + 0 + "_" + i; 
public void testMultithreaded ( ) throws Exception { AddOp bench = new AddOp ( Arrays . asList ( new String [ ] { " -op " , " add " , " -threads " , " 128 " , " -numTx " , " 5000 " } ) ) ; bench . benchmark ( ) ; bench . printResults ( ) ; } 
private static void deletePrevaylerDirectory ( ) { File prevaylerDir = new File ( TEST_DATA_DIRECTORY ) ; if ( prevaylerDir . exists ( ) ) assertTrue ( " Cannot delete prevayler directory " , 
private static < T > T castTo ( Object obj ) { @SuppressWarnings ( " unchecked " ) T typed = ( T ) obj ; return typed ; } 
public static boolean delete ( File file , boolean recursive ) { if ( ! file . exists ( ) ) { return true ; } if ( ! recursive | | ! file . isDirectory ( ) ) return file . delete ( ) ; String [ ] list = file . list ( ) ; for ( int i = 0 ; i < list . length ; i + + ) { if ( ! delete ( new File ( file , list [ i ] ) , true ) ) return false ; } return file . delete ( ) ; } 
public static long now ( ) { return System.nanoTime(); return System.currentTimeMillis(); } 
public void run ( ) { localNumOpsExecuted = 0 ; localCumulativeTime = 0 ; arg1 = statsOp . getExecutionArgument ( daemonId ) ; try { benchmarkOne ( ) ; 
public String toString ( ) { return " StatsDaemon- " + daemonId ; } 
void benchmarkOne ( ) throws IOException { for ( int idx = 0 ; idx < opsPerThread ; idx + + ) { long stat = statsOp . executeOp ( daemonId , idx , arg1 ) ; 
boolean isInProgress ( ) { return localNumOpsExecuted < opsPerThread ; } 
void benchmark ( ) throws IOException { daemons = new ArrayList < StatsDaemon > ( ) ; long start = 0 ; try { numOpsExecuted = 0 ; 
private boolean isInProgress ( ) { for ( StatsDaemon d : daemons ) if ( d . isInProgress ( ) ) return true ; return false ; } 
void incrementStats ( int ops , long time ) { numOpsExecuted + = ops ; cumulativeTime + = time ; } 
protected boolean verifyOpArgument ( List < String > args ) { if ( args . size ( ) < 2 | | ! args . get ( 0 ) . startsWith ( " -op " ) ) printUsage ( ) ; process common options int llIndex = args.indexOf("-logLevel"); if(llIndex >= 0) { if(args.size() <= llIndex + 1) printUsage(); logLevel = Level.parse(args.get(llIndex+1)); args.remove(llIndex+1); args.remove(llIndex); } String type = args.get(1); if(OP_ALL_NAME.equals(type)) { type = getOpName(); return true; } if(!getOpName().equals(type)) printUsage(); return false; } 
void printStats ( ) { LOG . info ( " --- " + getOpName ( ) + " stats --- " ) ; LOG . info ( " # operations: " + getNumOpsExecuted ( ) ) ; LOG . info ( " Elapsed Time: " + getElapsedTime ( ) ) ; LOG . info ( " Ops per sec: " + getOpsPerSecond ( ) ) ; LOG . info ( " Average Time: " + getAverageTime ( ) ) ; } 
void parseArguments ( List < String > args ) { boolean ignoreUnrelatedOptions = verifyOpArgument ( args ) ; for ( int i = 2 ; i < args . size ( ) ; i + + ) { parse command line if(args.get(i).equals("-numTx")) { 
void generateInputs ( int [ ] opsPerThread ) throws IOException { assert opsPerThread . length = = numThreads : " Error opsPerThread.length " ; LOG . info ( " Generate " + numOpsRequired + " inputs for " + getOpName ( ) ) ; transactions = new AddTx [ numThreads ] [ ] ; for ( int idx = 0 ; idx < numThreads ; idx + + ) { int threadOps = opsPerThread [ idx ] ; 
long executeOp ( int daemonId , int inputIdx , String clientName ) throws IOException { long start = now ( ) ; prevayler . execute ( transactions [ daemonId ] [ inputIdx ] ) ; long end = now ( ) ; return end - start ; } 
void printResults ( ) { LOG . info ( " --- " + getOpName ( ) + " inputs --- " ) ; LOG . info ( " numTx = " + numOpsRequired ) ; LOG . info ( " nrThreads = " + numThreads ) ; printStats ( ) ; } 
static void printUsage ( ) { System . err . println ( " Usage: " + PrevaylerBenchmark . class . getSimpleName ( ) + " " + OperationStatsBase . OP_ALL_USAGE + " | " + AddOp . OP_ADD_USAGE ) ; System . exit ( - 1 ) ; } 
public static void main ( String [ ] args ) throws Exception { setUpBeforeClass ( ) ; AddOp bench = null ; try { bench = new AddOp ( Arrays . asList ( args ) ) ; 
private void preallocate ( ) throws IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } while ( need > 0 ) { ByteBuffer buf = ByteBuffer . allocateDirect ( _preallocateLength ) ; int written = _fileChannel . write ( buf , size ) ; assert written = = _preallocateLength : " incomplete write " ; need - = written ; } _fileChannel . force ( true ) ; } 
private void preallocate ( ) throws IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } else if ( need < _preallocateLength ) { need = _preallocateLength ; } _fileChannel . write ( ByteBuffer . allocate ( 1 ) , size + need - 1 ) ; _fileChannel . force ( true ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) ; public void close ( ) throws IOException ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) throws IOException { stream . write ( Integer . toHexString ( chunk . getBytes ( ) . length ) . toUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator < Map . Entry < String , String > > iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , String > entry = iterator . next ( ) ; String name = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( ! validToken ( name ) ) { throw new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { throw new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( chunk . getBytes ( ) ) ; stream . write ( CRLF ) ; } 
public static < P > P deepCopyParallel ( P original , Serializer serializer ) throws Exception { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver < P > receiver = new Receiver < P > ( inputStream , serializer ) ; try { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { try { _result = ( P ) _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { _error = e ; throw e ; } try { Some serializers may write more than they actually need to deserialize the object, but if 
public P getResult ( ) throws Exception { try { join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Unexpected InterruptedException " , e ) ; } join() guarantees that all shared memory is synchronized between the two threads if (_error != null) throw new RuntimeException("Error during deserialization", _error); if (_exception != null) throw _exception; if (_result == null) throw new RuntimeException("Deep copy failed in an unknown way"); return _result; } 
private void preallocate ( ) throws IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } else if ( need < _preallocateLength ) { need = _preallocateLength ; } _fileChannel . write ( ByteBuffer . allocate ( 1 ) , size + need - 1 ) ; _fileChannel . force ( true ) ; } 
void sync ( ) throws IOException { synchronized ( _syncLock ) { _fileChannel . force ( false ) ; 
public void sync ( ) throws IOException { durableOutputStream . sync ( ) ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { return true ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { return false ; } 
public void sync ( ) throws IOException { setSyncFileDescriptorAfterNextTransactionBatch ( false ) ; super . sync ( ) ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { synchronized ( this ) { try { 
public boolean isSyncFileDescriptorAfterNextTransactionBatch ( ) { return syncFileDescriptorAfterNextTransactionBatch ; } 
protected Class < ? > resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { if ( _loader = = null ) return super . resolveClass ( v ) ; try { return Class . forName ( v . getName ( ) , false , _loader ) ; 
public void notify ( Class < ? > clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class < ? > clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class < ? > clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class < ? > clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
protected abstract void info ( Class < ? > clazz , String Message ) ; protected abstract void error ( Class < ? > clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class < ? > clazz ) { return true ; } } 
protected abstract void error ( Class < ? > clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class < ? > clazz ) { return true ; } } 
protected boolean isInfoEnabled ( Class < ? > clazz ) { return true ; } 
void notify ( Class < ? > clazz , String message ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , Exception ex ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , File file ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class < ? > clazz , String message , File file , Exception exception ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message , Exception ex ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message , File file ) { } } 
protected void info ( Class < ? > clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class < ? > clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected Cipher initialValue ( ) { try { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
private Cipher getCipher ( ) throws GeneralSecurityException { try { return _ciphers . get ( ) ; 
public T deserialize ( Serializer journalSerializer ) { try { return ( T ) journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public void executeOn ( P prevalentSystem , Date executionTime , Serializer journalSerializer ) { T transaction ; if ( _directTransaction ! = null ) { transaction = _directTransaction ; } else { transaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( transaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( T transaction , P prevalentSystem , Date executionTime ) ; public abstract Capsule < P , T > cleanCopy ( ) ; Chunk toChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule < P > ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule < P , T > cleanCopy ( ) ; Chunk toChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( this instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule < P > ( chunk . getBytes ( ) ) ; } } } 
static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; 
public void subscribeTo ( TransactionPublisher < P > publisher ) throws IOException , ClassNotFoundException { long initialTransaction ; synchronized ( this ) { _ignoreRuntimeExceptions = true ; During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution. initialTransaction = _systemVersion + 1; } publisher.subscribe(this, initialTransaction); synchronized (this) { _ignoreRuntimeExceptions = false; 
public void receive ( TransactionTimestamp < P > transactionTimestamp ) { Capsule < ? super P , ? extends TransactionBase > capsule = transactionTimestamp . capsule ( ) ; long systemVersion = transactionTimestamp . systemVersion ( ) ; Date executionTime = transactionTimestamp . executionTime ( ) ; synchronized ( this ) { if ( _prevalentSystem = = null ) { 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator < File > ( ) { public int compare ( File f1 , File f2 ) { return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public int compare ( File f1 , File f2 ) { return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public Set < File > necessaryFiles ( ) throws IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { throw new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set < File > neededFiles = new TreeSet < File > ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
public void execute ( Transaction < P > transaction ) { publish ( new TransactionCapsule < P > ( transaction , _journalSerializer , _transactionDeepCopyMode ) ) ; TODO Optimization: The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array, even if "_transactionDeepCopyMode" is "true" } 
private void publish ( Capsule < P , ? extends TransactionBase > capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) throws Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > transactionWithQuery ) throws Exception { TransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( transactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { try { return execute ( ( TransactionWithQuery < P , R > ) sureTransactionWithQuery ) ; 
protected void justExecute ( Transaction < P > transaction , P prevalentSystem , Date executionTime ) { transaction . executeOn ( prevalentSystem , executionTime ) ; } 
public Capsule < P , Transaction < P > > cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
public TransactionTimestamp < P > timestamp ( ) { return _transactionTimestamp ; } 
public Capsule < ? super P , ? extends TransactionBase > capsule ( ) { return _capsule ; } 
public TransactionTimestamp < P > cleanCopy ( ) { return new TransactionTimestamp < P > ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public static < P > TransactionTimestamp < P > fromChunk ( Chunk chunk ) { Capsule < P , ? extends TransactionBase > capsule = Capsule . fromChunk ( chunk ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp < P > ( capsule , systemVersion , executionTime ) ; } 
protected void justExecute ( TransactionWithQuery < ? super P , R > transaction , P prevalentSystem , Date executionTime ) { try { _queryResult = transaction . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public Capsule < P , TransactionWithQuery < ? super P , R > > cleanCopy ( ) { return new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
public void append ( TransactionGuide < P > guide ) ; public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide < P > guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; try { try { 
public void update ( TransactionSubscriber < P > subscriber , long initialTransactionWanted ) throws IOException , ClassNotFoundException { File initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void append ( TransactionGuide < P > guide ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = true ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) throw new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) throw new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp < P > entry = journal . get ( i ) ; 
public synchronized void addSubscriber ( TransactionSubscriber < P > subscriber ) { _subscribers . add ( subscriber ) ; } 
public synchronized void cancelSubscription ( TransactionSubscriber < P > subscriber ) { _subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( TransactionTimestamp < P > transactionTimestamp ) { Iterator < TransactionSubscriber < P > > i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) i . next ( ) . receive ( transactionTimestamp ) ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _pausableClock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule < ? super P , ? extends TransactionBase > capsule ) { TransactionGuide < P > guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide < P > guideFor ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp < P > timestamp = new TransactionTimestamp < P > ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide < P > guide ) { guide . startTurn ( ) ; try { _pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public synchronized void receive ( TransactionTimestamp < P > transactionTimestamp ) { _queue . add ( transactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( true ) { TransactionTimestamp < P > notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp < P > waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( this ) ; } return _queue . removeFirst ( ) ; } 
public void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; } 
public void cancelSubscription ( TransactionSubscriber < P > subscriber ) ; public void close ( ) throws IOException ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) ; public void close ( ) throws IOException ; } 
public void receive ( TransactionTimestamp < P > transactionTimestamp ) ; } 
public Serializer primarySerializer ( ) { return _strategies . get ( _primarySuffix ) ; } 
private P readSnapshot ( File snapshotFile ) throws Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; Serializer serializer = _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return ( P ) ( serializer . readObject ( in ) ) ; 
private static void list ( Prevayler < ProjectManagementSystem > prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator < ? > i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( Prevayler < ProjectManagementSystem > prevayler , String id , String name ) throws Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( Prevayler < ProjectManagementSystem > prevayler , String id , String name , String start , String end , String projectId ) throws Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; . setId ( Integer . parseInt ( id ) ) ; . setName ( name ) ; . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
static private void createPropertiesFile ( File file ) throws IOException { PrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; try { stream . println ( 
protected void executeOperation ( QueryConnection connection , long operationSequence ) { connection . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { try { C connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { try { C connection = acquireConnection ( ) ; 
protected abstract void executeOperation ( C connection , long operation ) ; private C acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = true ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String toResultString ( double operationsPerSecond , int threads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + threads + " threads) " ; } static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
private C acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
protected void executeOperation ( TransactionConnection connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; connection . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public List < Record > queryByName ( String name ) { List < Record > list = new ArrayList < Record > ( ) ; try { selectStatement . setString ( 1 , name ) ; ResultSet resultSet = selectStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { dealWithSQLException ( sqlex , " selecting record from " + table ( ) ) ; } return list ; } 
public QueryConnection createTestConnection ( ) { return new JDBCQueryConnection ( createConnection ( ) ) ; } 
public TransactionConnection createTestConnection ( ) { return new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( S system , Date ignored ) { system . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
public List < Record > queryByName ( String name ) { return querySystem . queryByName ( name ) ; } 
public QueryConnection createTestConnection ( ) { return new PrevaylerQueryConnection ( prevayler . prevalentSystem ( ) ) ; } 
public TransactionConnection createTestConnection ( ) { return new PrevaylerTransactionConnection ( prevayler ) ; } 
public List < Record > queryByName ( String name ) { return recordsByName . get ( name ) ; } 
private void put ( Record newRecord ) { List < Record > records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { records = new ArrayList < Record > ( ) ; recordsByName . put ( newRecord . getName ( ) , records ) ; } records . add ( newRecord ) ; } 
private void makeReadOnly ( ) { Iterator < Map . Entry < String , List < Record > > > entries = recordsByName . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry < String , List < Record > > entry = entries . next ( ) ; 
private Object put ( Record newRecord ) { Long key = new Long ( newRecord . getId ( ) ) ; return recordsById . put ( key , newRecord ) ; } 
public Method getMethod ( ) throws Exception { Class < ? > [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static < P > P create ( Class < P > p_intf , Prevayler < ? extends P > p_prevayler ) { return create ( p_intf , p_prevayler , 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return ( P ) Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date timestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date timestamp ) ; } 
public Set < CampSite > getCampSites ( ) ; public void setTransactionTime ( Date timestamp ) ; } 
protected void info ( Class < ? > clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class < ? > clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
protected boolean isInfoEnabled ( Class < ? > clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class < ? > clazz ) { return Logger . getLogger ( clazz ) ; } 
private void log ( Class < ? > clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public void deleteAccount ( long number ) throws AccountNotFound { @SuppressWarnings ( " unused " ) Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; } 
public List < Account > accounts ( ) { List < Account > accounts = new ArrayList < Account > ( accountsByNumber . values ( ) ) ; Collections . sort ( accounts , new Comparator < Account > ( ) { public int compare ( Account acc1 , Account acc2 ) { return acc1 . number ( ) < acc2 . number ( ) ? - 1 : 1 ; } } ) ; return accounts ; } 
public int compare ( Account acc1 , Account acc2 ) { return acc1 . number ( ) < acc2 . number ( ) ? - 1 : 1 ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( new Long ( number ) ) ; } 
public String toString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator < Account > iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . toString ( ) ; } 
public Account executeAndQuery ( Bank prevalentSystem , Date timestamp ) throws Exception { mementos = new HashMap < Memento , Memento > ( ) ; try { return transaction . execute ( this , prevalentSystem ) ; 
protected XStream initialValue ( ) { return createXStream ( ) ; } 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( true ) ; try { return factory . create ( ) ; 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ? JournalDiskSyncStrategy . ALWAYS : JournalDiskSyncStrategy . NEVER ; } 
public void configureJournalDiskSync ( JournalDiskSyncStrategy journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public Prevayler < P > create ( ) throws Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher < P > publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener < P > ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) throw new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher < P > publisher ( GenericSnapshotManager < P > snapshotManager ) throws IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher < P > ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher < P > ( clock ( ) , journal ( ) ) ; } 
private Journal < P > journal ( ) throws IOException { if ( _transientMode ) { return new TransientJournal < P > ( ) ; 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( ) ; } 
private GenericSnapshotManager < P > snapshotManager ( ) throws Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; 
public synchronized void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber < P > subscriber ) { throw new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { if ( _subscriber = = null ) throw new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
void publishRemoteTransaction ( ) throws IOException , ClassNotFoundException { _remoteCapsule = ( Capsule < ? super P , ? extends TransactionBase > ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp < P > tt ) { if ( tt . capsule ( ) = = _remoteCapsule ) tt = new TransactionTimestamp < P > ( null , tt . systemVersion ( ) , tt . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
public void run ( ) { try { while ( true ) new ServerConnection < P > ( _publisher , _serverSocket . accept ( ) ) ; 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
public Todo [ ] toArray ( ) { Todo [ ] results = new Todo [ todoList . size ( ) ] ; int i = 0 ; Iterator iter = todoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = todoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo get ( int id ) { return todoList . get ( new Integer ( id ) ) ; } 
public void testBadSuffix ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; try { factory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void testTryToConfigureTwo ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; factory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; try { factory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void testQuery ( ) throws Exception { LinkedList < String > prevalentSystem = new LinkedList < String > ( ) ; Prevayler < LinkedList < String > > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Integer result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList < String > , Integer > query ( ) { return new Query < LinkedList < String > , Integer > ( ) { private static final long serialVersionUID = - 9053395276292652684L ; 
public Integer query ( LinkedList < String > prevalentSystem , Date ignored ) throws Exception { return new Integer ( prevalentSystem . size ( ) ) ; } 
public void testTransactionWithQuery ( ) throws Exception { LinkedList < String > prevalentSystem = new LinkedList < String > ( ) ; Prevayler < LinkedList < String > > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; String result = prevayler . execute ( transactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList < String > , String > transactionWithQuery ( ) { return new TransactionWithQuery < LinkedList < String > , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList < String > prevalentSystem , Date timestamp ) { prevalentSystem . add ( " added element " ) ; return " abc " ; } 
public void testBadSuffix ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; try { factory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public void receive ( TransactionTimestamp < ? super P > transactionTimestamp ) { Capsule < ? super P , ? extends TransactionBase > capsule = transactionTimestamp . capsule ( ) ; long systemVersion = transactionTimestamp . systemVersion ( ) ; Date executionTime = transactionTimestamp . executionTime ( ) ; synchronized ( this ) { if ( _prevalentSystem = = null ) { 
private void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { try { return execute ( sureTransactionWithQuery ) ; 
protected void justExecute ( Transaction < ? super P > transaction , P prevalentSystem , Date executionTime ) { transaction . executeOn ( prevalentSystem , executionTime ) ; } 
public Capsule < P , Transaction < ? super P > > cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
protected void justExecute ( TransactionWithQuery < ? super P , R > transaction , P prevalentSystem , Date executionTime ) { try { _queryResult = transaction . executeAndQuery ( prevalentSystem , executionTime ) ; 
public void append ( TransactionGuide < ? super P > guide ) ; public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; public void close ( ) throws IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide < ? super P > guide ) { if ( ! _nextTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; try { try { 
public void append ( TransactionGuide < ? super P > guide ) { if ( ! _initialTransactionInitialized ) throw new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = true ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) throw new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) throw new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp < ? super P > entry = journal . get ( i ) ; 
protected synchronized void notifySubscribers ( TransactionTimestamp < ? super P > transactionTimestamp ) { Iterator < TransactionSubscriber < P > > i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) i . next ( ) . receive ( transactionTimestamp ) ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _clock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule < ? super P , ? extends TransactionBase > capsule ) { TransactionGuide < ? super P > guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide < ? super P > guideFor ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp < P > timestamp = new TransactionTimestamp < P > ( capsule , _nextTransaction , _clock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide < ? super P > guide ) { guide . startTurn ( ) ; try { _clock . advanceTo ( guide . executionTime ( ) ) ; 
public synchronized void receive ( TransactionTimestamp < ? super P > transactionTimestamp ) { _queue . add ( transactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( true ) { TransactionTimestamp < ? super P > notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp < ? super P > waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( this ) ; } return _queue . removeFirst ( ) ; } 
public void receive ( TransactionTimestamp < ? super P > transactionTimestamp ) ; } 
private P readSnapshot ( File snapshotFile ) throws Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) throw new IOException ( snapshotFile . toString ( ) + " cannot be read; only " + _strategies . keySet ( ) . toString ( ) + " supported " ) ; Serializer serializer = _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return ( P ) serializer . readObject ( in ) ; 
protected R execute ( P p_prevalentSystem , Date p_timestamp ) throws Exception { try { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint < P > p_hint ) { return ( P ) Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public R query ( P p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( P p_prevalentSystem , Date p_timestamp ) { try { execute ( p_prevalentSystem , p_timestamp ) ; 
public R executeAndQuery ( P p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { } } ; public void preExecute ( P p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public void preExecute ( P p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception ; } 
public void preExecute ( CampGuide p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) throws Exception { p_prevalentSystem . setTransactionTime ( p_timestamp ) ; } 
void publishRemoteTransaction ( ) throws IOException , ClassNotFoundException { _remoteCapsule = ( Capsule < P , ? extends TransactionBase > ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp < ? super P > tt ) { if ( tt . capsule ( ) = = _remoteCapsule ) tt = new TransactionTimestamp < P > ( null , tt . systemVersion ( ) , tt . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
public void executeOn ( Map < String , Serializable > prevalentSystem , Date executionTime ) { Map < String , Serializable > map = prevalentSystem ; map . put ( key , value ) ; } 
public Serializable query ( Map < String , Serializable > prevalentSystem , Date executionTime ) throws Exception { Map < String , Serializable > map = prevalentSystem ; return map . get ( key ) ; } 
public static void setUpBeforeClass ( ) throws Exception { deletePrevaylerDirectory ( ) ; prevayler = createPrevayler ( true ) ; Map < String , Serializable > map = prevayler . prevalentSystem ( ) ; assertEquals ( " Prevayler size " , 0 , map . size ( ) ) ; LOG . info ( " Created empty prevayler " ) ; } 
Object getState ( ) ; void setState ( P prevalentSystem ) ; Object receive ( ClusteredTransaction < P > transaction ) ; } 
void setState ( P prevalentSystem ) ; Object receive ( ClusteredTransaction < P > transaction ) ; } 
public Object receive ( ClusteredTransaction < P > transaction ) { return transaction . executeOn ( this ) ; } 
public void execute ( Transaction < ? super P > transaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( transaction , clock ( ) . time ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) throws Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > transactionWithQuery ) throws Exception { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { throw new UnsupportedOperationException ( " Not implemented " ) ; } 
public File takeSnapshot ( ) throws Exception { return prevayler . takeSnapshot ( ) ; } 
public void executeBroadcastedTransaction ( Transaction < ? super P > transaction ) { prevayler . execute ( transaction ) ; } 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( ( ClusteredTransaction < P > ) message . getObject ( ) ) ; } return null ; } 
public void testReplicationOfTransactions ( ) throws Exception { Transaction < P > transaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( transaction ) ; assertAllSystemsEqual ( ) ; } 
public void testSync ( ) throws Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , prevayler1 . prevalentSystem ( ) . text . toString ( ) ) ; } 
public void testRestartingClusterWillKeepData ( ) throws Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , prevayler1 . prevalentSystem ( ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , prevayler1 . prevalentSystem ( ) . text . toString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void testLocking ( ) throws Exception { Thread t1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread t2 = createAddToListThread ( prevayler1 , " 2 " ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( 20 , prevayler1 . prevalentSystem ( ) . text . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( prevayler1 . prevalentSystem ( ) . text , prevayler2 . prevalentSystem ( ) . text ) ; } 
public void executeOn ( ListSystem prevalentSystem , Date executionTime ) { ListSystem list = prevalentSystem ; list . add ( string , executionTime ) ; } 
public void snapshotError ( Prevayler < P > prevayler , Error error , long prevaylerDate , long systemDate ) ; public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) ; } 
public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) ; } 
public void snapshotStarted ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler < P > prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the exception was: " + exception ) ; } 
public void snapshotError ( Prevayler < P > prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " the error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void removeListener ( SnapshotListener < P > listener ) { listenerList . remove ( listener ) ; } 
public void addListener ( SnapshotListener < P > listener ) { listenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . clock ( ) . time ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
protected abstract X lookup ( P prevalentSystem ) throws Exception ; public R executeAndQuery ( P prevalentSystem , Date timestamp ) throws Exception { X subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public R executeAndQuery ( P prevalentSystem , Date timestamp ) throws Exception { X subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
protected Todo lookup ( TodoList todoList ) throws Exception { return todoList . get ( id ) ; } 
public synchronized void unregisterCallback ( CallbackNode callback ) { Iterator < CallbackNode > i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( i . next ( ) = = callback ) { i . remove ( ) ; } } callback . freed = true ; } 
public void checkCallbackFreed ( CallbackNode callback ) throws CallbackAlreadyFreedException { if ( callback . freed ) throw new CallbackAlreadyFreedException ( " Callback has already been freed: " + callback . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator < CallbackNode > i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = i . next ( ) ; 
public static void connect ( String host , int port ) throws IOException , ClassNotFoundException { conn = new Remote < Object > ( host , port ) ; } 
public synchronized Serializable exec ( Transaction < ? super P > transaction ) throws Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( transaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException thrownException = ( ThrownException ) result ; throw thrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction < ? super P > transaction , String errorMsg ) { Serializable result = null ; try { result = exec ( transaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public void unregisterCallback ( CallbackNode callback ) throws IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; try { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote<TodoList> remote = Remote.getConnection(); remote.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public Todo [ ] toArray ( ) { Todo [ ] results = new Todo [ todoList . size ( ) ] ; int i = 0 ; Iterator < Integer > iter = todoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = todoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo todo = new Todo ( id ) ; todoList . put ( id , todo ) ; return todo ; } 
public Todo get ( int id ) { return todoList . get ( id ) ; } 
public Todo executeAndQuery ( TodoList todoList , Date timestamp ) throws Exception { Todo todo = todoList . newTodo ( ) ; todo . setDesc ( desc ) ; Notify interested clients that the list just changed Note that much more complex notification schemes can be devised than this. Notification.submit(senderID, "ListChanged", todoList); return todo; } 
public TodoList executeAndQuery ( TodoList todoList , Date timestamp ) throws Exception { return todoList ; } 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = ServerConfig.properties.getProperty("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt(ServerConfig.properties.getProperty("BasePort")); Set up the root object class String rootObjectClassName = ServerConfig.properties.getProperty("RootObjectClass"); Class<?> rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory<Object> factory = new PrevaylerFactory<Object>(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread<Object>(prevayler); snapshotThread.start(); } 
private static void runCommandServer ( ) throws Exception { ServerSocket ss = null ; boolean listening = true ; Listen dynamically try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread<Object>(prevayler, ss.accept()).start(); ss.close(); } 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator < NotificationThread > i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; Map < String , Integer > callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } else { callbacks = new HashMap<String, Integer>(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; Map < String , Integer > callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = true ; Listen for a client connection and dispatch a thread to handle it try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open notification server port"); System.exit(-1); } while (listening) { try { NotificationThread client = new NotificationThread(ss.accept()); clients.add(client); client.start(); } catch (Exception e) { Log.error(e, "Notification server error"); } } try { ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . add ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
public abstract R executeAndQuery ( P prevalentSystem , Date timestamp ) throws Exception ; public void executeOn ( P prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( P prevalentSystem , Date timestamp ) { try { executeAndQuery ( prevalentSystem , timestamp ) ; 
public Method getMethod ( ) throws Exception { Class < ? > [ ] args = new Class < ? > [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public void testSimple ( ) throws Exception { Method m = String . class . getMethod ( " length " , new Class < ? > [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator < NotificationThread > i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = i . next ( ) ; 
public static void reap ( Long id ) { NotificationThread thread = notificationThreads . get ( id ) ; if ( thread ! = null ) { if ( thread . isAlive ( ) ) thread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return true ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return true ; } 
private void crashRecover ( String expectedResult ) throws Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configureJournalFileSizeThreshold ( 232 ) ; Enough to hold 2 transactions. factory.configureJournalFileAgeThreshold(0); Not being tested. factory.configurePrevalenceDirectory(_testDirectory); factory.configurePrevalentSystem(new AppendingSystem()); _prevayler = factory.create(); verify(expectedResult); } 
protected Object execute ( P p_prevalentSystem , Date p_timestamp ) throws Exception { try { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
private Method getMethod ( ) throws Exception { return m_methodInfo . getMethod ( ) ; } 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint < ? super P > p_hint ) { return p_intf . cast ( Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object query ( P p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public Object executeAndQuery ( P p_prevalentSystem , Date p_timestamp ) throws Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) throws Exception { return p_prevayler . execute ( new ProxyQuery < P > ( p_method , p_args , p_hint ) ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) throws Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery < P > ( p_method , p_args , p_hint ) ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) throws Exception { p_prevayler . execute ( new ProxyTransaction < P > ( p_method , p_args , p_hint ) ) ; return null ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) throws Exception { return null ; } 
public Account createAccount ( String holder ) throws Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( nextAccountNumber + + , account ) ; return account ; } 
public void deleteAccount ( long number ) throws AccountNotFound { findAccount ( number ) ; accountsByNumber . remove ( number ) ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( number ) ; } 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator < File > ( ) { public int compare ( File f1 , File f2 ) { return Long . valueOf ( journalVersion ( f1 ) ) . compareTo ( Long . valueOf ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public int compare ( File f1 , File f2 ) { return Long . valueOf ( journalVersion ( f1 ) ) . compareTo ( Long . valueOf ( journalVersion ( f2 ) ) ) ; } 
void keep ( int nextNumber ) { numbers . add ( nextNumber ) ; } 
static private int intProperty ( String name ) { try { return Integer . valueOf ( property ( name ) ) ; 
private void initializePrevayler ( ) throws Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . getDeclaredConstructor ( ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; No snapshot is generated by the test. } 
private Object put ( Record newRecord ) { return recordsById . put ( newRecord . getId ( ) , newRecord ) ; } 
public void deleteAccount ( long number ) throws AccountNotFound { findAccount ( number ) ; accountsByNumber . remove ( Long . valueOf ( number ) ) ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( Long . valueOf ( number ) ) ; } 
public void testMultipleMessages ( ) throws Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( Integer . valueOf ( i ) ) ; } else { node2 . broadcast ( Integer . valueOf ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( Integer . valueOf ( i ) , receivedMessages . get ( i ) ) ; 
public synchronized void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) throws IOException , ClassNotFoundException { if ( _subscriber ! = null ) throw new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( Long . valueOf ( initialTransaction ) ) ; 
private void handleRequests ( ) throws Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(Long.valueOf(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
private static void initPrevayler ( ) throws Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = ServerConfig.properties.getProperty("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt(ServerConfig.properties.getProperty("BasePort")); Set up the root object class String rootObjectClassName = ServerConfig.properties.getProperty("RootObjectClass"); Class<?> rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.getDeclaredConstructor().newInstance(), prevalenceBase); PrevaylerFactory<Object> factory = new PrevaylerFactory<Object>(); factory.configurePrevalentSystem(rootObjectClass.getDeclaredConstructor().newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread<Object>(prevayler); snapshotThread.start(); } 
public static void registerCallback ( long myId , String message ) { Map < String , Integer > callbacks ; Long id = myId ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } else { callbacks = new HashMap<String, Integer>(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, 1); 
public static void unregisterCallback ( long myId , String message ) { Map < String , Integer > callbacks = null ; Long id = myId ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void testParallelPathological ( ) throws Exception { Object original = Byte . valueOf ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) throws Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } public Object readObject(InputStream stream) throws Exception { return Byte.valueOf((byte) stream.read()); } }); assertEquals(original, copy); assertNotSame(original, copy); 
public Object readObject ( InputStream stream ) throws Exception { return Byte . valueOf ( ( byte ) stream . read ( ) ) ; } 
public Integer query ( LinkedList < String > prevalentSystem , Date ignored ) throws Exception { return prevalentSystem . size ( ) ; } 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) throws Exception { String dataPath = " target/E103TestData " ; File dataDir = new File ( dataPath ) ; dataDir . mkdirs ( ) ; for ( File dataFile : dataDir . listFiles ( ) ) { assertTrue ( dataFile . toString ( ) . endsWith ( " .journal " ) ) ; dataFile . delete ( ) ; } Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final Entity entity = prevayler.execute(createEntityTransaction); 
