public synchronized Date ime ( ) { if ( isPaused ) return ime ; if ( currentTimeMillis ( ) ! = millis ) { set ( new Date ( currentTimeMillis ( ) ) ) ; } return ime ; } 
public synchronized void recover ( Date newTime ) { if ( ! isPaused ) hrow new RuntimeException ( " AlarmClock must be paused for advancing. " ) ; long newMillis = newTime . getTime ( ) ; if ( newMillis < = millis ) hrow new RuntimeException ( " AlarmClock's time cannot move forwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) hrow new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( newTime ) ; } 
public synchronized void pause ( ) { if ( isPaused ) hrow new RuntimeException ( " AlarmClock was already paused. " ) ; ime ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
public synchronized void resume ( ) { if ( ! isPaused ) hrow new RuntimeException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
protected long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } 
private void set ( Date ime ) { his . ime = ime ; his . millis = ime . getTime ( ) ; } 
Serializable execute ( PrevalentSystem system ) hrows Exception ; } 
public synchronized Serializable executeCommand ( Command command ) hrows Exception { clock . pause ( ) ; To be deterministic, the system must know exactly at what time the command is being executed. try { Date thisTime = clock.time(); 
public synchronized void akeSnapshot ( ) hrows IOException { clock . pause ( ) ; ry { output . writeSnapshot ( system ) ; 
public PrevalentSystem system ( ) { return system ; } 
public Prevayler create ( PrevalentSystemFactory factory , String directory ) hrows IOException , ClassNotFoundException { CommandInputStream input = new CommandInputStream ( directory ) ; PrevalentSystem system = ( PrevalentSystem ) input . readLastSnapshot ( ) ; if ( system = = null ) system = factory . create ( ) ; his . recoverCommands ( system , input ) ; system . clock ( ) . resume ( ) ; return new Prevayler ( system , input . commandOutputStream ( ) ) ; } 
private void recoverCommands ( PrevalentSystem system , CommandInputStream input ) hrows IOException , ClassNotFoundException { Command command ; while ( rue ) { ry { 
public void write ( byte [ ] b ) hrows IOException { super . write ( b ) ; bytesWritten + = b . length ; } 
public void write ( byte [ ] b , int off , int len ) hrows IOException { super . write ( b , off , len ) ; bytesWritten + = len ; } 
public void write ( int b ) hrows IOException { super . write ( b ) ; + + bytesWritten ; } 
public long bytesWritten ( ) { return bytesWritten ; } 
public Serializable execute ( PrevalentSystem system ) { system . clock ( ) . recover ( new Date ( millis ) ) ; return null ; } 
public Object readLastSnapshot ( ) hrows IOException , ClassNotFoundException { File snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; ry { return ois . readObject ( ) ; 
public Command readCommand ( ) hrows IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; ry { return ( Command ) currentLogStream . readObject ( ) ; 
public CommandOutputStream commandOutputStream ( ) { return new CommandOutputStream ( fileFinder . fileCreator ( ) ) ; } 
private ObjectInputStream newLogStream ( ) hrows IOException { File logFile = fileFinder . nextPendingLog ( ) ; return new ObjectInputStream ( new FileInputStream ( logFile ) ) ; } 
public void writeCommand ( Serializable command ) hrows IOException { ObjectOutputStream oos = logStream ( ) ; ry { oos . writeObject ( command ) ; } catch ( IOException iox ) { oos . close ( ) ; hrow iox ; } oos . flush ( ) ; } 
public synchronized void writeSnapshot ( Serializable system ) hrows IOException { closeLogStream ( ) ; ObjectOutputStream snapshot = snapshotStream ( ) ; ry { snapshot . writeObject ( system ) ; 
private ObjectOutputStream logStream ( ) hrows IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = 100000L ) { } 
private void closeLogStream ( ) hrows IOException { if ( logStream ! = null ) logStream . close ( ) ; logStream = null ; } 
private ObjectOutputStream snapshotStream ( ) hrows IOException { File file = fileCreator . newSnapshot ( ) ; return new ObjectOutputStream ( new FileOutputStream ( file ) ) ; } 
public File newLog ( ) hrows IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; log . createNewFile ( ) ; + + nextFileNumber ; return log ; } 
public File newSnapshot ( ) hrows IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . createNewFile ( ) ; return snapshot ; } 
public File lastSnapshot ( ) { return lastSnapshot ; } 
public File nextPendingLog ( ) hrows EOFException { File log = new File ( directory , NumberFileCreator . LOG_FORMAT . format ( fileNumber + 1 ) ) ; if ( ! log . exists ( ) ) { fileCreator = new NumberFileCreator ( directory , fileNumber + 1 ) ; hrow new EOFException ( ) ; } + + fileNumber ; return log ; } 
public NumberFileCreator fileCreator ( ) { return fileCreator ; } 
private void init ( ) hrows IOException { findLastSnapshot ( ) ; fileNumber = lastSnapshot = = null ? 0 
private long number ( File snapshot ) { ry { return ( NumberFileCreator . SNAPSHOT_FORMAT . parse ( snapshot . getName ( ) ) ) . longValue ( ) ; 
private void findLastSnapshot ( ) hrows IOException { File [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; Arrays . sort ( snapshots ) ; lastSnapshot = snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
public boolean accept ( File file ) { ry { number ( file ) ; } catch ( InternalParseException ipe ) { return false ; } return rue ; } 
public AlarmClock clock ( ) { return clock ; } 
public PrevalentSystem create ( ) { return new AddingSystem ( ) ; } 
public Serializable execute ( PrevalentSystem system ) { ( ( AddingSystem ) system ) . add ( value ) ; return null ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) hrow new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; currentTimeMillis = newMillis ; } 
protected long currentTimeMillis ( ) { return currentTimeMillis ; } 
static public void main ( String [ ] args ) { ry { 
static private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) hrow new RuntimeException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) hrow new RuntimeException ( " AlarmClock's time cannot move forwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) hrow new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
synchronized void pause ( ) { if ( isPaused ) hrow new RuntimeException ( " AlarmClock was already paused. " ) ; ime ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) hrow new RuntimeException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
public synchronized Serializable executeCommand ( Command command ) hrows Exception { clock . pause ( ) ; To be deterministic, the system must know exactly at what time the command is being executed. try { output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
private void recoverCommands ( CommandInputStream input ) hrows IOException , ClassNotFoundException { Command command ; while ( rue ) { ry { 
public Serializable execute ( PrevalentSystem system ) hrows Exception { system . clock ( ) . recover ( millis ) ; return command . execute ( system ) ; } 
public String oString ( ) { } 
public String numberString ( ) { return numberString ( number ) ; } 
static String numberString ( long number ) { return ( new java . ext . DecimalFormat ( " 00000 " ) . format ( number ) ) ; } 
public void holder ( String holder ) hrows InvalidHolder { verify ( holder ) ; this . holder = holder ; notifyListeners ( ) ; } 
public void deposit ( long ammount ) hrows InvalidAmmount { verify ( ammount ) ; register ( ammount ) ; } 
public void withdraw ( long ammount ) hrows InvalidAmmount { verify ( ammount ) ; register ( - ammount ) ; } 
private void register ( long ammount ) { balance + = ammount ; ransactionHistory . add ( new Transaction ( ammount ) ) ; notifyListeners ( ) ; } 
private void verify ( long ammount ) hrows InvalidAmmount { if ( ammount < = 0 ) hrow new InvalidAmmount ( " Ammount must be greater than zero. " ) ; if ( ammount > 10000 ) hrow new InvalidAmmount ( " Ammount maximum (10000) exceeded. " ) ; } 
public List ransactionHistory ( ) { return ransactionHistory ; } 
public void addAccountListener ( AccountListener listener ) { listeners ( ) . add ( listener ) ; } 
public void removeAccountListener ( AccountListener listener ) { listeners ( ) . remove ( listener ) ; } 
private Set listeners ( ) { if ( listeners = = null ) listeners = new HashSet ( ) ; return listeners ; } 
private void notifyListeners ( ) { Iterator it = listeners ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( AccountListener ) it . next ( ) ) . accountChanged ( ) ; 
private void verify ( String holder ) hrows InvalidHolder { if ( holder = = null | | holder . equals ( " " ) ) hrow new InvalidHolder ( ) ; } 
public String oString ( ) { return imestampString ( ) + " Ammount: " + ammount ; } 
private String imestampString ( ) { return new java . ext . SimpleDateFormat ( " yyyy/MM/dd hh:mm:ss.SSS " ) . format ( imestamp ) ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder , clock ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; return account ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; if ( bankListener ! = null ) bankListener . accountDeleted ( account ) ; } 
public List accounts ( ) { List accounts = new ArrayList ( accountsByNumber . values ( ) ) ; Collections . sort ( accounts , new Comparator ( ) { public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } } ) ; return accounts ; } 
public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } 
public Account findAccount ( long number ) hrows AccountNotFound { Account account = searchAccount ( number ) ; if ( account = = null ) hrow new AccountNotFound ( number ) ; return account ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long ammount ) hrows AccountNotFound , Account . InvalidAmmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( ammount ) ; destination . deposit ( ammount ) ; } 
private Account searchAccount ( long number ) { return ( Account ) accountsByNumber . get ( new Long ( number ) ) ; } 
public void accountCreated ( Account account ) ; public void accountDeleted ( Account account ) ; } 
public static void run ( ) hrows IOException , ClassNotFoundException , InterruptedException { String prevalenceBase = System . getProperty ( " user.dir " ) + " /prevalenceBase " ; out ( " The following directory shall be used for the snapshot files and log files: " + prevalenceBase ) ; Prevayler prevayler = new Prevayler ( new Bank ( ) , prevalenceBase ) ; new BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; while ( rue ) { Thread . sleep ( 1000 * 60 * 60 * 24 ) ; 
private static void out ( String message ) { System . out . println ( message ) ; } 
protected Serializable execute ( Bank bank ) hrows Exception { execute ( bank . findAccount ( accountNumber ) ) ; return null ; } 
protected abstract void execute ( Account account ) hrows Exception ; } 
protected Serializable execute ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected Serializable execute ( Bank bank ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } 
public Serializable execute ( PrevalentSystem bank ) hrows Exception { return execute ( ( Bank ) bank ) ; } 
protected abstract Serializable execute ( Bank bank ) hrows Exception ; } 
public void execute ( Account account ) hrows Account . InvalidAmmount { account . deposit ( ammount ) ; } 
public void execute ( Account account ) hrows Account . InvalidHolder { account . holder ( newHolder ) ; } 
public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , ammount ) ; return null ; } 
public void execute ( Account account ) hrows Account . InvalidAmmount { account . withdraw ( ammount ) ; } 
protected void addFields ( Box fieldBox ) { super . addFields ( fieldBox ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Transaction History " ) ) ; historyList = new JList ( ) ; historyList . disable ( ) ; fieldBox . add ( new JScrollPane ( historyList ) ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Balance " ) ) ; balanceField = new JTextField ( ) ; balanceField . disable ( ) ; fieldBox . add ( balanceField ) ; } 
protected void addButtons ( JPanel buttonPanel ) { buttonPanel . add ( new JButton ( new DepositAction ( ) ) ) ; buttonPanel . add ( new JButton ( new WithdrawAction ( ) ) ) ; buttonPanel . add ( new JButton ( new TransferAction ( ) ) ) ; } 
public void action ( ) hrows Exception { Number ammount = enterAmmount ( " Deposit " ) ; if ( ammount = = null ) return ; prevayler . executeCommand ( new Deposit ( account , ammount . longValue ( ) ) ) ; } 
public void action ( ) hrows Exception { Number ammount = enterAmmount ( " Withdrawal " ) ; if ( ammount = = null ) return ; prevayler . executeCommand ( new Withdrawal ( account , ammount . longValue ( ) ) ) ; } 
private Number enterAmmount ( String operation ) hrows Exception { String ammountText = JOptionPane . showInputDialog ( null , " Enter ammount " , operation , JOptionPane . PLAIN_MESSAGE ) ; if ( ammountText = = null ) return null ; return new Long ( parse ( ammountText ) ) ; } 
public void action ( ) { new TransferFrame ( account , prevayler , getDesktopPane ( ) ) ; } 
public void accountChanged ( ) { } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; try { prevayler . executeCommand ( new HolderChange ( account , holderText ( ) ) ) ; 
protected String holderText ( ) { return holderField . getText ( ) ; } 
private Box fieldBox ( ) { Box fieldBox = Box . createVerticalBox ( ) ; addFields ( fieldBox ) ; return fieldBox ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " Holder " ) ) ; fieldBox . add ( holderField ) ; } ; 
private JPanel buttonPanel ( ) { JPanel buttonPanel = new JPanel ( ) ; addButtons ( buttonPanel ) ; return buttonPanel ; } 
abstract protected void addButtons ( JPanel buttonPanel ) ; protected Container labelContainer ( String ext ) { Box box = Box . createHorizontalBox ( ) ; JLabel label = new JLabel ( ext ) ; box . add ( label ) ; box . add ( Box . createHorizontalGlue ( ) ) ; return box ; } protected Component gap ( ) { return Box . createVerticalStrut ( 3 ) ; } protected long parse ( String numericString ) hrows ParseException { return new DecimalFormat ( " # " ) . parse ( numericString ) . longValue ( ) ; The exception thrown has a better message than Long.parseLong(String). }} 
protected Container labelContainer ( String ext ) { Box box = Box . createHorizontalBox ( ) ; JLabel label = new JLabel ( ext ) ; box . add ( label ) ; box . add ( Box . createHorizontalGlue ( ) ) ; return box ; } 
protected Component gap ( ) { return Box . createVerticalStrut ( 3 ) ; } 
protected long parse ( String numericString ) hrows ParseException { return new DecimalFormat ( " # " ) . parse ( numericString ) . longValue ( ) ; The exception thrown has a better message than Long.parseLong(String). } 
private void listenToAccounts ( ) { java . util . Iterator it = accounts ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( Account ) it . next ( ) ) . addAccountListener ( his ) ; 
private void refreshAccounts ( ) { accountList . setListData ( accounts ( ) . oArray ( ) ) ; } 
private java . util . List accounts ( ) { return bank ( ) . accounts ( ) ; } 
private Bank bank ( ) { return ( Bank ) prevayler . system ( ) ; } 
public void accountCreated ( Account a ) { } 
public void accountDeleted ( Account a ) { } 
public void accountChanged ( ) { } 
private JPanel accountButtons ( ) { JPanel result = new JPanel ( ) ; result . add ( new JButton ( new AccountCreation ( ) ) ) ; result . add ( new JButton ( new AccountEditAction ( ) ) ) ; result . add ( new JButton ( new AccountDeleteAction ( ) ) ) ; return result ; } 
public void actionPerformed ( ActionEvent e ) { new NewAccountFrame ( prevayler , getDesktopPane ( ) ) ; } 
private void refreshEnabled ( ) { this . setEnabled ( accountList . getSelectedValue ( ) ! = null ) ; } 
public void valueChanged ( ListSelectionEvent event ) { refreshEnabled ( ) ; } 
protected void action ( ) hrows Exception { action ( ( Account ) accountList . getSelectedValue ( ) ) ; } 
abstract void action ( Account account ) hrows Exception ; } class AccountEditAction extends SelectedAccountAction { AccountEditAction ( ) { super ( " Edit " ) ; } void action ( Account account ) { new AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } } class AccountDeleteAction extends SelectedAccountAction { AccountDeleteAction ( ) { super ( " Delete " ) ; } void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; prevayler . executeCommand ( new AccountDeletion ( account ) ) ; } } } 
void action ( Account account ) { new AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } 
void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; prevayler . executeCommand ( new AccountDeletion ( account ) ) ; } 
private void addLine ( String line ) { JLabel label = new JLabel ( line ) ; label . setAlignmentX ( 0.5f ) ; getContentPane ( ) . add ( label ) ; } 
protected void addButtons ( JPanel buttonPanel ) { buttonPanel . add ( new JButton ( new OKAction ( ) ) ) ; } 
protected void action ( ) hrows Exception { prevayler . executeCommand ( new AccountCreation ( holderText ( ) ) ) ; dispose ( ) ; } 
public void actionPerformed ( ActionEvent e ) { try { action ( ) ; 
protected abstract void action ( ) hrows Exception ; static void display ( Exception exception ) { JOptionPane . showMessageDialog ( null , exception . getMessage ( ) , " Error " , JOptionPane . ERROR_MESSAGE ) ; } } 
static void display ( Exception exception ) { JOptionPane . showMessageDialog ( null , exception . getMessage ( ) , " Error " , JOptionPane . ERROR_MESSAGE ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . disable ( ) ; fieldBox . add ( sourceField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Ammount " ) ) ; ammountField = new JTextField ( ) ; fieldBox . add ( ammountField ) ; } 
protected void addButtons ( JPanel buttonPanel ) { buttonPanel . add ( new JButton ( new OKAction ( ) ) ) ; } 
public void action ( ) hrows Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long ammount = parse ( ammountField . getText ( ) ) ; prevayler . executeCommand ( new Transfer ( account . number ( ) , destinationNumber , ammount ) ) ; dispose ( ) ; } 
public void flush ( ) hrows IOException { super . flush ( ) ; "The flush method of OutputStream does nothing." - JDK1.3 API documentation. I'm calling it just in case it starts doing something in a future version of FileOutputStream or OutputStream. getFD().sync(); "Force all system buffers to synchronize with the underlying device." - JDK1.3 API documentation. } 
public PrevalentSystem readLastSnapshot ( ) hrows IOException , ClassNotFoundException { File snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; out ( snapshotFile ) ; ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; ry { return ( PrevalentSystem ) ois . readObject ( ) ; 
public Command readCommand ( ) hrows IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; Throws EOFException if there are no more log streams. try { return (Command)currentLogStream.readObject(); } catch (EOFException eof) { No more commands in this file. } catch (ObjectStreamException osx) { logStreamExceptionMessage(osx); } catch (RuntimeException rx) { logStreamExceptionMessage(rx); Some stream corruptions cause runtime exceptions! } currentLogStream.close(); currentLogStream = null; return readCommand(); } 
private ObjectInputStream newLogStream ( ) hrows IOException { File logFile = fileFinder . nextPendingLog ( ) ; Throws EOFException if there are no more pending log files. out(logFile); return new ObjectInputStream(new FileInputStream(logFile)); } 
private void logStreamExceptionMessage ( Exception exception ) { out ( " " + exception ) ; out ( " Some commands might have been lost. Looking for the next file... " ) ; } 
private static void out ( File file ) { out ( " Reading " + file + " ... " ) ; } 
private static void out ( Object obj ) { System . out . println ( obj ) ; } 
public void writeCommand ( Command command ) hrows IOException { ObjectOutputStream oos = logStream ( ) ; ry { oos . writeObject ( command ) ; 
public synchronized void writeSnapshot ( PrevalentSystem system ) hrows IOException { closeLogStream ( ) ; After every snapshot, a new commandLog file must be started. File tempSnapshot = fileCreator.newTempSnapshot(); ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream(tempSnapshot)); stream.writeObject(system); stream.close(); File snapshot = fileCreator.newSnapshot(); if (!tempSnapshot.renameTo(snapshot)) throw new IOException("Unable to rename " + tempSnapshot + " to " + snapshot); } 
private ObjectOutputStream logStream ( ) hrows IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = LOG_FILE_SIZE ) { closeLogStream ( ) ; return logStream ( ) ; } 
private void closeLogStream ( ) hrows IOException { if ( logStream = = null ) return ; logStream . close ( ) ; logStream = null ; } 
File newLog ( ) hrows IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) hrow new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; + + nextFileNumber ; return log ; } 
File newSnapshot ( ) hrows IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . delete ( ) ; If no commands are logged, the same snapshot file will be created over and over. return snapshot; } 
File newTempSnapshot ( ) hrows IOException { return File . createTempFile ( " emp " , " generatingSnapshot " , directory ) ; } 
private long number ( File snapshot ) hrows NumberFormatException { NumberFomatException is a RuntimeException. String name = snapshot.getName(); if (!name.endsWith("." + NumberFileCreator.SNAPSHOT_SUFFIX)) throw new NumberFormatException(); return Long.parseLong(name.substring(0,name.indexOf('.'))); "00000.snapshot" becomes "00000". The following doesn't work! It throws ParseException (UnparseableNumber): return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue(); 
public boolean accept ( File file ) { ry { number ( file ) ; } catch ( NumberFormatException nfx ) { return false ; } return rue ; } 
Long add ( long value ) { otal + = value ; return new Long ( otal ) ; } 
public Serializable execute ( PrevalentSystem system ) { return ( ( AddingSystem ) system ) . add ( value ) ; } 
static public void main ( String [ ] args ) { ry { header ( " Persistence Test... " ) ; 
static public void run ( ) hrows Exception { clearPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. crashRecover(); add(40,40); 1 add(30,70); 2 verify(70); crashRecover(); verify(70); add(20,90); 3 add(15,105); 4 snapshot(); snapshot(); verify(105); crashRecover(); snapshot(); add(10,115); 5 snapshot(); add(5,120); 6 add(4,124); 7 verify(124); crashRecover(); add(3,127); 8 verify(127); snapshot(); clearPrevalenceBase(); snapshot(); crashRecover(); verify(127); add(2,129); 9 crashRecover(); verify(129); clearPrevalenceBase(); Check if all files were properly closed and can be deleted. 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new Prevayler ( new AddingSystem ( ) , prevalenceBase ) ; prevaylers . add ( prevayler ) ; } 
static private void snapshot ( ) hrows IOException { out ( " Snapshot. " ) ; prevayler . akeSnapshot ( ) ; } 
static private void add ( long value , long expectedTotal ) hrows Exception { out ( " Adding " + value ) ; Long otal = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; compare ( otal . longValue ( ) , expectedTotal , " Total " ) ; } 
static private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; compare ( system ( ) . otal ( ) , expectedTotal , " Total " ) ; } 
static private AddingSystem system ( ) { return ( AddingSystem ) prevayler . system ( ) ; } 
static private void clearPrevalenceBase ( ) hrows Exception { Iterator it = prevaylers . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( Prevayler ) it . next ( ) ) . akeSnapshot ( ) ; } 
static private void delete ( File [ ] files ) { for ( int i = 0 ; i < files . length ; + + i ) { verify ( files [ i ] . delete ( ) , " Unable to delete " + files [ i ] ) ; 
static private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
static private void verify ( boolean condition , String message ) { if ( ! condition ) { hrow new RuntimeException ( message ) ; 
static private void out ( Object obj ) { } static private Prevayler prevayler; static private final Set prevaylers = new HashSet(); static private final String prevalenceBase = System.getProperty("user.dir") + "\\prevalenceBase";} 
public static void run ( ) hrows IOException , ClassNotFoundException , InterruptedException { String prevalenceBase = System . getProperty ( " user.dir " ) + " /prevalenceBase " ; out ( " The following directory shall be used for the snapshot files and log files: " + prevalenceBase ) ; Prevayler prevayler = new Prevayler ( new Bank ( ) , prevalenceBase ) ; new BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; while ( rue ) { Thread . sleep ( 1000 * 60 * 60 * 24 ) ; 
void clock ( AlarmClock clock ) ; AlarmClock clock ( ) ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( Command command ) hrows Exception ; } 
public Serializable executeCommand ( Command command ) hrows Exception ; } 
public void deposit ( long amount ) hrows InvalidAmount { verify ( amount ) ; register ( amount ) ; } 
public void withdraw ( long amount ) hrows InvalidAmount { verify ( amount ) ; register ( - amount ) ; } 
private void register ( long amount ) { balance + = amount ; ransactionHistory . add ( new Transaction ( amount ) ) ; notifyListeners ( ) ; } 
private void verify ( long amount ) hrows InvalidAmount { if ( amount < = 0 ) hrow new InvalidAmount ( " Amount must be greater than zero. " ) ; if ( amount > 10000 ) hrow new InvalidAmount ( " Amount maximum (10000) exceeded. " ) ; } 
public String oString ( ) { return imestampString ( ) + " Amount: " + amount ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder , clock ( ) ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; return account ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long amount ) hrows AccountNotFound , Account . InvalidAmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( amount ) ; destination . deposit ( amount ) ; } 
public static void run ( ) hrows IOException , ClassNotFoundException , InterruptedException { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) ) ; new BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; while ( rue ) { Thread . sleep ( 1000 * 60 * 60 * 24 ) ; 
public void execute ( Account account ) hrows Account . InvalidAmount { account . deposit ( amount ) ; } 
public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } 
public void execute ( Account account ) hrows Account . InvalidAmount { account . withdraw ( amount ) ; } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; prevayler . executeCommand ( new Deposit ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; prevayler . executeCommand ( new Withdrawal ( account , amount . longValue ( ) ) ) ; } 
private Number enterAmount ( String operation ) hrows Exception { String amountText = JOptionPane . showInputDialog ( null , " Enter amount " , operation , JOptionPane . PLAIN_MESSAGE ) ; if ( amountText = = null ) return null ; return new Long ( parse ( amountText ) ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . disable ( ) ; fieldBox . add ( sourceField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Amount " ) ) ; amountField = new JTextField ( ) ; fieldBox . add ( amountField ) ; } 
public void action ( ) hrows Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; prevayler . executeCommand ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) ; dispose ( ) ; } 
public void clock ( AlarmClock clock ) { if ( his . clock ! = null ) hrow new IllegalStateException ( " The clock had already been set. " ) ; this . clock = clock ; } 
boolean isCommandSequenceRestarted ( ) { return isCommandSequenceRestarted ; } 
boolean recover ( long nextNumber ) hrows EOFException , IOException , ClassNotFoundException { preparePendingCommand ( ) ; if ( nextNumber ! = pendingCommandNumber ) return false ; clock . recover ( pendingCommandExecutionTime ) ; try { pendingCommand . execute ( system ) ; } catch ( Exception e ) { } 
private void preparePendingCommand ( ) hrows EOFException , IOException , ClassNotFoundException { if ( pendingCommand ! = null ) return ; ry { 
private void abort ( Exception exception ) hrows EOFException { out ( " " + exception + " (File: " + logFile + " ) " ) ; out ( " Some commands might have been lost. Looking for the next command... " ) ; throw new EOFException ( ) ; } 
static private void out ( String message ) { System . out . println ( message ) ; } 
void writeCommand ( Command command ) hrows IOException { objectOutputStream . writeObject ( command ) ; } 
void commandSequence ( long executionTime , long commandSequence ) { this . executionTime = executionTime ; this . commandSequence = commandSequence ; } 
void flushToDisk ( ) hrows IOException { objectOutputStream . writeLong ( executionTime ) ; objectOutputStream . writeLong ( commandSequence ) ; flushStreams ( safeCommandLogs ) ; } 
boolean isValid ( ) { return ! isExpired ( ) & & ! isFull ( ) ; } 
private boolean isExpired ( ) { if ( commandLogsThresholdMillis = = 0 ) return false ; return stopWatch . millisEllapsed ( ) > = commandLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( commandLogsThresholdBytes = = 0 ) return false ; return logFile . length ( ) > = commandLogsThresholdBytes ; } 
void close ( ) hrows IOException { objectOutputStream . close ( ) ; } 
static private long parseSystemProperty ( String propertyName ) { try { return Long . parseLong ( System . getProperty ( propertyName ) ) ; 
static private boolean safeCommandLogsSystemProperty ( ) { boolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeCommandLogs " ) ) ; safeCommandLogsMessage ( safe ) ; return safe ; } 
static private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost, though. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } lastTimeWasSafe = safe ; } 
static private void out ( Object message ) { System . out . println ( message ) ; } 
File newLog ( File directory ) hrows IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) hrow new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; nextFileNumber + + ; return log ; } 
File newSnapshot ( File directory ) hrows IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . delete ( ) ; } 
File newTempSnapshot ( File directory ) hrows IOException { return File . createTempFile ( " emp " , " generatingSnapshot " , directory ) ; } 
public PrevalentSystem recoverSystem ( PrevalentSystem newSystem ) hrows ClassNotFoundException , IOException { SystemRecoverer recoverer = new SystemRecoverer ( snapshotDirectory , commandLogDirectories ) ; PrevalentSystem system = recoverer . recover ( newSystem ) ; fileCreator = new FileCreator ( recoverer . nextLogFileNumber ( ) ) ; return system ; } 
public CommandLogger availableCommandLogger ( ) hrows IOException { synchronized ( availableLoggers ) { while ( availableLoggers . isEmpty ( ) ) { 
private void waitForAvailableLogger ( ) { try { availableLoggers . wait ( ) ; 
private void createLoggers ( ) hrows IOException { createLogger ( commandLogDirectories [ 0 ] , rue ) ; for ( int i = 1 ; i < commandLogDirectories . length ; i + + ) { createLogger ( commandLogDirectories [ i ] , false ) ; } nextCommandSequence = 1 ; loggersCreated = rue ; } 
private void createLogger ( File directory , boolean sequenceRestarted ) hrows IOException { File logFile = fileCreator . newLog ( directory ) ; availableLoggers . add ( new CommandLogger ( logFile , sequenceRestarted ) ) ; } 
public void generateCommandSequence ( CommandLogger commandLogger , long executionTime ) { commandLogger . commandSequence ( executionTime , nextCommandSequence + + ) ; } 
public void flushToDisk ( CommandLogger commandLogger ) hrows IOException { commandLogger . flushToDisk ( ) ; makeLoggerAvailable ( commandLogger ) ; } 
private void makeLoggerAvailable ( CommandLogger commandLogger ) hrows IOException { synchronized ( availableLoggers ) { if ( commandLogger . isValid ( ) ) { 
public void writeSnapshot ( PrevalentSystem system ) hrows IOException { File empSnapshot = fileCreator . newTempSnapshot ( snapshotDirectory ) ; ObjectOutputStream stream = new ObjectOutputStream ( new FileOutputStream ( empSnapshot ) ) ; stream . writeObject ( system ) ; stream . close ( ) ; File snapshot = fileCreator . newSnapshot ( snapshotDirectory ) ; if ( ! empSnapshot . renameTo ( snapshot ) ) hrow new IOException ( " Unable to rename " + empSnapshot + " to " + snapshot ) ; closeLoggers ( ) ; } 
private void closeLoggers ( ) hrows IOException { Iterator it = availableLoggers . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( CommandLogger ) it . next ( ) ) . close ( ) ; } availableLoggers . clear ( ) ; loggersCreated = false ; } 
static private File findDirectory ( String directoryName ) hrows IOException { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + directoryName ) ; return directory ; } 
static private File [ ] findDirectories ( String [ ] directoryNames ) hrows IOException { File [ ] directories = new File [ directoryNames . length ] ; for ( int i = 0 ; i < directoryNames . length ; i + + ) { directories [ i ] = findDirectory ( directoryNames [ i ] ) ; } return directories ; } 
public void akeSnapshot ( ) hrows IOException { synchronized ( snapshotMonitor ) { while ( commandsBeingExecuted ! = 0 ) Thread . yield ( ) ; 
public Serializable executeCommand ( Command command ) hrows Exception { prepareForMyTurn ( command ) ; try { 
private void prepareForMyTurn ( Command command ) hrows IOException { commandExecutionStarting ( ) ; CommandLogger myCommandLogger = prevalenceBase . availableCommandLogger ( ) ; myCommandLogger . writeCommand ( command ) ; } 
private void waitForMyTurn ( Object myPlaceHolder ) { synchronized ( myPlaceHolder ) { Object firstPlaceHolder ; 
private void endMyTurn ( ) { Object nextPlaceHolder = null ; synchronized ( commandQueue ) { commandQueue . remove ( 0 ) ; if ( commandQueue . isEmpty ( ) ) { clock . resume ( ) ; } else { nextPlaceHolder = commandQueue . get ( 0 ) ; } } if ( nextPlaceHolder ! = null ) { synchronized ( nextPlaceHolder ) { nextPlaceHolder . notify ( ) ; } } commandExecutionFinishing ( ) ; } 
private void commandExecutionStarting ( ) { synchronized ( snapshotMonitor ) { synchronized ( commandExecutionMonitor ) { 
private void commandExecutionFinishing ( ) { synchronized ( commandExecutionMonitor ) { commandsBeingExecuted - - ; 
static private String [ ] fillArray ( String element , int size ) { String [ ] result = new String [ size ] ; Arrays . fill ( result , element ) ; return result ; } 
synchronized void pause ( ) { if ( isPaused ) hrow new IllegalStateException ( " AlarmClock was already paused. " ) ; ime ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) hrow new IllegalStateException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) hrow new RuntimeException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) hrow new RuntimeException ( " AlarmClock's time cannot be set backwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) hrow new RuntimeException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
PrevalentSystem recover ( PrevalentSystem newSystem ) hrows ClassNotFoundException , IOException { File snapshotFile = findLastSnapshotFile ( snapshotDirectory ) ; if ( snapshotFile = = null ) { system = newSystem ; nextLogFileNumber = 1 ; } else { system = readSystem ( snapshotFile ) ; nextLogFileNumber = number ( snapshotFile ) + 1 ; } recoverPendingCommands ( ) ; return system ; } 
private void recoverPendingCommands ( ) hrows IOException , ClassNotFoundException { long nextCommandNumber = 1 ; final List logRecoverers = new LinkedList ( ) ; while ( nextLogFile ( ) ) { CommandLogRecoverer newLogRecoverer = new CommandLogRecoverer ( currentLogFile , system ) ; 
private boolean recoverNextCommand ( long nextCommandNumber , List logRecoverers ) hrows IOException , ClassNotFoundException { Iterator iterator = logRecoverers . iterator ( ) ; while ( iterator . hasNext ( ) ) { CommandLogRecoverer logRecoverer = ( CommandLogRecoverer ) iterator . next ( ) ; try { if ( logRecoverer . recover ( nextCommandNumber ) ) return rue ; } catch ( EOFException eof ) { logRecoverer . close ( ) ; iterator . remove ( ) ; } } return false ; } 
private boolean nextLogFile ( ) hrows IOException { for ( int i = 0 ; i < commandLogDirectories . length ; i + + ) { currentLogFile = new File ( commandLogDirectories [ i ] , FileCreator . LOG_FORMAT . format ( nextLogFileNumber ) ) ; if ( currentLogFile . exists ( ) ) { nextLogFileNumber + + ; return rue ; } } return false ; } 
static private void clearLogRecoverers ( List logRecoverers ) hrows IOException { Iterator iterator = logRecoverers . iterator ( ) ; while ( iterator . hasNext ( ) ) { ( ( CommandLogRecoverer ) iterator . next ( ) ) . close ( ) ; } logRecoverers . clear ( ) ; } 
static private File findLastSnapshotFile ( File directory ) hrows IOException { File [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; Arrays . sort ( snapshots ) ; return snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
static private long number ( File snapshot ) hrows NumberFormatException { } 
static private PrevalentSystem readSystem ( File snapshotFile ) hrows ClassNotFoundException , IOException { ObjectInputStream ois = objectInputStream ( snapshotFile ) ; try { return ( PrevalentSystem ) ois . readObject ( ) ; 
static private ObjectInputStream objectInputStream ( File file ) hrows IOException { System . out . println ( " Reading " + file + " ... " ) ; return new ObjectInputStream ( new FileInputStream ( file ) ) ; } 
public boolean accept ( File file ) { try { number ( file ) ; } catch ( NumberFormatException nfx ) { return false ; } return rue ; } 
Long add ( long value ) { total + = value ; return new Long ( otal ) ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) hrow new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; currentTimeMillis = newMillis ; } 
public long currentTimeMillis ( ) { return currentTimeMillis ; } 
static public void run ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; } 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; clockPuppet = new AlarmClockPuppet ( clockPuppet . currentTimeMillis ( ) ) ; } 
static private void snapshot ( ) hrows IOException { out ( " Snapshot. " ) ; prevayler . akeSnapshot ( ) ; } 
static private void setTime ( long newTime ) hrows Exception { out ( " Setting time: " + newTime ) ; clockPuppet . currentTimeMillis ( newTime ) ; prevayler . executeCommand ( new NullCommand ( ) ) ; } 
static private void verify ( long expectedTime ) { out ( " Expecting time: " + expectedTime ) ; compare ( system ( ) . clock ( ) . ime ( ) . getTime ( ) , expectedTime , " Time " ) ; } 
static private PrevalentSystem system ( ) { return prevayler . system ( ) ; } 
static private String prevalenceBase ( ) { if ( prevalenceBase = = null ) { prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } return prevalenceBase ; } 
static private void newPrevalenceBase ( ) { prevalenceBase = null ; } 
static private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
static private void verify ( boolean condition , String message ) { if ( ! condition ) { throw new RuntimeException ( message ) ; 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
static public void main ( String [ ] args ) { ry { header ( " PersistenceTest... " ) ; 
public Serializable execute ( PrevalentSystem system ) { return null ; } 
static public void run ( ) hrows Exception { clearPrevalenceBase ( ) ; crashRecover ( ) ; } 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; prevaylers . add ( prevayler ) ; } 
static private void add ( long value , long expectedTotal ) hrows Exception { out ( " Adding " + value ) ; Long otal = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; compare ( otal . longValue ( ) , expectedTotal , " Total " ) ; } 
static private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; compare ( system ( ) . otal ( ) , expectedTotal , " Total " ) ; } 
static private AddingSystem system ( ) { return ( AddingSystem ) prevayler . system ( ) ; } 
static private String prevalenceBase ( ) { return " PrevalenceBase " ; } 
static private void clearPrevalenceBase ( ) hrows Exception { Iterator it = prevaylers . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( SnapshotPrevayler ) it . next ( ) ) . akeSnapshot ( ) ; } 
static public void deletePrevalenceFiles ( String directoryName ) { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; File [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; for ( int i = 0 ; i < files . length ; + + i ) { out ( " Deleting: " + files [ i ] ) ; 
static private void out ( Object obj ) { }} 
public boolean accept ( File directory , String filename ) { return filename . endsWith ( " commandLog " ) | | filename . endsWith ( " snapshot " ) ; 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) ; } 
protected String name ( ) { return " Manipulation Test " ; } 
protected void executeOperation ( Object connection , long operationSequence ) { Record recordToInsert = new Record ( operationSequence + 1000000 ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( idToDelete + 500000 ) ; ( ( ManipulationConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
static private long spreadId ( long id ) { return ( id / 500000 ) * 500000 + ( ( id * 16807 ) % 500000 ) ; 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 500000. This guarantees that all ids in the range will be covered. 
protected void executeOperation ( Object connection , long operationSequence ) { ( ( QueryConnection ) connection ) . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
static private String generateLargeString ( ) { char [ ] chars = new char [ 980 ] ; Arrays . fill ( chars , 'A' ) ; return new String ( chars ) ; } 
static private BigDecimal randomBigDecimal ( ) { return new BigDecimal ( 0.12 + random . nextInt ( ) ) ; } 
static private Date randomDate ( ) { return new Date ( random . nextInt ( 10000000 ) ) ; } 
public boolean hasNext ( ) { return remainingRecords ! = 0 ; } 
public Record next ( ) { indicateProgress ( ) ; remainingRecords - - ; return new Record ( remainingRecords ) ; } 
private void indicateProgress ( ) { if ( remainingRecords = = 1000000 ) { out ( " Creating one million records... " ) ; return ; } if ( remainingRecords % 100000 = = 0 ) out ( " " + ( 1000000 - remainingRecords ) + " ... " ) ; } 
static private String [ ] logDirectories ( ) { String [ ] logDirectories = new String [ 10 ] ; java . util . Arrays . fill ( logDirectories , " PrevalenceBase " ) ; return logDirectories ; } 
private void performTest ( int minThreads , int maxThreads ) { int hreads = minThreads ; while ( hreads < = maxThreads ) { double operationsPerSecond = performRound ( hreads ) ; 
private double performRound ( int hreads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( hreads ) ; sleep ( ) ; stopThreads ( ) ; return ( operationCount - initialOperationCount ) / stopWatch . secondsEllapsed ( ) ; } 
private void startThreads ( int hreads ) { isRoundFinished = false ; for ( int i = 1 ; i < = hreads ; i + + ) { startThread ( ) ; 
private void startThread ( ) { ( new Thread ( ) { public void run ( ) { Object connection = acquireConnection ( ) ; while ( ! isRoundFinished ) { long operation ; synchronized ( roundMonitor ) { operation = operationCount ; operationCount + + ; } executeOperation ( connection , operation ) ; } synchronized ( roundMonitor ) { connectionCache . add ( connection ) ; activeRoundThreads - - ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { Object connection = acquireConnection ( ) ; while ( ! isRoundFinished ) { long operation ; synchronized ( roundMonitor ) { operation = operationCount ; operationCount + + ; } executeOperation ( connection , operation ) ; } synchronized ( roundMonitor ) { connectionCache . add ( connection ) ; 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { synchronized ( roundMonitor ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } static private void sleep ( ) { try { Thread . sleep ( ROUND_DURATION_MILLIS ) ; } catch ( InterruptedException ix ) { throw new RuntimeException ( " Unexpected InterruptedException. " ) ; } } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
private Object acquireConnection ( ) { synchronized ( roundMonitor ) { return connectionCache . isEmpty ( ) 
private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; 
static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } 
static private void sleep ( ) { try { Thread . sleep ( ROUND_DURATION_MILLIS ) ; 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
public String name ( ) ; public void replaceAllRecords ( RecordIterator newRecords ) ; public Object createTestConnection ( ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) ; public Object createTestConnection ( ) ; } 
protected String able ( ) { return " PREVAYLER_MANIPULATION_TEST " ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { insert ( recordToInsert ) ; update ( recordToUpdate ) ; delete ( idToDelete ) ; try { connection . commit ( ) ; 
private void update ( Record recordToUpdate ) { try { updateStatement . setString ( 1 , recordToUpdate . getName ( ) ) ; 
private void delete ( long idToDelete ) { try { deleteStatement . setLong ( 1 , idToDelete ) ; 
public Object createTestConnection ( ) { return new JDBCManipulationConnection ( createConnection ( ) ) ; } 
public List queryByName ( String name ) { ArrayList list = new ArrayList ( ) ; try { selectStatement . setString ( 1 , name ) ; ResultSet resultSet = selectStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { dealWithSQLException ( sqlex , " selecting record from " + able ( ) ) ; } return list ; } 
public Object createTestConnection ( ) { return new JDBCQueryConnection ( createConnection ( ) ) ; } 
protected void insert ( Record recordToInsert ) { try { insertStatement . setLong ( 1 , recordToInsert . getId ( ) ) ; 
protected PreparedStatement prepare ( String statement ) { try { return connection . prepareStatement ( statement ) ; 
void replaceAllRecords ( RecordIterator newRecords ) { try { connection . createStatement ( ) . execute ( " delete from " + able ( ) ) ; } catch ( SQLException sqlx ) { dealWithSQLException ( sqlx , " deleting all records from " + able ( ) ) ; } while ( newRecords . hasNext ( ) ) { insert ( newRecords . next ( ) ) ; } try { connection . commit ( ) ; 
static protected void dealWithSQLException ( SQLException sqlx , String duringOperation ) { sqlx . printStackTrace ( ) ; throw new RuntimeException ( " SQLException " + duringOperation + " . " ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( newRecords ) ; } 
public Serializable execute ( PrevalentSystem system ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; return null ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { put ( recordToInsert ) ; put ( recordToUpdate ) ; recordsById . remove ( new Long ( idToDelete ) ) ; } 
private void put ( Record newRecord ) { Object key = new Long ( newRecord . getId ( ) ) ; recordsById . put ( key , newRecord ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsById . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; 
public java . io . Serializable execute ( PrevalentSystem system ) { ( ( ManipulationSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; return null ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { try { 
public Object createTestConnection ( ) { return new PrevaylerManipulationConnection ( prevayler ) ; } 
public List queryByName ( String name ) { return querySystem . queryByName ( name ) ; } 
public Object createTestConnection ( ) { return new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . system ( ) ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { try { 
public List queryByName ( String name ) { return ( List ) recordsByName . get ( name ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsByName . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; } makeReadOnly ( ) ; } 
private void put ( Record newRecord ) { List records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { records = new ArrayList ( ) ; recordsByName . put ( newRecord . getName ( ) , records ) ; } records . add ( newRecord ) ; } 
private void makeReadOnly ( ) { Iterator entries = recordsByName . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) entries . next ( ) ; 
static public StopWatch start ( ) { return new StopWatch ( ) ; } 
public long millisEllapsed ( ) { return System . currentTimeMillis ( ) - 0 ; } 
public double secondsEllapsed ( ) { return millisEllapsed ( ) / 1000.0 ; } 
public Serializable execute ( PrevalentSystem system ) hrows Exception ; } 
public void clock ( AlarmClock clock ) ; public AlarmClock clock ( ) ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( Command command ) hrows Exception ; } 
public Serializable executeCommand ( Command command ) hrows Exception ; } 
public static void main ( String [ ] args ) hrows Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. When you restart the system, you will see that nothing was lost. " ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeFrame ( prevayler ) ; } 
void keep ( int nextNumber ) { numbers . add ( new Integer ( nextNumber ) ) ; } 
int lastNumber ( ) { return numbers . isEmpty ( ) ? 0 
public Serializable execute ( PrevalentSystem system ) hrows Exception { ( ( NumberKeeper ) system ) . keep ( numberToKeep ) ; return null ; } 
void start ( ) hrows Exception { int primeCandidate = numberKeeper . lastNumber ( ) = = 0 ? 2 : numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { primeFrame . setCandidate ( primeCandidate ) ; 
private boolean isPrime ( int candidate ) { int factor = 2 ; while ( factor < candidate ) { if ( candidate % factor = = 0 ) return false ; factor + + ; } return rue ; } 
private JPanel numbersPanel ( ) { JPanel result = new JPanel ( new GridLayout ( 3 , 2 , 10 , 10 ) ) ; result . setBorder ( new EmptyBorder ( 10 , 10 , 10 , 10 ) ) ; result . add ( new JLabel ( " Primes Found: " ) ) ; result . add ( primesFoundLabel ) ; result . add ( new JLabel ( " Largest Prime: " ) ) ; result . add ( largestPrimeLabel ) ; result . add ( new JLabel ( " Current Candidate: " ) ) ; result . add ( candidateLabel ) ; return result ; } 
private JButton snapshotButton ( ) { JButton result = new JButton ( " Take Snapshot " ) ; result . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { akeSnapshot ( ) ; } } ) ; return result ; } 
public void actionPerformed ( ActionEvent e ) { akeSnapshot ( ) ; 
public void clock ( AlarmClock clock ) { if ( his . clock ! = null ) hrow new IllegalStateException ( " The clock had already been set. " ) ; his . clock = clock ; } 
boolean isExecutionSequenceRestarted ( ) { return isExecutionSequenceRestarted ; } 
boolean recover ( long nextExecutionSequence ) hrows EOFException , IOException , ClassNotFoundException { preparePendingCommand ( ) ; if ( nextExecutionSequence ! = executionSequence ) return false ; clock . recover ( executionTime ) ; ry { pendingCommand . execute ( system ) ; } catch ( Exception e ) { Don't do anything at all now, during recovery. This exception was already treated by the client when it was thrown the first time, during normal system execution. } pendingCommand = null; return true; } 
private void preparePendingCommand ( ) hrows EOFException , IOException , ClassNotFoundException { if ( pendingCommand ! = null ) return ; Had already been prepared. try { 
private void abort ( Exception exception ) hrows EOFException { out ( " " + exception + " (File: " + logFile + " ) " ) ; out ( " The above is a stream corruption that can be caused by: " ) ; out ( " - A system crash while writing to the commandLog file (that is OK). " ) ; out ( " - A corruption in the file system (that is NOT OK). " ) ; out ( " - Tampering with the commandLog file (that is NOT OK). " ) ; out ( " Looking for the next command... " ) ; hrow new EOFException ( ) ; } 
void close ( ) hrows IOException { logStream . close ( ) ; } 
static private void out ( String message ) { System . out . println ( message ) ; } 
void writeCommand ( Command command ) hrows IOException { objectOutputStream . writeObject ( command ) ; } 
void executionSequence ( long executionTime , long executionSequence ) { his . executionTime = executionTime ; his . executionSequence = executionSequence ; } 
void flushToDisk ( ) hrows IOException { objectOutputStream . writeLong ( executionTime ) ; objectOutputStream . writeLong ( executionSequence ) ; flushStreams ( safeCommandLogs ) ; } 
private void flushStreams ( boolean sync ) hrows IOException { objectOutputStream . flush ( ) ; if ( sync ) fileOutputStream . getFD ( ) . sync ( ) ; } 
boolean isValid ( ) { return ! isExpired ( ) & & ! isFull ( ) ; } 
private boolean isExpired ( ) { if ( commandLogsThresholdMillis = = 0 ) return false ; return stopWatch . millisEllapsed ( ) > = commandLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( commandLogsThresholdBytes = = 0 ) return false ; return logFile . length ( ) > = commandLogsThresholdBytes ; } 
void close ( ) hrows IOException { objectOutputStream . close ( ) ; } 
File directory ( ) { return logFile . getParentFile ( ) ; } 
static private long parseSystemProperty ( String propertyName ) { ry { return Long . parseLong ( System . getProperty ( propertyName ) ) ; 
static private boolean safeCommandLogsSystemProperty ( ) { boolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeCommandLogs " ) ) ; safeCommandLogsMessage ( safe ) ; return safe ; } 
static private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost, though. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } lastTimeWasSafe = safe ; } 
static private void out ( Object message ) { System . out . println ( message ) ; } 
PrevalentSystem recoverSystem ( PrevalentSystem newSystem ) hrows ClassNotFoundException , IOException { SystemRecoverer recoverer = new SystemRecoverer ( snapshotDirectory , commandLogDirectories ) ; PrevalentSystem system = recoverer . recover ( newSystem ) ; fileCreator = new FileCreator ( recoverer . nextLogFileNumber ( ) ) ; return system ; } 
CommandLogger availableCommandLogger ( ) hrows IOException { synchronized ( availableLoggers ) { while ( availableLoggers . isEmpty ( ) ) { 
void generateExecutionSequence ( CommandLogger commandLogger , long executionTime ) { commandLogger . executionSequence ( executionTime , nextCommandSequence + + ) ; } 
void flushToDisk ( CommandLogger commandLogger ) hrows IOException { commandLogger . flushToDisk ( ) ; makeLoggerAvailable ( commandLogger ) ; } 
void writeSnapshot ( PrevalentSystem system ) hrows IOException { closeLoggers ( ) ; File empSnapshot = fileCreator . newTempSnapshot ( snapshotDirectory ) ; ObjectOutputStream stream = new ObjectOutputStream ( new FileOutputStream ( empSnapshot ) ) ; stream . writeObject ( system ) ; stream . close ( ) ; File snapshot = fileCreator . newSnapshot ( snapshotDirectory ) ; if ( ! empSnapshot . renameTo ( snapshot ) ) hrow new IOException ( " Unable to rename " + empSnapshot + " to " + snapshot ) ; } 
private void prepareForMyTurn ( Command command ) hrows IOException { commandExecutionStarting ( ) ; CommandLogger myCommandLogger = prevalenceBase . availableCommandLogger ( ) ; myCommandLogger . writeCommand ( command ) ; } 
public synchronized Date ime ( ) { if ( isPaused ) return ime ; long currentMillis = currentTimeMillis ( ) ; if ( currentMillis ! = millis ) { set ( new Date ( currentMillis ) ) ; } return ime ; } 
synchronized void pause ( ) { if ( isPaused ) hrow new IllegalStateException ( " AlarmClock was already paused. " ) ; ime ( ) ; Guarantees the time is up-to-date. isPaused = true; } 
synchronized void resume ( ) { if ( ! isPaused ) hrow new IllegalStateException ( " AlarmClock was not paused. " ) ; isPaused = false ; } 
synchronized void recover ( long newMillis ) { if ( ! isPaused ) hrow new IllegalStateException ( " AlarmClock must be paused for recovering. " ) ; if ( newMillis = = millis ) return ; if ( newMillis < millis ) hrow new IllegalArgumentException ( " AlarmClock's time cannot be set backwards. " ) ; if ( newMillis > currentTimeMillis ( ) ) hrow new IllegalArgumentException ( " AlarmClock's time cannot be set after the current time. " ) ; set ( new Date ( newMillis ) ) ; } 
protected long currentTimeMillis ( ) { return System . currentTimeMillis ( ) ; } 
private void set ( Date ime ) { his . ime = ime ; his . millis = ime . getTime ( ) ; } 
static private void safeCommandLogsMessage ( boolean safe ) { if ( ! safe & & lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is OFF. " ) ; out ( " Writes to the commandLog files will be cached for greater performance. In the event of a system crash, some of the last executed commands might be lost. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeCommandLogs system property is ON. " ) ; out ( " Writes to the commandLog files will be flushed to the underlying device before each command is executed. " ) ; out ( " ===================================== " ) ; } lastTimeWasSafe = safe ; } 
protected void prepare ( ) { super . prepare ( ) ; halfTheObjects = numberOfObjects / 2 ; } 
protected void executeOperation ( Object connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( ManipulationConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
private long spreadId ( long id ) { return ( id / halfTheObjects ) * halfTheObjects + ((id * 16807) % halfTheObjects); 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 50000, 500000 and 5000000. This guarantees that all ids in the range will be covered. 
static private BigDecimal randomBigDecimal ( ) { return new BigDecimal ( random . nextInt ( ) ) ; } 
public boolean hasNext ( ) { return nextRecordId < numberOfRecords ; } 
public Record next ( ) { indicateProgress ( ) ; return new Record ( nextRecordId + + ) ; } 
private void indicateProgress ( ) { if ( nextRecordId = = 0 ) { out ( " Creating " + numberOfRecords + " objects... " ) ; return ; } if ( nextRecordId % 100000 = = 0 ) out ( " " + nextRecordId + " ... " ) ; } 
static public void main ( String [ ] args ) { out ( " n============================================================= " ) ; out ( " Prevayler vs JDBC Scalability Tests " ) ; out ( " ============================================================= " ) ; out ( " If you have any trouble running the tests, just write to " ) ; out ( " prevayler-scalability@lists.sourceforge.net and we will be glad to help. " ) ; try { out ( " Reading the properties file: " + propertiesFile ( ) . getAbsolutePath ( ) ) ; 
static private void runPrevaylerQuery ( ) hrows Exception { new QueryTestRun ( new PrevaylerQuerySubject ( ) , 
static private void runPrevaylerManipulation ( ) hrows Exception { new ManipulationTestRun ( new PrevaylerManipulationSubject ( prevaylerManipulationLogDirectories ( ) ) , 
static private void runJdbcQuery ( ) { new QueryTestRun ( new JDBCQuerySubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private void runJdbcManipulation ( ) { new ManipulationTestRun ( new JDBCManipulationSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private File propertiesFile ( ) hrows IOException { File result = new File ( " ScalabilityTestProperties.txt " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; createPropertiesFile ( result ) ; } return result ; } 
static private void createPropertiesFile ( File file ) hrows IOException { PrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; stream . println ( " ########################################################### " + 
static private int numberOfObjects ( ) { String property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; throw new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION or TEN_MILLION. " ) ; } 
static private boolean isPrevaylerQueryChosen ( ) { return booleanProperty ( " RunPrevaylerQueryTest " ) ; } 
static private int prevaylerQueryThreadsMin ( ) { return intProperty ( " PrevaylerQueryThreadsMinimum " ) ; } 
static private int prevaylerQueryThreadsMax ( ) { return intProperty ( " PrevaylerQueryThreadsMaximum " ) ; } 
static private boolean isPrevaylerManipulationChosen ( ) { return booleanProperty ( " RunPrevaylerManipulationTest " ) ; } 
static private int prevaylerManipulationThreadsMin ( ) { return intProperty ( " PrevaylerManipulationThreadsMinimum " ) ; } 
static private int prevaylerManipulationThreadsMax ( ) { return intProperty ( " PrevaylerManipulationThreadsMaximum " ) ; } 
static private String [ ] prevaylerManipulationLogDirectories ( ) { out ( " nPrevayler CommandLog Directories: " ) ; List directories = new ArrayList ( ) ; int i = 1 ; while ( rue ) { String directory = properties . getProperty ( " CommandLogDirectory " + i ) ; if ( directory = = null ) break ; out ( directory ) ; directories . add ( directory ) ; i + + ; } if ( directories . isEmpty ( ) ) hrow new RuntimeException ( " There must be at least one CommandLog directory to run the Prevayler Manipulation Test. " ) ; return ( String [ ] ) directories . oArray ( new String [ 0 ] ) ; } 
static private boolean isJdbcQueryChosen ( ) { return booleanProperty ( " RunJdbcQueryTest " ) ; } 
static private int jdbcQueryThreadsMin ( ) { return intProperty ( " JdbcQueryThreadsMinimum " ) ; } 
static private int jdbcQueryThreadsMax ( ) { return intProperty ( " JdbcQueryThreadsMaximum " ) ; } 
static private boolean isJdbcManipulationChosen ( ) { return booleanProperty ( " RunJdbcManipulationTest " ) ; } 
static private int jdbcManipulationThreadsMin ( ) { return intProperty ( " JdbcManipulationThreadsMinimum " ) ; } 
static private int jdbcManipulationThreadsMax ( ) { return intProperty ( " JdbcManipulationThreadsMaximum " ) ; } 
static private String jdbcDriverClassName ( ) { return property ( " JdbcDriverClassName " ) ; } 
static private String jdbcConnectionURL ( ) { return property ( " JdbcConnectionURL " ) ; } 
static private String jdbcUser ( ) { return property ( " JdbcUser " ) ; } 
static private String jdbcPassword ( ) { return property ( " JdbcPassword " ) ; } 
static private String property ( String name ) { String result = properties . getProperty ( name ) ; if ( result = = null ) hrow new RuntimeException ( " Property " + name + " not found. " ) ; return result ; } 
static private int intProperty ( String name ) { try { return Integer . valueOf ( property ( name ) ) . intValue ( ) ; 
static private boolean booleanProperty ( String name ) { boolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return rue ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; return false ; } 
protected void prepare ( ) { subject . replaceAllRecords ( new RecordIterator ( numberOfObjects ) ) ; System . gc ( ) ; } 
private double performRound ( int hreads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( hreads ) ; sleep ( ) ; stopThreads ( ) ; double secondsEllapsed = stopWatch . secondsEllapsed ( ) ; double operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . otalMemory ( ) ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + oResultString ( operationsPerSecond , hreads ) ) ; return operationsPerSecond ; } 
private void startThread ( ) { ( new Thread ( ) { public void run ( ) { try { Object connection = acquireConnection ( ) ; while ( ! isRoundFinished ) { long operation ; synchronized ( roundMonitor ) { operation = operationCount ; operationCount + + ; } executeOperation ( connection , operation ) ; } synchronized ( roundMonitor ) { connectionCache . add ( connection ) ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { try { Object connection = acquireConnection ( ) ; 
static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + 
protected String able ( ) { return " MANIPULATION_TEST " ; } 
public void flush ( ) hrows IOException { super . flush ( ) ; getFD().sync(); "Force all system buffers to synchronize with the underlying device." - JDK1.3 API documentation. } 
public void write ( byte [ ] b ) hrows IOException { super . write ( b ) ; bytesWritten + = b . length ; } 
public void write ( byte [ ] b , int off , int len ) hrows IOException { super . write ( b , off , len ) ; bytesWritten + = len ; } 
public void write ( int b ) hrows IOException { super . write ( b ) ; + + bytesWritten ; } 
public PrevalentSystem readLastSnapshot ( ) hrows IOException , ClassNotFoundException { File snapshotFile = fileFinder . lastSnapshot ( ) ; if ( snapshotFile = = null ) return null ; out ( snapshotFile ) ; ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( snapshotFile ) ) ; try { return ( PrevalentSystem ) ois . readObject ( ) ; 
public Command readCommand ( ) hrows IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; return readCommand(); } 
public CommandOutputStream commandOutputStream ( ) { return new CommandOutputStream ( fileFinder . fileCreator ( ) ) ; } 
private ObjectInputStream newLogStream ( ) hrows IOException { File logFile = fileFinder . nextPendingLog ( ) ; return new ObjectInputStream(new FileInputStream(logFile)); } 
private void logStreamExceptionMessage ( Exception exception ) { out ( " " + exception ) ; out ( " Some commands might have been lost. Looking for the next file... " ) ; } 
private static void out ( File file ) { out ( " Reading " + file + " ... " ) ; } 
private static void out ( Object obj ) { System . out . println ( obj ) ; } 
public void writeCommand ( Command command ) hrows IOException { ObjectOutputStream oos = logStream ( ) ; try { oos . writeObject ( command ) ; 
public synchronized void writeSnapshot ( PrevalentSystem system ) hrows IOException { closeLogStream ( ) ; if (!tempSnapshot.renameTo(snapshot)) throw new IOException("Unable to rename " + tempSnapshot + " to " + snapshot); } 
private ObjectOutputStream logStream ( ) hrows IOException { if ( logStream = = null ) { fileStream = new ByteCountStream ( fileCreator . newLog ( ) ) ; logStream = new ObjectOutputStream ( fileStream ) ; } if ( fileStream . bytesWritten ( ) > = LOG_FILE_SIZE ) { closeLogStream ( ) ; return logStream ( ) ; } 
private void closeLogStream ( ) hrows IOException { if ( logStream = = null ) return ; logStream . close ( ) ; logStream = null ; } 
File newLog ( ) hrows IOException { File log = new File ( directory , LOG_FORMAT . format ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) hrow new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; + + nextFileNumber ; return log ; } 
File newSnapshot ( ) hrows IOException { File snapshot = new File ( directory , SNAPSHOT_FORMAT . format ( nextFileNumber - 1 ) ) ; snapshot . delete ( ) ; return snapshot; } 
File newTempSnapshot ( ) hrows IOException { return File . createTempFile ( " emp " , " generatingSnapshot " , directory ) ; } 
public File nextPendingLog ( ) hrows EOFException { File log = new File ( directory , NumberFileCreator . LOG_FORMAT . format ( fileNumber + 1 ) ) ; if ( ! log . exists ( ) ) { fileCreator = new NumberFileCreator ( directory , fileNumber + 1 ) ; hrow new EOFException ( ) ; } + + fileNumber ; return log ; } 
public NumberFileCreator fileCreator ( ) { return fileCreator ; } 
private void init ( ) hrows IOException { findLastSnapshot ( ) ; fileNumber = lastSnapshot = = null ? 0 
private long number ( File snapshot ) hrows NumberFormatException { The following doesn't work! It throws ParseException (UnparseableNumber): return (NumberFileCreator.SNAPSHOT_FORMAT.parse(snapshot.getName())).longValue(); 
private void findLastSnapshot ( ) hrows IOException { File [ ] snapshots = directory . listFiles ( new SnapshotFilter ( ) ) ; if ( snapshots = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; Arrays . sort ( snapshots ) ; lastSnapshot = snapshots . length > 0 ? snapshots [ snapshots . length - 1 ] 
public boolean accept ( File file ) { ry { number ( file ) ; } catch ( NumberFormatException nfx ) { return false ; } return rue ; } 
public synchronized Serializable executeCommand ( Command command ) hrows Exception { clock . pause ( ) ; output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
public synchronized void akeSnapshot ( ) hrows IOException { clock . pause ( ) ; try { output . writeSnapshot ( system ) ; 
private void recoverCommands ( CommandInputStream input ) hrows IOException , ClassNotFoundException { Command command ; while ( rue ) { try { 
public Serializable execute ( PrevalentSystem system ) hrows Exception { ( ( SystemClock ) system . clock ( ) ) . recover ( millis ) ; return command . execute ( system ) ; } 
public Serializable execute ( PrevalentSystem system ) { return ( ( AddingSystem ) system ) . add ( value ) ; } 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) hrow new IllegalArgumentException ( " AlarmClock's time can only be set forwards. " ) ; currentTimeMillis = newMillis ; } 
protected long currentTimeMillis ( ) { return currentTimeMillis ; } 
static public void main ( String [ ] args ) { try { header ( " Persistence Test... " ) ; 
static private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
static public void run ( ) hrows Exception { clearPrevalenceBase ( ) ; crashRecover ( ) ; clearPrevalenceBase(); Check if all files were properly closed and can be deleted. 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; prevaylers . add ( prevayler ) ; } 
static private void snapshot ( ) hrows IOException { out ( " Snapshot. " ) ; prevayler . akeSnapshot ( ) ; } 
static private void add ( long value , long expectedTotal ) hrows Exception { out ( " Adding " + value ) ; Long otal = ( Long ) prevayler . executeCommand ( new Addition ( value ) ) ; compare ( otal . longValue ( ) , expectedTotal , " Total " ) ; } 
static private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; compare ( system ( ) . otal ( ) , expectedTotal , " Total " ) ; } 
static private AddingSystem system ( ) { return ( AddingSystem ) prevayler . system ( ) ; } 
static private void clearPrevalenceBase ( ) hrows Exception { Iterator it = prevaylers . iterator ( ) ; while ( it . hasNext ( ) ) { ( ( SnapshotPrevayler ) it . next ( ) ) . akeSnapshot ( ) ; } 
static private void delete ( File [ ] files ) { for ( int i = 0 ; i < files . length ; + + i ) { verify ( files [ i ] . delete ( ) , " Unable to delete " + files [ i ] ) ; 
static private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
static private void verify ( boolean condition , String message ) { if ( ! condition ) { hrow new RuntimeException ( message ) ; 
static private void out ( Object obj ) { } static private SnapshotPrevayler prevayler; static private final Set prevaylers = new HashSet(); static private final String prevalenceBase = System.getProperty("user.dir") + "\\prevalenceBase";} 
static private long randomDate ( ) { return random . nextInt ( 10000000 ) ; } 
public static void main ( String [ ] args ) hrows Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. When you restart the system, you will see that nothing was lost. " ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeFrame ( prevayler ) ; } 
public static void run ( ) hrows IOException , ClassNotFoundException , InterruptedException { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2 " ) ; new BankFrame ( prevayler ) ; out ( " A system snapshot will be taken every 24h... " ) ; while ( rue ) { Thread . sleep ( 1000 * 60 * 60 * 24 ) ; 
public static void main ( String [ ] args ) { out ( " Using NullPrevayler. System state will NOT be persisted. " ) ; new BankFrame ( new NullPrevayler ( new Bank ( ) ) ) ; } 
public Serializable executeCommand ( Command command ) hrows Exception { return command . execute ( system ) ; } 
private static AlarmClock defaultClock ( ) { SystemClock clock = new SystemClock ( ) ; clock . resume ( ) ; return clock ; } 
public static void main ( String [ ] args ) hrows Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { String yped = bf . readLine ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
void start ( ) hrows Exception { int largestPrime = 0 ; int primesFound = 0 ; int primeCandidate = numberKeeper . lastNumber ( ) = = 0 ? 2 : numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
static private long parseSystemProperty ( String propertyName ) { String property = System . getProperty ( propertyName ) ; if ( property = = null ) return 0 ; ry { return Long . parseLong ( property ) ; 
static String snapshotFileName ( long fileNumber ) { String fileName = " 000000000000000000000 " + fileNumber ; return fileName . substring ( fileName . length ( ) - 21 ) + FileCreator . SNAPSHOT_SUFFIX ; } 
static String logFileName ( long fileNumber ) { String fileName = " 000000000000000000000 " + fileNumber ; return fileName . substring ( fileName . length ( ) - 21 ) + FileCreator . LOG_SUFFIX ; } 
File newLog ( File directory ) hrows IOException { File log = new File ( directory , FileCreator . logFileName ( nextFileNumber ) ) ; if ( ! log . createNewFile ( ) ) hrow new IOException ( " Attempt to create command log file that already existed: " + log ) ; ; nextFileNumber + + ; return log ; } 
File newSnapshot ( File directory ) hrows IOException { File snapshot = new File ( directory , FileCreator . snapshotFileName ( nextFileNumber - 1 ) ) ; snapshot . delete ( ) ; } 
private boolean nextLogFile ( ) hrows IOException { for ( int i = 0 ; i < commandLogDirectories . length ; i + + ) { currentLogFile = new File ( commandLogDirectories [ i ] , FileCreator . logFileName ( nextLogFileNumber ) ) ; if ( currentLogFile . exists ( ) ) { nextLogFileNumber + + ; return rue ; } } return false ; } 
static private long number ( File snapshot ) hrows NumberFormatException { } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) hrows java . io . IOException ; } 
public void execute ( Transaction ransaction ) hrows java . io . IOException ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
static private void printMessage ( ) hrows Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) . readLine ( ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( NumberKeeper ) prevalentSystem ) . keep ( _numberToKeep ) ; } 
void start ( ) hrows Exception { int largestPrime = 0 ; int primesFound = 0 ; int primeCandidate = _numberKeeper . lastNumber ( ) = = 0 ? 2 : _numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
private boolean isPrime ( int candidate ) { int factor = 2 ; while ( factor < candidate ) { if ( candidate % factor = = 0 ) return false ; factor + + ; } return rue ; } 
public static void main ( String [ ] ignored ) hrows Exception { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; new BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE from the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated tests scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
protected Object executeAndQuery ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( _holder ) ; } 
protected Object executeAndQuery ( Bank bank ) hrows Bank . AccountNotFound { bank . deleteAccount ( _accountNumber ) ; return null ; } 
protected Object executeAndQuery ( Bank bank ) hrows Exception { executeAndQuery ( bank . findAccount ( _accountNumber ) ) ; return null ; } 
protected abstract void executeAndQuery ( Account account ) hrows Exception ; } 
public Object executeAndQuery ( Object bank ) hrows Exception { return executeAndQuery ( ( Bank ) bank ) ; } 
protected abstract Object executeAndQuery ( Bank bank ) hrows Exception ; } 
public void executeAndQuery ( Account account ) hrows Account . InvalidAmount { account . deposit ( _amount ) ; } 
public void executeAndQuery ( Account account ) hrows Account . InvalidHolder { account . holder ( _newHolder ) ; } 
public Object executeAndQuery ( Bank bank ) hrows Exception { bank . ransfer ( _originAccountNumber , _destinationAccountNumber , _amount ) ; return null ; } 
public void executeAndQuery ( Account account ) hrows Account . InvalidAmount { account . withdraw ( _amount ) ; } 
protected void addFields ( Box fieldBox ) { super . addFields ( fieldBox ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Transaction History " ) ) ; historyList = new JList ( ) ; historyList . disable ( ) ; fieldBox . add ( new JScrollPane ( historyList ) ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Balance " ) ) ; balanceField = new JTextField ( ) ; balanceField . disable ( ) ; fieldBox . add ( balanceField ) ; } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; ( new Deposit ( account , amount . longValue ( ) ) ) . executeUsing ( prevayler ) ; } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; ( new Withdrawal ( account , amount . longValue ( ) ) ) . executeUsing ( prevayler ) ; } 
public void accountChanged ( ) { } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; try { ( new HolderChange ( account , holderText ( ) ) ) . executeUsing ( prevayler ) ; 
private Bank bank ( ) { return ( Bank ) prevayler . prevalentSystem ( ) ; } 
abstract void action ( Account account ) hrows Exception ; } class AccountEditAction extends SelectedAccountAction { AccountEditAction ( ) { super ( " Edit " ) ; } void action ( Account account ) { new AccountEditFrame ( account , prevayler , getDesktopPane ( ) ) ; } } class AccountDeleteAction extends SelectedAccountAction { AccountDeleteAction ( ) { super ( " Delete " ) ; } void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; ( new AccountDeletion ( account ) ) . executeUsing ( prevayler ) ; } } } 
void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; ( new AccountDeletion ( account ) ) . executeUsing ( prevayler ) ; } 
protected void action ( ) hrows Exception { ( new AccountCreation ( holderText ( ) ) ) . executeUsing ( prevayler ) ; dispose ( ) ; } 
public void action ( ) hrows Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) . executeUsing ( prevayler ) ; dispose ( ) ; } 
static public File produceDirectory ( String directoryName ) hrows IOException { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + directoryName ) ; return directory ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { return _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public long objectCount ( ) hrows IOException , ClassNotFoundException { long result = 0 ; while ( rue ) { try { 
public void close ( ) hrows IOException { _delegate . close ( ) ; _EOF = rue ; } 
private void message ( Exception exception ) { System . out . println ( " " + exception + " (File: " + _file + " ) " + 
public void writeObject ( Object object ) hrows IOException { _delegate . writeObject ( object ) ; } 
public void sync ( ) hrows IOException { _fileDescriptor . sync ( ) ; } 
public void close ( ) hrows IOException { _delegate . close ( ) ; _isValid = false ; } 
void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = File . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " , directory ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; } 
protected void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows IOException { SimpleOutputStream stream = new SimpleOutputStream ( snapshotFile ) ; stream . writeObject ( prevalentSystem ) ; stream . close ( ) ; } 
long latestVersion ( ) hrows IOException { String [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
Object readSnapshot ( Object initialVersion , long version ) hrows ClassNotFoundException , IOException { if ( version = = 0 ) return initialVersion ; File snapshotFile = snapshotFile ( version ) ; return readSnapshot ( snapshotFile ) ; } 
protected Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { SimpleInputStream ois = new SimpleInputStream ( snapshotFile ) ; try { return ois . readObject ( ) ; } finally { ois . close ( ) ; } } 
private File snapshotFile ( long version ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; } 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
public void akeSnapshot ( ) hrows IOException { synchronized ( _subscriber ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void execute ( Transaction ransaction ) { _publisher . publish ( ransaction ) ; } 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { public synchronized void receive ( Transaction ransaction ) { 
public synchronized void receive ( Transaction ransaction ) { _systemVersion + + ; transaction . executeOn ( _prevalentSystem ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void publish ( Transaction ransaction ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransactionIgnored ) hrows IOException , ClassNotFoundException { _subscribers . add ( subscriber ) ; } 
public void publish ( Transaction ransaction ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransaction ) ; } 
public synchronized void publish ( Transaction ransaction ) { if ( ! _nextTransactionKnown ) hrow new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; try { _outputLog . writeObject ( ransaction ) ; _outputLog . sync ( ) ; } catch ( IOException iox ) { handleExceptionWhileWriting ( iox , _outputLog . file ( ) , ransaction , _nextTransaction ) ; } _nextTransaction + + ; super . publish ( ransaction ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { _nextTransaction = initialTransaction ; _nextTransactionKnown = rue ; } else { if ( initialTransaction > _nextTransaction ) hrow new IOException ( " Unable to find transactions from " + _nextTransaction + " to " + ( initialTransaction - 1 ) + " . " ) ; long initialFileCandidate = initialTransaction ; while ( ! ransactionLogFile ( initialFileCandidate ) . exists ( ) ) { initialFileCandidate - - ; if ( initialFileCandidate < = 0 ) hrowNotFound ( initialTransaction ) ; } update ( subscriber , initialTransaction , initialFileCandidate ) ; } super . addSubscriber ( subscriber , - 1 ) ; } 
private File lastTransactionFile ( ) hrows IOException { File [ ] files = _directory . listFiles ( his ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; if ( files . length = = 0 ) return null ; return ( File ) Collections . max ( Arrays . asList ( files ) ) ; } 
public boolean accept ( File file ) { String name = file . getName ( ) ; if ( ! name . endsWith ( " .transactionLog " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; try { number ( file ) ; } catch ( RuntimeException r ) { return false ; } return rue ; } 
static private long number ( File file ) { return Long . parseLong ( file . getName ( ) . substring ( 0 , 19 ) ) ; } 
private void createNewOutputLog ( ) { File file = ransactionLogFile ( _nextTransaction ) ; try { _outputLog = new SimpleOutputStream ( file ) ; 
private File ransactionLogFile ( long ransaction ) { String fileName = " 0000000000000000000 " + ransaction ; fileName = fileName . substring ( fileName . length ( ) - 19 ) + " .transactionLog " ; return new File ( _directory , fileName ) ; } 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) hrows IOException , ClassNotFoundException { long recoveringTransaction = initialFile ; SimpleInputStream inputLog = new SimpleInputStream ( ransactionLogFile ( recoveringTransaction ) ) ; while ( recoveringTransaction < _nextTransaction ) { try { 
static private void hrowNotFound ( long ransaction ) hrows IOException { throw new IOException ( " Unable to find transactionLog file containing transaction " + ransaction ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Transaction ransaction , long ransactionNumber ) { hang ( iox , " nThe exception above was thrown while trying to write transaction " + ransactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and stop all transaction logging. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Transaction transaction, long transactionNumber). " ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { hang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and stop all transaction logging. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
static private void hang ( IOException iox , String message ) { iox . printStackTrace ( ) ; System . out . println ( message ) ; while ( rue ) Thread . yield ( ) ; } 
public void run ( ) { try { while ( rue ) new RemoteConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public void run ( ) { try { long initialTransaction = ( ( Long ) _fromRemote . readObject ( ) ) . longValue ( ) ; 
void publishRemoteTransaction ( ) hrows Exception { _remoteTransaction = ( Transaction ) _fromRemote . readObject ( ) ; _publisher . publish ( _remoteTransaction ) ; } 
public void receive ( Transaction ransaction ) { send ( ransaction = = _remoteTransaction ? ( Object ) Protocol . REMOTE_TRANSACTION 
private void send ( Object message ) { try { _toRemote . writeObject ( message ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _subscriberUpToDateMonitor ) { _toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public synchronized void publish ( Transaction ransaction ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, the RemoteTransactionPublisher needs a registered subscriber. " ) ; synchronized ( _myTransactionMonitor ) { _myTransaction = ransaction ; 
public void run ( ) { try { while ( rue ) receiveTransactionFromServer ( ) ; 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( Protocol . TRANSACTIONS_UP_TO_DATE ) ) { notify ( _subscriberUpToDateMonitor ) ; return ; } if ( ransactionCandidate . equals ( Protocol . REMOTE_TRANSACTION ) ) { synchronized ( _myTransactionMonitor ) { _subscriber . receive ( _myTransaction ) ; notify ( _myTransactionMonitor ) ; } return ; } _subscriber . receive ( ( Transaction ) ransactionCandidate ) ; } 
private static void wait ( Object monitor ) { try { monitor . wait ( ) ; 
private static void notify ( Object monitor ) { synchronized ( monitor ) { monitor . notify ( ) ; } } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; } 
static public void main ( String [ ] args ) hrows Exception { } 
static private void header ( String head ) { out ( " " ) ; out ( " " ) ; out ( " > > > " + head ) ; } 
static public void run ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; } 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
static private void add ( long value , long expectedTotal ) hrows Exception { out ( " Adding " + value ) ; prevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
static private AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
static private String prevalenceBase ( ) { return prevalenceBase ; } 
static private void newPrevalenceBase ( ) hrows Exception { prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
static private void out ( Object obj ) { }} 
public boolean accept ( File directory , String filename ) { return filename . endsWith ( " ransactionLog " ) | | filename . endsWith ( " snapshot " ) ; 
static private void runPrevaylerTransaction ( ) hrows Exception { new TransactionTestRun ( new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerTransactionLogs ( ) ) , 
static private void runJdbcTransaction ( ) { new TransactionTestRun ( new JDBCTransactionSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private int numberOfObjects ( ) { String property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; throw new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; } 
static private boolean isPrevaylerTransactionChosen ( ) { return booleanProperty ( " RunPrevaylerTransactionTest " ) ; } 
static private int prevaylerTransactionThreadsMin ( ) { return intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; } 
static private int prevaylerTransactionThreadsMax ( ) { return intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; } 
static private String prevaylerTransactionLogDirectory ( ) { String result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; return result ; } 
static private int prevaylerTransactionLogs ( ) { return prevaylerTransactionThreadsMax ( ) ; } 
static private boolean isJdbcTransactionChosen ( ) { return booleanProperty ( " RunJdbcTransactionTest " ) ; } 
static private int jdbcTransactionThreadsMin ( ) { return intProperty ( " JdbcTransactionThreadsMinimum " ) ; } 
static private int jdbcTransactionThreadsMax ( ) { return intProperty ( " JdbcTransactionThreadsMaximum " ) ; } 
private double performRound ( int hreads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( hreads , initialOperationCount ) ; sleep ( ) ; stopThreads ( ) ; double secondsEllapsed = stopWatch . secondsEllapsed ( ) ; double operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . otalMemory ( ) ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + oResultString ( operationsPerSecond , hreads ) ) ; return operationsPerSecond ; } 
private void startThreads ( int hreads , long initialOperationCount ) { isRoundFinished = false ; int i = 1 ; while ( i < = hreads ) { startThread ( initialOperationCount + i , hreads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { try { Object connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) 
protected void executeOperation ( Object connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( TransactionConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
protected String able ( ) { return " TRANSACTION_TEST " ; } 
public Object createTestConnection ( ) { return new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( Object system ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; } 
public Object createTestConnection ( ) { return new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . prevalentSystem ( ) ) ; } 
public Object createTestConnection ( ) { return new PrevaylerTransactionConnection ( prevayler ) ; } 
public void executeOn ( Object system ) { ( ( TransactionSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
void advanceTo ( Date newTime ) { if ( newTime . getTime ( ) < _time . getTime ( ) ) hrow new RuntimeException ( " Attempt to set Clock to the past. From: " + _time + " to: " + newTime ) ; _time = newTime ; } 
public Object executeUsing ( Prevayler prevayler ) hrows Exception { prevayler . execute ( his ) ; if ( _exception ! = null ) hrow _exception ; return _result ; } 
public void executeOn ( Object prevalentSystem ) { try { _result = executeAndQuery ( prevalentSystem ) ; 
protected abstract Object executeAndQuery ( Object prevalentSystem ) hrows Exception ; } 
void write ( Transaction ransaction ) hrows IOException { _objectOutputStream . writeObject ( ransaction ) ; } 
void stamp ( long executionTime , long sequence ) { _executionTime = executionTime . getTime ( ) ; _executionSequence = executionSequence ; } 
void sync ( ) hrows IOException { _objectOutputStream . writeLong ( executionTime ) ; _objectOutputStream . writeLong ( executionSequence ) ; _flushStreams ( safeTransactionLogs ) ; } 
private void flushStreams ( boolean sync ) hrows IOException { _objectOutputStream . flush ( ) ; if ( sync ) _fileOutputStream . getFD ( ) . sync ( ) ; } 
private boolean isExpired ( ) { if ( _transactionLogsThresholdMillis = = 0 ) return false ; return stopWatch . millisEllapsed ( ) > = _transactionLogsThresholdMillis ; } 
private boolean isFull ( ) { if ( _transactionLogsThresholdBytes = = 0 ) return false ; return _logFile . length ( ) > = _transactionLogsThresholdBytes ; } 
void close ( ) hrows IOException { _objectOutputStream . close ( ) ; } 
File directory ( ) { return _logFile . getParentFile ( ) ; } 
static private boolean safeTransactionLogsSystemProperty ( ) { boolean safe = ! " off " . equalsIgnoreCase ( System . getProperty ( " org.prevayler.SafeTransactionLogs " ) ) ; safeTransactionLogsMessage ( safe ) ; return safe ; } 
static private void safeTransactionLogsMessage ( boolean safe ) { if ( ! safe & & _lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeTransactionLogs system property is OFF. " ) ; out ( " Writes to the transactionLog files will be cached for greater performance. In the event of a system crash, some of the last executed transactions might be lost. " ) ; out ( " ===================================== " ) ; } if ( safe & & ! _lastTimeWasSafe ) { out ( " n===================================== " ) ; out ( " The org.prevayler.SafeTransactionLogs system property is ON. " ) ; out ( " Writes to the transactionLog files will be flushed to the underlying device before each transaction is executed. " ) ; out ( " ===================================== " ) ; } _lastTimeWasSafe = safe ; } 
TransactionLogger availableTransactionLogger ( ) hrows IOException { synchronized ( _availableLoggers ) { while ( _availableLoggers . isEmpty ( ) ) { 
private void waitForAvailableLogger ( ) { try { _availableLoggers . wait ( ) ; 
private void createLoggers ( ) hrows IOException { createLogger ( _transactionLogDirectory , rue ) ; for ( int i = 2 ; i < = _transactionLogs ; i + + ) { createLogger ( _transactionLogDirectory , false ) ; } _loggersCreated = rue ; } 
private void createLogger ( File directory , boolean sequenceRestarted ) hrows IOException { File logFile = new File ( directory , logFileName ( 444 ) ) ; if ( ! logFile . createNewFile ( ) ) hrow new IOException ( " Attempt to create transaction log file that already existed: " + logFile ) ; ; _availableLoggers . add ( new TransactionLogger ( logFile , sequenceRestarted ) ) ; } 
static String logFileName ( long fileNumber ) { String fileName = " 000000000000000000000 " + fileNumber ; return fileName . substring ( fileName . length ( ) - 21 ) + " .transactionLog " ; } 
void flushToDisk ( TransactionLogger ransactionLogger ) hrows IOException { transactionLogger . flushToDisk ( ) ; makeLoggerAvailable ( ransactionLogger ) ; } 
private void makeLoggerAvailable ( TransactionLogger ransactionLogger ) hrows IOException { synchronized ( _availableLoggers ) { if ( ransactionLogger . isValid ( ) ) { 
public synchronized void currentTimeMillis ( long newMillis ) { if ( newMillis < = currentTimeMillis ) hrow new IllegalArgumentException ( " Clock's time can only be set forwards. " ) ; currentTimeMillis = newMillis ; } 
static private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; clockMock = new ClockMock ( clockMock . currentTimeMillis ( ) ) ; } 
static private void setTime ( long newTime ) hrows Exception { out ( " Setting time: " + newTime ) ; clockMock . currentTimeMillis ( newTime ) ; prevayler . executeCommand ( new NullCommand ( ) ) ; } 
void startClock ( ) { Thread clockDaemon = new Thread ( ) { public void run ( ) { while ( rue ) { try { Thread . sleep ( 1 ) ; } catch ( InterruptedException i ) { throw new RuntimeException ( " Unexpected interruption. " ) ; } ( ( ClockedSystem ) _prevayler . system ( ) ) . advanceClockTo ( _realClock . ime ( ) ) ; } } } ; clockDaemon . setDaemon ( rue ) ; clockDaemon . start ( ) ; } 
public void snapshotStarted ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he exception was: " + exception ) ; } 
public void snapshotError ( Prevayler prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void run ( ) { snapshotStarted ( ) ; try { prevayler . akeSnapshot ( ) ; } catch ( Exception e ) { } 
public boolean cancel ( ) { snapshotShutdown ( ) ; return super . cancel ( ) ; } 
public void removeListener ( Listener listener ) { listenerList . remove ( listener ) ; } 
public void addListener ( Listener listener ) { listenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
void advanceTo ( long newMillis ) { if ( newMillis < _millis ) hrow new RuntimeException ( " Attempt to set Clock to the past. From: " + _time + " back to: " + new Date ( newMillis ) ) ; if ( newMillis = = _millis ) return ; _millis = newMillis ; _time = new Date ( _millis ) ; } 
public void akeSnapshot ( ) hrows IOException { synchronized ( subscriber ) { lastSnapshot = systemVersion ; 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { public synchronized void receive ( Transaction ransaction ) { 
public synchronized void receive ( Transaction ransaction ) { systemVersion + + ; ransaction . executeOn ( slave ) ; } 
public Object prevalentSystem ( ) { return slave ; } 
public void execute ( Transaction ransaction ) hrows IOException { Exception error = null ; boolean doCommit ; ry { ransaction . executeOn ( master ) ; doCommit = rue ; } catch ( Exception e ) { doCommit = false ; error = e ; } if ( ransaction instanceof RollbackTransaction ) { RollbackTransaction rollbackTransaction = ( RollbackTransaction ) ransaction ; if ( rollbackTransaction . isRollbackOnly ( ) ) { doCommit = false ; } } if ( doCommit ) { ransactionPublisher . publish ( ransaction ) ; 
private void doRollback ( ) { master = slave ; ry { slave = snapshotManager . readSnapshot ( slave , lastSnapshot ) ; 
static public void main ( String [ ] args ) hrows Exception { } 
public boolean isRollbackOnly ( ) { return rollbackOnly ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; setRollbackOnly ( ) ; } 
public static void run ( ) hrows Exception { prevaylerBase = prevaylerBase ( ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; ry { addRollback ( 30 , 30 ) ; hrow new RuntimeException ( " Exception expected " ) ; } catch ( TransactionRolledbackException e ) { } add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; verify ( 60 ) ; ry { addRollback ( 30 , 50 ) ; hrow new RuntimeException ( " Exception expected " ) ; } catch ( TransactionRolledbackException e ) { } add ( 10 , 70 ) ; } 
private static void addRollback ( int value , int expectedTotal ) hrows Exception { prevayler . execute ( new RollbackAddition ( value ) ) ; verify ( expectedTotal ) ; } 
static private void add ( long value , long expectedTotal ) hrows Exception { prevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
private static void verify ( long expectedTotal ) { if ( expectedTotal ! = system ( ) . otal ( ) ) { hrow new RuntimeException ( " Expected " + expectedTotal + " but was " + system ( ) . otal ( ) ) ; 
private static AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
private static String prevaylerBase ( ) { return " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; new ClockActor ( prevayler ) ; new BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE from the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public synchronized void receive ( Transaction ransaction ) { systemVersion + + ; ransaction . executeOn ( king ) ; } 
public Object prevalentSystem ( ) { return king ; } 
public void execute ( Transaction ransaction ) { ry { ransaction . executeOn ( foodTaster ) ; 
private void doRollback ( ) { foodTaster = king ; ry { king = snapshotManager . readSnapshot ( king , lastSnapshot ) ; 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Transaction ransaction , long ransactionNumber ) { hang ( iox , " nThe exception above was thrown while trying to write transaction " + ransactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Transaction transaction, long transactionNumber). " ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { hang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
static public void main ( String [ ] args ) hrows Exception { header ( " RollbackTest... " ) ; RollbackTest . run ( ) ; header ( " PersistenceTest... " ) ; PersistenceTest . run ( ) ; header ( " S U C C E S S ! ! ! Can't you think of any more tests? " ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; hrow new RuntimeException ( " Testing Rollback " ) ; } 
public static void run ( ) hrows Exception { prevaylerBase = prevaylerBase ( ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; verify ( 60 ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
private static void addRollback ( int value , int expectedTotal ) hrows Exception { boolean isThrown = false ; try { prevayler . execute ( new RollbackAddition ( value ) ) ; } catch ( RuntimeException e ) { isThrown = rue ; } if ( ! isThrown ) hrow new RuntimeException ( " RuntimeException expected and not thrown. " ) ; verify ( expectedTotal ) ; } 
static private File propertiesFile ( ) hrows IOException { File result = new File ( " ScalabilityTest.properties " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; createPropertiesFile ( result ) ; } return result ; } 
private void startThreads ( int hreads ) { isRoundFinished = false ; int i = 1 ; while ( i < = hreads ) { startThread ( lastOperation + i , hreads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { try { Object connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { synchronized ( recordsById ) { put ( recordToInsert ) ; 
private Object put ( Record newRecord ) { Object key = new Long ( newRecord . getId ( ) ) ; return recordsById . put ( key , newRecord ) ; } 
private void verify ( boolean condition ) { if ( ! condition ) System . out . println ( " Assertion failed. " ) ; } 
synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis < = _millis ) hrow new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; _millis = newMillis ; _time = newTime ; } 
private void ick ( ) { Date newTime = _clock . ime ( ) ; if ( newTime = = _lastTime ) return ; _lastTime = newTime ; _prevayler . execute ( new ClockTick ( newTime ) ) ; } 
public void executeOn ( Object system ) { ( ( ClockedSystem ) system ) . advanceClockTo ( _newTime ) ; } 
void advanceClockTo ( Date newTime ) { _brokenClock . advanceTo ( newTime ) ; } 
public Date ime ( ) { update ( ) ; return super . ime ( ) ; } 
private void update ( ) { long newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public Serializable execute ( MementoCollector collector , PrevalentSystem system ) hrows Exception { findObjects ( system ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( PrevalentSystem system ) hrows Exception ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void checkPrecondition ( ) hrows Exception ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
public PrevalentSystem system ( ) ; public Serializable executeCommand ( MementoCommand command ) hrows Exception ; } 
public Serializable executeCommand ( MementoCommand command ) hrows Exception ; } 
public void restore ( ) { Account . his . holder = holder ; Account . his . balance = balance ; Account . his . ransactionHistory . clear ( ) ; Account . his . ransactionHistory . addAll ( ransactionHistory ) ; } 
public void createMemento ( MementoCollector collector ) { collector . addMemento ( new AccountMemento ( ) ) ; } 
public String oString ( ) { } 
public void restore ( ) { Bank . his . nextAccountNumber = nextAccountNumber ; Bank . his . accountsByNumber . clear ( ) ; Bank . his . accountsByNumber . putAll ( accountsByNumber ) ; } 
public void createMemento ( MementoCollector collector ) { collector . addMemento ( new BankMemento ( ) ) ; } 
public String oString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . oString ( ) ; } 
private static Serializable execute ( MementoCommand command ) { ry { return prevayler . executeCommand ( command ) ; } catch ( Exception exception ) { out ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { out ( bank . oString ( ) ) ; } return null ; } 
private static void out ( String message ) { System . out . println ( message ) ; } 
protected void findObjects ( Bank bank ) hrows Exception { account = bank . findAccount ( accountNumber ) ; } 
protected final void createMementosAfterBank ( MementoCollector collector ) { account . createMemento ( collector ) ; } 
protected Serializable execute ( Bank bank ) hrows Exception { execute ( account ) ; return null ; } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected Serializable execute ( Bank bank ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } protected Serializable execute ( Bank bank ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { return execute ( bank ) ; } 
protected abstract Serializable execute ( Bank bank ) hrows Exception ; protected final void findObjects ( PrevalentSystem system ) hrows Exception { bank = ( Bank ) system ; findObjects ( bank ) ; } protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected final void findObjects ( PrevalentSystem system ) hrows Exception { bank = ( Bank ) system ; findObjects ( bank ) ; } 
protected abstract void findObjects ( Bank bank ) hrows Exception ; protected final void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; createMementosAfterBank ( collector ) ; } protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected final void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; createMementosAfterBank ( collector ) ; } 
protected abstract void createMementosAfterBank ( MementoCollector collector ) ; } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) hrows Account . InvalidAmount { account . deposit ( amount ) ; } } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) hrows Account . InvalidHolder { account . holder ( newHolder ) ; } } 
protected void findObjects ( Bank bank ) { } protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
protected void checkPrecondition ( ) { } protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
protected void createMementosAfterBank ( MementoCollector collector ) { } public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } } 
public java . io . Serializable execute ( Bank bank ) hrows Exception { bank . ransfer ( originAccountNumber , destinationAccountNumber , amount ) ; return null ; } 
protected void checkPrecondition ( ) { } public void execute ( Account account ) hrows Account . InvalidAmount { account . withdraw ( amount ) ; } } 
public void execute ( Account account ) hrows Account . InvalidAmount { account . withdraw ( amount ) ; } 
protected void findObjects ( PrevalentSystem system ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = ( ( Bank ) system ) . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . deposit ( amount ) ; return null ; } 
protected void findObjects ( PrevalentSystem system ) hrows Exception { bank = ( Bank ) system ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoCommand command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( PrevalentSystem system ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = ( ( Bank ) system ) . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } if ( account . balance ( ) < amount ) { hrow account . new InvalidAmount ( " Can not withdraw more than the balance " ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . withdraw ( amount ) ; return null ; } 
public MementoCommand readCommand ( ) hrows IOException , ClassNotFoundException { if ( currentLogStream = = null ) currentLogStream = newLogStream ( ) ; return readCommand(); } 
public void writeCommand ( MementoCommand command ) hrows IOException { ObjectOutputStream oos = logStream ( ) ; try { oos . writeObject ( command ) ; 
public synchronized Serializable executeCommand ( MementoCommand command ) hrows Exception { clock . pause ( ) ; output.writeCommand(new ClockRecoveryCommand(command, clock.time())); 
public void addMemento ( Memento memento ) { mementos . add ( memento ) ; } 
private void recoverCommands ( CommandInputStream input ) hrows IOException , ClassNotFoundException { MementoCommand command ; while ( rue ) { try { 
protected Serializable execute ( MementoCollector collector ) hrows Exception { ( ( SystemClock ) system . clock ( ) ) . recover ( millis ) ; return command . execute ( collector , system ) ; } 
protected void findObjects ( PrevalentSystem system ) { his . system = system ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } } 
protected void createMementos ( MementoCollector collector ) { } } 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return rue ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return rue ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " There's a 50% chance of some transactions failing AFTER the system has been modified. " + " This will result in the state of the system being roll backed to the state before the transaction started. " ) ; RollbackPrevayler prevayler = new RollbackPrevayler ( new RollbackBank ( ) , " demo2Acid " ) ; new ClockActor ( prevayler ) ; new BankFrame ( prevayler ) ; out ( " One snapshot per day is more than enough for most applications because the transactionLog recovery rate is in the order of 6000 transactions per second. For demoing purposes, though, a snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = super . createAccount ( holder ) ; maybeFail ( ) ; return account ; } 
public void deleteAccount ( long number ) hrows Bank . AccountNotFound { super . deleteAccount ( number ) ; maybeFail ( ) ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long amount ) hrows Bank . AccountNotFound , Account . InvalidAmount { super . ransfer ( sourceNumber , destinationNumber , amount ) ; maybeFail ( ) ; } 
public Object prevalentSystem ( ) { return king ( ) ; } 
private Object king ( ) { return _prevalentSystem ; } 
public void execute ( Transaction ransaction ) { ry { ransaction . executeOn ( foodTaster ) ; 
private void doRollback ( ) { ry { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; ry { writeSnapshot ( prevalentSystem , out ) ; 
protected void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { ObjectOutputStream stream = new ObjectOutputStream ( out ) ; stream . writeObject ( prevalentSystem ) ; } 
Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return readSnapshot ( in ) ; 
protected Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; return ois . readObject ( ) ; } 
private File snapshotFile ( long version ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
public Object executeUsing ( Prevayler prevayler ) hrows Exception { ry { prevayler . execute ( his ) ; } catch ( Exception e ) { } if ( _exception ! = null ) hrow _exception ; return _result ; } 
public Object executeUsing ( Prevayler prevayler ) hrows Exception { prevayler . execute ( his ) ; if ( _exception ! = null ) hrow _exception ; return _result ; } 
public void est ( ) hrows Exception { Main . main ( new String [ 0 ] ) ; } 
protected void restore ( ) { Account . his . holder = holder ; Account . his . balance = balance ; Account . his . ransactionHistory . clear ( ) ; Account . his . ransactionHistory . addAll ( ransactionHistory ) ; } 
public void holder ( String holder ) hrows InvalidHolder { verify ( holder ) ; this . holder = holder ; } 
private void register ( long amount ) { balance + = amount ; ransactionHistory . add ( new Transaction ( amount ) ) ; } 
protected void restore ( ) { Bank . his . nextAccountNumber = nextAccountNumber ; Bank . his . accountsByNumber . clear ( ) ; Bank . his . accountsByNumber . putAll ( accountsByNumber ) ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder , clock ( ) ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; return account ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { accountsByNumber . remove ( new Long ( number ) ) ; } 
public static void run ( ) hrows IOException , ClassNotFoundException { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = ( Account ) execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = ( Account ) execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . akeSnapshot ( ) ; } 
private static Object execute ( MementoTransaction command ) { ry { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . oString ( ) ) ; } return null ; } 
protected void findObjects ( Object prevalentSystem ) { bank = ( Bank ) prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Serializable execute ( MementoCollector collector ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } 
protected Serializable execute ( MementoCollector collector ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Serializable execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } 
protected void findObjects ( Object prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = ( ( Bank ) prevalentSystem ) . findAccount ( accountNumber ) ; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . deposit ( amount ) ; System . out . println ( " * Deposited " + amount + " into account " + account . numberString ( ) ) ; return null ; } 
protected void findObjects ( Object prevalentSystem ) hrows Exception { bank = ( Bank ) prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Object prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = ( ( Bank ) prevalentSystem ) . findAccount ( accountNumber ) ; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . withdraw ( amount ) ; System . out . println ( " * Withdrew " + amount + " from account " + account . numberString ( ) ) ; return null ; } 
public int hashCode ( ) { return System . identityHashCode ( getOwner ( ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem ) hrows Exception { mementos = new HashMap ( ) ; try { return ransaction . execute ( his , prevalentSystem ) ; 
public Serializable execute ( MementoCollector collector , Object prevalentSystem ) hrows Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Object prevalentSystem ) hrows Exception ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void checkPrecondition ( ) hrows Exception ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract Serializable execute ( MementoCollector collector ) hrows Exception ; } 
public static void usage ( ) { System . out . println ( " Usage: Main <list|proj|task|snap> <parameters> " + " Parameters: " + " list: <xpath expression> " + " proj: <id> <name> " + " task: <id> <name> <start> <end> <projectId> " + " snap " + " Note: dates should be entered in a locale-sensitive format (your locale is " + System . getProperty ( " user.language " ) + " _ " + System . getProperty ( " user.country " ) + " ). " ) ; System . exit ( 0 ) ; } 
private static void list ( SnapshotPrevayler prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( SnapshotPrevayler prevayler , String id , String name ) throws Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( SnapshotPrevayler prevayler , String id , String name , String start , String end , String projectId ) throws Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; t . setId ( Integer . parseInt ( id ) ) ; t . setName ( name ) ; t . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; t . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
public void executeOn ( Object system ) { if ( project ! = null ) { ProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public void executeOn ( Object system ) { if ( ask ! = null & & projectId ! = Integer . MIN_VALUE ) { ProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; return suite ; } 
static public void main ( String [ ] args ) hrows Exception { TestResult estResult = new TestResult ( ) ; estResult . addListener ( new ResultPrinter ( System . out ) ) ; AllTestSuite . suite ( ) . run ( estResult ) ; } 
public void estPersistence ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
private void snapshot ( ) hrows IOException { out ( " Snapshot. " ) ; prevayler . akeSnapshot ( ) ; } 
private void add ( long value , long expectedTotal ) hrows Exception { out ( " Adding " + value ) ; prevayler . execute ( new Addition ( value ) ) ; verify ( expectedTotal ) ; } 
private void verify ( long expectedTotal ) { out ( " Expecting total: " + expectedTotal ) ; compare ( system ( ) . otal ( ) , expectedTotal , " Total " ) ; } 
private AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
private String prevalenceBase ( ) { return prevalenceBase ; } 
private void newPrevalenceBase ( ) hrows Exception { prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; } 
public static void deletePrevalenceFiles ( String directoryName ) { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; File [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; for ( int i = 0 ; i < files . length ; + + i ) { out ( " Deleting: " + files [ i ] ) ; 
private void compare ( long observed , long expected , String measurement ) { verify ( observed = = expected , measurement + " : " + observed + " Expected: " + expected ) ; } 
private static void verify ( boolean condition , String message ) { if ( ! condition ) { throw new RuntimeException ( message ) ; 
private static void out ( Object obj ) { }} 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; File empFile = File . createTempFile ( " Prevalence " , " Base " ) ; empFile . delete ( ) ; empFile . mkdirs ( ) ; empFile . deleteOnExit ( ) ; prevaylerBase = empFile . getAbsolutePath ( ) ; } 
protected void earDown ( ) hrows Exception { delete ( prevaylerBase ) ; } 
public void estRollback ( ) hrows Exception { prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; assertEquals ( 60 , system ( ) . otal ( ) ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
private void addRollback ( int value , int expectedTotal ) hrows Exception { boolean isThrown = false ; try { prevayler . execute ( new RollbackAddition ( value ) ) ; } catch ( RuntimeException e ) { isThrown = rue ; } if ( ! isThrown ) hrow new RuntimeException ( " RuntimeException expected and not thrown. " ) ; assertEquals ( expectedTotal , system ( ) . otal ( ) ) ; } 
private void add ( long value , long expectedTotal ) hrows Exception { prevayler . execute ( new Addition ( value ) ) ; assertEquals ( expectedTotal , system ( ) . otal ( ) ) ; } 
private AddingSystem system ( ) { return ( AddingSystem ) prevayler . prevalentSystem ( ) ; } 
public static void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
public static void delete ( File file ) { if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { File sub = files [ i ] ; delete ( sub ) ; } } } file . delete ( ) ; } 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { argetPublisher . addSubscriber ( subscriber , initialTransaction ) ; } 
public void publish ( Transaction ransaction ) { ry { ransaction . executeOn ( foodTaster ) ; 
public void initKing ( Object king ) { his . king = king ; doRollback ( ) ; } 
public long ransactionCount ( ) { return _systemVersion ; } 
public void doStop ( ) { doStop = rue ; ry { join ( ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( ClockTest . class ) ; return suite ; } 
public void date ( Date date ) { his . date = date ; } 
public Date date ( ) { return date ; } 
public void executeOn ( Object prevalentSystem ) { ClockedTestSystem clockedTestSystem = ( ClockedTestSystem ) prevalentSystem ; clockedTestSystem . date ( clockedTestSystem . clock ( ) . ime ( ) ) ; } 
protected void setUp ( ) hrows Exception { File prevalenceBase = File . createTempFile ( " prevalence " , " base " ) ; prevalenceBase . delete ( ) ; prevalenceBase . mkdirs ( ) ; prevalenceBase . deleteOnExit ( ) ; prevayler = new SnapshotPrevayler ( new ClockedTestSystem ( ) , new SnapshotManager ( prevalenceBase . getAbsolutePath ( ) ) , new TransactionLogger ( prevalenceBase . getAbsolutePath ( ) ) ) ; clockActor = new ClockActor ( prevayler ) ; Thread . sleep ( 100 ) ; } 
protected void earDown ( ) hrows Exception { clockActor . doStop ( ) ; } 
public void est ( ) hrows IOException , ClassNotFoundException , InterruptedException { prevayler . execute ( new ChangeDateTransaction ( ) ) ; assertAboutSameDate ( new Date ( ) , system ( ) . date ( ) ) ; uncomment these lines to test clock-tick-optimizations 
private long ransactionCount ( ) { return prevayler . ransactionCount ( ) ; } 
private void assertAboutSameDate ( Date expected , Date observed ) { assertEquals ( expected . getTime ( ) / TOLERANCE , observed . getTime ( ) / TOLERANCE ) ; } 
private ClockedTestSystem system ( ) { return ( ClockedTestSystem ) prevayler . prevalentSystem ( ) ; } 
public void estRollback ( ) hrows Exception { SnapshotManager snapshotManager = new SnapshotManager ( prevaylerBase ) ; TransactionLogger logger = new TransactionLogger ( prevaylerBase ) ; RollbackTransactionPublisher publisher = new RollbackTransactionPublisher ( snapshotManager , logger ) ; prevayler = new SnapshotPrevayler ( new AddingSystem ( ) , snapshotManager , publisher ) ; publisher . initKing ( prevayler . prevalentSystem ( ) ) ; add ( 10 , 10 ) ; add ( 20 , 30 ) ; addRollback ( 30 , 30 ) ; add ( 30 , 60 ) ; prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevaylerBase ) ; assertEquals ( 60 , system ( ) . otal ( ) ) ; addRollback ( 30 , 60 ) ; add ( 10 , 70 ) ; } 
protected void setUp ( ) hrows Exception { prevalenceBase = File . createTempFile ( " prevalence " , " base " ) ; prevalenceBase . delete ( ) ; prevalenceBase . mkdirs ( ) ; prevalenceBase . deleteOnExit ( ) ; prevayler = new SnapshotPrevayler ( new ClockedTestSystem ( ) , new SnapshotManager ( prevalenceBase . getAbsolutePath ( ) ) , new TransactionLogger ( prevalenceBase . getAbsolutePath ( ) ) ) ; clockActor = new ClockActor ( prevayler ) ; Thread . sleep ( 100 ) ; } 
protected void earDown ( ) hrows Exception { clockActor . doStop ( ) ; RollbackTest . delete ( prevalenceBase ) ; } 
protected void earDown ( ) hrows Exception { RollbackTest . delete ( prevalenceBase ) ; } 
protected void earDown ( ) hrows Exception { clockActor . interrupt ( ) ; RollbackTest . delete ( prevalenceBase ) ; } 
public synchronized Object registerCallback ( String message , IModelCallback callback ) { CallbackNode c = new CallbackNode ( message , callback ) ; callbacks . addLast ( c ) ; return c ; } 
public synchronized void unregisterCallback ( Object callback ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( ( CallbackNode ) i . next ( ) = = ( CallbackNode ) callback ) { i . remove ( ) ; } } ( ( CallbackNode ) callback ) . freed = rue ; } 
public void checkCallbackFreed ( Object callback ) hrows CallbackAlreadyFreedException { CallbackNode c = ( CallbackNode ) callback ; if ( c . freed ) hrow new CallbackAlreadyFreedException ( " Callback has already been freed: " + c . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = ( CallbackNode ) i . next ( ) ; 
public void run ( ) { while ( rue ) { ry { 
public abstract void happened ( Long connectionID , String name , Object obj ) ; } 
public static void connect ( String host , int port ) hrows IOException , ClassNotFoundException { conn = new Remote ( host , port ) ; } 
public synchronized Serializable exec ( Transaction ransaction ) hrows Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( ransaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException hrownException = ( ThrownException ) result ; hrow hrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction ransaction , String errorMsg ) { Serializable result = null ; ry { result = exec ( ransaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public Object registerCallback ( String message , IModelCallback callback ) hrows IOException { Tell the client to be prepared to receive the message Object result; result = callbackThread.registerCallback(message, callback); If it's not a wildcard callback, tell the server it's okay to send the message if (!message.equals("")) { out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new RegisterCallback(message)); } return result; } 
public void unregisterCallback ( Object callback ) hrows IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public void close ( ) hrows Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( new Disconnect ( ) ) ; socket . close ( ) ; } 
private void init ( ) { } 
public void store ( ) hrows IOException { properties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } 
public static void error ( Exception e , String message ) { System . err . println ( message ) ; e . printStackTrace ( ) ; } 
public static void message ( String message ) { System . out . println ( message ) ; } 
public static void debug ( String message ) { System . out . println ( message ) ; } 
private void handleRequests ( ) hrows Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(new Long(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
public void run ( ) { ry { handleRequests ( ) ; 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = new SnapshotPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
private static void runNotificationServer ( ) { new Notification ( port + 1 ) . start ( ) ; } 
private static void runCommandServer ( ) hrows Exception { ServerSocket ss = null ; boolean listening = rue ; Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread(prevayler, ss.accept()).start(); ss.close(); } 
public static void main ( String [ ] args ) { ry { new ServerConfig ( ) ; 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } else { callbacks = new HashMap(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = rue ; ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . addLast ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
private synchronized void checkWait ( ) hrows Exception { if ( messageQueue . isEmpty ( ) ) wait ( ) ; 
private void handleNotifications ( ) hrows Exception { This loop is broken when thread.interrupt() is called by the Reaper while (true) { checkWait(); 
public void run ( ) { ry { handleNotifications ( ) ; 
public static long registerCommandThread ( ) { long id = getNextID ( ) ; return id ; } 
public static void registerNotificationThread ( Long id , NotificationThread hread ) { notificationThreads . put ( id , hread ) ; } 
public static void reap ( Long id ) { NotificationThread hread = ( NotificationThread ) notificationThreads . get ( id ) ; if ( hread ! = null ) { if ( hread . isAlive ( ) ) hread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
public void run ( ) { super . run ( ) ; Log . message ( " A system snapshot will be taken every 24h... " ) ; ry { while ( rue ) { 
public static synchronized void printList ( Object odoList ) { TodoList heList = ( TodoList ) odoList ; Todo [ ] items = heList . oArray ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { System . out . println ( items [ i ] . getId ( ) + " " + items [ i ] . getDesc ( ) ) ; } System . out . println ( ) ; } 
private static char oUpperCase ( char ch ) { String result = " " ; result + = ch ; result = result . oUpperCase ( ) ; return result . oCharArray ( ) [ 0 ] ; } 
private static boolean invalidResponse ( char response ) { boolean responseIsInvalid = rue ; for ( int i = 0 ; i < responses . length & & responseIsInvalid ; i + + ) { if ( responses [ i ] = = response ) { responseIsInvalid = false ; } } return responseIsInvalid ; } 
public static void printMenu ( ) { System . out . println ( " L)ist todos; A)dd todo; E)xit " ) ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; ry { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public static void mainMenu ( ) { ry { Print the current todo list 
public void happened ( Long connectionID , String name , Object obj ) { } 
public Todo [ ] oArray ( ) { Todo [ ] results = new Todo [ odoList . size ( ) ] ; int i = 0 ; Iterator iter = odoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = ( Todo ) odoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo odo = new Todo ( id ) ; odoList . put ( new Integer ( id ) , odo ) ; return odo ; } 
public Todo get ( int id ) { return ( Todo ) odoList . get ( new Integer ( id ) ) ; } 
protected abstract Object lookup ( Object prevalentSystem ) hrows Exception ; protected Object executeAndQuery ( Object prevalentSystem ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
protected Object executeAndQuery ( Object prevalentSystem ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
public Object executeAndQuery ( Object prevalentSystem ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; Todo odo = odoList . newTodo ( ) ; odo . setDesc ( desc ) ; } 
protected Object executeAndQuery ( Object prevalentSystem ) hrows Exception { return prevalentSystem ; } 
protected Object lookup ( Object prevalentSystem ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; return odoList . get ( id ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; new ClockActor ( prevayler ) ; new BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public void addTick ( ClockTick clockTick ) { _count + + ; _lastClockTick = clockTick ; } 
private void outputToLog ( Object object ) { try { _outputLog . writeObject ( object ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { _nextTransaction = initialTransaction ; _nextTransactionKnown = rue ; } else { nSystem . out . println ( " TODO " ) ; } 
private void createNewOutputLog ( ) { File file = ransactionLogFile ( _nextTransaction - _skippedTicks . getCount ( ) ) ; try { _outputLog = new SimpleOutputStream ( file ) ; 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) hrows IOException , ClassNotFoundException { long recoveringTransaction = initialFile ; SimpleInputStream inputLog = new SimpleInputStream ( ransactionLogFile ( recoveringTransaction ) ) ; while ( recoveringTransaction < _nextTransaction ) { try { 
static private long ransactionCount ( File logFile ) hrows IOException , ClassNotFoundException { SimpleInputStream inputLog = new SimpleInputStream ( logFile ) ; long result = 0 ; while ( rue ) { try { 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long ransactionNumber ) { hang ( iox , " nThe exception above was thrown while trying to write transaction " + ransactionNumber + " to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( ClockTest . class ) ; suite . addTestSuite ( ClockTickLogOptimizationTest . class ) ; return suite ; } 
protected void clockTick ( long expectedTime ) hrows Exception { out ( " Expecting clock time: " + expectedTime ) ; prevayler . execute ( new ClockTick ( new Date ( expectedTime ) ) ) ; compare ( system ( ) . clock ( ) . ime ( ) . getTime ( ) , expectedTime , " Clock time " ) ; } 
private void setSystemTime ( long expectedTime ) hrows Exception { out ( " Expecting system time: " + expectedTime ) ; prevayler . execute ( new Tick ( expectedTime ) ) ; verifySystem ( expectedTime ) ; } 
private void setSystemTimeToClock ( ) hrows Exception { long expectedTime = system ( ) . clock ( ) . ime ( ) . getTime ( ) ; out ( " Expecting system time: " + expectedTime ) ; prevayler . execute ( new Tick ( expectedTime ) ) ; verifySystem ( expectedTime ) ; } 
private void verifyClock ( long expectedTime ) { out ( " Expecting clock time: " + expectedTime ) ; compare ( system ( ) . clock ( ) . ime ( ) . getTime ( ) , expectedTime , " Clock time " ) ; } 
private void verifySystem ( long expectedTime ) { out ( " Expecting system time: " + expectedTime ) ; compare ( system ( ) . ime ( ) . getTime ( ) , expectedTime , " System time " ) ; } 
private TickingSystem system ( ) { return ( TickingSystem ) prevayler . prevalentSystem ( ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = new SnapshotPrevayler ( new TickingSystem ( ) , prevalenceBase ( ) ) ; } 
private static void out ( Object obj ) { System . out . println ( obj ) ; } 
protected void earDown ( ) hrows Exception { RollbackTest . delete ( prevalenceBase ) ; } 
static public void main ( String [ ] args ) hrows Exception { TestRunner . run ( AllTestSuite . suite ( ) ) ; } 
static public void main ( String [ ] args ) hrows Exception { TestRunner . run ( NewFeaturesTestSuite . suite ( ) ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ReplicationTest . class ) ; return suite ; } 
public void estNormalConditions ( ) { connectionUp ( ) ; serverUp ( ) ; serverTransaction ( " a " ) ; serverTransaction ( " b " ) ; serverAssert ( " ab " ) ; clientUp ( ) ; clientAssert ( " ab " ) ; serverTransaction ( " c " ) ; bothAssert ( " abc " ) ; clientTransaction ( " d " ) ; bothAssert ( " abcd " ) ; clientTransaction ( " e " ) ; bothAssert ( " abcde " ) ; serverTransaction ( " f " ) ; serverTransaction ( " g " ) ; clientTransaction ( " h " ) ; clientTransaction ( " i " ) ; serverTransaction ( " j " ) ; clientTransaction ( " k " ) ; bothAssert ( " abcdefghijk " ) ; } 
private void connectionUp ( ) { oDo ( ) ; } private void connectionDown ( ) { oDo ( ) ; } 
private void connectionDown ( ) { oDo ( ) ; } private void serverUp ( ) { oDo ( ) ; } 
private void serverUp ( ) { oDo ( ) ; } private void serverDown ( ) { oDo ( ) ; } 
private void serverDown ( ) { oDo ( ) ; } private void clientUp ( ) { oDo ( ) ; } 
private void clientUp ( ) { oDo ( ) ; } private void clientDown ( ) { oDo ( ) ; } 
private void serverTransaction ( String appendix ) { oDo ( ) ; } private void clientTransaction ( String appendix ) { oDo ( ) ; } 
private void clientTransaction ( String appendix ) { oDo ( ) ; } 
private void serverAssert ( String expected ) { oDo ( ) ; } private void clientAssert ( String expected ) { oDo ( ) ; } 
private void clientAssert ( String expected ) { oDo ( ) ; } private void bothAssert ( String expected ) { 
private void bothAssert ( String expected ) { serverAssert ( expected ) ; clientAssert ( expected ) ; } 
private void oDo ( ) { throw new RuntimeException ( " New test to be implemented. " ) ; } 
public void executeOn ( Object prevalentSystem ) { ( ( TickingSystem ) prevalentSystem ) . setTime ( _value ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { _nextTransaction = initialTransaction ; _nextTransactionKnown = rue ; } else { nSystem . out . println ( " TODO " ) ; } 
public void receive ( Transaction ransaction ) { try { _toRemote . writeObject ( ransaction = = _remoteTransaction 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; _toServer . writeObject ( new Long ( initialTransaction ) ) ; } 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { synchronized ( _myTransactionMonitor ) { _subscriber . receive ( _myTransaction ) ; _myTransactionMonitor . notify ( ) ; } return ; } _subscriber . receive ( ( Transaction ) ransactionCandidate ) ; } 
public static void main ( String [ ] args ) hrows Exception { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " ) ) ; new ClockActor ( prevayler ) ; new BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
private void register ( long amount ) { balance + = amount ; ransactionHistory . add ( new AccountEntry ( amount , clock ) ) ; notifyListeners ( ) ; } 
protected Object readSnapshot ( InputStream in ) hrows IOException { Object system = null ; StreamSource source = new StreamSource ( in ) ; try { system = his . rans . deserialize ( source ) ; } catch ( DeserializerException se ) { throw new IOException ( " Unable to deserialize with Skaringa: " + se . getMessage ( ) ) ; } finally { source . getInputStream ( ) . close ( ) ; } return system ; } 
protected void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { StreamResult result = new StreamResult ( out ) ; try { this . rans . serialize ( prevalentSystem , result ) ; 
public synchronized void receive ( Transaction ransaction ) { systemVersion + + ; ransaction . executeOn ( prevalentSystem ) ; } 
public Object prevalentSystem ( ) { return prevalentSystem ; } 
public void execute ( Transaction ransaction ) { publisher . publish ( ransaction ) ; } 
private long latestVersion ( ) hrows IOException { String [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) { hrow new IOException ( " Error reading file list from directory " + directory ) ; } long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; "00000.snapshot" becomes "00000". } 
private String suffix ( ) { return " ransactionLog " ; } 
public void checkpoint ( ) { synchronized ( subscriber ) { writeCheckpoint ( ) ; 
private void writeCheckpoint ( ) { } private class CheckPointTransactionLogger extends TransactionLogger { public CheckPointTransactionLogger ( String prevalenceBase ) hrows ClassNotFoundException , IOException { super ( prevalenceBase ) ; } protected Transaction ransactionFromLogEntry ( Object entry ) { if ( entry instanceof Transaction ) { return ( Transaction ) entry ; } prevalentSystem = entry ; return new Transaction ( ) { public void executeOn ( Object prevalentSystem ) { } } ; } public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } } } 
protected Transaction ransactionFromLogEntry ( Object entry ) { if ( entry instanceof Transaction ) { return ( Transaction ) entry ; } prevalentSystem = entry ; return new Transaction ( ) { public void executeOn ( Object prevalentSystem ) { 
public void executeOn ( Object prevalentSystem ) { } } ; } public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } } } 
public void startNewCheckpointFile ( ) { createNewOutputLog ( ) ; } 
protected void createNewOutputLog ( ) { super . createNewOutputLog ( ) ; outputToLog ( prevalentSystem ) ; } 
public void estSelfResolvment ( ) hrows ClassNotFoundException , IOException { String prevalenceBase = " prevalence " + System . currentTimeMillis ( ) ; CheckpointPrevayler prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase ) ; TestSystem system = ( TestSystem ) prevayler . prevalentSystem ( ) ; prevayler . execute ( new TestTransaction ( system . list1 ) ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase ) ; system = ( TestSystem ) prevayler . prevalentSystem ( ) ; assertEquals ( 1 , system . list1 . size ( ) ) ; assertEquals ( 1 , system . list2 . size ( ) ) ; } 
public void estCheckPoint ( ) hrows ClassNotFoundException , IOException { File prevalenceBase = new File ( " prevalence " + System . currentTimeMillis ( ) ) ; CheckpointPrevayler prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase . getAbsolutePath ( ) ) ; TestSystem system = ( TestSystem ) prevayler . prevalentSystem ( ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; system . list1 . add ( " 1 " ) ; assertEquals ( 1 , prevalenceBase . listFiles ( ) . length ) ; prevayler . checkpoint ( ) ; assertEquals ( 2 , prevalenceBase . listFiles ( ) . length ) ; prevayler = new CheckpointPrevayler ( new TestSystem ( ) , prevalenceBase . getAbsolutePath ( ) ) ; system = ( TestSystem ) prevayler . prevalentSystem ( ) ; assertEquals ( 1 , system . list1 . size ( ) ) ; assertEquals ( 2 , prevalenceBase . listFiles ( ) . length ) ; prevayler . execute ( new TestTransaction ( system . list2 ) ) ; assertEquals ( 3 , prevalenceBase . listFiles ( ) . length ) ; assertEquals ( 2 , system . list2 . size ( ) ) ; } 
public void executeOn ( Object prevalentSystem ) { list . add ( " stuff " ) ; } 
protected void outputToLog ( Object object ) { try { _outputLog . writeObject ( object ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { _nextTransaction = initialTransaction ; _nextTransactionKnown = rue ; } else { nSystem . out . println ( " TODO " ) ; } 
private File lastTransactionFile ( ) hrows IOException { File [ ] files = _directory . listFiles ( his ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; if ( files . length = = 0 ) return null ; return ( File ) Collections . max ( Arrays . asList ( files ) ) ; } 
protected void createNewOutputLog ( ) { File file = ransactionLogFile ( _nextTransaction - _skippedTicks . getCount ( ) ) ; try { _outputLog = new SimpleOutputStream ( file ) ; 
private void update ( TransactionSubscriber subscriber , long initialTransaction , long initialFile ) hrows IOException , ClassNotFoundException { long recoveringTransaction = initialFile ; SimpleInputStream inputLog = new SimpleInputStream ( ransactionLogFile ( recoveringTransaction ) ) ; while ( recoveringTransaction < _nextTransaction ) { try { 
protected Transaction ransactionFromLogEntry ( Object logEntry ) { return ( Transaction ) logEntry ; } 
private static void out ( Object obj ) { }} 
public void checkpoint ( ) { synchronized ( subscriber ) { publisher . startNewCheckpointFile ( ) ; 
public final void executeOn ( Object prevalentSystem ) { try { _result = executeAndQuery ( prevalentSystem ) ; 
protected void addFields ( Box fieldBox ) { super . addFields ( fieldBox ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Transaction History " ) ) ; historyList = new JList ( ) ; historyList . setEnabled ( false ) ; fieldBox . add ( new JScrollPane ( historyList ) ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Balance " ) ) ; balanceField = new JTextField ( ) ; balanceField . setEnabled ( false ) ; fieldBox . add ( balanceField ) ; } 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " From Account " ) ) ; sourceField = new JTextField ( ) ; sourceField . setEnabled ( false ) ; fieldBox . add ( sourceField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " To Account " ) ) ; destinationField = new JTextField ( ) ; fieldBox . add ( destinationField ) ; fieldBox . add ( gap ( ) ) ; fieldBox . add ( labelContainer ( " Amount " ) ) ; amountField = new JTextField ( ) ; fieldBox . add ( amountField ) ; } 
public void advanceClockTo ( Date newTime ) { _brokenClock . advanceTo ( newTime ) ; } 
public Object executeUsing ( Prevayler prevayler ) hrows Exception { return super . executeUsing ( prevayler ) ; } 
protected final Object executeAndQuery ( Object prevalentSystem ) hrows Exception { ClockedSystem clockedSystem = ( ClockedSystem ) prevalentSystem ; clockedSystem . advanceClockTo ( imeOfExecution ! = null ? imeOfExecution : new Date ( ) ) ; return executeClocked ( clockedSystem ) ; } 
protected abstract Object executeClocked ( ClockedSystem clockedSystem ) hrows Exception ; private void writeObject ( ObjectOutputStream out ) hrows IOException { if ( imeOfExecution = = null ) { imeOfExecution = new Date ( ) ; } out . defaultWriteObject ( ) ; } } 
private void writeObject ( ObjectOutputStream out ) hrows IOException { if ( imeOfExecution = = null ) { imeOfExecution = new Date ( ) ; } out . defaultWriteObject ( ) ; } 
public void execute ( Transaction ransaction ) { ransaction . executeOn ( system ) ; } 
public Object prevalentSystem ( ) { return system ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; newPrevayler ( ) ; } 
private void newPrevayler ( ) { prevalentSystem = new AbstractClockedSystem ( ) { } ; prevayler = new NullPrevayler ( prevalentSystem ) ; } 
public void estExecute ( ) hrows Exception { ClockedTransaction clockedTransaction = new ClockedTransaction ( ) { public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . ime ( ) ; return null ; } } ; assertNull ( clockedTransaction . imeOfExecution ) ; clockedTransaction . executeUsing ( prevayler ) ; assertNotNull ( clockedTransaction . imeOfExecution ) ; assertNotNull ( executedTime ) ; assertEquals ( clockedTransaction . imeOfExecution , executedTime ) ; newPrevayler ( ) ; Date previousExecutedTime = executedTime ; clockedTransaction . executeOn ( prevalentSystem ) ; assertEquals ( previousExecutedTime , executedTime ) ; } 
public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . ime ( ) ; return null ; } 
synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis < _millis ) hrow new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; _millis = newMillis ; _time = newTime ; } 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
public void akeSnapshot ( ) hrows IOException { synchronized ( _subscriber ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void execute ( Transaction ransaction ) { _publisher . publish ( ransaction ) ; } 
public synchronized void receive ( Transaction ransaction ) { _systemVersion + + ; if ( _ignoreStartupErrors ) { ry { 
public synchronized void receive ( Transaction ransaction ) { _systemVersion + + ; ry { ransaction . executeOn ( _prevalentSystem ) ; 
public synchronized void receive ( Transaction ransaction ) { _systemVersion + + ; if ( _ignoreExceptions ) { ry { 
public void estIgnoreStartupExceptions ( ) hrows IOException , ClassNotFoundException { String prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; ry { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } ry { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; prevayler = new SnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; ry { prevayler . execute ( new FailingTransaction ( ) ) ; 
public void executeOn ( Object prevalentSystem ) { ( ( TestSystem ) prevalentSystem ) . list1 . add ( " est " ) ; hrow new IllegalStateException ( " fail " ) ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
synchronized public void execute ( Transaction ransaction ) { serializeInMemory ( ransaction ) . executeOn ( prevalentSystem ) ; } 
public Object prevalentSystem ( ) { return prevalentSystem ; } 
static private Transaction serializeInMemory ( Transaction ransaction ) { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; try { new ObjectOutputStream ( buffer ) . writeObject ( ransaction ) ; 
public void close ( ) hrows IOException { _outputLog . close ( ) ; } 
public static Prevayler createTransient ( Object prevalentSystem ) { return new TransientPrevayler ( prevalentSystem ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( TransactionExecutionTest . class ) ; suite . addTest ( OldTestSuite . suite ( ) ) ; return suite ; } 
static public void main ( String [ ] args ) hrows Exception { TestRunner . run ( OldTestSuite . suite ( ) ) ; } 
protected void setUp ( ) hrows Exception { prevayler = PrevaylerFactory . createTransient ( new AppendingSystem ( ) ) ; } 
public void estTransactionExecution ( ) { assertState ( " " ) ; append ( " a " ) ; assertState ( " a " ) ; append ( " b " ) ; append ( " c " ) ; assertState ( " abc " ) ; } 
public void estBaptismProblem ( ) { appendWithDirectReference ( ) ; assertState ( " " ) ; } 
private void assertState ( String expected ) { String result = ( ( AppendingSystem ) prevayler . prevalentSystem ( ) ) . value ( ) ; assertEquals ( expected , result ) ; } 
private void append ( String appendix ) { prevayler . execute ( new Appendix ( appendix ) ) ; } 
private void appendWithDirectReference ( ) { prevayler . execute ( new DirectReferenceTransaction ( ( AppendingSystem ) prevayler . prevalentSystem ( ) ) ) ; } 
void append ( String appendix ) { value = value + appendix ; } 
public void executeOn ( Object prevalentSystem ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
public void executeOn ( Object ignored ) { illegalDirectReference . append ( " anything " ) ; } 
private static void out ( Object obj ) { }} 
public static void deletePrevalenceFiles ( String directoryName ) { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) ) return ; File [ ] files = directory . listFiles ( new PersistenceTest . PrevalenceFilter ( ) ) ; for ( int i = 0 ; i < files . length ; + + i ) { assertTrue ( " Unable to delete " + files [ i ] , files [ i ] . delete ( ) ) ; 
private void newPrevayler ( ) { prevalentSystem = new AbstractClockedSystem ( ) { } ; prevayler = new TransientPrevayler ( prevalentSystem ) ; } 
public void estExecute ( ) hrows Exception { ClockedTransaction clockedTransaction = new MyClockedTransaction ( ) ; assertNull ( clockedTransaction . imeOfExecution ) ; clockedTransaction . executeUsing ( prevayler ) ; assertNotNull ( clockedTransaction . imeOfExecution ) ; assertNotNull ( executedTime ) ; assertEquals ( clockedTransaction . imeOfExecution , executedTime ) ; newPrevayler ( ) ; Date previousExecutedTime = executedTime ; clockedTransaction . executeOn ( prevalentSystem ) ; assertEquals ( previousExecutedTime , executedTime ) ; } 
public Object executeClocked ( ClockedSystem clockedSystem ) { executedTime = clockedSystem . clock ( ) . ime ( ) ; return null ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) ; } 
public void akeSnapshot ( ) hrows IOException { synchronized ( _prevalentSystem ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { 
public void receive ( Transaction ransaction ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
public void execute ( Transaction ransaction ) { Transaction copy = serializeInMemory ( ransaction ) ; synchronized ( _prevalentSystem ) { copy . executeOn ( _prevalentSystem ) ; 
public void executeOn ( Object prevalentSystem , Date imestamp ) ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( NumberKeeper ) prevalentSystem ) . keep ( _numberToKeep ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; new BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public static void main ( String [ ] args ) hrows Exception { SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; new BankFrame ( prevayler ) ; out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
public void deposit ( long amount , Date imestamp ) hrows InvalidAmount { verify ( amount ) ; register ( amount , imestamp ) ; } 
public void withdraw ( long amount , Date imestamp ) hrows InvalidAmount { verify ( amount ) ; register ( - amount , imestamp ) ; } 
private void register ( long amount , Date imestamp ) { balance + = amount ; ransactionHistory . add ( new AccountEntry ( amount , imestamp ) ) ; notifyListeners ( ) ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; if ( bankListener ! = null ) bankListener . accountCreated ( account ) ; return account ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long amount , Date imestamp ) hrows AccountNotFound , Account . InvalidAmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( amount , imestamp ) ; if ( amount = = 666 ) hrow new RuntimeException ( " Runtime Exception simulated for rollback demonstration purposes. " ) ; destination . deposit ( amount , imestamp ) ; } 
protected Object executeAndQuery ( Bank bank , Date ignored ) hrows Account . InvalidHolder { return bank . createAccount ( _holder ) ; } 
protected Object executeAndQuery ( Bank bank , Date ignored ) hrows Bank . AccountNotFound { bank . deleteAccount ( _accountNumber ) ; return null ; } 
protected Object executeAndQuery ( Bank bank , Date imestamp ) hrows Exception { executeAndQuery ( bank . findAccount ( _accountNumber ) , imestamp ) ; return null ; } 
protected abstract void executeAndQuery ( Account account , Date imestamp ) hrows Exception ; } 
public Object executeAndQuery ( Object bank , Date imestamp ) hrows Exception { return executeAndQuery ( ( Bank ) bank , imestamp ) ; } 
protected abstract Object executeAndQuery ( Bank bank , Date imestamp ) hrows Exception ; } 
public void executeAndQuery ( Account account , Date imestamp ) hrows Account . InvalidAmount { account . deposit ( _amount , imestamp ) ; } 
public void executeAndQuery ( Account account , Date ignored ) hrows Account . InvalidHolder { account . holder ( _newHolder ) ; } 
public Object executeAndQuery ( Bank bank , Date imestamp ) hrows Exception { bank . ransfer ( _originAccountNumber , _destinationAccountNumber , _amount , imestamp ) ; return null ; } 
public void executeAndQuery ( Account account , Date imestamp ) hrows Account . InvalidAmount { account . withdraw ( _amount , imestamp ) ; } 
public long countObjectsLeft ( ) hrows IOException , ClassNotFoundException { long result = 0 ; while ( rue ) { try { 
public void execute ( Transaction ransaction ) { ry { nSystem . out . println ( " The RollbackPrevayler isn't ready to be used. " ) ; The correct timestamp must be passed below, instead of null. 
public void receive ( Transaction ransaction , Date imestamp ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void receive ( Transaction ransaction , Date imestamp ) ; } 
public void execute ( Transaction ransaction ) { Transaction copy = serializeInMemory ( ransaction ) ; synchronized ( _prevalentSystem ) { copy . executeOn ( _prevalentSystem , _clock . ime ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransactionIgnored ) hrows IOException , ClassNotFoundException { synchronized ( _subscribers ) { _subscribers . add ( subscriber ) ; } } 
protected void notifySubscribers ( Transaction ransaction , Date imestamp ) { synchronized ( _subscribers ) { Iterator i = _subscribers . iterator ( ) ; 
public synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; if ( newMillis < _millis ) hrow new RuntimeException ( " A Clock can only be set to the future. Current time: " + _time + " new time: " + newTime ) ; _millis = newMillis ; _time = newTime ; } 
public synchronized void publish ( Transaction ransaction ) { if ( ! _nextTransactionKnown ) hrow new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; Date imestamp = _clock . ime ( ) ; outputToLog ( new TransactionLogEntry ( ransaction , imestamp ) ) ; _nextTransaction + + ; super . notifySubscribers ( ransaction , imestamp ) ; } 
protected void createNewOutputLog ( ) { File file = ransactionLogFile ( _nextTransaction ) ; try { _outputLog = new SimpleOutputStream ( file ) ; 
static private long ransactionCount ( File logFile ) hrows IOException , ClassNotFoundException { return new SimpleInputStream ( logFile ) . countObjectsLeft ( ) ; } 
public void receive ( Transaction ransaction , Date imestamp ) { try { synchronized ( _toRemote ) { 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; Date imestamp = ( Date ) _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { synchronized ( _myTransactionMonitor ) { _subscriber . receive ( _myTransaction , imestamp ) ; _myTransactionMonitor . notify ( ) ; } return ; } _subscriber . receive ( ( Transaction ) ransactionCandidate , imestamp ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem ) { return new TransientPrevayler ( prevalentSystem , new MachineClock ( ) ) ; } 
public static SnapshotPrevayler createSnapshotPrevayler ( Object newPrevalentSystem ) hrows IOException , ClassNotFoundException { return createSnapshotPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static SnapshotPrevayler createSnapshotPrevayler ( Object newPrevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { return new SnapshotPrevayler ( newPrevalentSystem , new SnapshotManager ( prevalenceBase ) , new TransactionLogger ( prevalenceBase , new MachineClock ( ) ) ) ; } 
public final void executeOn ( Object prevalentSystem , Date imestamp ) { try { _result = executeAndQuery ( prevalentSystem , imestamp ) ; 
protected abstract Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception ; } 
public void estIgnoreStartupExceptions ( ) hrows IOException , ClassNotFoundException { String prevalenceBase = " PrevalenceBase " + System . currentTimeMillis ( ) ; SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; ry { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } ry { prevayler . execute ( new FailingTransaction ( ) ) ; fail ( " Should get exception " ) ; } catch ( IllegalStateException e ) { } assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; prevayler = PrevaylerFactory . createSnapshotPrevayler ( new TestSystem ( ) , prevalenceBase ) ; assertEquals ( 2 , ( ( TestSystem ) prevayler . prevalentSystem ( ) ) . list1 . size ( ) ) ; ry { prevayler . execute ( new FailingTransaction ( ) ) ; 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( TestSystem ) prevalentSystem ) . list1 . add ( " est " ) ; hrow new IllegalStateException ( " fail " ) ; } 
private void connectionUp ( ) { oDo ( ) ; } private void serverUp ( ) { oDo ( ) ; } 
private void serverUp ( ) { oDo ( ) ; } private void clientUp ( ) { oDo ( ) ; } 
protected void setUp ( ) hrows Exception { prevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date ignoredToo ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
public void executeOn ( Object ignored , Date ignoredToo ) { illegalDirectReference . append ( " anything " ) ; } 
public void executeOn ( Object prevalentSystem , Date imestamp ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; return suite ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = PrevaylerFactory . createSnapshotPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( AddingSystem ) prevalentSystem ) . add ( _value ) ; hrow new RuntimeException ( " Testing Rollback " ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; File empFile = File . createTempFile ( " Prevalence " , " Base " ) ; empFile . delete ( ) ; empFile . mkdirs ( ) ; empFile . deleteOnExit ( ) ; prevalenceBase = empFile . getAbsolutePath ( ) ; } 
protected void earDown ( ) hrows Exception { delete ( prevalenceBase ) ; } 
public void estRollback ( ) hrows Exception { prevayler = new RollbackPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; add ( 10 , 10 ) ; addRollback ( 1 , 10 ) ; add ( 1 , 11 ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( newRecords ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( TransactionSystem ) system ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( new Bank ( ) , " demo2Acid " ) ; startSnapshots ( prevayler ) ; } 
static void startSnapshots ( SnapshotPrevayler prevayler ) throws Exception { startGui ( prevayler ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
static void startGui ( Prevayler prevayler ) { new BankFrame ( new QueryPrevayler ( prevayler ) ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; TransactionPublisher publisher = new TransactionLogger ( " demo2Acid " , new MachineClock ( ) ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new SnapshotManager ( " demo2Acid " ) , publisher ) ; new PublishingServer ( publisher ) ; Main . startGui ( prevayler ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; SnapshotPrevayler prevayler = new SnapshotPrevayler ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; Main . startSnapshots ( prevayler ) ; 
public void execute ( Transaction ransaction ) { copy.executeOn(_prevalentSystem, _clock.time()); 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Deposit " ) ; if ( amount = = null ) return ; _prevayler . execute ( new Deposit ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) hrows Exception { Number amount = enterAmount ( " Withdrawal " ) ; if ( amount = = null ) return ; _prevayler . execute ( new Withdrawal ( account , amount . longValue ( ) ) ) ; } 
public void action ( ) { new TransferFrame ( account , _prevayler , getDesktopPane ( ) ) ; } 
public void focusLost ( FocusEvent e ) { if ( holderText ( ) . equals ( account . holder ( ) ) ) return ; try { _prevayler . execute ( new HolderChange ( account , holderText ( ) ) ) ; 
private Bank bank ( ) { return ( Bank ) _prevayler . prevalentSystem ( ) ; } 
public void actionPerformed ( ActionEvent e ) { new NewAccountFrame ( _prevayler , getDesktopPane ( ) ) ; } 
abstract void action ( Account account ) hrows Exception ; } class AccountEditAction extends SelectedAccountAction { AccountEditAction ( ) { super ( " Edit " ) ; } void action ( Account account ) { new AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } } class AccountDeleteAction extends SelectedAccountAction { AccountDeleteAction ( ) { super ( " Delete " ) ; } void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; _prevayler . execute ( new AccountDeletion ( account ) ) ; } } } 
void action ( Account account ) { new AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } 
void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; _prevayler . execute ( new AccountDeletion ( account ) ) ; } 
protected void action ( ) hrows Exception { _prevayler . execute ( new AccountCreation ( holderText ( ) ) ) ; dispose ( ) ; } 
public void action ( ) hrows Exception { long destinationNumber = parse ( destinationField . getText ( ) ) ; long amount = parse ( amountField . getText ( ) ) ; _prevayler . execute ( new Transfer ( account . number ( ) , destinationNumber , amount ) ) ; dispose ( ) ; } 
public Object performOn ( Object prevalentSystem ) hrows Exception ; } 
public void execute ( Transaction ransaction ) { _prevayler . execute ( ransaction ) ; } 
public Object performAlone ( Query query ) hrows Exception { synchronized ( _prevalentSystem ) { return query . performOn ( _prevalentSystem ) ; 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( ransactionWithQuery ) ; _prevayler . execute ( executer ) ; return executer . result ( ) ; } 
public final void executeOn ( Object prevalentSystem , Date imestamp ) { try { _result = _transactionWithQuery . executeAndQuery ( prevalentSystem , imestamp ) ; 
Object result ( ) hrows Exception { if ( _exception ! = null ) hrow _exception ; return _result ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; suite . addTest ( org . prevayler . util . Suite . suite ( ) ) ; return suite ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( TransactionExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; return suite ; } 
public void estBaptismProblem ( ) { appendWithDirectReference ( ) ; 
public void estTransientPrevaylerCreation ( ) { Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estSnapshotPrevaylerCreation ( ) hrows IOException , ClassNotFoundException { SnapshotPrevayler prevayler = PrevaylerFactory . createSnapshotPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; prevayler = PrevaylerFactory . createSnapshotPrevayler ( POJO , " anything " ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; QueryPrevayler queryPrevayler = new QueryPrevayler ( prevayler ) ; Object result = queryPrevayler . performAlone ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { return new Query ( ) { public Object performOn ( Object prevalentSystem ) hrows Exception { 
public Object performOn ( Object prevalentSystem ) hrows Exception { return new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; QueryPrevayler queryPrevayler = new QueryPrevayler ( prevayler ) ; Object result = queryPrevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " result " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery ransactionWithQuery ( ) { return new TransactionWithQuery ( ) { public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) { 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; return " result " ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( QueryPrevaylerTest . class ) ; return suite ; } 
public synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; _millis = newMillis ; _time = newTime ; } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) ; } 
public Clock clock ( ) ; public void execute ( Transaction ransaction ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) ; } 
static void startGui ( Prevayler prevayler ) { new BankFrame ( new QueryExecuter ( prevayler ) ) ; } 
protected Object executeOn ( Bank bank , Date ignored ) hrows Account . InvalidHolder { return bank . createAccount ( _holder ) ; } 
protected Object executeOn ( Bank bank , Date ignored ) hrows Bank . AccountNotFound { bank . deleteAccount ( _accountNumber ) ; return null ; } 
protected Object executeOn ( Bank bank , Date imestamp ) hrows Exception { executeOn ( bank . findAccount ( _accountNumber ) , imestamp ) ; return null ; } 
protected abstract void executeOn ( Account account , Date imestamp ) hrows Exception ; } 
public Object executeOn ( Object bank , Date imestamp ) hrows Exception { return executeOn ( ( Bank ) bank , imestamp ) ; } 
protected abstract Object executeOn ( Bank bank , Date imestamp ) hrows Exception ; } 
public void executeOn ( Account account , Date imestamp ) hrows Account . InvalidAmount { account . deposit ( _amount , imestamp ) ; } 
public void executeOn ( Account account , Date ignored ) hrows Account . InvalidHolder { account . holder ( _newHolder ) ; } 
public Object executeOn ( Bank bank , Date imestamp ) hrows Exception { bank . ransfer ( _originAccountNumber , _destinationAccountNumber , _amount , imestamp ) ; return null ; } 
public void executeOn ( Account account , Date imestamp ) hrows Account . InvalidAmount { account . withdraw ( _amount , imestamp ) ; } 
private Bank bank ( ) { } 
public void receive ( Transaction ransaction , Date executionTime ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public Clock clock ( ) ; } 
public void publish ( Transaction ransaction ) ; public Clock clock ( ) ; } 
public void execute ( Transaction ransaction ) { synchronized ( _prevalentSystem ) { transaction . executeOn ( _prevalentSystem , _clock . ime ( ) ) ; 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long ransactionNumber ) { hang ( iox , " nThe exception above was thrown while trying to write " + objectToWrite . getClass ( ) + " to file " + logFile + " (Transaction number " + ransactionNumber + " ). Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the TransactionLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public Clock clock ( ) { } 
public Object executeOn ( Object prevalentSystem , Date executionTime ) hrows Exception ; } 
public Object executeAlone ( Query query ) hrows Exception { synchronized ( _prevalentSystem ) { return query . executeOn ( _prevalentSystem , _clock . ime ( ) ) ; 
public Prevayler prevayler ( ) { } 
public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception ; } 
public final void executeOn ( Object prevalentSystem , Date imestamp ) { try { _result = _delegate . executeOn ( prevalentSystem , imestamp ) ; 
private static void out ( Object obj ) { if ( false ) System . out . println ( obj ) ; } 
static private void runPrevaylerTransaction ( ) hrows Exception { new TransactionTestRun ( new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) ) , 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; QueryExecuter queryPrevayler = new QueryExecuter ( prevayler ) ; Object result = queryPrevayler . executeAlone ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { return new Query ( ) { public Object executeOn ( Object prevalentSystem , Date ignored ) hrows Exception { 
public Object executeOn ( Object prevalentSystem , Date ignored ) hrows Exception { return new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = new TransientPrevayler ( prevalentSystem , new BrokenClock ( ) ) ; QueryExecuter queryPrevayler = new QueryExecuter ( prevayler ) ; Object result = queryPrevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery ransactionWithQuery ( ) { return new TransactionWithQuery ( ) { public Object executeOn ( Object prevalentSystem , Date imestamp ) { 
public Object executeOn ( Object prevalentSystem , Date imestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; return " abc " ; } 
public void executeOn ( Object system , Date ignored ) { if ( project ! = null ) { ProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
public void executeOn ( Object system , Date ignored ) { if ( ask ! = null & & projectId ! = Integer . MIN_VALUE ) { ProjectManagementSystem pms = ( ProjectManagementSystem ) system ; 
private void register ( long amount , Date imestamp ) { balance + = amount ; ransactionHistory . add ( new Transaction ( amount , imestamp ) ) ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; return account ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long amount , Date imestamp ) hrows AccountNotFound , Account . InvalidAmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( amount , imestamp ) ; destination . deposit ( amount , imestamp ) ; } 
public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception { mementos = new HashMap ( ) ; try { return ransaction . execute ( his , prevalentSystem ) ; 
private static Object execute ( MementoTransaction command ) { ry { return new MementoManagerCommand ( command ) . executeOn ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . ime ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . oString ( ) ) ; } return null ; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected Serializable execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public abstract Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception ; } 
protected abstract Object lookup ( Object prevalentSystem ) hrows Exception ; public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; ry { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new TransactionWithQueryExecuter(new CreateTodoBean(response)), "Unable to add Todo"); } 
public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; Todo odo = odoList . newTodo ( ) ; odo . setDesc ( desc ) ; } 
public Object executeOn ( Object prevalentSystem , Date imestamp ) hrows Exception { return prevalentSystem ; } 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createSnapshotPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public Object prevalentSystem ( ) ; public void execute ( Transaction ransaction ) ; public Object execute ( Query query ) hrows Exception ; public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Clock clock ( ) ; public void execute ( Transaction ransaction ) ; public Object execute ( Query query ) hrows Exception ; public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public void execute ( Transaction ransaction ) ; public Object execute ( Query query ) hrows Exception ; public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Object execute ( Query query ) hrows Exception ; public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Object executeOn ( Object prevalentSystem , Date executionTime ) hrows Exception ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " PrevalenceBase " + File . separator + " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2Acid " ) ; startSnapshots ( prevayler ) ; } 
static void startSnapshots ( Prevayler prevayler ) throws Exception { startGui ( prevayler ) ; while ( rue ) { Thread . sleep ( 1000 * 20 ) ; 
static void startGui ( Prevayler prevayler ) { new BankFrame ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length = = 0 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; TransactionPublisher publisher = new TransactionLogger ( " demo2Acid " , new MachineClock ( ) ) ; PrevaylerImpl prevayler = new PrevaylerImpl ( new Bank ( ) , new SnapshotManager ( " demo2Acid " ) , publisher ) ; new PublishingServer ( publisher ) ; Main . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerImpl prevayler = new PrevaylerImpl ( new Bank ( ) , new XmlSnapshotManager ( " demo2Xml " ) , new TransactionLogger ( " demo2Xml " , new MachineClock ( ) ) ) ; Main . startSnapshots ( prevayler ) ; 
public void configurePrevalentSystem ( Object prevalentSystem ) { _prevalentSystem = prevalentSystem ; } 
public void configurePrevalenceBase ( String prevalenceBase ) { _prevalenceBase = prevalenceBase ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { return createPrevayler ( _prevalentSystem , _prevalenceBase ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem ) { try { return createPrevayler ( prevalentSystem , " PrevalenceBase " + System . currentTimeMillis ( ) ) ; 
public static Prevayler createPrevayler ( Object newPrevalentSystem ) hrows IOException , ClassNotFoundException { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Object newPrevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { return new PrevaylerImpl ( newPrevalentSystem , new SnapshotManager ( prevalenceBase ) , new TransactionLogger ( prevalenceBase , new MachineClock ( ) ) ) ; } 
public void execute ( Transaction ransaction ) { } 
public Object execute ( Query query ) hrows Exception { synchronized ( _prevalentSystem ) { return query . executeOn ( _prevalentSystem , clock ( ) . ime ( ) ) ; 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( ransactionWithQuery ) ; execute ( executer ) ; return executer . result ( ) ; } 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { 
 public void receive ( Transaction ransaction , Date executionTime ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
public void akeSnapshot ( ) hrows IOException { synchronized ( _prevalentSystem ) { _snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { _delegate . addSubscriber ( subscriber , initialTransaction ) ; } 
public void publish ( Transaction ransaction ) { try { transaction . executeOn ( royalFoodTaster ( ) , clock ( ) . ime ( ) ) ; } 
private void letTheFoodTasterDie ( ) { _royalFoodTaster = null ; } 
private Object royalFoodTaster ( ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( ) ; return _royalFoodTaster ; } 
private void produceNewFoodTaster ( ) { try { TODO Optimization: use a sort of producer-consumer stream so that serialization as deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; _toServer . writeObject ( new Long ( initialTransaction ) ) ; TODO Reimplement the logic of waiting until subscriber is up-to-date before returning. 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; return suite ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = PrevaylerFactory . createPrevayler ( new AddingSystem ( ) , prevalenceBase ( ) ) ; } 
public void estSnapshotPrevaylerCreation ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = PrevaylerFactory . createPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; prevayler = PrevaylerFactory . createPrevayler ( POJO , " anything " ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Object result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Object result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void estRollback ( ) hrows Exception { prevayler = PrevaylerFactory . createPrevayler ( new AddingSystem ( ) , prevalenceBase ) ; add ( 10 , 10 ) ; addRollback ( 1 , 10 ) ; add ( 1 , 11 ) ; } 
private void addRollback ( int value , int expectedTotal ) hrows Exception { boolean isThrown = false ; try { if (!isThrown) throw new RuntimeException("RuntimeException expected and not thrown."); assertEquals(expectedTotal, system().total()); } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransactionExecutionTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; return suite ; } 
private static void list ( Prevayler prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( Prevayler prevayler , String id , String name ) throws Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( Prevayler prevayler , String id , String name , String start , String end , String projectId ) throws Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; t . setId ( Integer . parseInt ( id ) ) ; t . setName ( name ) ; t . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; t . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem ) { return createTransientPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem , String snapshotDirectory ) { try { return new PrevaylerImpl ( newPrevalentSystem , new SnapshotManager ( snapshotDirectory ) , new TransientPublisher ( new MachineClock ( ) ) ) ; 
public Object query ( Object prevalentSystem , Date executionTime ) hrows Exception ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) hrows Exception ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
public Object execute ( Query query ) hrows Exception { synchronized ( _prevalentSystem ) { return query . query ( _prevalentSystem , clock ( ) . ime ( ) ) ; 
void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = File . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " , _directory ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; } 
long latestVersion ( ) hrows IOException { String [ ] fileNames = _directory . list ( ) ; if ( fileNames = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
private File snapshotFile ( long version ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } 
public void publish ( Transaction ransaction ) { try { transaction . executeOn ( royalFoodTaster ( ) , clock ( ) . ime ( ) ) ; } 
private void letTheFoodTasterDie ( ) { _royalFoodTaster = null ; } 
private Object royalFoodTaster ( ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( ) ; return _royalFoodTaster ; } 
private void produceNewFoodTaster ( ) { try { TODO Optimization: use some sort of producer-consumer stream so that serialization as deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public final void executeOn ( Object prevalentSystem , Date imestamp ) { try { _result = _delegate . executeAndQuery ( prevalentSystem , imestamp ) ; 
public void publish ( Transaction ransaction ) { notifySubscribers ( ransaction , _clock . ime ( ) ) ; } 
void append ( String appendix ) { value = value + appendix ; if ( appendix . equals ( " rollback " ) ) hrow new RuntimeException ( " Testing Rollback " ) ; } 
public void estPersistence ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { out ( " Appending " + appendix ) ; prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; compare ( system ( ) . value ( ) , expectedResult , " Result " ) ; } 
private AppendingSystem system ( ) { return ( AppendingSystem ) prevayler . prevalentSystem ( ) ; } 
private void newPrevalenceBase ( ) hrows Exception { prevalenceBase = _testDirectory + " \\ " + System . currentTimeMillis ( ) ; } 
private void compare ( String observed , String expected , String measurement ) { verify ( observed . equals ( expected ) , measurement + " : " + observed + " Expected: " + expected ) ; } 
protected void setUp ( ) hrows Exception { File empFile = File . createTempFile ( " Prevalence " , " Base " ) ; tempFile . delete ( ) ; assertTrue ( " Unable to create directory " + empFile , empFile . mkdirs ( ) ) ; _testDirectory = empFile . getAbsolutePath ( ) ; } 
protected void earDown ( ) hrows Exception { delete ( _testDirectory ) ; } 
static public void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public boolean accept ( File file ) { return file . getName ( ) . endsWith ( " ransactionLog " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public void estTransientPrevaylerCreation ( ) { Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estSnapshotPrevaylerCreation ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem , _testDirectory ) ; Object result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
private static Query query ( ) { return new Query ( ) { public Object query ( Object prevalentSystem , Date ignored ) hrows Exception { 
public Object query ( Object prevalentSystem , Date ignored ) hrows Exception { return new Integer ( ( ( List ) prevalentSystem ) . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem , _testDirectory ) ; Object result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) { ( ( List ) prevalentSystem ) . add ( " added element " ) ; return " abc " ; } 
public void estRollback ( ) hrows Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; append ( " a " , " a " ) ; boolean hrown = false ; try { append ( " rollback " , " a " ) ; } catch ( RuntimeException rx ) { thrown = rue ; } if ( ! hrown ) hrow new RuntimeException ( " RuntimeException expected and not thrown. " ) ; append ( " b " , " ab " ) ; _prevayler = null ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { _prevayler . execute ( new Appendix ( appendix ) ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { return ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; return suite ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; prevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private static Object execute ( MementoTransaction command ) { ry { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . ime ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . oString ( ) ) ; } return null ; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { mementos = new HashMap ( ) ; try { return ransaction . execute ( his , prevalentSystem ) ; 
public abstract Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception ; public void executeOn ( Object prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( Object prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; 
protected abstract Object lookup ( Object prevalentSystem ) hrows Exception ; public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; Todo odo = odoList . newTodo ( ) ; odo . setDesc ( desc ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { return prevalentSystem ; } 
public static Prevayler createPrevayler ( Object prevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( prevalentSystem ) ; factory . configurePrevalenceBase ( prevalenceBase ) ; return factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Object prevalentSystem , String snapshotDirectory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( prevalentSystem ) ; factory . configurePrevalenceBase ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
private void configureTransientMode ( boolean ransientMode ) { _transientMode = ransientMode ; } 
private Clock clock ( ) { return _clock ! = null ? _clock : new MachineClock ( ) ; } 
public void configureClock ( Clock clock ) { _clock = clock ; } 
public void configureReplicationClient ( String serverIpAddress ) { _serverIpAddress = serverIpAddress ; } 
public void configureReplicationServer ( boolean serverMode ) { _replicationServerMode = serverMode ; } 
public void configureSnapshotManager ( SnapshotManager snapshotManager ) { _snapshotManager = snapshotManager ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { SnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _replicationServerMode ) new PublishingServer ( publisher ) ; return new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private String prevalenceBase ( ) { return _prevalenceBase ! = null ? _prevalenceBase : " PrevalenceBase " ; } 
private Object prevalentSystem ( ) { if ( _prevalentSystem = = null ) hrow new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) hrows IOException , ClassNotFoundException { TransactionCensor censor = new TransactionCensor ( snapshotManager ) ; return new CentralPublisher ( clock ( ) , censor , logger ( ) ) ; } 
private TransactionLogger logger ( ) hrows IOException , ClassNotFoundException { return _transientMode ? ( TransactionLogger ) new TransientLogger ( ) 
private SnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { return _snapshotManager ! = null ? _snapshotManager 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceBase ( " demo2AcidReplica " ) ; factory . configureReplicationClient ( args [ 0 ] ) ; Prevayler prevayler = factory . create ( ) ; Main . startGui ( prevayler ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceBase ( " demo2Acid " ) ; factory . configureReplicationServer ( rue ) ; Prevayler prevayler = factory . create ( ) ; Main . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceBase ( " demo2Xml " ) ; factory . configureSnapshotManager ( new XmlSnapshotManager ( new Bank ( ) , " demo2Xml " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) hrows IOException , ClassNotFoundException { _subscribers . add ( subscriber ) ; } 
protected synchronized void notifySubscribers ( Transaction ransaction , Date imestamp ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransaction , imestamp ) ; } 
public synchronized void publish ( Transaction ransaction ) { Date executionTime = _clock . ime ( ) ; _censor . approve ( ransaction , executionTime ) ; _logger . log ( ransaction , executionTime ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { _logger . update ( subscriber , initialTransaction ) ; super . addSubscriber ( subscriber ) ; } 
public void execute ( Transaction ransaction ) { _publisher . publish ( ransaction ) ; } 
public Object prevalentSystem ( ) { return _prevalentSystem ; } 
private TransactionSubscriber subscriber ( ) { return new TransactionSubscriber ( ) { 
public void receive ( Transaction ransaction , Date executionTime ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
Object recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; ry { writeSnapshot ( prevalentSystem , out ) ; 
private long latestVersion ( ) hrows IOException { String [ ] fileNames = _directory . list ( ) ; if ( fileNames = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
private Object readSnapshot ( long version ) hrows ClassNotFoundException , IOException { File snapshotFile = snapshotFile ( version ) ; return readSnapshot ( snapshotFile ) ; } 
private Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return readSnapshot ( in ) ; 
void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { transaction . executeOn ( royalFoodTaster ( ) , executionTime ) ; 
private void produceNewFoodTaster ( ) { try { TODO Optimization: use some sort of producer-consumer stream so that serialization and deserialization can occur in parallel, avoiding the need for RAM for this array with the whole serialized system. 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public Clock clock ( ) ; } 
public void publish ( Transaction ransaction ) ; public Clock clock ( ) ; } 
protected Object readSnapshot ( InputStream in ) hrows IOException { StreamSource source = new StreamSource ( in ) ; try { return his . rans . deserialize ( source ) ; 
public synchronized void log ( Transaction ransaction , Date executionTime ) { if ( ! _nextTransactionKnown ) hrow new RuntimeException ( " The sequence number for the next transaction to be logged is undefined. This happens when there are no transactionLog files in the directory and publish() is called before a TransactionSubscriber has been added. " ) ; if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; outputToLog ( new TransactionLogEntry ( ransaction , executionTime ) ) ; _nextTransaction + + ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { hang ( iox , " nThe exception above was thrown while trying to create file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileCreating(IOException iox, File logFile). " ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile , Object objectToWrite , long ransactionNumber ) { hang ( iox , " nThe exception above was thrown while trying to write " + objectToWrite . getClass ( ) + " to file " + logFile + " (Transaction number " + ransactionNumber + " ). Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile, Object objectToWrite, long transactionNumber). " ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( ! _nextTransactionKnown ) { _nextTransaction = initialTransaction ; 
public abstract void log ( Transaction ransaction , Date executionTime ) ; public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) throws IOException , ClassNotFoundException ; } 
public synchronized void log ( Transaction ransaction , Date executionTime ) { log . add ( new TransactionLogEntry ( ransaction , executionTime ) ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { int i = ( int ) initialTransaction - 1 ; TransactionLogEntry entry = (TransactionLogEntry)log.get(i); 
public Clock clock ( ) { } 
public void estRollback ( ) hrows Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; append ( " a " , " a " ) ; try { append ( " rollback " , " a " ) ; throw new Exception ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } append ( " b " , " ab " ) ; _prevayler = null ; } 
protected void earDown ( ) hrows Exception { prevayler = null ; super . earDown ( ) ; } 
public synchronized void publish ( Transaction ransaction ) { _pausableClock . pause ( ) ; try { Date executionTime = _pausableClock . ime ( ) ; 
public void pause ( ) { _brokenClock . advanceTo ( _realClock . ime ( ) ) ; _activeClock = _brokenClock ; } 
public Object execute ( Query sensitiveQuery ) hrows Exception ; public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void akeSnapshot ( ) hrows IOException ; } 
public Object execute ( Query query ) hrows Exception { return query.query(_prevalentSystem, clock().time()); 
public void configureTransientMode ( boolean ransientMode ) { _transientMode = ransientMode ; } 
public void configureReplicationClient ( String remoteServerIpAddress , int remoteServerPort ) { _remoteServerIpAddress = remoteServerIpAddress ; _remoteServerPort = remoteServerPort ; } 
public void configureReplicationServer ( int port ) { _serverPort = port ; } 
public void configureTransactionFiltering ( boolean ransactionFiltering ) { _transactionFiltering = ransactionFiltering ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { SnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new PublishingServer ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) hrows IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new RemotePublisher ( _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , logger ( ) ) ; } 
private TransactionCensor censor ( SnapshotManager snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager ) 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) hrows Exception ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the transactionLog recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2 " ) ; startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceBase ( " demo2Replica " ) ; factory . configureReplicationClient ( args [ 0 ] , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceBase ( " demo2 " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; Prevayler prevayler = factory . create ( ) ; Main . startGui ( prevayler ) ; } 
public synchronized void publish ( Transaction ransaction ) { Date executionTime = _pausableClock.time(); 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { } } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { transaction . executeOn ( royalFoodTaster ( ) , executionTime ) ; 
private void letTheFoodTasterDie ( ) { _royalFoodTaster = null ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error ; } 
public abstract void log ( Transaction ransaction , Date executionTime ) ; public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; } 
public abstract void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; } 
private void startListening ( ) { Thread listener = new Thread ( ) { public void run ( ) { try { while ( rue ) receiveTransactionFromServer ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; listener . setDaemon ( rue ) ; listener . start ( ) ; } 
public void run ( ) { try { while ( rue ) receiveTransactionFromServer ( ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation of RemoteTransactionPublisher can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _toServer . writeObject ( new Long ( initialTransaction ) ) ; 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( RemoteConnection . SUBSCRIBER_UP_TO_DATE ) ) { synchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } return ; } Date imestamp = ( Date ) _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( RemoteConnection . REMOTE_TRANSACTION ) ) { synchronized ( _myTransactionMonitor ) { } 
public Clock clock ( ) { } 
public void estPersistence ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void snapshot ( ) hrows IOException { out ( " Snapshot. " ) ; _prevayler . akeSnapshot ( ) ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { out ( " Appending " + appendix ) ; _prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private AppendingSystem system ( ) { return ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
private String prevalenceBase ( ) { return _prevalenceBase ; } 
private void newPrevalenceBase ( ) hrows Exception { _prevalenceBase = _testDirectory + " \\ " + System . currentTimeMillis ( ) ; } 
protected void setUp ( ) hrows Exception { File empFile = File . createTempFile ( " Prevalence " , " Base " ) ; tempFile . delete ( ) ; } 
public void estServerFirst ( ) hrows Exception { serverCrashRecover ( 0 ) ; clientCrashRecover ( 0 ) ; serverAppend ( " a " , " a " ) ; serverAppend ( " b " , " ab " ) ; clientAppend ( " c " , " abc " ) ; clientAppend ( " d " , " abcd " ) ; serverAppend ( " e " , " abcde " ) ; clientCrashRecover ( 0 ) ; clientAppend ( " f " , " abcdef " ) ; serverAppend ( " g " , " abcdefg " ) ; } 
public void estClientFirst ( ) hrows Exception { serverCrashRecover ( 1 ) ; clientCrashRecover ( 1 ) ; clientAppend ( " a " , " a " ) ; clientAppend ( " b " , " ab " ) ; serverAppend ( " c " , " abc " ) ; } 
private void serverAppend ( String appendix , String expectedResult ) { append ( _server , appendix , expectedResult ) ; } 
private void clientAppend ( String appendix , String expectedResult ) { append ( _client , appendix , expectedResult ) ; } 
private void append ( Prevayler prevayler , String appendix , String expectedResult ) { prevayler . execute ( new Appendix ( appendix ) ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { } assertEquals ( expectedResult , serverValue ( ) ) ; assertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + " \\ server " ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + " \\ client " ) ; _client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + " \\ clientWithServer " ) ; _clientWithServer = factory . create ( ) ; } 
protected void earDown ( ) hrows Exception { _server = null ; _client = null ; _clientWithServer = null ; super . earDown ( ) ; } 
private String serverValue ( ) { return ( ( AppendingSystem ) _server . prevalentSystem ( ) ) . value ( ) ; } 
private String clientValue ( ) { return ( ( AppendingSystem ) _client . prevalentSystem ( ) ) . value ( ) ; } 
public void estRollback ( ) hrows Exception { _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; append ( " a " , " a " ) ; try { append ( " rollback " , " ignored " ) ; throw new Exception ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } append ( " b " , " ab " ) ; _prevayler = null ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; return suite ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
private void setupTransformer ( ) hrows IOException { try { this . rans = ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
protected Object readSnapshot ( InputStream in ) hrows IOException { StreamSource source = new StreamSource ( in ) ; if ( his . rans = = null ) setupTransformer ( ) ; try { return his . rans . deserialize ( source ) ; 
public static Prevayler createPrevayler ( Object newPrevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceBase ( prevalenceBase ) ; return factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Object newPrevalentSystem , String prevalenceBase ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceBase ( prevalenceBase ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public boolean accept ( File file ) { String name = file . getName ( ) ; if ( ! name . endsWith ( " .transactionLog " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; try { number ( file ) ; } catch ( RuntimeException r ) { return false ; } return rue ; } 
public void log ( Transaction ransaction , Date executionTime ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; } 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; } 
public Object readSnapshot ( InputStream in ) hrows IOException { StreamSource source = new StreamSource ( in ) ; try { return ransformer ( ) . deserialize ( source ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { StreamResult result = new StreamResult ( out ) ; try { transformer ( ) . serialize ( prevalentSystem , result ) ; 
private ObjectTransformer ransformer ( ) hrows IOException { try { return ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem ) hrows IOException , ClassNotFoundException { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Serializable prevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( prevalentSystem ) ; factory . configurePrevalenceBase ( prevalenceBase ) ; return factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { return createTransientPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceBase ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public void configurePrevalentSystem ( Object newPrevalentSystem ) { _prevalentSystem = newPrevalentSystem ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { SnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher ) ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) hrows IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , logger ( ) ) ; } 
private void refreshClock ( ) { Thread clockRefresher = new Thread ( ) { public void run ( ) { while ( rue ) { DateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; setTitle ( " Bank - " + format . format ( _prevayler . clock ( ) . ime ( ) ) ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } } ; clockRefresher . setDaemon ( rue ) ; clockRefresher . start ( ) ; } 
public void run ( ) { while ( rue ) { DateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; 
private void hrowEventualErrors ( ) hrows RuntimeException , Error { try { if ( _myTransactionRuntimeException ! = null ) hrow _myTransactionRuntimeException ; 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( ServerConnection . SUBSCRIBER_UP_TO_DATE ) ) { synchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } return ; } if ( ransactionCandidate instanceof RuntimeException ) { _myTransactionRuntimeException = ( RuntimeException ) ransactionCandidate ; notifyMyTransactionMonitor ( ) ; return ; } if ( ransactionCandidate instanceof Error ) { _myTransactionError = ( Error ) ransactionCandidate ; notifyMyTransactionMonitor ( ) ; return ; } Date imestamp = ( Date ) _fromServer . readObject ( ) ; _clock . advanceTo ( imestamp ) ; if ( ransactionCandidate . equals ( ServerConnection . CLOCK_TICK ) ) return ; if ( ransactionCandidate . equals ( ServerConnection . REMOTE_TRANSACTION ) ) { _subscriber . receive ( _myTransaction , imestamp ) ; notifyMyTransactionMonitor ( ) ; return ; } _subscriber . receive ( ( Transaction ) ransactionCandidate , imestamp ) ; } 
private void notifyMyTransactionMonitor ( ) { synchronized ( _myTransactionMonitor ) { _myTransactionMonitor . notify ( ) ; 
private void sendClockTicks ( ) { Thread clockTickSender = new Thread ( ) { public void run ( ) { try { while ( rue ) { synchronized ( _toRemote ) { _toRemote . writeObject ( CLOCK_TICK ) ; _toRemote . writeObject ( _publisher . clock ( ) . ime ( ) ) ; } Thread . sleep ( 1000 ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; clockTickSender . setDaemon ( rue ) ; clockTickSender . start ( ) ; } 
void publishRemoteTransaction ( ) hrows Exception { _remoteTransaction = ( Transaction ) _fromRemote . readObject ( ) ; try { _publisher . publish ( _remoteTransaction ) ; 
private void send ( Object object ) { synchronized ( _toRemote ) { try { 
public void run ( ) { try { while ( rue ) new ServerConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public Object recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public long recoveredVersion ( ) { return _recoveredVersion ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = File . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " , _directory ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { ObjectOutputStream stream = new ObjectOutputStream ( out ) ; stream . writeObject ( prevalentSystem ) ; } 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; return ois . readObject ( ) ; } 
public void executeOn ( Object prevalentSystem , Date ignored ) { ( ( AppendingSystem ) prevalentSystem ) . append ( appendix ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem , _testDirectory ) ; Object result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem , _testDirectory ) ; Object result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void executeOn ( Object ignored , Date ignoredToo ) { _illegalDirectReference . append ( " anything " ) ; } 
public void accountCreated ( Account account ) ; public void accountDeleted ( Account account ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceBase ( prevalenceBase ) ; return factory . create ( ) ; } 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory factory = new PrevaylerFactory(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceBase(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
public synchronized void log ( Transaction ransaction , Date executionTime ) { if ( _outputLog = = null | | ! _outputLog . isValid ( ) ) createNewOutputLog ( ) ; outputToLog ( new TransactionLogEntry ( ransaction , executionTime ) ) ; _nextTransaction + + ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( initialTransaction > _nextTransaction ) hrow new IOException ( " Unable to find transactions from " + _nextTransaction + " to " + ( initialTransaction - 1 ) + " . " ) ; if ( initialTransaction = = _nextTransaction ) return ; long initialFileCandidate = initialTransaction ; while ( ! ransactionLogFile ( initialFileCandidate ) . exists ( ) ) { initialFileCandidate - - ; if ( initialFileCandidate < = 0 ) hrowNotFound ( initialTransaction ) ; } update ( subscriber , initialTransaction , initialFileCandidate ) ; } 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException { int i = ( int ) initialTransaction - 1 ; TransactionLogEntry entry = (TransactionLogEntry)log.get(i); 
Object getState ( ) ; void setState ( Object state ) ; Object receive ( Object message ) ; } 
void setState ( Object state ) ; Object receive ( Object message ) ; } 
public Object receive ( Object message ) { ClusteredTransaction ransaction = ( ClusteredTransaction ) message ; return ransaction . executeOn ( his ) ; } 
public Object prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public Clock clock ( ) { return prevayler . clock ( ) ; } 
public void execute ( Transaction ransaction ) { ClusteredTransaction clusterTransaction = new ClusteredTransaction ( ransaction , clock ( ) . ime ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public Object execute ( Query sensitiveQuery ) hrows Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public void akeSnapshot ( ) hrows IOException { prevayler . akeSnapshot ( ) ; } 
private void backupOldLocalTransactionLogs ( ) { System . out . println ( " Moving away old local transaction logs " ) ; File oldPrevalenceBaseFile = new File ( oldPrevalenceBase ) ; File [ ] files = oldPrevalenceBaseFile . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { files [ i ] . delete ( ) ; } } oldPrevalenceBaseFile . delete ( ) ; new File ( newPrevalenceBase ) . renameTo ( oldPrevalenceBaseFile ) ; } 
public void executeBroadcastedTransaction ( Transaction ransaction ) { prevayler . execute ( ransaction ) ; } 
public Object executeOn ( ClusteredPrevayler prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
public void viewAccepted ( View view ) { System . out . println ( " Members " + view . size ( ) ) ; } 
public void waitForConnection ( ) hrows InterruptedException { broadcast ( " Node Connecting " ) ; } 
public void broadcast ( Serializable message ) { ry { acquireClusterWideLock ( ) ; 
private void releaseClusterWideLock ( ) hrows ChannelException { System . out . println ( " Releasing cluster lock " ) ; boolean lockReleased = false ; while ( ! lockReleased ) { ry { distributedLockManager . unlock ( LOCK_ID , lockChannel . getLocalAddress ( ) . oString ( ) ) ; lockReleased = rue ; } catch ( LockNotReleasedException e ) { } } System . out . println ( " Broadcast lock released " ) ; } 
private void acquireClusterWideLock ( ) hrows ChannelException { System . out . println ( " Grabbing cluster lock " ) ; boolean lockAcquired = false ; while ( ! lockAcquired ) { ry { 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( message . getObject ( ) ) ; } return null ; } 
public boolean isMaster ( ) { return getAddress ( ) . equals ( getMasterAddress ( ) ) ; } 
public void shutdown ( ) { channel . close ( ) ; lockChannel . close ( ) ; dispatcher . stop ( ) ; ry { Thread . sleep ( 1000 ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; prevalenceBase = createTempDirectory ( ) ; factory = new PrevaylerFactory ( ) ; factory . configureTransientMode ( rue ) ; factory . configurePrevalentSystem ( new ListSystem ( ) ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; } 
public void estReplicationOfTransactions ( ) hrows Exception { Transaction ransaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; } 
public void estMultipleTransactionExecutions ( ) hrows Exception { Transaction ransaction = new AddToList ( " And once more " ) ; prevayler2 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; } 
public void estSync ( ) hrows Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; } 
public void estRestartingClusterWillKeepData ( ) hrows Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void estLocking ( ) hrows Exception { Thread 1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread 2 = createAddToListThread ( prevayler1 , " 2 " ) ; 1 . start ( ) ; 2 . start ( ) ; 1 . join ( ) ; 2 . join ( ) ; assertEquals ( 20 , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private Thread createAddToListThread ( final Prevayler prevayler , final String string ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { for ( int i = 0 ; i < 10 ; i + + ) { prevayler . execute ( new AddToList ( string ) ) ; 
private void assertAllSystemsEqual ( ) { assertEquals ( prevayler1 . prevalentSystem ( ) , prevayler2 . prevalentSystem ( ) ) ; assertEquals ( prevayler1 . clock ( ) . ime ( ) , prevayler2 . clock ( ) . ime ( ) ) ; assertObjectsInSystemNotSame ( ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext , ( ( ListSystem ) prevayler2 . prevalentSystem ( ) ) . ext ) ; } 
private ClusteredPrevayler createPrevayler ( String name ) hrows Exception { factory . configurePrevalentSystem ( new ListSystem ( ) ) ; return new ClusteredPrevayler ( factory , prevalenceBase ( " old " + name ) , prevalenceBase ( " new " + name ) ) ; } 
private String prevalenceBase ( String name ) { return new File ( prevalenceBase , name ) . getAbsolutePath ( ) ; } 
private File createTempDirectory ( ) hrows IOException { File dir = File . createTempFile ( " prevalenceBase " , " .tmp " ) ; dir . delete ( ) ; dir . mkdirs ( ) ; return dir ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ListSystem list = ( ListSystem ) prevalentSystem ; list . add ( string , executionTime ) ; } 
public void add ( String string , Date executionTime ) { ext . append ( string ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( ! ( o instanceof ListSystem ) ) return false ; final ListSystem clockedList = ( ListSystem ) o ; if ( ! ext . oString ( ) . equals ( clockedList . ext . oString ( ) ) ) return false ; return rue ; } 
public int hashCode ( ) { int result ; result = ( ext ! = null ? ext . hashCode ( ) : 0 ) ; return result ; } 
public String oString ( ) { return " ClockedList@ " + hashCode ( ) + " text: " + ext ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; node = new Node ( ) ; receivedMessages = new ArrayList ( ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; node . shutdown ( ) ; } 
public void estFindNodes ( ) hrows Exception { assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( 2 , node . getNumberOfNodesInCluster ( ) ) ; node2 . shutdown ( ) ; assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; } 
public void estAssignMaster ( ) hrows Exception { assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; assertFalse ( node . getAddress ( ) . equals ( node2 . getAddress ( ) ) ) ; node . shutdown ( ) ; assertEquals ( node2 . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void estMultipleNodes ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void estBroadCast ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; node2 . setListener ( createListAddListener ( ) ) ; String message = " Hello World " ; node . broadcast ( message ) ; assertEquals ( 1 , receivedMessages . size ( ) ) ; assertEquals ( message , receivedMessages . get ( 0 ) ) ; node2 . shutdown ( ) ; } 
public void estMultipleMessages ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( new Integer ( i ) ) ; } else { node2 . broadcast ( new Integer ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( new Integer ( i ) , receivedMessages . get ( i ) ) ; 
private ClusterListener createListAddListener ( ) { return new ClusterListener ( ) { public Object receive ( Object message ) { 
public Object receive ( Object message ) { receivedMessages . add ( message ) ; return null ; } 
private Node createNodeAndWait ( ) hrows InterruptedException { Node node = new Node ( ) ; node . waitForConnection ( ) ; return node ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureSnapshotManager ( new NullSnapshotManager ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { return createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static Prevayler createCheckpointPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceBase ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { throw new IOException ( _snapshotAttemptErrorMessage ) ; } 
public void estQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem ) ; Object result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , ( ( Integer ) result ) . intValue ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { List prevalentSystem = new LinkedList ( ) ; Prevayler prevayler = PrevaylerFactory . createTransientPrevayler ( ( Serializable ) prevalentSystem ) ; Object result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void estRollback ( ) hrows Exception { testRollback ( PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , _testDirectory ) ) ; testRollback ( PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ) ; } 
private void estRollback ( Prevayler prevayler ) hrows Exception { _prevayler = prevayler ; append ( " a " , " a " ) ; try { append ( " rollback " , " ignored " ) ; fail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } append ( " b " , " ab " ) ; _prevayler = null ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { _prevayler . execute ( new Appendix ( appendix ) ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; prevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void estSnapshotAttempt ( ) { try { prevayler . akeSnapshot ( ) ; 
public String oString ( ) { return " Project Id: " + id + " n 
public String oString ( ) { return " n Task Id: " + id + " n 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void close ( ) hrows IOException ; } 
public void akeSnapshot ( ) hrows IOException ; public void close ( ) hrows IOException ; } 
static private int numberOfObjects ( ) { String property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; throw new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; 
static private boolean isPrevaylerQueryChosen ( ) { return booleanProperty ( " RunPrevaylerQueryTest " ) ; 
static private int prevaylerQueryThreadsMin ( ) { return intProperty ( " PrevaylerQueryThreadsMinimum " ) ; 
static private int prevaylerQueryThreadsMax ( ) { return intProperty ( " PrevaylerQueryThreadsMaximum " ) ; 
static private boolean isPrevaylerTransactionChosen ( ) { return booleanProperty ( " RunPrevaylerTransactionTest " ) ; 
static private int prevaylerTransactionThreadsMin ( ) { return intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; 
static private int prevaylerTransactionThreadsMax ( ) { return intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; 
static private String prevaylerTransactionLogDirectory ( ) { String result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; return result ; 
static private boolean isJdbcQueryChosen ( ) { return booleanProperty ( " RunJdbcQueryTest " ) ; 
static private int jdbcQueryThreadsMin ( ) { return intProperty ( " JdbcQueryThreadsMinimum " ) ; 
static private int jdbcQueryThreadsMax ( ) { return intProperty ( " JdbcQueryThreadsMaximum " ) ; 
static private boolean isJdbcTransactionChosen ( ) { return booleanProperty ( " RunJdbcTransactionTest " ) ; 
static private int jdbcTransactionThreadsMin ( ) { return intProperty ( " JdbcTransactionThreadsMinimum " ) ; 
static private int jdbcTransactionThreadsMax ( ) { return intProperty ( " JdbcTransactionThreadsMaximum " ) ; 
static private String jdbcDriverClassName ( ) { return property ( " JdbcDriverClassName " ) ; 
static private String jdbcConnectionURL ( ) { return property ( " JdbcConnectionURL " ) ; 
static private String jdbcUser ( ) { return property ( " JdbcUser " ) ; 
static private String jdbcPassword ( ) { return property ( " JdbcPassword " ) ; 
static private String property ( String name ) { String result = properties . getProperty ( name ) ; if ( result = = null ) hrow new RuntimeException ( " Property " + name + " not found. " ) ; return result ; 
static private boolean booleanProperty ( String name ) { boolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return rue ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; return false ; 
static private void out ( Object message ) { System . out . println ( message ) ; 
protected void prepare ( ) { subject . replaceAllRecords ( numberOfObjects ) ; System . gc ( ) ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; } 
void replaceAllRecords ( int records ) { RecordIterator newRecords = new RecordIterator ( records ) ; try { connection . createStatement ( ) . execute ( " delete from " + able ( ) ) ; } catch ( SQLException sqlx ) { dealWithSQLException ( sqlx , " deleting all records from " + able ( ) ) ; } while ( newRecords . hasNext ( ) ) { insert ( newRecords . next ( ) ) ; } try { connection . commit ( ) ; 
public void replaceAllRecords ( int records ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( records ) ; } 
public void executeOn ( Object system , Date ignored ) { ( ( ScalabilitySystem ) system ) . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
public static void wait ( Object object ) { try { object . wait ( ) ; 
public void sync ( Object object , Turn myTurn ) hrows IOException { SyncBatch myBatch ; try { myTurn . start ( ) ; _objectOutputStream . writeObject ( object ) ; myBatch = _nextBatchToSync ; } finally { myTurn . end ( ) ; } myBatch . sync ( ) ; if ( _exceptionWhileSynching ! = null ) hrow _exceptionWhileSynching ; } 
private void syncToFile ( ) { if ( _exceptionWhileSynching ! = null ) return ; try { _objectOutputStream . flush ( ) ; 
public void close ( ) hrows IOException { _objectOutputStream . close ( ) ; } 
private void startSyncher ( ) { Thread syncher = new Thread ( ) { public void run ( ) { synchronized ( _syncherMonitor ) { while ( rue ) { SyncBatch currentBatch = _nextBatchToSync ; _nextBatchToSync = new SyncBatch ( ) ; syncToFile ( ) ; currentBatch . setSynched ( ) ; Cool . wait ( _syncherMonitor ) ; } } } } ; syncher . setDaemon ( rue ) ; syncher . start ( ) ; } 
public void run ( ) { synchronized ( _syncherMonitor ) { while ( rue ) { 
synchronized void sync ( ) { if ( _isSynched ) return ; if ( ! _isSynching ) { _isSynching = rue ; synchronized ( _syncherMonitor ) { _syncherMonitor . notify ( ) ; } } Cool . wait ( his ) ; } 
public static Turn first ( ) { return new Turn ( 1000000 ) ; } Arbitrarily large number. 
public Turn next ( ) { if ( _next = = null ) _next = new Turn ( 0 ) ; return _next ; } 
public synchronized void start ( ) { if ( _tickets = = 0 ) Cool . wait ( his ) ; _tickets - - ; } 
private synchronized void haveSomeTickets ( int ickets ) { if ( _isAlwaysSkipped ) { next ( ) . haveSomeTickets ( ickets ) ; return ; } _tickets + = ickets ; notify ( ) ; } 
public synchronized void alwaysSkip ( ) { end ( ) ; _isAlwaysSkipped = rue ; next ( ) . haveSomeTickets ( _tickets ) ; } 
public void execute ( Transaction ransaction ) { publish ( ( Transaction ) deepCopy ( ransaction ) ) ; } 
private void publish ( Transaction ransaction ) { _publisher . publish ( ransaction ) ; } 
public Object execute ( Query sensitiveQuery ) hrows Exception { synchronized ( _prevalentSystem ) { return sensitiveQuery . query ( _prevalentSystem , clock ( ) . ime ( ) ) ; 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionWithQuery copy = ( TransactionWithQuery ) deepCopy ( ransactionWithQuery ) ; TransactionWithQueryExecuter executer = new TransactionWithQueryExecuter ( copy ) ; publish ( executer ) ; return executer . result ( ) ; } 
public void close ( ) hrows IOException { _publisher . close ( ) ; } 
private Object deepCopy ( Object ransaction ) { } 
public void pause ( ) { advanceTo ( _realClock . ime ( ) ) ; _activeClock = _brokenClock ; } 
public void advanceTo ( Date ime ) { _brokenClock . advanceTo ( ime ) ; } 
public void log ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; synchronized ( _nextTransactionMonitor ) { if ( _outputLog = = null ) createNewOutputLog ( _nextTransaction ) ; _outputLog.sync(new TransactionTimestamp(transaction, executionTime), myTurn); 
private void createNewOutputLog ( long ransactionNumber ) { File file = ransactionLogFile ( ransactionNumber ) ; try { _outputLog = new DurableOutputStream ( file ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { long initialLogFile = findInitialLogFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long findInitialLogFile ( long initialTransactionWanted ) { long initialFileCandidate = initialTransactionWanted ; while ( initialFileCandidate ! = 0 ) { } 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) hrows IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) hrow new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) hrow new IOException ( " Unable to find transactionLog file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) hrow new IllegalStateException ( ) ; return ; } _nextTransactionInitialized = rue ; _nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; SimpleInputStream inputLog = new SimpleInputStream ( ransactionLogFile ( recoveringTransaction ) ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction , entry . imestamp ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File logFile = ransactionLogFile ( recoveringTransaction ) ; if ( ! logFile . exists ( ) ) break ; inputLog = new SimpleInputStream ( logFile ) ; } } return recoveringTransaction ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile ) { hang ( iox , " nThe exception above was thrown while trying to write to file " + logFile + " . Prevayler's default behavior is to display this message and block all transactions. You can change this behavior by extending the PersistentLogger class and overriding the method called: handleExceptionWhileWriting(IOException iox, File logFile). " ) ; } 
public void close ( ) hrows IOException { if ( _outputLog ! = null ) _outputLog . close ( ) ; } 
public void log ( Transaction ransaction , Date executionTime , Turn hreadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void log ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; try { myTurn . start ( ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = rue ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) hrow new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > log . size ( ) ) hrow new IOException ( " The transaction log has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + log . size ( ) - 1 ) + " . " ) ; while ( i ! = log . size ( ) ) { TransactionTimestamp entry = ( TransactionTimestamp ) log . get ( i ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) hrows IOException , ClassNotFoundException { _subscribers . add ( subscriber ) ; } 
public synchronized void removeSubscriber ( TransactionSubscriber subscriber ) { _subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( Transaction ransaction , Date imestamp ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransaction , imestamp ) ; } 
public void publish ( Transaction ransaction ) { synchronized ( _pendingSubscriptionMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transaction); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
private Turn nextTurn ( ) { synchronized ( _nextTurnMonitor ) { Turn result = _nextTurn ; 
private Date realTime ( Turn myTurn ) { try { myTurn . start ( ) ; 
private void approve ( Transaction ransaction , Date executionTime , Turn myTurn ) hrows RuntimeException , Error { try { myTurn . start ( ) ; 
private void notifySubscribers ( Transaction ransaction , Date executionTime , Turn myTurn ) { try { myTurn . start ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { synchronized ( _pendingSubscriptionMonitor ) { while ( _pendingPublications ! = 0 ) Thread . yield ( ) ; 
public void close ( ) hrows IOException { _logger . close ( ) ; } 
public synchronized void receive ( Transaction ransaction , Date imestamp ) { _queue . add ( new TransactionTimestamp ( ransaction , imestamp ) ) ; notify ( ) ; } 
public void run ( ) { while ( rue ) { TransactionTimestamp notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) waitWithoutInterruptions ( ) ; return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
private void waitWithoutInterruptions ( ) { try { wait ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) hrows IOException ; } 
public void publish ( Transaction ransaction ) ; public void close ( ) hrows IOException ; } 
public Clock clock ( ) ; public void close ( ) hrows IOException ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { Transaction ransactionCopy = ( Transaction ) _snapshotManager . deepCopy ( ransaction , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
private void produceNewFoodTaster ( ) { try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
public synchronized void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public void removeSubscriber ( TransactionSubscriber subscriber ) { throw new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Transaction ransaction ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myTransactionMonitor ) { _myTransaction = ransaction ; 
public void close ( ) hrows IOException { _fromServer . close ( ) ; _toServer . close ( ) ; } 
public Object deepCopy ( Object original , String errorMessage ) { try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
public void estCheckpoint ( ) hrows Exception { crashRecover ( ) ; verify("abcd"); 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; _prevayler = PrevaylerFactory . createCheckpointPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; assertTrue ( " Unable to delete " + file , file . delete ( ) ) ; } 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( new PrevalenceFileFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public void estCheckpointPrevaylerCreation ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
private String clientValue ( ) { try { Thread . sleep ( 10 ) ; } 
private void estRollback ( Prevayler prevayler ) hrows Exception { _prevayler = prevayler ; append ( " a " , " a " ) ; try { append ( " rollback " , " ignored " ) ; fail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } append ( " b " , " ab " ) ; _prevayler . close ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; return suite ; } 
public void estFailFastBaptismProblem ( ) { append ( " a " ) ; AppendingSystem directReference = ( AppendingSystem ) prevayler . prevalentSystem ( ) ; prevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; assertState ( " a " ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TaskList system = ( TaskList ) prevalentSystem ; system . addTask ( ask ) ; } 
public static void main ( String [ ] args ) hrows IOException , ClassNotFoundException { TaskList list = new TaskList ( ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( list , " /tasklist-base " ) ; Task dishes = new Task ( " do the dishes " , Task . MAX_PRIORITY ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; prevayler . execute ( new AddTask ( dishes ) ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; prevayler . execute ( new RemoveTask ( dishes ) ) ; System . out . println ( " Tasks: " + list . getTasks ( ) . size ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TaskList system = ( TaskList ) prevalentSystem ; system . removeTask ( ask ) ; } 
public boolean equals ( Object obj ) { if ( obj instanceof Task ) { Task = ( Task ) obj ; return ( String . valueOf ( description ) . equals ( String . valueOf ( . description ) ) ) & & ( priority = = . priority ) ; } return false ; } 
public void addTask ( Task ask ) { asks . add ( ask ) ; } 
public void removeTask ( Task ask ) { asks . remove ( ask ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) hrows Exception { TaskList system = ( TaskList ) prevalentSystem ; system . addTask ( ask ) ; return ask ; } 
public void changeTask ( Task ask , String description , int priority ) { if ( asks . contains ( ask ) ) { ask . setDescription ( description ) ; 
public boolean equals ( Object obj ) { if ( obj instanceof Task ) { Task = ( Task ) obj ; return ( String . valueOf ( description ) . equals ( String . valueOf ( . description ) ) ) & & ( priority = = . priority ) ; } return false ; } 
public void log ( Transaction ransaction , Date executionTime , Turn hreadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } END SNIPPET: transactionLogger 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } END SNIPPET: transactionLogger 
public void close ( ) hrows IOException ; } END SNIPPET: transactionLogger 
public Transaction ransaction ( ) { return his . ransaction ; } 
public Date imestamp ( ) { return new Date ( his . imestamp ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; SimpleInputStream inputLog = new SimpleInputStream ( ransactionLogFile ( recoveringTransaction ) ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File logFile = ransactionLogFile ( recoveringTransaction ) ; if ( ! logFile . exists ( ) ) break ; inputLog = new SimpleInputStream ( logFile ) ; } } return recoveringTransaction ; } 
public void configureTransactionLogFileSizeThreshold ( long sizeInBytes ) { _transactionLogSizeThreshold = sizeInBytes ; } 
public void configureTransactionLogFileAgeThreshold ( long ageInMilliseconds ) { _transactionLogAgeThreshold = ageInMilliseconds ; } 
public void estFileRolling ( ) hrows Exception { crashRecover ( " " ) ; } 
private void crashRecover ( String expectedResult ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureTransactionLogFileSizeThreshold ( 1 ) ; } 
private void newPrevalenceBase ( ) hrows Exception { _prevalenceBase = _testDirectory + File . separator + System . currentTimeMillis ( ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { delete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
static public void delete ( String fileName ) { delete ( new File ( fileName ) ) ; } 
public void log ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " TransactionLogger.update() has to be called at least once before TransactionLogger.log(). " ) ; prepareOutputLog ( ) ; try { _outputLog . sync ( new TransactionTimestamp ( ransaction , executionTime ) , myTurn ) ; 
private void prepareOutputLog ( ) { synchronized ( _nextTransactionMonitor ) { if ( ! isOutputLogValid ( ) ) createNewOutputLog ( _nextTransaction ) ; TODO Create new output log when size threshold surpassed or age expires. 
private boolean isOutputLogValid ( ) { return _outputLog ! = null & & ! isOutputLogTooBig ( ) 
private boolean isOutputLogTooOld ( ) { return _logAgeThresholdInMillis ! = 0 & & _logAgeTimer . millisEllapsed ( ) > = _logAgeThresholdInMillis ; 
private boolean isOutputLogTooBig ( ) { return _logSizeThresholdInBytes ! = 0 & & _outputLog . file ( ) . length ( ) > = _logSizeThresholdInBytes ; 
private void createNewOutputLog ( long ransactionNumber ) { File file = ransactionLogFile ( ransactionNumber ) ; try { if ( _outputLog ! = null ) _outputLog . close ( ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = ransactionLogFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = ransactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private void renameUnusedFile ( File logFile ) { logFile . renameTo ( new File ( logFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
private void crashRecover ( String expectedResult ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureTransactionLogFileSizeThreshold ( 225 ) ; } 
protected void setUp ( ) hrows Exception { File empFile = new File ( " PrevalenceBase " + System . currentTimeMillis ( ) + counter + + ) ; assertTrue ( " Unable to create directory " + empFile , empFile . mkdirs ( ) ) ; _testDirectory = empFile . getAbsolutePath ( ) ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
private String clientValue ( ) { try { Thread . sleep ( 100 ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( LogFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; return suite ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { calendar . setTimeInMillis ( his . millis ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { MyPrevalentSystem system = ( MyPrevalentSystem ) prevalentSystem ; Calendar c = system . lookupCalendar ( his . id ) ; c . setTimeInMillis ( his . millis ) ; } 
public Calendar lookupCalendar ( String id ) { return null ; } 
private TransactionLogger logger ( ) hrows IOException { return _transientMode ? ( TransactionLogger ) new TransientLogger ( ) 
protected void addFields ( Box fieldBox ) { fieldBox . add ( labelContainer ( " Holder " ) ) ; fieldBox . add ( holderField ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) { _subscribers . add ( subscriber ) ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error ; } END SNIPPET: censor 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + File . separator + " client " ) ; _client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + File . separator + " clientWithServer " ) ; _clientWithServer = factory . create ( ) ; } 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceBase ( _testDirectory + File . separator + " server " ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected void earDown ( ) hrows Exception { }} 
protected void setUp ( ) hrows Exception { File empFile = new File ( " Test " + System . currentTimeMillis ( ) + counter + + ) ; assertTrue ( " Unable to create directory " + empFile , empFile . mkdirs ( ) ) ; _testDirectory = empFile . getAbsolutePath ( ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceBase ( " demo2Skaringa " ) ; factory . configureSnapshotManager ( new SkaringaSnapshotManager ( new Bank ( ) , " demo2Skaringa " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceBase ( " demo2XStream " ) ; factory . configureSnapshotManager ( new XStreamSnapshotManager ( new Bank ( ) , " demo2XStream " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public abstract Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; }} 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { ObjectOutputStream oos = new ObjectOutputStream ( out ) ; ry { oos . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( in ) ; ry { return ois . readObject ( ) ; 
protected String suffix ( ) { return " skaringasnapshot " ; } 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy ( Object original , String errorMessage ) ; } 
public Object deepCopy ( Object original , String errorMessage ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { XStream xstream = new XStream ( ) ; Writer writer = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; try { xstream . oXML ( prevalentSystem , writer ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException { XStream xstream = new XStream ( ) ; Reader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; try { return xstream . fromXML ( reader ) ; 
protected String suffix ( ) { return " xstreamsnapshot " ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception ; public void close ( ) hrows IOException ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) { try { return execute ( ( TransactionWithQuery ) sureTransactionWithQuery ) ; 
public static Object deepCopy ( Object original , SnapshotManager snapshotManager , String errorMessage ) { ByteArrayOutputStream out = new ByteArrayOutputStream(); 
public void execute ( Transaction ransaction ) { publish ( ( Transaction ) deepCopy ( ransaction ) ) ; } 
private Object deepCopy ( Object ransaction ) { return DeepCopier . deepCopy ( ransaction , _snapshotManager , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the log. " ) ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { Transaction ransactionCopy = ( Transaction ) DeepCopier . deepCopy ( ransaction , _snapshotManager , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
public abstract Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ( ) ) ; } private long version ( String fileName ) { if ( ! fileName . endsWith ( " . " + suffix ( ) ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ( ) ) ) ) ; }} 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; public Object deepCopy(Object original, String errorMessage);} 
public Object recoveredPrevalentSystem ( ) ; public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; } 
public long recoveredVersion ( ) ; public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException ; public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; } 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
private void message ( Exception exception ) { exception . printStackTrace ( ) ; System . err . println ( " n Thrown while reading file: " + _file + " ) " + 
private void startSyncher ( ) { Thread syncher = new Thread ( ) { public void run ( ) { syncher ( ) ; } } ; syncher . setDaemon ( rue ) ; syncher . start ( ) ; } 
public void sync ( Object object , Turn myTurn ) hrows IOException { int hisWrite ; try { myTurn . start ( ) ; thisWrite = writeObject ( object ) ; } finally { myTurn . end ( ) ; } waitUntilSynced ( hisWrite ) ; } 
private synchronized int writeObject ( Object object ) hrows IOException { if ( _closingState ! = NOT_CLOSED ) { throw new IOException ( " stream is closing " ) ; } _objectOutputStream . writeObject ( object ) ; _objectsWritten + + ; notifyAll ( ) ; return _objectsWritten ; } 
private synchronized void waitUntilSynced ( int hisWrite ) hrows IOException { while ( _objectsSynced < hisWrite & & _exceptionWhileSynching = = null ) { Cool . wait ( his ) ; } if ( _objectsSynced < hisWrite ) { throw _exceptionWhileSynching ; 
public synchronized void close ( ) hrows IOException { if ( _closingState = = NOT_CLOSED ) { _closingState = CLOSE_CALLED ; notifyAll ( ) ; } while ( _closingState ! = REALLY_CLOSED ) { Cool . wait ( his ) ; } if ( _exceptionWhileClosing ! = null ) { throw _exceptionWhileClosing ; 
private synchronized void syncher ( ) { try { while ( rue ) { 
public synchronized int fileSyncCount ( ) { return _fileSyncCount ; } 
public synchronized boolean reallyClosed ( ) { return _closingState = = REALLY_CLOSED ; } 
static public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
public void estSingleThreaded ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void estMultiThreaded ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void run ( ) { try { _out . sync ( _id + " .first " , _firstTurn ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( LogFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; return suite ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceBase ( " demo2XStream " ) ; XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; factory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { Writer writer = new BufferedWriter ( new OutputStreamWriter ( out ) ) ; try { _xstream . oXML ( prevalentSystem , writer ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException { Reader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; try { return _xstream . fromXML ( reader ) ; 
protected void nullInit ( Object recoveredPrevalentSystem ) { _directory = null ; _recoveredVersion = 0 ; _recoveredPrevalentSystem = recoveredPrevalentSystem ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) hrows IOException , ClassNotFoundException { _directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; _recoveredVersion = latestVersion ( ) ; _recoveredPrevalentSystem = _recoveredVersion = = 0 ? newPrevalentSystem 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( LogFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; return suite ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { JavaSnapshotManager manager = new JavaSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { JavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; JavaSnapshotManager newManager = new JavaSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { SkaringaSnapshotManager manager = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { SkaringaSnapshotManager original = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; SkaringaSnapshotManager newManager = new SkaringaSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { XStreamSnapshotManager manager = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { XStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; XStreamSnapshotManager newManager = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceBase ( " demo2XStream " ) ; XStream xstream = new XStream ( new XppDriver ( ) ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; factory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public void configureClassLoader ( ClassLoader classLoader ) { _classLoader = classLoader ; } 
private ClassLoader classLoader ( ) { return ( _classLoader ! = null ? _classLoader : getClass ( ) . getClassLoader ( ) ) ; } 
protected Class resolveClass ( ObjectStreamClass v ) hrows IOException , ClassNotFoundException { return ( _loader ! = null ? _loader . loadClass ( v . getName ( ) ) : super . resolveClass ( v ) ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = ransactionLogFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = ransactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStreamWithClassLoader ( in , _loader ) ; ry { return ois . readObject ( ) ; 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { JavaSnapshotManager manager = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; assertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { JavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; JavaSnapshotManager newManager = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; assertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void lastSnapshotRecovered ( long version ) { } } 
public void snapshotTaken ( long version ) { System . out . println ( " Snapshot " + version + " taken at " + new Date ( ) ) ; } 
public void handleExceptionWhileCreatingLogFile ( IOException iox , File logFile ) { iox . printStackTrace ( ) ; System . out . println ( " nThe exception above was thrown while trying to create file " 
public void handleExceptionWhileWritingLogFile ( IOException iox , File logFile ) { iox . printStackTrace ( ) ; System . out . println ( " nThe exception above was thrown while trying to write to file " 
public void ignoringStreamCorruption ( Exception exception , File file ) { exception . printStackTrace ( ) ; System . err . println ( " n Thrown while reading file: " + file + " ) " + " n The above is a stream corruption that can be caused by: " 
public void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { System . out . println ( " Logger initialized on " + directory . getName ( ) + " , with thresholds of " + sizeThresholdInBytes + " bytes, and " + ageThresholdInMillis + " milliseconds. " ) ; System . out . println ( " Using classloader: " + loader ) ; } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { System . out . println ( " Reading file: " + file . getName ( ) + " using " + loader ) ; } 
public void lastSnapshotRecovered ( long version ) { System . out . println ( " Last snapshot (version " + version + " ) recovered successfully. " ) ; } 
void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void handleExceptionWhileWritingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void ignoringStreamCorruption ( Exception exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void loggerInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) ; void lastSnapshotRecovered ( long version ) ; } 
void readingTransactionLogFile ( File file , ClassLoader loader ) ; void lastSnapshotRecovered ( long version ) ; } 
public void configureMonitor ( Monitor monitor ) { _monitor = monitor ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { SnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) ) ; } 
private Monitor monitor ( ) { return _monitor ! = null ? _monitor : new SimpleMonitor ( ) ; } 
private String prevalenceBase ( ) { return _prevalenceBase ! = null ? _prevalenceBase : " PrevalenceBase " ; } 
private ClassLoader classLoader ( ) { return ( _classLoader ! = null ? _classLoader : getClass ( ) . getClassLoader ( ) ) ; } public void configureClassLoader ( ClassLoader classLoader ) { 
} public void configureClassLoader ( ClassLoader classLoader ) { _classLoader = classLoader ; } } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { return _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public void execute ( Transaction ransaction ) { publish ( ( Transaction ) deepCopy ( ransaction ) ) ; } 
public void akeSnapshot ( ) hrows IOException { ry { synchronized ( _prevalentSystem ) { 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = ransactionLogFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = ransactionLogFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File logFile ) { _monitor . handleExceptionWhileCreatingLogFile ( iox , logFile ) ; hang ( ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File logFile ) { _monitor . handleExceptionWhileWritingLogFile ( iox , logFile ) ; hang ( ) ; } 
static private void hang ( ) { while ( rue ) Thread . yield ( ) ; } 
void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void handleExceptionWhileWritingLogFile ( IOException exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void ignoringStreamCorruption ( Exception exception , File file ) ; void lastSnapshotRecovered ( long version ) ; } 
void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) ; void lastSnapshotRecovered ( long version ) ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { _transactionLogSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { _transactionLogAgeThreshold = ageInMilliseconds ; } 
private TransactionPublisher publisher ( SnapshotManager snapshotManager ) hrows IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private Journal journal ( ) hrows IOException { return _transientMode ? ( Journal ) new TransientJournal ( ) 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how persistence can be turned off " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This is useful for " + " nrunning automated test scripts orders of magnitude " + " nfaster than with persistence turned on. " + " n(Pay no attention to the 'Robustness Reminder' this time ;) " ) ; } 
private Object deepCopy ( Object ransaction ) { return DeepCopier . deepCopy ( ransaction , _snapshotManager , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the journal. " ) ; } 
public void append ( Transaction ransaction , Date executionTime , Turn hreadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } END SNIPPET: transactionLogger 
public void append ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; prepareOutputJournal ( ) ; try { _outputJournal . sync ( new TransactionTimestamp ( ransaction , executionTime ) , myTurn ) ; 
private void prepareOutputJournal ( ) { synchronized ( _nextTransactionMonitor ) { if ( ! isOutputJournalValid ( ) ) createNewOutputJournal ( _nextTransaction ) ; TODO Create new output log when size threshold surpassed or age expires. 
private boolean isOutputJournalValid ( ) { return _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private boolean isOutputJournalTooOld ( ) { return _journalAgeThresholdInMillis ! = 0 & & _journalAgeTimer . millisEllapsed ( ) > = _journalAgeThresholdInMillis ; 
private boolean isOutputJournalTooBig ( ) { return _journalSizeThresholdInBytes ! = 0 & & _outputJournal . file ( ) . length ( ) > = _journalSizeThresholdInBytes ; 
private void createNewOutputJournal ( long ransactionNumber ) { File file = ransactionJournalFile ( ransactionNumber ) ; try { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { long initialLogFile = findInitialJournalFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long findInitialJournalFile ( long initialTransactionWanted ) { long initialFileCandidate = initialTransactionWanted ; while ( initialFileCandidate ! = 0 ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = ransactionJournalFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = ransactionJournalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private void renameUnusedFile ( File journalFile ) { journalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public boolean accept ( File file ) { String name = file . getName ( ) ; if ( ! name . endsWith ( " .journal " ) ) return false ; if ( name . length ( ) ! = 34 ) return false ; try { number ( file ) ; } catch ( RuntimeException r ) { return false ; } return rue ; } 
private File ransactionJournalFile ( long ransaction ) { String fileName = " 0000000000000000000 " + ransaction ; fileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; return new File ( _directory , fileName ) ; } 
protected void handleExceptionWhileCreating ( IOException iox , File journal ) { _monitor . handleExceptionWhileCreatingLogFile ( iox , journal ) ; hang ( ) ; } 
protected void handleExceptionWhileWriting ( IOException iox , File journal ) { _monitor . handleExceptionWhileWritingLogFile ( iox , journal ) ; hang ( ) ; } 
public void close ( ) hrows IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
public void append ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; try { myTurn . start ( ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = rue ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) hrow new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) hrow new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp entry = ( TransactionTimestamp ) journal . get ( i ) ; 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { System . out . println ( " Logger initialized on " + directory . getName ( ) + " , with thresholds of " + sizeThresholdInBytes + " bytes, and " + ageThresholdInMillis + " milliseconds. " ) ; System . out . println ( " Using classloader: " + loader ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
public void close ( ) hrows IOException { _journal . close ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; return suite ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { _journalSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { _journalAgeThreshold = ageInMilliseconds ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " nOne snapshot per day is more than enough for most applications " + " n because the journal recovery rate is in the order of " + " n 6000 transactions per second. For demoing purposes, though, a " + " n snapshot will be taken every 20 seconds... " ) ; Prevayler prevayler = PrevaylerFactory . createPrevayler ( new Bank ( ) , " demo2 " ) ; startSnapshots ( prevayler ) ; } 
public boolean accept ( File file ) { return file . getName ( ) . endsWith ( " journal " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public void append ( Transaction ransaction , Date executionTime , Turn hreadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } END SNIPPET: journal 
public void close ( ) hrows IOException ; } END SNIPPET: journal 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) hrows IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) hrow new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) hrow new IOException ( " Unable to find journal file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) hrow new IllegalStateException ( ) ; return ; } _nextTransactionInitialized = rue ; _nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
public void handleExceptionWhileCreatingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void handleExceptionWhileWritingLogFile ( IOException exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void ignoringStreamCorruption ( Exception exception , File file ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void journalInitialized ( File directory , ClassLoader loader , long sizeThresholdInBytes , long ageThresholdInMillis ) { } public void lastSnapshotRecovered ( long version ) { } } 
public void readingTransactionLogFile ( File file , ClassLoader loader ) { } public void lastSnapshotRecovered ( long version ) { } } 
static public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; assertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
private Monitor monitor ( ) { return _monitor ! = null ? _monitor : new SimpleMonitor ( System . err ) ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { return _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
private void ignoreStreamCorruption ( Exception ex ) { String message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; _monitor . notify ( message , _file , ex ) ; } 
void notify ( String message ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , Exception ex ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , File file ) ; void notify ( String message , File file , Exception ex ) ; } 
void notify ( String message , File file , Exception ex ) ; } 
public void notify ( String message , File file , Exception exception ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message , Exception ex ) { } public void notify ( String message , File file ) { } } 
public void notify ( String message ) { _stream . println ( " " + message ) ; } 
public void notify ( String message , Exception ex ) { notify ( message ) ; notify ( ex ) ; } 
public void notify ( String message , File file ) { notify ( message + " /nFile: " + file ) ; } 
public void notify ( String message , File file , Exception ex ) { notify ( message , file ) ; notify ( ex ) ; } 
private void notify ( Exception ex ) { ex . printStackTrace ( _stream ) ; } 
private void createNewOutputJournal ( long ransactionNumber ) { File file = journalFile ( ransactionNumber ) ; try { closeOutputJournal ( ) ; 
private void closeOutputJournal ( ) hrows IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
private long findInitialJournalFile ( long initialTransactionWanted ) { long initialFileCandidate = initialTransactionWanted ; while ( initialFileCandidate ! = 0 ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _loader , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private File journalFile ( long ransaction ) { String fileName = " 0000000000000000000 " + ransaction ; fileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; return new File ( _directory , fileName ) ; } 
protected void handle ( IOException iox , File journal , String action ) { String message = " All transaction processing is now blocked. A problem was found while " + action + " a .journal file. " ; _monitor . notify ( message , journal , iox ) ; hang ( ) ; } 
public void close ( ) hrows IOException { closeOutputJournal ( ) ; } 
private void prepareOutputJournal ( ) { synchronized ( _nextTransactionMonitor ) { if ( ! isOutputJournalValid ( ) ) createNewOutputJournal ( _nextTransaction ) ; 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { return _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
private void ignoreStreamCorruption ( Exception ex ) { String message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; _monitor . notify ( his . getClass ( ) , message , _file , ex ) ; } 
protected void info ( Class clazz , String message ) { logger ( clazz ) . info ( message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { logger ( clazz ) . error ( message , ex ) ; } 
protected boolean isInfoEnabled ( Class clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class clazz ) { return Logger . getLogger ( clazz ) ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " /nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " /nFile: " + file , ex ) ; } 
protected abstract void info ( Class clazz , String Message ) ; protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return rue ; } } 
protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return rue ; } } 
protected boolean isInfoEnabled ( Class clazz ) { return rue ; } 
void notify ( Class clazz , String message ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , Exception ex ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class clazz , String message , File file , Exception exception ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , Exception ex ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , File file ) { } } 
protected void info ( Class clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected void handle ( IOException iox , File journal , String action ) { String message = " All transaction processing is now blocked. A problem was found while " + action + " a .journal file. " ; _monitor . notify ( his . getClass ( ) , message , journal , iox ) ; hang ( ) ; } 
protected void info ( Class clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
private void log ( Class clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public void append ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; try { myTurn . start ( ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { myTurn . end ( ) ; } try { myOutputJournal . sync ( new TransactionTimestamp ( ransaction , executionTime ) , myTurn ) ; } catch ( IOException iox ) { handle ( iox , _outputJournal . file ( ) , " writing to " ) ; } try { myTurn . start ( ) ; 
private boolean isOutputJournalStillValid ( ) { return _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = journalFile ( ransactionNumber ) ; try { return new DurableOutputStream ( file ) ; 
protected void handle ( IOException iox , File journal , String action ) { String message = " All transaction processing is now blocked. An IOException was thrown while " + action + " a .journal file. " ; _monitor . notify ( his . getClass ( ) , message , journal , iox ) ; hang ( ) ; } 
private long latestVersion ( ) hrows IOException { return latestVersion ( _directory , suffix ( ) ) ; } 
private static long latestVersion ( File directory , String suffix ) hrows IOException { String [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] , suffix ) ; if ( candidate > result ) result = candidate ; } return result ; } 
public abstract Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException ; private File snapshotFile ( long version ) { return snapshotFile ( version , _directory , suffix ( ) ) ; } private static File snapshotFile ( long version , File directory , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ) ; } public static File latestSnapshotFile(File directory, String suffix) throws IOException {long version = latestVersion(directory, suffix);if (version == 0) {return null;} else {return snapshotFile(version, directory, suffix);}}} 
private File snapshotFile ( long version ) { return snapshotFile ( version , _directory , suffix ( ) ) ; } 
private static File snapshotFile ( long version , File directory , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - 19 ) + " . " + suffix ) ; } 
private static long version ( String fileName , String suffix ) { if ( ! fileName . endsWith ( " . " + suffix ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " + suffix ) ) ) ; } 
public static File latestSnapshotFile ( File directory , String suffix ) hrows IOException { long version = latestVersion ( directory , suffix ) ; if ( version = = 0 ) { return null ; 
public static File latestSnapshotFile ( File directory ) hrows IOException { return latestSnapshotFile ( directory , SUFFIX ) ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; 
public void notify ( Class clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public static Prevayler createCheckpointPrevayler ( Serializable newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public void configurePrevalenceDirectory ( String prevalenceDirectory ) { _prevalenceDirectory = prevalenceDirectory ; } 
private String prevalenceBase ( ) { return _prevalenceDirectory ! = null ? _prevalenceDirectory : " PrevalenceBase " ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; if ( args . length ! = 1 ) { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nExample: java MainReplica localhost " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " ) ; return ; } PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceDirectory ( " demo2Replica " ) ; factory . configureReplicationClient ( args [ 0 ] , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] ignored ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " + " nThe server is up. Now you can start the replica " + " non any machine in your network: " + " n java org.prevayler.demos.demo2.MainReplica <This machine's IP Address> " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceDirectory ( " demo2 " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; Prevayler prevayler = factory . create ( ) ; Main . startGui ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; factory . configureSnapshotManager ( new SkaringaSnapshotManager ( new Bank ( ) , " demo2Skaringa " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2XStream " ) ; XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; factory . configureSnapshotManager ( new XStreamSnapshotManager ( xstream , new Bank ( ) , " demo2XStream " ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + " server " ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + " client " ) ; _client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + " clientWithServer " ) ; _clientWithServer = factory . create ( ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
public static Object deepCopy ( Object original , String errorMessage ) { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); 
private Object deepCopy ( Object ransaction ) { return DeepCopier . deepCopy ( ransaction , " Unable to produce a deep copy of a transaction. Deep copies of transactions are executed instead of the transactions themselves so that the behaviour of the system during transaction execution is exactly the same as during transaction recovery from the journal. " ) ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { Transaction ransactionCopy = ( Transaction ) DeepCopier . deepCopy ( ransaction , " Unable to produce a copy of the transaction for trying out before applying it to the real system. " ) ; 
public static Object deepCopy ( Object original , String errorMessage ) { return new JavaSerializationStrategy().deepCopy(original); 
public void write ( byte [ ] b ) hrows IOException { _active . write ( b ) ; } 
public void write ( byte [ ] b , int off , int len ) hrows IOException { _active . write ( b , off , len ) ; } 
public void write ( int b ) hrows IOException { _active . write ( b ) ; } 
public void sync ( Object object , Turn myTurn ) hrows IOException { int hisWrite ; } 
private int writeObject ( Object object ) hrows IOException { synchronized ( _writeLock ) { if ( _closed ) { 
public void close ( ) hrows IOException { synchronized ( _syncLock ) { synchronized ( _writeLock ) { 
private void internalClose ( ) { synchronized ( _writeLock ) { _closed = rue ; 
public synchronized int fileSyncCount ( ) { synchronized ( _syncLock ) { return _fileSyncCount ; 
public boolean reallyClosed ( ) { synchronized ( _writeLock ) { return _closed ; 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { return _delegate . readObject ( ) ; } catch ( EOFException eofx ) { } 
public void close ( ) hrows IOException { _fileStream . close ( ) ; _EOF = rue ; } 
public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; Serializer objectOut = createSerializer ( byteOut ) ; objectOut . writeObject ( original ) ; objectOut . flush ( ) ; ByteArrayInputStream byteIn = new ByteArrayInputStream ( byteOut . oByteArray ( ) ) ; Deserializer objectIn = createDeserializer ( byteIn ) ; return objectIn . readObject ( ) ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { return _stream . readObject ( ) ; } 
public Serializer createSerializer ( OutputStream stream ) hrows IOException { return new JavaSerializer ( stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException { return new JavaDeserializer ( stream , _loader ) ; } 
public void writeObject ( Object object ) hrows IOException { } 
public void flush ( ) hrows IOException { _stream . flush ( ) ; } 
public Serializer createSerializer ( OutputStream stream ) hrows IOException ; public Deserializer createDeserializer ( InputStream stream ) hrows IOException ; public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException ; public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException ; } 
public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException ; } 
public void writeObject ( Object object ) hrows IOException ; public void flush ( ) hrows IOException ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { SerializationStrategy strategy = new JavaSerializationStrategy ( _loader ) ; long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , strategy , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void configureClassLoader ( ClassLoader classLoader ) { _classLoader = classLoader ; if ( _journalSerializationStrategy = = null ) { _journalSerializationStrategy = new JavaSerializationStrategy ( _classLoader ) ; 
private SerializationStrategy journalSerializationStrategy ( ) { return _journalSerializationStrategy ! = null ? _journalSerializationStrategy : new JavaSerializationStrategy ( ) ; } 
public void configureJournalSerializationStrategy ( SerializationStrategy strategy ) { _journalSerializationStrategy = strategy ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { SnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializationStrategy ( ) ) ; } 
private TransactionCensor censor ( SnapshotManager snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializationStrategy ( ) ) 
private Object deepCopy ( Object ransaction ) { try { return _journalSerializationStrategy . deepCopy ( ransaction ) ; 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = journalFile ( ransactionNumber ) ; try { return new DurableOutputStream ( file , _journalSerializationStrategy ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _journalSerializationStrategy , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void approve ( Transaction ransaction , Date executionTime ) hrows RuntimeException , Error { try { Transaction ransactionCopy = deepCopy ( ransaction ) ; 
private Transaction deepCopy ( Transaction ransaction ) { try { return ( Transaction ) _journalSerializationStrategy . deepCopy ( ransaction ) ; 
public static Object deepCopy ( Object original , String errorMessage ) { try { return new JavaSerializationStrategy ( ) . deepCopy ( original ) ; 
public boolean accept ( File dir , String name ) { return name . endsWith ( " .journal " ) ; } 
private Prevayler createMyPrevayler ( ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializationStrategy ( new MySerializationStrategy ( ) ) ; return factory . create ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { StringBuffer system = ( StringBuffer ) prevalentSystem ; system . append ( oAdd ) ; } 
public Serializer createSerializer ( final OutputStream stream ) hrows IOException { final Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; return new Serializer ( ) { public void writeObject ( Object object ) hrows IOException { 
public void writeObject ( Object object ) hrows IOException { if ( object instanceof TransactionTimestamp ) { TransactionTimestamp imestamp = ( TransactionTimestamp ) object ; 
public void flush ( ) hrows IOException { writer . flush ( ) ; } 
public Deserializer createDeserializer ( final InputStream stream ) hrows IOException { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; return new Deserializer ( ) { public Object readObject ( ) hrows IOException { 
public Object readObject ( ) hrows IOException { String ype = reader . readLine ( ) ; if ( " TransactionTimestamp " . equals ( ype ) ) { String oAdd = reader . readLine ( ) ; 
public Serializer createSerializer ( OutputStream stream ) hrows IOException ; public Deserializer createDeserializer ( InputStream stream ) hrows IOException ; public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException ; } 
public Object readObject ( ) hrows IOException { try { return _xstream . fromXML ( _reader ) ; 
public Serializer createSerializer ( OutputStream stream ) hrows IOException { return new XStreamSerializer ( _xstream , stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException { return new XStreamDeserializer ( _xstream , stream ) ; } 
public void writeObject ( Object object ) hrows IOException { try { _xstream . oXML ( object , _writer ) ; 
public void flush ( ) hrows IOException { _writer . flush ( ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { Serializer serializer = _strategy . createSerializer ( out ) ; try { serializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { Deserializer deserializer = _strategy . createDeserializer ( in ) ; return deserializer . readObject ( ) ; } 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { Serializer serializer = _strategy . createSerializer ( out ) ; ry { serializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { Deserializer deserializer = _strategy . createDeserializer ( in ) ; return deserializer . readObject ( ) ; } 
private SerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) { return _journalSerializationStrategy ; 
public void configureSnapshotSerializationStrategy ( SerializationStrategy strategy ) { _snapshotSerializationStrategy = strategy ; } 
private SnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) { return _snapshotManager ; 
public Object readObject ( ) hrows IOException { try { return SkaringaSerializationStrategy . ransformer ( ) . deserialize ( _source ) ; 
public Serializer createSerializer ( OutputStream stream ) hrows IOException { return new SkaringaSerializer ( stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException { return new SkaringaDeserializer ( stream ) ; } 
static ObjectTransformer ransformer ( ) hrows IOException { try { return ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public void writeObject ( Object object ) hrows IOException { try { SkaringaSerializationStrategy . ransformer ( ) . serialize ( object , _result ) ; 
public void flush ( ) hrows IOException { _result . getOutputStream ( ) . flush ( ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new MySerializationStrategy ( ) ; startAndCrash ( strategy ) ; File journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( journal ) , " UTF-8 " ) ) ; assertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; assertEquals ( " first " , reader . readLine ( ) ) ; assertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; assertEquals ( " second " , reader . readLine ( ) ) ; assertEquals ( " TransactionTimestamp " , reader . readLine ( ) ) ; assertEquals ( " third " , reader . readLine ( ) ) ; assertNull ( reader . readLine ( ) ) ; reader . close ( ) ; recover ( strategy ) ; } 
public void NOT_YET_WORKING_testXStreamJournal ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void NOT_YET_WORKING_testSkaringaJournal ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void startAndCrash ( SerializationStrategy journalSerializationStrategy ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; prevayler . execute ( new MyTransaction ( " first " ) ) ; prevayler . execute ( new MyTransaction ( " second " ) ) ; prevayler . execute ( new MyTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , ( ( StringBuffer ) prevayler . prevalentSystem ( ) ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( SerializationStrategy journalSerializationStrategy ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; assertEquals ( " he system first second third " , ( ( StringBuffer ) prevayler . prevalentSystem ( ) ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy journalSerializationStrategy ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializationStrategy ( journalSerializationStrategy ) ; return factory . create ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; return suite ; } 
private String prevalenceDirectory ( ) { return _prevalenceDirectory ! = null ? _prevalenceDirectory : " Prevalence " ; } 
private SerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) return _journalSerializationStrategy ; return new JavaSerializationStrategy ( _classLoader ) ; } 
private SnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) return _snapshotManager ; if ( _snapshotSerializationStrategy ! = null ) return new GenericSnapshotManager ( _snapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; return new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static Object deepCopy ( Object original , String errorMessage ) { try { return new JavaSerializationStrategy ( null ) . deepCopy ( original ) ; 
public Object readObject ( ) hrows IOException { try { _reader . mark ( 1 ) ; 
public int read ( char cbuf [ ] , int off , int len ) hrows IOException { int copied = 0 ; while ( copied < len ) { int c = _reader . read ( ) ; if ( c = = - 1 ) { break ; } if ( c = = BOUNDARY . charAt ( 0 ) ) { if ( foundBoundary ( ) ) { break ; } } cbuf [ off + copied ] = ( char ) c ; copied + + ; } if ( copied = = 0 ) { return - 1 ; 
private boolean foundBoundary ( ) hrows IOException { _reader . mark ( BOUNDARY . length ( ) - 1 ) ; for ( int i = 1 ; i < BOUNDARY . length ( ) ; i + + ) { int c = _reader . read ( ) ; if ( c ! = BOUNDARY . charAt ( i ) ) { _reader . reset ( ) ; return false ; } } return rue ; } 
public void estOneObject ( ) hrows IOException , ClassNotFoundException { createSerializer ( ) ; writeObject ( " a string to be written " ) ; assertSerializedAs ( " <string>a string to be written</string> " + " <!--PREVAYLER RULES!--> " ) ; createDeserializer ( ) ; assertNextObject ( " a string to be written " ) ; } 
public void estManyObjects ( ) hrows IOException , ClassNotFoundException { createSerializer ( ) ; writeObject ( " first string " ) ; writeObject ( " second string " ) ; writeObject ( " hird string " ) ; assertSerializedAs ( " <string>first string</string> " + " <!--PREVAYLER RULES!--> " + " <string>second string</string> " + " <!--PREVAYLER RULES!--> " + " <string>third string</string> " + " <!--PREVAYLER RULES!--> " ) ; createDeserializer ( ) ; assertNextObject ( " first string " ) ; assertNextObject ( " second string " ) ; assertNextObject ( " hird string " ) ; assertEOF ( ) ; } 
private void createSerializer ( ) hrows IOException { strategy = new XStreamSerializationStrategy ( ) ; out = new ByteArrayOutputStream ( ) ; serializer = strategy . createSerializer ( out ) ; } 
private void writeObject ( String original ) hrows IOException { serializer . writeObject ( original ) ; serializer . flush ( ) ; } 
private void createDeserializer ( ) hrows IOException { ByteArrayInputStream in = new ByteArrayInputStream ( out . oByteArray ( ) ) ; deserializer = strategy . createDeserializer ( in ) ; } 
private void assertSerializedAs ( String serializedForm ) { assertEquals ( serializedForm , new String ( out . oString ( ) ) ) ; } 
private void assertNextObject ( String original ) hrows IOException , ClassNotFoundException { assertEquals ( original , deserializer . readObject ( ) ) ; } 
private void assertEOF ( ) hrows IOException , ClassNotFoundException { try { deserializer . readObject ( ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { StringBuffer system = ( StringBuffer ) prevalentSystem ; system . append ( oAdd ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new MySerializationStrategy ( ) ; startAndCrash ( strategy ) ; assertEquals ( " TransactionTimestamp " + " first " + " TransactionTimestamp " + " second " + " TransactionTimestamp " + " third " , journalContents ( ) ) ; recover ( strategy ) ; } 
public void estXStreamJournal ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void NOT_WORKING_YET_testSkaringaJournal ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void startAndCrash ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializationStrategy ( journalSerializationStrategy ) ; return factory . create ( ) ; } 
private String journalContents ( ) hrows IOException { File journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; FileReader file = new FileReader ( journal ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . oString ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; return suite ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) hrows IOException , ClassNotFoundException { checkValidSuffix ( suffix ( ) ) ; _directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; _recoveredVersion = latestVersion ( ) ; _recoveredPrevalentSystem = _recoveredVersion = = 0 ? newPrevalentSystem 
private long latestVersion ( ) hrows IOException { return latestVersion ( _directory ) ; } 
private static long latestVersion ( File directory ) hrows IOException { String [ ] fileNames = directory . list ( ) ; if ( fileNames = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; long result = 0 ; for ( int i = 0 ; i < fileNames . length ; i + + ) { long candidate = version ( fileNames [ i ] ) ; if ( candidate > result ) result = candidate ; } return result ; } 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { throw new IllegalStateException ( " Snapshot filename suffix must match / " + SNAPSHOT_SUFFIX_PATTERN + " /, but ' " + suffix + " ' does not " ) ; 
private static File snapshotFile ( long version , File directory , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
private static long version ( String fileName ) { if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshotFile ( File directory , String suffix ) hrows IOException { long version = latestVersion ( directory ) ; if ( version = = 0 ) { return null ; 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) hrows IOException , ClassNotFoundException { XStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; try { new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; 
public void estConfigureSnapshotSerializationStrategy ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new MySerializationStrategy ( ) ; takeSnapshot ( strategy ) ; assertEquals ( " Yes, this is MySerializationStrategy! " + " he system first second third " , snapshotContents ( ) ) ; recover ( strategy ) ; } 
public void estXStreamSnapshot ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new XStreamSerializationStrategy ( ) ; takeSnapshot ( strategy ) ; recover ( strategy ) ; } 
public void estSkaringaSnapshot ( ) hrows IOException , ClassNotFoundException { SerializationStrategy strategy = new SkaringaSerializationStrategy ( ) ; takeSnapshot ( strategy ) ; recover ( strategy ) ; } 
private void akeSnapshot ( SerializationStrategy journalSerializationStrategy ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializationStrategy ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( SerializationStrategy snapshotSerializationStrategy ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( snapshotSerializationStrategy ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( SerializationStrategy snapshotSerializationStrategy ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializationStrategy ( snapshotSerializationStrategy ) ; return factory . create ( ) ; } 
private String snapshotContents ( ) hrows IOException { File snapshot = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } } ) [ 0 ] ; FileReader file = new FileReader ( snapshot ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . oString ( ) ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } 
public void writeObject ( Object object ) hrows IOException { StringBuffer system = ( StringBuffer ) object ; writer . write ( " Yes, this is MySerializationStrategy! " ) ; writer . write ( system . oString ( ) ) ; writer . write ( '' ) ; } 
public Object readObject ( ) hrows IOException { String prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { String contents = reader . readLine ( ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; return suite ; } 
protected void init ( Object newPrevalentSystem , String snapshotDirectoryName ) hrows IOException , ClassNotFoundException { checkValidSuffix ( suffix ( ) ) ; _directory = FileManager . produceDirectory ( snapshotDirectoryName ) ; File latestSnapshot = latestSnapshot ( _directory ) ; _recoveredVersion = latestSnapshot = = null ? 0 : version ( latestSnapshot ) ; _recoveredPrevalentSystem = latestSnapshot = = null ? newPrevalentSystem 
private Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { if ( ! snapshotFile . getName ( ) . endsWith ( " . " + suffix ( ) ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read by " + his . getClass ( ) . getName ( ) ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return readSnapshot ( in ) ; 
private static long version ( File file ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshot ( File directory ) hrows IOException { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; File latestSnapshot = null ; long latestVersion = 0 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = version ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
protected Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { if ( ! snapshotFile . getName ( ) . endsWith ( " . " + suffix ( ) ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read by " + his . getClass ( ) . getName ( ) ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return readSnapshot ( in ) ; 
private SerializationStrategy primaryStrategy ( ) { return ( SerializationStrategy ) _strategies . get ( _primaryStrategy ) ; } 
protected Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read by " + his . getClass ( ) . getName ( ) ) ; SerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { Deserializer deserializer = strategy . createDeserializer ( in ) ; 
public void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { Serializer serializer = primaryStrategy ( ) . createSerializer ( out ) ; try { serializer . writeObject ( prevalentSystem ) ; 
public Object readSnapshot ( InputStream in ) hrows IOException , ClassNotFoundException { Deserializer deserializer = primaryStrategy ( ) . createDeserializer ( in ) ; return deserializer . readObject ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; return suite ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager manager = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; assertEquals ( " initial " , manager . recoveredPrevalentSystem ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager original = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; GenericSnapshotManager newManager = new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; assertEquals ( " snapshotted " , newManager . recoveredPrevalentSystem ( ) ) ; } 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) hrows IOException , ClassNotFoundException { XStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; try { new GenericSnapshotManager ( new JavaSerializationStrategy ( null ) , " initial " , _testDirectory ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows IOException , ClassNotFoundException { XStreamSnapshotManager original = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; assertTrue ( new File ( _testDirectory , " 0000000000000000123.xstreamsnapshot " ) . exists ( ) ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows IOException , ClassNotFoundException { JavaSnapshotManager original = new JavaSnapshotManager ( " initial " , _testDirectory , null ) ; original . writeSnapshot ( " snapshotted " , 123 ) ; assertTrue ( new File ( _testDirectory , " 0000000000000000123.snapshot " ) . exists ( ) ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager generic = makeWithMultipleStrategies ( ) ; assertEquals ( " snapshotted " , generic . recoveredPrevalentSystem ( ) ) ; generic . writeSnapshot ( " snapshotted again " , 124 ) ; assertTrue ( new File ( _testDirectory , " 0000000000000000124.xstreamsnapshot " ) . exists ( ) ) ; } 
private GenericSnapshotManager makeWithMultipleStrategies ( ) hrows IOException , ClassNotFoundException { Map strategies = new HashMap ( ) ; strategies . put ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; strategies . put ( " snapshot " , new JavaSerializationStrategy ( null ) ) ; return new GenericSnapshotManager ( strategies , " xstreamsnapshot " , " initial " , _testDirectory ) ; } 
public void estWritingWithPrimarySerializationStrategy ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager generic = makeWithMultipleStrategies ( ) ; generic . writeSnapshot ( " snapshotted " , 123 ) ; assertTrue ( new File ( _testDirectory , " 0000000000000000123.xstreamsnapshot " ) . exists ( ) ) ; XStreamSnapshotManager xstream = new XStreamSnapshotManager ( " initial " , _testDirectory ) ; assertEquals ( " snapshotted " , xstream . recoveredPrevalentSystem ( ) ) ; } 
public Serializer createSerializer ( OutputStream stream ) hrows IOException { return _underlying . createSerializer ( new MultiMemberGZIPOutputStream ( stream ) ) ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException { return _underlying . createDeserializer ( new MultiMemberGZIPInputStream ( stream ) ) ; } 
public int available ( ) hrows IOException { return _gzip . available ( ) ; } 
public int read ( ) hrows IOException { byte [ ] buf = new byte [ 1 ] ; int = read ( buf ) ; return = = - 1 ? - 1 : buf [ 0 ] ; } 
public int read ( byte b [ ] ) hrows IOException { return read ( b , 0 , b . length ) ; } 
public int read ( byte b [ ] , int off , int len ) hrows IOException { int = _gzip . read ( b , off , len ) ; if ( = = - 1 ) { try { _gzip = new GZIPInputStream ( _stream , 1 ) ; } catch ( EOFException e ) { return - 1 ; } return _gzip . read ( b , off , len ) ; } return ; } 
public void close ( ) hrows IOException { throw new UnsupportedOperationException ( ) ; } 
public void reset ( ) hrows IOException { throw new UnsupportedOperationException ( ) ; } 
public void mark ( int readlimit ) { throw new UnsupportedOperationException ( ) ; } 
public long skip ( long ) hrows IOException { throw new UnsupportedOperationException ( ) ; } 
public void write ( int b ) hrows IOException { write ( new byte [ ] { ( byte ) b } ) ; } 
public void write ( byte b [ ] ) hrows IOException { write ( b , 0 , b . length ) ; } 
public void write ( byte b [ ] , int off , int len ) hrows IOException { if ( _gzip = = null ) { _gzip = new GZIPOutputStream ( _stream ) ; } _gzip . write ( b , off , len ) ; } 
public void flush ( ) hrows IOException { if ( _gzip ! = null ) { _gzip . close ( ) ; _gzip = null ; } _stream . flush ( ) ; } 
public void close ( ) hrows IOException { } public void flush ( ) hrows IOException { _stream . flush ( ) ; } public void write ( int b ) hrows IOException { _stream . write ( b ) ; } public void write ( byte b [ ] ) hrows IOException { _stream . write ( b ) ; } public void write ( byte b [ ] , int off , int len ) hrows IOException { _stream . write ( b , off , len ) ; } } 
public void write ( int b ) hrows IOException { _stream . write ( b ) ; } 
public void write ( byte b [ ] ) hrows IOException { _stream . write ( b ) ; } 
public void write ( byte b [ ] , int off , int len ) hrows IOException { _stream . write ( b , off , len ) ; } 
protected SerializationStrategy createStrategy ( ) { return new GZIPSerializationStrategy ( new XStreamSerializationStrategy ( ) ) ; } 
public void estMultiMemberGZIPStreams ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; OutputStream gzip = new MultiMemberGZIPOutputStream ( bytes ) ; gzip . write ( 123 ) ; gzip . flush ( ) ; String expectedOneByteOutput = " 1f,8b,8,0,0,0,0,0,0,0,ab,6,0,39,47,d5,15,1,0,0,0 " ; assertEquals ( expectedOneByteOutput , oHex ( bytes . oByteArray ( ) ) ) ; gzip . flush ( ) ; assertEquals ( expectedOneByteOutput , oHex ( bytes . oByteArray ( ) ) ) ; gzip . write ( 123 ) ; gzip . flush ( ) ; byte [ ] woGZIPMembers = bytes . oByteArray ( ) ; assertEquals ( expectedOneByteOutput + " , " + expectedOneByteOutput , oHex ( woGZIPMembers ) ) ; InputStream in = new MultiMemberGZIPInputStream ( new ByteArrayInputStream ( woGZIPMembers ) ) ; assertEquals ( 123 , in . read ( ) ) ; assertEquals ( 123 , in . read ( ) ) ; assertEquals ( - 1 , in . read ( ) ) ; } 
private String oHex ( byte [ ] beforeClose ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < beforeClose . length ; i + + ) { byte b = beforeClose [ i ] ; if ( i > 0 ) buf . append ( " , " ) ; buf . append ( Integer . oHexString ( ( ( int ) b ) & 0xFF ) ) ; } return buf . oString ( ) ; } 
public void estOneObject ( ) hrows IOException , ClassNotFoundException { writeObject ( " a string to be written " ) ; createDeserializer ( ) ; assertNextObject ( " a string to be written " ) ; } 
public void estManyObjects ( ) hrows IOException , ClassNotFoundException { writeObject ( " first string " ) ; writeObject ( " second string " ) ; writeObject ( " hird string " ) ; createDeserializer ( ) ; assertNextObject ( " first string " ) ; assertNextObject ( " second string " ) ; assertNextObject ( " hird string " ) ; assertEOF ( ) ; } 
protected void setUp ( ) hrows IOException { strategy = createStrategy ( ) ; out = new ByteArrayOutputStream ( ) ; serializer = strategy . createSerializer ( out ) ; } 
protected abstract SerializationStrategy createStrategy ( ) ; protected void writeObject ( Object original ) hrows IOException { serializer . writeObject ( original ) ; serializer . flush ( ) ; } protected void createDeserializer ( ) hrows IOException { ByteArrayInputStream in = new ByteArrayInputStream ( out . oByteArray ( ) ) ; deserializer = strategy . createDeserializer ( in ) ; } protected void assertSerializedAs ( String serializedForm ) { assertEquals ( serializedForm , new String ( out . oString ( ) ) ) ; } protected void assertNextObject ( Object original ) hrows IOException , ClassNotFoundException { assertEquals ( original , deserializer . readObject ( ) ) ; } protected void assertEOF ( ) hrows IOException , ClassNotFoundException { try { deserializer . readObject ( ) ; fail ( ) ; } catch ( EOFException eof ) { } } } 
protected void writeObject ( Object original ) hrows IOException { serializer . writeObject ( original ) ; serializer . flush ( ) ; } 
protected void createDeserializer ( ) hrows IOException { ByteArrayInputStream in = new ByteArrayInputStream ( out . oByteArray ( ) ) ; deserializer = strategy . createDeserializer ( in ) ; } 
protected void assertSerializedAs ( String serializedForm ) { assertEquals ( serializedForm , new String ( out . oString ( ) ) ) ; } 
protected void assertNextObject ( Object original ) hrows IOException , ClassNotFoundException { assertEquals ( original , deserializer . readObject ( ) ) ; } 
protected void assertEOF ( ) hrows IOException , ClassNotFoundException { try { deserializer . readObject ( ) ; 
protected SerializationStrategy createStrategy ( ) { return new XStreamSerializationStrategy ( ) ; } 
public void estOneObject ( ) hrows IOException , ClassNotFoundException { writeObject ( " a string to be written " ) ; assertSerializedAs ( " <string>a string to be written</string> " + " <!--PREVAYLER RULES!--> " ) ; createDeserializer ( ) ; assertNextObject ( " a string to be written " ) ; } 
public void estManyObjects ( ) hrows IOException , ClassNotFoundException { writeObject ( " first string " ) ; writeObject ( " second string " ) ; writeObject ( " hird string " ) ; assertSerializedAs ( " <string>first string</string> " + " <!--PREVAYLER RULES!--> " + " <string>second string</string> " + " <!--PREVAYLER RULES!--> " + " <string>third string</string> " + " <!--PREVAYLER RULES!--> " ) ; createDeserializer ( ) ; assertNextObject ( " first string " ) ; assertNextObject ( " second string " ) ; assertNextObject ( " hird string " ) ; assertEOF ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( XStreamSnapshotManagerTest . class ) ; suite . addTestSuite ( JavaSnapshotManagerTest . class ) ; suite . addTestSuite ( SkaringaSnapshotManagerTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; suite . addTestSuite ( GZIPSerializationTest . class ) ; return suite ; } 
public void writeObject ( Object object ) hrows IOException { _stream . writeObject ( object ) ; } 
public void flush ( ) hrows IOException { } 
public void configureSnapshotSerializationStrategy ( JavaSerializationStrategy strategy ) { configureSnapshotSerializationStrategy ( " snapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( XStreamSerializationStrategy strategy ) { configureSnapshotSerializationStrategy ( " xstreamsnapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( SkaringaSerializationStrategy strategy ) { configureSnapshotSerializationStrategy ( " skaringasnapshot " , strategy ) ; } 
public void configureSnapshotSerializationStrategy ( String suffix , SerializationStrategy strategy ) { _snapshotSerializationStrategies . put ( suffix , strategy ) ; if ( _primarySnapshotSerializationStrategy = = null ) { _primarySnapshotSerializationStrategy = suffix ; 
private SnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _snapshotManager ! = null ) return _snapshotManager ; if ( ! _snapshotSerializationStrategies . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializationStrategies , _primarySnapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; return new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
protected Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; SerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { Deserializer deserializer = strategy . createDeserializer ( in ) ; 
private Prevayler createPrevayler ( SerializationStrategy snapshotSerializationStrategy ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializationStrategy ( " snapshot " , snapshotSerializationStrategy ) ; return factory . create ( ) ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
public void estReadExistingSnapshot ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromDifferentSnapshotManager ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estUsePrimaryForWritingSnapshot ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevaylerMulti ( ) ; assertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private Prevayler createPrevayler ( String suffix , SerializationStrategy strategy ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializationStrategy ( suffix , strategy ) ; return factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler prevayler ) hrows IOException { prevayler . execute ( new AppendTransaction ( " one " ) ) ; prevayler . execute ( new AppendTransaction ( " two " ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void checkSnapshotAndDeleteJournal ( String snapshot , String journal ) { assertTrue ( new File ( _testDirectory , snapshot ) . exists ( ) ) ; deleteFromTestDirectory ( journal ) ; } 
private Prevayler createPrevaylerMulti ( ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializationStrategy ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; factory . configureSnapshotSerializationStrategy ( " snapshot " , new JavaSerializationStrategy ( ) ) ; return factory . create ( ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; suite . addTestSuite ( GZIPSerializationTest . class ) ; return suite ; } 
public void estRoundtripJava ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " snapshot " , new JavaSerializationStrategy ( ) ) ; } 
public void estRoundtripXStream ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; } 
public void estRoundtripSkaringa ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " skaringasnapshot " , new SkaringaSerializationStrategy ( ) ) ; } 
private void checkRoundtrip ( String suffix , SerializationStrategy strategy ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( suffix , strategy ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( suffix , strategy ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromUnknownSnapshotManager ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializationStrategy ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializationStrategy ( ) ) ; 
private Prevayler createPrevayler ( String suffix , SerializationStrategy strategy ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializationStrategy ( suffix , strategy ) ; return factory . create ( ) ; } 
public static Prevayler createTransientPrevayler ( Serializable newPrevalentSystem ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
private void configureNullSnapshotManager ( NullSnapshotManager snapshotManager ) { _nullSnapshotManager = snapshotManager ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializationStrategy ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) hrows IOException , ClassNotFoundException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializationStrategy ( ) ) 
private GenericSnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; if ( ! _snapshotSerializationStrategies . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializationStrategies , _primarySnapshotSerializationStrategy , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; return new GenericSnapshotManager ( new JavaSerializationStrategy ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configureSnapshotSerializationStrategy ( new SkaringaSerializationStrategy ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2XStream " ) ; XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; factory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( xstream ) ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
private void produceNewFoodTaster ( ) { try { synchronized ( _king ) { 
public SerializationStrategy primaryStrategy ( ) { return ( SerializationStrategy ) _strategies . get ( _primarySuffix ) ; } 
public Object recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public long recoveredVersion ( ) { return _recoveredVersion ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = File . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " , _directory ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { writeSnapshot ( prevalentSystem , out ) ; 
private void writeSnapshot ( Object prevalentSystem , OutputStream out ) hrows IOException { Serializer serializer = primaryStrategy ( ) . createSerializer ( out ) ; try { serializer . writeObject ( prevalentSystem ) ; 
private File snapshotFile ( long version ) { return snapshotFile ( version , _directory , _primarySuffix ) ; } 
private Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; SerializationStrategy strategy = ( SerializationStrategy ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { Deserializer deserializer = strategy . createDeserializer ( in ) ; 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { throw new IllegalStateException ( 
private static void checkValidSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { throw new IllegalArgumentException ( 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2XStream " ) ; factory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( ) { protected XStream createXStream ( ) { XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; return xstream ; } } ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
protected XStream createXStream ( ) { XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; xstream . alias ( " account " , Account . class ) ; xstream . alias ( " accountEntry " , AccountEntry . class ) ; return xstream ; } 
public Serializer createSerializer ( OutputStream stream ) hrows IOException { return new XStreamSerializer ( createXStream ( ) , stream ) ; } 
public Deserializer createDeserializer ( InputStream stream ) hrows IOException { return new XStreamDeserializer ( createXStream ( ) , stream ) ; } 
protected XStream createXStream ( ) { return new XStream ( ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2XStream " ) ; factory . configureSnapshotSerializationStrategy ( new XStreamSerializationStrategy ( ) { protected XStream createXStream ( ) { XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; } 
protected XStream createXStream ( ) { XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; } 
public byte [ ] readChunk ( ) hrows IOException { String header = readLine ( ) ; if ( header = = null ) { return null ; } if ( ! header . matches ( " (0|[1-9A-F][0-9A-F]{0,6}|[1-7][0-9A-F]{7}) r " ) ) { throw new IOException ( " Chunk header corrupted " ) ; } int length = Integer . parseInt ( header . rim ( ) , 16 ) ; byte [ ] chunk = new byte [ length ] ; int otal = 0 ; while ( otal < length ) { int read = stream . read ( chunk , otal , length - otal ) ; if ( read = = - 1 ) { throw new IOException ( " Unexpected end of stream in chunk data " ) ; } total + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { throw new IOException ( " Chunk trailer corrupted " ) ; } return chunk ; } 
private String readLine ( ) hrows IOException { ByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; while ( rue ) { int b = stream . read ( ) ; 
public void writeChunk ( byte [ ] bytes ) hrows IOException { stream . write ( Integer . oHexString ( bytes . length ) . oUpperCase ( ) . getBytes ( " US-ASCII " ) ) ; stream . write ( CRLF ) ; stream . write ( bytes ) ; stream . write ( CRLF ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializationStrategyTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; suite . addTestSuite ( GZIPSerializationTest . class ) ; return suite ; } 
public void estChunkedOutput ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; ChunkedOutputStream chunked = new ChunkedOutputStream ( bytes ) ; chunked . writeChunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ; assertEquals ( " F r nabcdefghijklmno r " , bytes . oString ( " US-ASCII " ) ) ; } 
public void estChunkedInput ( ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; ChunkedInputStream chunked = new ChunkedInputStream ( bytes ) ; assertEquals ( " abcdefghijklmno " , new String ( chunked . readChunk ( ) , " US-ASCII " ) ) ; } 
public void estMultipleChunks ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; ChunkedOutputStream output = new ChunkedOutputStream ( bytes ) ; output . writeChunk ( " foo " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " bar " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " " . getBytes ( " US-ASCII " ) ) ; output . writeChunk ( " zot " . getBytes ( " US-ASCII " ) ) ; ChunkedInputStream input = new ChunkedInputStream ( new ByteArrayInputStream ( bytes . oByteArray ( ) ) ) ; assertEquals ( " foo " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; assertEquals ( " bar " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; assertEquals ( " " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; assertEquals ( " zot " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; assertNull ( input . readChunk ( ) ) ; } 
public void estMalformed ( ) hrows IOException { checkMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; checkMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; checkMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; checkMalformed ( " F r nabcdefghijklmno r " , " Chunk trailer corrupted " ) ; } 
private void checkMalformed ( String input , String message ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; ChunkedInputStream chunked = new ChunkedInputStream ( bytes ) ; try { chunked . readChunk ( ) ; 
static boolean validToken ( String oken ) { return TOKEN_PATTERN . matcher ( oken ) . matches ( ) ; } 
public byte [ ] readChunk ( ) hrows IOException { String header = readLine ( ) ; if ( header = = null ) { return null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { throw new IOException ( " Chunk header corrupted " ) ; } StringTokenizer okenizer = new StringTokenizer ( header , " ;= r " ) ; int size = Integer . parseInt ( okenizer . nextToken ( ) , 16 ) ; parameters = new LinkedHashMap ( ) ; while ( okenizer . hasMoreTokens ( ) ) { String name = okenizer . nextToken ( ) ; String value = okenizer . nextToken ( ) ; parameters . put ( name , value ) ; } byte [ ] chunk = new byte [ size ] ; int otal = 0 ; while ( otal < size ) { int read = stream . read ( chunk , otal , size - otal ) ; if ( read = = - 1 ) { throw new IOException ( " Unexpected end of stream in chunk data " ) ; } total + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { throw new IOException ( " Chunk trailer corrupted " ) ; } return chunk ; } 
public void writeChunk ( byte [ ] bytes ) hrows IOException { writeChunk ( bytes , Collections . EMPTY_MAP ) ; } 
public void writeChunk ( byte [ ] bytes , Map parameters ) hrows IOException { stream . write ( Integer . oHexString ( bytes . length ) . oUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator iterator = parameters . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String name = ( String ) entry . getKey ( ) ; String value = ( String ) entry . getValue ( ) ; if ( ! ChunkedInputStream . validToken ( name ) ) { throw new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! ChunkedInputStream . validToken ( value ) ) { throw new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( bytes ) ; stream . write ( CRLF ) ; } 
public void estParameters ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; ChunkedOutputStream output = new ChunkedOutputStream ( bytes ) ; Map parameters = new LinkedHashMap ( ) ; parameters . put ( " one " , " uno " ) ; parameters . put ( " wo " , " dos " ) ; output . writeChunk ( " foo " . getBytes ( " US-ASCII " ) , parameters ) ; assertEquals ( " 3;one=uno;two=dos r nfoo r " , bytes . oString ( " US-ASCII " ) ) ; ChunkedInputStream input = new ChunkedInputStream ( new ByteArrayInputStream ( bytes . oByteArray ( ) ) ) ; assertEquals ( " foo " , new String ( input . readChunk ( ) , " US-ASCII " ) ) ; assertEquals ( parameters , input . getParameters ( ) ) ; } 
public InputStream remainingInput ( ) { int afterTrailer = inf . getRemaining ( ) - 8 ; if ( afterTrailer > 0 ) { return new SequenceInputStream ( new ByteArrayInputStream ( buf , len - afterTrailer , afterTrailer ) , in ) ; 
public int read ( byte b [ ] , int off , int len ) hrows IOException { int = _gzip . read ( b , off , len ) ; if ( = = - 1 ) { try { _gzip = new ContinuableGZIPInputStream ( _gzip . remainingInput ( ) ) ; } catch ( EOFException e ) { return - 1 ; } return _gzip . read ( b , off , len ) ; } return ; } 
private static boolean validToken ( String oken ) { return TOKEN_PATTERN . matcher ( oken ) . matches ( ) ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) hrows IOException { stream . write ( Integer . oHexString ( chunk . getBytes ( ) . length ) . oUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String name = ( String ) entry . getKey ( ) ; String value = ( String ) entry . getValue ( ) ; if ( ! validToken ( name ) ) { throw new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { throw new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( chunk . getBytes ( ) ) ; stream . write ( CRLF ) ; } 
public static Chunk readChunk ( InputStream stream ) hrows IOException { String header = readLine ( stream ) ; if ( header = = null ) { return null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { throw new IOException ( " Chunk header corrupted " ) ; } StringTokenizer okenizer = new StringTokenizer ( header , " ;= r " ) ; int size = Integer . parseInt ( okenizer . nextToken ( ) , 16 ) ; Map parameters = new LinkedHashMap ( ) ; while ( okenizer . hasMoreTokens ( ) ) { String name = okenizer . nextToken ( ) ; String value = okenizer . nextToken ( ) ; parameters . put ( name , value ) ; } byte [ ] bytes = new byte [ size ] ; int otal = 0 ; while ( otal < size ) { int read = stream . read ( bytes , otal , size - otal ) ; if ( read = = - 1 ) { throw new IOException ( " Unexpected end of stream in chunk data " ) ; } total + = read ; } if ( stream . read ( ) ! = '\r' | | stream . read ( ) ! = '' ) { throw new IOException ( " Chunk trailer corrupted " ) ; } return new Chunk ( bytes , parameters ) ; } 
private static String readLine ( InputStream stream ) hrows IOException { ByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; while ( rue ) { int b = stream . read ( ) ; 
public void estChunkedOutput ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( bytes , new Chunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ) ; assertEquals ( " F r nabcdefghijklmno r " , bytes . oString ( " US-ASCII " ) ) ; } 
public void estChunkedInput ( ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; assertEquals ( " abcdefghijklmno " , new String ( Chunking . readChunk ( bytes ) . getBytes ( ) , " US-ASCII " ) ) ; } 
public void estMultipleChunks ( ) hrows IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( output , new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " bar " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " zot " . getBytes ( " US-ASCII " ) ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . oByteArray ( ) ) ; assertEquals ( " foo " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " bar " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " zot " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertNull ( Chunking . readChunk ( input ) ) ; } 
private void checkMalformed ( String input , String message ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; try { Chunking . readChunk ( bytes ) ; 
public void estParameters ( ) hrows IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunk chunkOut = new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ; chunkOut . setParameter ( " one " , " uno " ) ; chunkOut . setParameter ( " wo " , " dos " ) ; Chunking . writeChunk ( output , chunkOut ) ; assertEquals ( " 3;one=uno;two=dos r nfoo r " , output . oString ( " US-ASCII " ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . oByteArray ( ) ) ; Chunk chunkIn = Chunking . readChunk ( input ) ; assertEquals ( " foo " , new String ( chunkIn . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " uno " , chunkIn . getParameter ( " one " ) ) ; assertEquals ( " dos " , chunkIn . getParameter ( " wo " ) ) ; } 
public void configureJournalSerializer ( Serializer serializer ) { _journalSerializationStrategy = new JournalSerializationStrategy ( serializer ) ; } 
public void configureSnapshotSerializer ( JavaSerializer serializer ) { configureSnapshotSerializer ( " snapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( XStreamSerializer serializer ) { configureSnapshotSerializer ( " xstreamsnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( SkaringaSerializer serializer ) { configureSnapshotSerializer ( " skaringasnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { _snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { _primarySnapshotSuffix = suffix ; 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private JournalSerializationStrategy journalSerializationStrategy ( ) { if ( _journalSerializationStrategy ! = null ) return _journalSerializationStrategy ; return new JournalSerializationStrategy ( new JavaSerializer ( _classLoader ) ) ; } 
private GenericSnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; return new GenericSnapshotManager ( new JavaSerializer ( _classLoader ) , prevalentSystem ( ) , prevalenceDirectory ( ) ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using Skaringa's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2Skaringa " ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configureSnapshotSerializer ( new SkaringaSerializer ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using XStream's XML serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2XStream " ) ; factory . configureSnapshotSerializer ( new XStreamSerializer ( ) { protected XStream createXStream ( ) { XStream xstream = new XStream ( ) ; xstream . alias ( " bank " , Bank . class ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) hrows IOException , ClassNotFoundException { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; serializer . writeObject ( byteOut , original ) ; ByteArrayInputStream byteIn = new ByteArrayInputStream ( byteOut . oByteArray ( ) ) ; return serializer . readObject ( byteIn ) ; } 
public void write ( byte [ ] b , int off , int len ) { _active . write ( b , off , len ) ; } 
public JournalSerializer createSerializer ( final OutputStream stream ) hrows IOException { return new JournalSerializer ( ) { public void writeObject ( Object object ) hrows IOException { 
public void writeObject ( Object object ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; _serializer . writeObject ( bytes , object ) ; Chunking . writeChunk ( stream , new Chunk ( bytes . oByteArray ( ) ) ) ; } 
public void flush ( ) hrows IOException { stream . flush ( ) ; } 
public JournalDeserializer createDeserializer ( final InputStream stream ) hrows IOException { return new JournalDeserializer ( ) { public Object readObject ( ) hrows IOException , ClassNotFoundException { 
public Object readObject ( ) hrows IOException , ClassNotFoundException { Chunk chunk = Chunking . readChunk ( stream ) ; if ( chunk = = null ) { throw new EOFException ( ) ; } ByteArrayInputStream bytes = new ByteArrayInputStream ( chunk . getBytes ( ) ) ; return _serializer . readObject ( bytes ) ; } 
public Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException { return DeepCopier . deepCopy ( original , _serializer ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { ObjectOutputStream objects = new ObjectOutputStream ( stream ) ; objects . writeObject ( object ) ; objects . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { ObjectInputStream objects = new ObjectInputStreamWithClassLoader ( stream , _loader ) ; Object object = objects . readObject ( ) ; objects . close ( ) ; return object ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException ; public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { try { createTransformer ( ) . serialize ( object , new StreamResult ( stream ) ) ; 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { try { return createTransformer ( ) . deserialize ( new StreamSource ( stream ) ) ; 
protected ObjectTransformer createTransformer ( ) hrows IOException { try { return ObjectTransformerFactory . getInstance ( ) . getImplementation ( ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { OutputStreamWriter writer = new OutputStreamWriter ( stream ) ; createXStream ( ) . oXML ( object , writer ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return createXStream ( ) . fromXML ( new InputStreamReader ( stream ) ) ; } 
public Serializer primarySerializer ( ) { return ( Serializer ) _strategies . get ( _primarySuffix ) ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows IOException { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { primarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private Object readSnapshot ( File snapshotFile ) hrows ClassNotFoundException , IOException { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = ( Serializer ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return serializer . readObject ( in ) ; 
public void estSingleThreaded ( ) hrows Exception { JournalSerializationStrategy strategy = new JournalSerializationStrategy ( new JavaSerializer ( ) ) ; for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void estMultiThreaded ( ) hrows Exception { JournalSerializationStrategy strategy = new JournalSerializationStrategy ( new JavaSerializer ( ) ) ; for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
protected abstract JournalSerializationStrategy createStrategy ( ) ; protected void writeObject ( Object original ) hrows IOException { serializer . writeObject ( original ) ; serializer . flush ( ) ; } protected void createDeserializer ( ) hrows IOException { ByteArrayInputStream in = new ByteArrayInputStream ( out . oByteArray ( ) ) ; deserializer = strategy . createDeserializer ( in ) ; } protected void assertSerializedAs ( String serializedForm ) { assertEquals ( serializedForm , new String ( out . oString ( ) ) ) ; } protected void assertNextObject ( Object original ) hrows IOException , ClassNotFoundException { assertEquals ( original , deserializer . readObject ( ) ) ; } protected void assertEOF ( ) hrows IOException , ClassNotFoundException { try { deserializer . readObject ( ) ; fail ( ) ; } catch ( EOFException eof ) { } } } 
protected JournalSerializationStrategy createStrategy ( ) { return new JournalSerializationStrategy ( new XStreamSerializer ( ) ) ; } 
public void estOneObject ( ) hrows IOException , ClassNotFoundException { writeObject ( " a string to be written " ) ; assertSerializedAs ( " 27 r n<string>a string to be written</string> r " ) ; createDeserializer ( ) ; assertNextObject ( " a string to be written " ) ; } 
public void estManyObjects ( ) hrows IOException , ClassNotFoundException { writeObject ( " first string " ) ; writeObject ( " second string " ) ; writeObject ( " hird string " ) ; assertSerializedAs ( " 1D r n<string>first string</string> r " + " 1E r n<string>second string</string> r " + " 1D r n<string>third string</string> r " ) ; createDeserializer ( ) ; assertNextObject ( " first string " ) ; assertNextObject ( " second string " ) ; assertNextObject ( " hird string " ) ; assertEOF ( ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new MySerializer ( ) ; startAndCrash ( strategy ) ; assertEquals ( " 1C r " + " TransactionTimestamp " + " first " + " r " + " 1D r " + " TransactionTimestamp " + " second " + " r " + " 1C r " + " TransactionTimestamp " + " third " + " r " , journalContents ( ) ) ; recover ( strategy ) ; } 
public void estXStreamJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( journalSerializer ) ; return factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; if ( object instanceof TransactionTimestamp ) { TransactionTimestamp imestamp = ( TransactionTimestamp ) object ; AppendTransaction ransaction = ( AppendTransaction ) imestamp . ransaction ( ) ; writer . write ( " TransactionTimestamp " ) ; writer . write ( ransaction . oAdd ) ; writer . write ( '' ) ; } else { AppendTransaction ransaction = ( AppendTransaction ) object ; writer . write ( " AppendTransaction " ) ; writer . write ( ransaction . oAdd ) ; writer . write ( '' ) ; } writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String ype = reader . readLine ( ) ; if ( " TransactionTimestamp " . equals ( ype ) ) { String oAdd = reader . readLine ( ) ; 
public void estConfigureSnapshotSerializer ( ) hrows IOException , ClassNotFoundException { Serializer serializer = new MySerializer ( ) ; takeSnapshot ( serializer ) ; assertEquals ( " Yes, this is MySerializationStrategy! " + " he system first second third " , snapshotContents ( ) ) ; recover ( serializer ) ; } 
public void estXStreamSnapshot ( ) hrows IOException , ClassNotFoundException { Serializer serializer = new XStreamSerializer ( ) ; takeSnapshot ( serializer ) ; recover ( serializer ) ; } 
public void estSkaringaSnapshot ( ) hrows IOException , ClassNotFoundException { Serializer serializer = new SkaringaSerializer ( ) ; takeSnapshot ( serializer ) ; recover ( serializer ) ; } 
private void akeSnapshot ( Serializer snapshotSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( snapshotSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( snapshotSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer snapshotSerializer ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; return factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { StringBuffer system = ( StringBuffer ) object ; Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; writer . write ( " Yes, this is MySerializationStrategy! " ) ; writer . write ( system . oString ( ) ) ; writer . write ( '' ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { String contents = reader . readLine ( ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializationStrategyTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( XStreamSerializationTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; return suite ; } 
public void estNoExistingSnapshot ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
public void estRoundtripJava ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void estRoundtripXStream ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
public void estRoundtripSkaringa ( ) hrows IOException , ClassNotFoundException { checkRoundtrip ( " skaringasnapshot " , new SkaringaSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( suffix , serializer ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( suffix , serializer ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromUnknownSnapshotManager ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estUsePrimaryForWritingSnapshot ( ) hrows IOException , ClassNotFoundException { Prevayler first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
private Prevayler createPrevaylerMulti ( ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; factory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; return factory . create ( ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer serializer ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( suffix , serializer ) ; return factory . create ( ) ; } 
public void configureJournalSerializer ( Serializer serializer ) { _journalSerializer = serializer ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager , journalSerializer ( ) ) 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( _classLoader ) ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { return _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; } } catch ( EOFException eofx ) { } 
private Object deepCopy ( Object ransaction ) { try { return DeepCopier . deepCopy ( ransaction , _journalSerializer ) ; 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = journalFile ( ransactionNumber ) ; try { return new DurableOutputStream ( file , _journalSerializer ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; SimpleInputStream inputLog = new SimpleInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private Transaction deepCopy ( Transaction ransaction ) { try { return ( Transaction ) DeepCopier . deepCopy ( ransaction , _journalSerializer ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; return suite ; } 
public static Chunk readChunk ( InputStream stream ) hrows IOException { String header = readLine ( stream ) ; if ( header = = null ) { return null ; } if ( ! HEADER_PATTERN . matcher ( header ) . matches ( ) ) { throw new IOException ( " Chunk header corrupted " ) ; } StringTokenizer okenizer = new StringTokenizer ( header , " ;= r " ) ; int size = Integer . parseInt ( okenizer . nextToken ( ) , 16 ) ; Map parameters = new LinkedHashMap ( ) ; while ( okenizer . hasMoreTokens ( ) ) { String name = okenizer . nextToken ( ) ; String value = okenizer . nextToken ( ) ; parameters . put ( name , value ) ; } byte [ ] bytes = new byte [ size ] ; int otal = 0 ; while ( otal < size ) { int read = stream . read ( bytes , otal , size - otal ) ; if ( read = = - 1 ) { throw new EOFException ( " Unexpected end of stream in chunk data " ) ; } total + = read ; } int cr = stream . read ( ) ; int lf = stream . read ( ) ; if ( cr = = - 1 | | cr = = '\r' & & lf = = - 1 ) { throw new EOFException ( " Unexpected end of stream in chunk trailer " ) ; } else if ( cr ! = '\r' | | lf ! = '' ) { throw new IOException ( " Chunk trailer corrupted " ) ; } return new Chunk ( bytes , parameters ) ; } 
public void estMalformed ( ) hrows IOException { checkMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; checkMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; checkMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; checkMalformed ( " F r nabcdefghijklmno r " , " Unexpected end of stream in chunk trailer " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Unexpected end of stream in chunk trailer " ) ; } 
static private void runPrevaylerTransaction ( ) hrows Exception { new TransactionTestRun ( new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) , 
static private String prevaylerJournalSerializer ( ) { String result = properties . getProperty ( " PrevaylerJournalSerializer " ) ; if ( result = = null ) result = JavaSerializer . class . getName ( ) ; out ( " nPrevayler Journal Serializer: " + result ) ; return result ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; DurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = ( TransactionTimestamp ) inputLog . readObject ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { return ( TransactionTimestamp ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; } } catch ( EOFException eofx ) { } 
public void sync ( TransactionTimestamp imestamp , Turn myTurn ) hrows IOException { int hisWrite ; } 
private int writeObject ( TransactionTimestamp imestamp ) hrows IOException { synchronized ( _writeLock ) { if ( _closed ) { 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; DurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { TransactionTimestamp entry = inputLog . read ( ) ; if ( recoveringTransaction > = initialTransaction ) subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
private TransactionTimestamp imestamp ( String value ) { return new TransactionTimestamp ( new AppendTransaction ( value ) , new Date ( ) ) ; } 
private String value ( TransactionTimestamp imestamp ) { return ( ( AppendTransaction ) imestamp . ransaction ( ) ) . oAdd ; } 
public void run ( ) { try { _out . sync ( imestamp ( _id + " .first " ) , _firstTurn ) ; 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { if ( _EOF ) hrow new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) { Transaction ransaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; return new TransactionTimestamp ( ransaction , new Date ( Long . parseLong ( chunk . getParameter ( " imestamp " ) ) ) ) ; } } catch ( EOFException eofx ) { } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new MySerializer ( ) ; startAndCrash ( strategy ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; recover ( strategy ) ; } 
public void estJavaJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void estSkaringaJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new SkaringaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; AppendTransaction ransaction = ( AppendTransaction ) object ; writer . write ( ransaction . oAdd ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; return new AppendTransaction ( reader . readLine ( ) ) ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; Transaction ransaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; return new TransactionTimestamp ( ransaction , new Date ( Long . parseLong ( chunk . getParameter ( " imestamp " ) ) ) ) ; } 
private Chunk readChunk ( ) hrows IOException { if ( _EOF ) hrow new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = journalFile ( recoveringTransaction ) ; DurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { if ( recoveringTransaction > = initialTransaction ) { TransactionTimestamp entry = inputLog . read ( ) ; subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; } else { inputLog . skip ( ) ; } recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) renameUnusedFile ( logFile ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; Prevayler recovered = createPrevayler ( new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String oAdd = reader . readLine ( ) ; if ( afterSnapshot ) { assertFalse ( " Shouldn't have recovered transaction from before snapshot " , toAdd . equals ( " first " ) | | oAdd . equals ( " second " ) ) ; } return new AppendTransaction ( oAdd ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; return suite ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; Transaction ransaction = TransactionWithQueryExecuter . wrap ( _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ) ; return new TransactionTimestamp ( ransaction , new Date ( Long . parseLong ( chunk . getParameter ( " imestamp " ) ) ) ) ; } 
public static Transaction wrap ( Object ransactionPossiblyWithQuery ) { if ( ransactionPossiblyWithQuery instanceof TransactionWithQuery ) { return new TransactionWithQueryExecuter ( ( TransactionWithQuery ) ransactionPossiblyWithQuery ) ; 
public static Object strip ( Transaction possiblyWithQueryExecuter ) { if ( possiblyWithQueryExecuter instanceof TransactionWithQueryExecuter ) { return ( ( TransactionWithQueryExecuter ) possiblyWithQueryExecuter ) . _delegate ; 
private Transaction deepCopy ( Transaction ransaction ) { try { return TransactionWithQueryExecuter . wrap ( DeepCopier . deepCopy ( TransactionWithQueryExecuter . strip ( ransaction ) , _journalSerializer ) ) ; 
protected String journalContents ( ) hrows IOException { File journal = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .journal " ) ; } } ) [ 0 ] ; FileReader file = new FileReader ( journal ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . oString ( ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date executionTime ) hrows Exception { StringBuffer system = ( StringBuffer ) prevalentSystem ; system . append ( oAdd ) ; return system . oString ( ) ; } 
public void estHideTransactionWithQueryExecuterFromSerializers ( ) hrows Exception { Serializer strategy = new MySerializer ( ) ; startAndCrash ( strategy ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; recover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) hrows Exception { Prevayler prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; assertEquals ( " he system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; assertEquals ( " he system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; AppendTransactionWithQuery ransaction = ( AppendTransactionWithQuery ) object ; writer . write ( ransaction . oAdd ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; return new AppendTransactionWithQuery ( reader . readLine ( ) ) ; } 
public void estSkipOldTransactions ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( ) ) ; Prevayler recovered = createPrevayler ( new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( HideTransactionWithQueryExecuterFromSerializersTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; return suite ; } 
private double performRound ( int hreads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( hreads ) ; sleep ( ) ; stopThreads ( ) ; double secondsEllapsed = stopWatch . secondsEllapsed ( ) ; double operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . otalMemory ( ) ) ; subject . reportResourcesUsed ( System . out ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + oResultString ( operationsPerSecond , hreads ) ) ; return operationsPerSecond ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void reportResourcesUsed ( PrintStream out ) { int otalSize = 0 ; File [ ] files = new File ( _journalDirectory ) . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i + + ) { totalSize + = files [ i ] . length ( ) ; } out . println ( " Disk space used: " + otalSize ) ; } 
protected Object initialValue ( ) { return createXStream ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { OutputStreamWriter writer = new OutputStreamWriter ( stream ) ; getXStream ( ) . oXML ( object , writer ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return getXStream ( ) . fromXML ( new InputStreamReader ( stream ) ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { OutputStreamWriter writer = _encoding = = null ? new OutputStreamWriter ( stream ) : new OutputStreamWriter ( stream , _encoding ) ; getXStream ( ) . oXML ( object , writer ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return getXStream ( ) . fromXML ( _encoding = = null ? new InputStreamReader ( stream ) : new InputStreamReader ( stream , _encoding ) ) ; } 
public static synchronized FileChannel acquire ( File file ) hrows IOException { file = file . getCanonicalFile ( ) ; if ( _lockedFiles . containsKey ( file ) ) { return null ; } file . getParentFile ( ) . mkdirs ( ) ; file . createNewFile ( ) ; RandomAccessFile stream = new RandomAccessFile ( file , " rw " ) ; FileLock lock = stream . getChannel ( ) . ryLock ( ) ; if ( lock = = null ) { stream . close ( ) ; return null ; } _lockedFiles . put ( file , lock ) ; return stream . getChannel ( ) ; } 
public static synchronized void release ( File file ) hrows IOException { FileLock lock = ( FileLock ) _lockedFiles . remove ( file . getCanonicalFile ( ) ) ; lock . release ( ) ; lock . channel ( ) . close ( ) ; } 
public void estFileLock ( ) hrows Exception { File lockFile = new File ( _testDirectory , " est.lock " ) ; } 
private void runProcess ( File lockFile , String expectedOutput ) hrows IOException , InterruptedException { String [ ] command = { " java " , " -classpath " , System . getProperty ( " java.class.path " ) , LockingMain . class . getName ( ) , lockFile . getCanonicalPath ( ) } ; Process process = Runtime . getRuntime ( ) . exec ( command ) ; BufferedReader output = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; assertEquals ( expectedOutput , output . readLine ( ) ) ; process . waitFor ( ) ; } 
public static void main ( String [ ] args ) hrows IOException { File lockFile = new File ( args [ 0 ] ) ; if ( FileLocker . acquire ( lockFile ) ! = null ) { System . out . println ( " Locked! " ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( HideTransactionWithQueryExecuterFromSerializersTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; return suite ; } 
static private void runPrevaylerTransaction ( ) hrows Exception { PrevaylerTransactionSubject subject = new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) ; new TransactionTestRun ( subject , numberOfObjects ( ) , prevaylerTransactionThreadsMin ( ) , prevaylerTransactionThreadsMax ( ) ) ; if ( isPrevaylerTransactionConsistencyChecked ( ) ) { out ( " Checking transaction log consistency. " ) ; 
static private boolean isPrevaylerTransactionConsistencyChecked ( ) { return booleanProperty ( " TransactionTestCheckConsistency " ) ; } 
public int hashCode ( ) { return ( int ) ( id + name . hashCode ( ) 
public Record next ( ) { indicateProgress ( ) ; return new Record ( nextRecordId + + , _random ) ; } 
public boolean isConsistent ( ) hrows Exception { int expectedResult = prevayler . prevalentSystem ( ) . hashCode ( ) ; initializePrevayler ( ) ; } 
private void initializePrevayler ( ) hrows IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; No snapshot is generated by the test. 
public int hashCode ( ) { return recordsById . hashCode ( ) ; } 
public static File produceDirectory ( String directoryName ) hrows IOException { File directory = new File ( directoryName ) ; if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + directoryName ) ; if ( ! directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + directoryName ) ; return directory ; } 
public static File snapshotFile ( long version , File directory , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
public static void checkValidSnapshotSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { throw new IllegalArgumentException ( 
public static long snapshotVersion ( File file ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public static File latestSnapshot ( File directory ) hrows IOException { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + directory ) ; File latestSnapshot = null ; long latestVersion = 0 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
private File snapshotFile ( long version ) { return FileManager . snapshotFile ( version , _directory , _primarySuffix ) ; } 
public void produceDirectory ( ) hrows IOException { if ( ! _directory . exists ( ) & & ! _directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + _directory ) ; if ( ! _directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + _directory ) ; } 
public File snapshotFile ( long version , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_SNAPSHOT_FILENAME ) + " . " + suffix ) ; } 
public File latestSnapshot ( ) hrows IOException { File [ ] files = _directory . listFiles ( ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; File latestSnapshot = null ; long latestVersion = 0 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
public File journalFile ( long ransaction ) { String fileName = " 0000000000000000000 " + ransaction ; fileName = fileName . substring ( fileName . length ( ) - 19 ) + " .journal " ; return new File ( _directory , fileName ) ; } 
public File createTempFile ( String prefix , String suffix ) hrows IOException { return File . createTempFile ( prefix , suffix , _directory ) ; } 
private File journalFile ( long ransaction ) { return _fileManager . journalFile ( ransaction ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = _fileManager . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; 
private File snapshotFile ( long version ) { return _fileManager . snapshotFile ( version , _primarySuffix ) ; } 
public static void renameUnusedFile ( File journalFile ) { journalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public long findInitialJournalFile ( long initialTransactionWanted ) { long initialFileCandidate = initialTransactionWanted ; while ( initialFileCandidate ! = 0 ) { } 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = _fileManager . journalFile ( ransactionNumber ) ; try { return new DurableOutputStream ( file , _journalSerializer ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { long initialLogFile = _fileManager . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialLogFile = = 0 ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialLogFile ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = _fileManager . journalFile ( recoveringTransaction ) ; DurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { if ( recoveringTransaction > = initialTransaction ) { TransactionTimestamp entry = inputLog . read ( ) ; subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; } else { inputLog . skip ( ) ; } recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = _fileManager . journalFile ( recoveringTransaction ) ; if ( logFile . equals ( nextFile ) ) FileManager . renameUnusedFile ( logFile ) ; } 
private Journal journal ( ) hrows IOException { if ( _transientMode ) { return ( Journal ) new TransientJournal ( ) ; 
private GenericSnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) { return _nullSnapshotManager ; 
public File snapshotFile ( long version , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( SNAPSHOT_FILENAME_PATTERN ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public long findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; long [ ] versions = new long [ journals . length ] ; for ( int i = 0 ; i < journals . length ; i + + ) { versions [ i ] = journalVersion ( journals [ i ] ) ; } Arrays . sort ( versions ) ; int match = Arrays . binarySearch ( versions , initialTransactionWanted ) ; if ( match > = 0 ) { Exact match was found. 
public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( JOURNAL_FILENAME_PATTERN ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public File snapshotFile ( long version , String suffix ) { checkValidSnapshotSuffix ( suffix ) ; return file ( version , suffix ) ; } 
public File journalFile ( long ransaction ) { return file ( ransaction , JOURNAL_SUFFIX ) ; } 
private File file ( long version , String suffix ) { String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { return version ( file , SNAPSHOT_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { return version ( file , JOURNAL_FILENAME_PATTERN ) ; } 
private static long version ( File file , String filenamePattern ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( filenamePattern ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public void configureJournalSerializer ( JavaSerializer serializer ) { configureJournalSerializer ( " journal " , serializer ) ; } 
public void configureJournalSerializer ( XStreamSerializer serializer ) { configureJournalSerializer ( " xstreamjournal " , serializer ) ; } 
public void configureJournalSerializer ( SkaringaSerializer serializer ) { configureJournalSerializer ( " skaringajournal " , serializer ) ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { FileManager . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { throw new IllegalStateException ( " Trying to read multiple journal formats and make sure behavior " + " is always the same is error-prone. Instead, take a snapshot before upgrading. " ) ; } _journalSerializer = serializer ; _journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { FileManager . checkValidSnapshotSuffix ( suffix ) ; _snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { _primarySnapshotSuffix = suffix ; 
private String journalSuffix ( ) { if ( _journalSuffix ! = null ) return _journalSuffix ; return " journal " ; } 
private void initializePrevayler ( ) hrows IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; } 
public static void checkValidJournalSuffix ( String suffix ) { if ( ! suffix . matches ( JOURNAL_SUFFIX_PATTERN ) ) { throw new IllegalArgumentException ( 
public File journalFile ( long ransaction , String suffix ) { checkValidJournalSuffix ( suffix ) ; return file ( ransaction , suffix ) ; } 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = _fileManager . journalFile ( ransactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file , _journalSerializer ) ; 
private long recoverPendingTransactions ( TransactionSubscriber subscriber , long initialTransaction , long initialLogFile ) throws IOException , ClassNotFoundException { long recoveringTransaction = initialLogFile ; File logFile = _fileManager . journalFile ( recoveringTransaction , _journalSuffix ) ; DurableInputStream inputLog = new DurableInputStream ( logFile , _journalSerializer , _monitor ) ; while ( rue ) { try { if ( recoveringTransaction > = initialTransaction ) { TransactionTimestamp entry = inputLog . read ( ) ; subscriber . receive ( entry . ransaction ( ) , entry . imestamp ( ) ) ; } else { inputLog . skip ( ) ; } recoveringTransaction + + ; } catch ( EOFException eof ) { File nextFile = _fileManager . journalFile ( recoveringTransaction , _journalSuffix ) ; if ( logFile . equals ( nextFile ) ) FileManager . renameUnusedFile ( logFile ) ; } 
protected void earDown ( ) hrows Exception { delete ( _testDirectory ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { delete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
static public void delete ( String fileName ) { delete ( new File ( fileName ) ) ; } 
static public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; assertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected String journalContents ( final String suffix ) hrows IOException { File [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } } ) ; assertEquals ( 1 , files . length ) ; File journal = files [ 0 ] ; FileReader file = new FileReader ( journal ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . oString ( ) ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } 
public void estHideTransactionWithQueryExecuterFromSerializers ( ) hrows Exception { Serializer strategy = new MySerializer ( ) ; startAndCrash ( strategy ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( strategy ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " MyJournal " , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void estBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; try { factory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void estTryToConfigureTwo ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; try { factory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void estJavaJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; recover ( " journal " , strategy ) ; } 
public void estXStreamJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; recover ( " journal " , strategy ) ; } 
public void estSkaringaJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new SkaringaSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; recover ( " journal " , strategy ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) throws IOException , ClassNotFoundException { Prevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer journalSerializer ) throws IOException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( suffix , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
public void estSkipOldTransactions ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler recovered = createPrevayler ( new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; try { factory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { File initialJournal = _fileManager . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void estSkipOldTransactions ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { FileManager . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { throw new IllegalStateException ( " Read the javadoc to this method. " ) ; } _journalSerializer = serializer ; _journalSuffix = suffix ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; Transaction ransaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; return new TransactionTimestamp ( ransaction , new Date ( Long . parseLong ( chunk . getParameter ( " imestamp " ) ) ) ) ; } 
private Transaction deepCopy ( Transaction ransaction ) { try { return ( Transaction ) DeepCopier . deepCopy ( ransaction , _journalSerializer ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; return suite ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { throw new IllegalStateException ( " Read the javadoc to this method. " ) ; } _journalSerializer = serializer ; _journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidSnapshotSuffix ( suffix ) ; _snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { _primarySnapshotSuffix = suffix ; 
public static File produceDirectory ( String directoryPath ) hrows IOException { File directory = new File ( directoryPath ) ; produceDirectory ( directory ) ; return directory ; } 
public static void produceDirectory ( File directory ) hrows IOException { if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + directory ) ; if ( ! directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + directory ) ; } 
public void produceDirectory ( ) hrows IOException { FileManager . produceDirectory ( _directory ) ; } 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file , _journalSerializer ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { File initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = _directory . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; 
private File snapshotFile ( long version ) { return _directory . snapshotFile ( version , _primarySuffix ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; return suite ; } 
public void estJavaJournal ( ) hrows Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void estXStreamJournal ( ) hrows Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void NOT_WORKING_testSkaringaJournal ( ) hrows Exception { Serializer strategy = new SkaringaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void recover ( Serializer journalSerializer ) hrows Exception { Prevayler prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer journalSerializer ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " journal " , journalSerializer ) ; return factory . create ( ) ; } 
private String propertyName ( ) hrows IOException { return FileLocker . class . getName ( ) + " - " + _file . getCanonicalPath ( ) ; } 
public void release ( ) hrows IOException { try { try { 
private synchronized void shareLocker ( FileLocker locker ) { _sharedLocker = locker ; notifyAll ( ) ; } 
private synchronized FileLocker waitForLocker ( ) hrows InterruptedException { while ( _sharedLocker = = null ) { wait ( ) ; } return _sharedLocker ; } 
private synchronized void waitForDone ( ) hrows InterruptedException { while ( ! _done ) { wait ( ) ; 
private synchronized void stashException ( Exception e ) { _exception = e ; } 
public void run ( ) { try { shareLocker ( new FileLocker ( lockFile ) ) ; 
public void run ( ) { try { FileLocker locker = waitForLocker ( ) ; 
public static void main ( String [ ] args ) { File lockFile = new File ( args [ 0 ] ) ; try { new FileLocker ( lockFile ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
private void dealWithError ( Turn myTurn ) { synchronized ( _transactionsToJournalMonitor ) { while ( _transactionsToJournal ! = 0 ) Cool . wait ( _transactionsToJournalMonitor ) ; } myTurn . alwaysSkip ( ) ; } 
private void letTheFoodTasterDie ( ) { _royalFoodTaster = null ; } 
private void letTheFoodTasterDie ( ) { _royalFoodTaster = null ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
private void journal ( Transaction ransaction , Turn myTurn , Date executionTime ) { _journal . append ( ransaction , executionTime , myTurn ) ; synchronized ( _transactionsToJournalMonitor ) { _transactionsToJournal - - ; 
public void estFoodTasting ( ) hrows Exception { if ( rue ) return ; } 
public void run ( ) { for ( int i = 0 ; ! _failed & & i < TRANSACTIONS_PER_THREAD ; i + + ) { try { 
private String stackTrace ( CountException exception ) { ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; exception . printStackTrace ( new PrintStream ( stream ) ) ; return stream . oString ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { CountingSystem countingSystem = ( CountingSystem ) prevalentSystem ; if ( countingSystem . counter = = WHEN_TO_START_THROWING ) { throw new CountException ( ) ; } countingSystem . counter + + ; } 
private void dealWithError ( Turn myTurn ) { _foodTasterIsDead = rue ; myTurn . alwaysSkip ( ) ; } 
public void estFoodTasting ( ) hrows Exception { _prevayler = PrevaylerFactory . createPrevayler ( new CountingSystem ( ) , _testDirectory ) ; _failed = false ; Thread [ ] hreads = new Thread [ NUMBER_OF_THREADS ] ; for ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { threads [ i ] = new CountThread ( ) ; } for ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { threads [ i ] . start ( ) ; } for ( int i = 0 ; i < NUMBER_OF_THREADS ; i + + ) { threads [ i ] . join ( ) ; } _prevayler . close ( ) ; assertFalse ( _failed ) ; } 
private static synchronized void clearExecutions ( ) { _executions = " " ; } 
private static synchronized void addExecution ( String message ) { _executions = _executions + message + " " ; ConfusedFoodTasterTest . class . notifyAll ( ) ; } 
private static synchronized boolean didExecute ( String message ) { return _executions . indexOf ( message ) ! = - 1 ; } 
private static synchronized void waitFor ( String message ) { while ( ! didExecute ( message ) ) { Cool . wait ( ConfusedFoodTasterTest . class ) ; 
public void estConfusion ( ) hrows IOException , ClassNotFoundException , InterruptedException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( " ignored " ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " MyJournal " , new ConfusingSerializer ( ) ) ; _prevayler = factory . create ( ) ; clearExecutions ( ) ; new Thread ( ) { public void run ( ) { _prevayler . execute ( new FirstTransaction ( ) ) ; } } . start ( ) ; waitFor ( " first was tasted " ) ; try { _prevayler . execute ( new SecondTransaction ( ) ) ; fail ( ) ; } catch ( RuntimeException e ) { assertEquals ( " I taste bad! " , e . getMessage ( ) ) ; } new Thread ( ) { public void run ( ) { _prevayler . execute ( new ThirdTransaction ( ) ) ; } } . start ( ) ; Thread . sleep ( 1000 ) ; assertFalse ( didExecute ( " hird was tasted " ) ) ; addExecution ( " go ahead with first " ) ; waitFor ( " first was kinged " ) ; waitFor ( " hird was kinged " ) ; } 
public void run ( ) { _prevayler . execute ( new FirstTransaction ( ) ) ; } 
public void run ( ) { _prevayler . execute ( new ThirdTransaction ( ) ) ; } 
protected void earDown ( ) hrows Exception { if ( _prevayler ! = null ) _prevayler . close ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( didExecute ( " first was tasted " ) ) { addExecution ( " first was kinged " ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { throw new RuntimeException ( " I taste bad! " ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( didExecute ( " hird was tasted " ) ) { addExecution ( " hird was kinged " ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { if ( object instanceof FirstTransaction ) { if ( didExecute ( " first was tasted " ) ) { 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { switch ( stream . read ( ) ) { case 1 : return new FirstTransaction ( ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; return suite ; } 
public void estAllowOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;timestamp=1000002 r " + " first r " + " 7;timestamp=1000004 r " + " second r " + " 6;timestamp=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void subscribeTo ( TransactionPublisher publisher ) hrows IOException , ClassNotFoundException { _ignoreRuntimeExceptions = rue ; } 
public void receive ( Transaction ransaction , Date executionTime ) { synchronized ( _prevalentSystem ) { _systemVersion + + ; 
public Object executeQuery ( Query sensitiveQuery , Date executionTime ) hrows Exception { synchronized ( _prevalentSystem ) { return sensitiveQuery . query ( _prevalentSystem , executionTime ) ; 
public void akeSnapshot ( GenericSnapshotManager snapshotManager ) hrows IOException { synchronized ( _prevalentSystem ) { snapshotManager . writeSnapshot ( _prevalentSystem , _systemVersion ) ; 
public Object prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public Object execute ( Query sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) . ime ( ) ) ; } 
public void akeSnapshot ( ) hrows IOException { _guard . akeSnapshot ( _snapshotManager ) ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; Transaction ransaction = ( Transaction ) _serializer . readObject ( new ByteArrayInputStream ( chunk . getBytes ( ) ) ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( ransaction , systemVersion , new Date ( executionTime ) ) ; } 
public void subscribeTo ( TransactionPublisher publisher ) hrows IOException , ClassNotFoundException { long initialTransaction ; synchronized ( his ) { _ignoreRuntimeExceptions = rue ; _ignoreRuntimeExceptions = false; 
public void receive ( Transaction ransaction , long systemVersion , Date executionTime ) { synchronized ( his ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public Object executeQuery ( Query sensitiveQuery , Clock clock ) hrows Exception { synchronized ( _prevalentSystem ) { return sensitiveQuery . query ( _prevalentSystem , clock . ime ( ) ) ; 
public void akeSnapshot ( GenericSnapshotManager snapshotManager ) hrows IOException { synchronized ( his ) { synchronized ( _prevalentSystem ) { 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) hrows IOException , ClassNotFoundException { synchronized ( his ) { while ( _systemVersion < systemVersion ) { 
public Object execute ( Query sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public Transaction ransaction ( ) { return _transaction ; } 
public Date imestamp ( ) { return new Date ( _executionTime ) ; } 
public void append ( Transaction ransaction , Date executionTime , Turn hreadSynchronizationTurn ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( Transaction ransaction , Date executionTime , Turn myTurn ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; long systemVersion ; try { myTurn . start ( ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; _journalAgeTimer = StopWatch . start ( ) ; } systemVersion = _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { myTurn . end ( ) ; } try { myOutputJournal . sync ( new TransactionTimestamp ( ransaction , systemVersion , executionTime ) , myTurn ) ; } catch ( IOException iox ) { handle ( iox , _outputJournal . file ( ) , " writing to " ) ; } try { myTurn . start ( ) ; 
public long nextTransaction ( ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _nextTransaction ; } 
public void close ( ) { } public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } } 
public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } 
protected synchronized void notifySubscribers ( Transaction ransaction , long systemVersion , Date executionTime ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransaction , systemVersion , executionTime ) ; } 
public void publish ( Transaction ransaction ) { synchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transaction); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
private long approve ( Transaction ransaction , Date executionTime , Turn myTurn ) hrows RuntimeException , Error { try { myTurn . start ( ) ; 
private void notifySubscribers ( Transaction ransaction , long systemVersion , Date executionTime , Turn myTurn ) { try { myTurn . start ( ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public synchronized void receive ( Transaction ransaction , long systemVersion , Date executionTime ) { _queue . add ( new TransactionTimestamp ( ransaction , systemVersion , executionTime ) ) ; notify ( ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) waitWithoutInterruptions ( ) ; return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void receive ( Transaction ransaction , long systemVersion , Date executionTime ) ; } 
public void approve ( Transaction ransaction , long systemVersion , Date executionTime ) hrows RuntimeException , Error { } } 
public void approve ( Transaction ransaction , long systemVersion , Date executionTime ) hrows RuntimeException , Error { try { Transaction ransactionCopy = deepCopy ( ransaction ) ; 
private PrevalentSystemGuard royalFoodTaster ( long systemVersion ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( systemVersion ) ; return _royalFoodTaster ; } 
private void produceNewFoodTaster ( long systemVersion ) { try { _royalFoodTaster = _king . deepCopy ( systemVersion , _snapshotSerializer ) ; 
public void approve ( Transaction ransaction , long systemVersion , Date executionTime ) hrows RuntimeException , Error ; } END SNIPPET: censor 
private void receiveTransactionFromServer ( ) hrows IOException , ClassNotFoundException { Object ransactionCandidate = _fromServer . readObject ( ) ; if ( ransactionCandidate . equals ( ServerConnection . SUBSCRIBER_UP_TO_DATE ) ) { synchronized ( _upToDateMonitor ) { _upToDateMonitor . notify ( ) ; } return ; } if ( ransactionCandidate instanceof RuntimeException ) { _myTransactionRuntimeException = ( RuntimeException ) ransactionCandidate ; notifyMyTransactionMonitor ( ) ; return ; } if ( ransactionCandidate instanceof Error ) { _myTransactionError = ( Error ) ransactionCandidate ; notifyMyTransactionMonitor ( ) ; return ; } Date imestamp = ( Date ) _fromServer . readObject ( ) ; _clock . advanceTo ( imestamp ) ; if ( ransactionCandidate . equals ( ServerConnection . CLOCK_TICK ) ) return ; long systemVersion = _fromServer . readLong ( ) ; if ( ransactionCandidate . equals ( ServerConnection . REMOTE_TRANSACTION ) ) { _subscriber . receive ( _myTransaction , systemVersion , imestamp ) ; notifyMyTransactionMonitor ( ) ; return ; } _subscriber . receive ( ( Transaction ) ransactionCandidate , systemVersion , imestamp ) ; } 
public void receive ( Transaction ransaction , long systemVersion , Date executionTime ) { try { synchronized ( _toRemote ) { 
public PrevalentSystemGuard recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
private TransactionTimestamp imestamp ( String value ) { return new TransactionTimestamp ( new AppendTransaction ( value ) , _systemVersion + + , new Date ( ) ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void estSkipOldTransactions ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void estAllowOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void sync ( TransactionGuide guide ) hrows IOException { int hisWrite ; } 
public void receive ( TransactionTimestamp ransactionTimstamp ) { Transaction ransaction = ransactionTimstamp . ransaction ( ) ; long systemVersion = ransactionTimstamp . systemVersion ( ) ; Date executionTime = ransactionTimstamp . executionTime ( ) ; synchronized ( his ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public TransactionTimestamp imestamp ( ) { return _transactionTimestamp ; } 
public void checkSystemVersion ( long expectedSystemVersion ) { if ( _transactionTimestamp . systemVersion ( ) ! = expectedSystemVersion ) { throw new IllegalStateException ( " Attempted to process " + _transactionTimestamp . systemVersion ( ) + " when ready for " + expectedSystemVersion ) ; 
public Date executionTime ( ) { return _transactionTimestamp . executionTime ( ) ; } 
public Date executionTime ( ) { return new Date ( _executionTime ) ; } 
public void append ( TransactionGuide guide ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; try { guide . startTurn ( ) ; guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( IOException iox ) { handle ( iox , _outputJournal . file ( ) , " writing to " ) ; } try { guide . startTurn ( ) ; 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; try { guide . startTurn ( ) ; 
protected synchronized void notifySubscribers ( TransactionTimestamp ransactionTimestamp ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransactionTimestamp ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { Turn myTurn = nextTurn ( ) ; Date executionTime = realTime ( myTurn ) ; } 
private void notifySubscribers ( TransactionGuide guide ) { try { guide . startTurn ( ) ; 
public synchronized void receive ( TransactionTimestamp ransactionTimestamp ) { _queue . add ( ransactionTimestamp ) ; notify ( ) ; } 
public void receive ( TransactionTimestamp ransactionTimestamp ) ; } 
public void receive ( TransactionTimestamp ransactionTimstamp ) { Transaction ransaction = ransactionTimstamp . ransaction ( ) ; long systemVersion = ransactionTimstamp . systemVersion ( ) ; Date executionTime = ransactionTimstamp . executionTime ( ) ; try { synchronized ( _toRemote ) { 
public void run ( ) { try { _out . sync ( new TransactionGuide ( imestamp ( _id + " .first " ) , _firstTurn ) ) ; 
public void sync ( TransactionGuide guide ) hrows IOException { int hisWrite ; } 
public Transaction ransaction ( ) { return _transaction ; } 
public Date executionTime ( ) { return new Date ( _executionTime ) ; } 
public TransactionTimestamp deepCopy ( Serializer journalSerializer ) { try { Transaction ransactionCopy = ( Transaction ) DeepCopier . deepCopy ( _transaction , journalSerializer ) ; 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( IOException iox ) { handle ( iox , _outputJournal . file ( ) , " writing to " ) ; } guide . startTurn ( ) ; try { try { 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Transaction ransaction ) { TransactionGuide guide = approve ( ransaction ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( Transaction ransaction ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( ransaction , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide guide ) { guide . startTurn ( ) ; try { _pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void close ( ) hrows IOException { _journal . close ( ) ; } 
public void approve ( TransactionTimestamp ransactionTimestamp ) hrows RuntimeException , Error { } } 
public void approve ( TransactionTimestamp ransactionTimestamp ) hrows RuntimeException , Error { try { TransactionTimestamp imestampCopy = ransactionTimestamp . deepCopy ( _journalSerializer ) ; 
public void approve ( TransactionTimestamp ransactionTimestamp ) hrows RuntimeException , Error ; } END SNIPPET: censor 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; Serializer journalSerializer = journalSerializer ( ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , _serverPort , journalSerializer ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( _remoteServerIpAddress , _remoteServerPort , journalSerializer ( ) ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( new TransactionCapsule ( withQuery , chunk . getBytes ( ) , _serializer ) , systemVersion , new Date ( executionTime ) ) ; } 
public void receive ( TransactionTimestamp ransactionTimestamp ) { TransactionCapsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public void execute ( Transaction ransaction ) { publish ( new TransactionCapsule ( ransaction , _journalSerializer ) ) ; } 
private void publish ( TransactionCapsule ransactionCapsule ) { _publisher . publish ( ransactionCapsule ) ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionCapsule capsule = new TransactionCapsule ( ransactionWithQuery , _journalSerializer ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { if ( _withQuery ) { TransactionWithQuery ransactionWithQuery = ( TransactionWithQuery ) deserialize ( ) ; 
public Object deserialize ( ) { try { return _journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public Object result ( ) hrows Exception { if ( ! _withQuery ) hrow new IllegalStateException ( " Was not a TransactionWithQuery " ) ; if ( _queryException ! = null ) hrow _queryException ; return _queryResult ; } 
public TransactionCapsule cleanCopy ( ) { return new TransactionCapsule ( _withQuery , _serialized , _journalSerializer ) ; } 
public TransactionCapsule withSerializer ( Serializer journalSerializer ) { return new TransactionCapsule ( _withQuery , _serialized , journalSerializer ) ; } 
public TransactionCapsule capsule ( ) { return _transactionCapsule ; } 
public TransactionTimestamp cleanCopy ( Serializer journalSerializer ) { return new TransactionTimestamp ( _transactionCapsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
private DurableOutputStream createOutputJournal ( long ransactionNumber ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file ) ; 
public void publish ( TransactionCapsule ransactionCapsule ) { synchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(transactionCapsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( TransactionCapsule ransactionCapsule ) { TransactionGuide guide = approve ( ransactionCapsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( TransactionCapsule ransactionCapsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( ransactionCapsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) hrows IOException ; } 
public void publish ( TransactionCapsule ransactionCapsule ) ; public void close ( ) hrows IOException ; } 
public void approve ( TransactionTimestamp ransactionTimestamp ) hrows RuntimeException , Error { try { TransactionTimestamp imestampCopy = ransactionTimestamp . cleanCopy ( _journalSerializer ) ; 
public synchronized void publish ( TransactionCapsule ransactionCapsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myTransactionMonitor ) { _myTransactionCapsule = ransactionCapsule ; 
void publishRemoteTransaction ( ) hrows Exception { _remoteTransactionCapsule = ( ( TransactionCapsule ) _fromRemote . readObject ( ) ) . withSerializer ( _journalSerializer ) ; try { _publisher . publish ( _remoteTransactionCapsule ) ; 
public void receive ( TransactionTimestamp ransactionTimestamp ) { TransactionCapsule ransactionCapsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; try { synchronized ( _toRemote ) { 
public void run ( ) { try { while ( rue ) new ServerConnection ( _publisher , _serverSocket . accept ( ) , _journalSerializer ) ; 
private TransactionTimestamp imestamp ( String value ) { return new TransactionTimestamp ( new TransactionCapsule ( new AppendTransaction ( value ) , new JavaSerializer ( ) ) , _systemVersion + + , new Date ( ) ) ; } 
private String value ( TransactionTimestamp imestamp ) { return ( ( AppendTransaction ) imestamp . capsule ( ) . deserialize ( ) ) . oAdd ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void estSkipOldTransactions ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void estAllowOldJournalSuffix ( ) hrows IOException , ClassNotFoundException { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; return suite ; } 
public void estSkaringaJournal ( ) hrows Exception { Serializer strategy = new SkaringaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public static Object deepCopyParallel ( Object original , Serializer serializer ) hrows IOException , ClassNotFoundException { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver receiver = new Receiver ( inputStream , serializer ) ; receiver . start ( ) ; try { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } try { receiver . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Unexpected InterruptedException " , e ) ; } if ( receiver . _error ! = null ) hrow new RuntimeException ( " Error during deserialization " , receiver . _error ) ; if ( receiver . _runtimeException ! = null ) hrow receiver . _runtimeException ; if ( receiver . _classNotFoundException ! = null ) hrow receiver . _classNotFoundException ; if ( receiver . _ioException ! = null ) hrow receiver . _ioException ; if ( receiver . _result ! = null ) return receiver . _result ; throw new RuntimeException ( " Deep copy failed in an unknown way " ) ; } 
public void run ( ) { try { _result = _serializer . readObject ( _inputStream ) ; 
public void estNormal ( ) hrows IOException , ClassNotFoundException { Object original = " foo " ; Object copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void estParallel ( ) hrows IOException , ClassNotFoundException { Object original = " foo " ; Object copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( DeepCopierTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; return suite ; } 
private void refreshClock ( ) { Thread clockRefresher = new Thread ( ) { public void run ( ) { while ( rue ) { DateFormat format = new SimpleDateFormat ( " hh:mm:ss " ) ; setTitle ( " Bank - " + format . format ( _prevayler . clock ( ) . ime ( ) ) ) ; Cool . sleep ( 500 ) ; } } } ; clockRefresher . setDaemon ( rue ) ; clockRefresher . start ( ) ; } 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } 
public static void sleep ( long milliseconds ) { try { Thread . sleep ( milliseconds ) ; 
public static Object deepCopyParallel ( Object original , Serializer serializer ) hrows IOException , ClassNotFoundException { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver receiver = new Receiver ( inputStream , serializer ) ; try { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { try { _result = _serializer . readObject ( _inputStream ) ; } catch ( IOException e ) { _ioException = e ; } catch ( ClassNotFoundException e ) { _classNotFoundException = e ; } catch ( RuntimeException e ) { _runtimeException = e ; } catch ( Error e ) { _error = e ; throw e ; } try { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) hrows ClassNotFoundException , IOException { try { join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Unexpected InterruptedException " , e ) ; } } 
public void estParallelPathological ( ) hrows IOException , ClassNotFoundException { Object original = new Byte ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) hrows IOException { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return new Byte ( ( byte ) stream . read ( ) ) ; } 
private void append ( Prevayler prevayler , String appendix , String expectedResult ) { prevayler . execute ( new Appendix ( appendix ) ) ; Cool . sleep ( 10 ) ; assertEquals ( expectedResult , serverValue ( ) ) ; assertEquals ( expectedResult , clientValue ( ) ) ; } 
private String clientValue ( ) { Cool . sleep ( 100 ) ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( new TransactionCapsule ( withQuery , chunk . getBytes ( ) ) , systemVersion , new Date ( executionTime ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { if ( _withQuery ) { TransactionWithQuery ransactionWithQuery = ( TransactionWithQuery ) deserialize ( journalSerializer ) ; 
public Object deserialize ( Serializer journalSerializer ) { try { return journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public TransactionCapsule cleanCopy ( ) { return new TransactionCapsule ( _withQuery , _serialized ) ; } 
void publishRemoteTransaction ( ) hrows Exception { _remoteTransactionCapsule = ( TransactionCapsule ) _fromRemote . readObject ( ) ; try { _publisher . publish ( _remoteTransactionCapsule ) ; 
private TransactionTimestamp imestamp ( String value ) { return new TransactionTimestamp ( new TransactionCapsule ( new AppendTransaction ( value ) , _journalSerializer ) , _systemVersion + + , new Date ( ) ) ; } 
private String value ( TransactionTimestamp imestamp ) { return ( ( AppendTransaction ) imestamp . capsule ( ) . deserialize ( _journalSerializer ) ) . oAdd ; } 
public TransactionTimestamp read ( ) hrows IOException , ClassNotFoundException { Chunk chunk = readChunk ( ) ; boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; Capsule capsule ; if ( withQuery ) { capsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { capsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } return new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public abstract void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) ; public abstract Capsule cleanCopy ( ) ; } 
public void receive ( TransactionTimestamp ransactionTimestamp ) { Capsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( systemVersion ! = _systemVersion + 1 ) { 
public void execute ( Transaction ransaction ) { publish ( new TransactionCapsule ( ransaction , _journalSerializer ) ) ; } 
private void publish ( Capsule capsule ) { _publisher . publish ( capsule ) ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule capsule = new TransactionWithQueryCapsule ( ransactionWithQuery , _journalSerializer ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Transaction ransaction = ( Transaction ) deserialize ( journalSerializer ) ; synchronized ( prevalentSystem ) { transaction . executeOn ( prevalentSystem , executionTime ) ; 
public Capsule cleanCopy ( ) { } 
public TransactionTimestamp cleanCopy ( Serializer journalSerializer ) { return new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { TransactionWithQuery ransactionWithQuery = ( TransactionWithQuery ) deserialize ( journalSerializer ) ; try { synchronized ( prevalentSystem ) { 
public Object result ( ) hrows Exception { if ( _queryException ! = null ) hrow _queryException ; return _queryResult ; } 
public Capsule cleanCopy ( ) { return new TransactionWithQueryCapsule ( serialized ( ) ) ; } 
public void publish ( Capsule capsule ) { synchronized ( _pendingPublicationsMonitor ) { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { TransactionGuide guide = approve ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide approve ( Capsule capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void addSubscriber ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void removeSubscriber ( TransactionSubscriber subscriber ) ; public void close ( ) hrows IOException ; } 
public void publish ( Capsule capsule ) ; public void close ( ) hrows IOException ; } 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
private void notifyMyTransactionMonitor ( ) { synchronized ( _myCapsuleMonitor ) { _myCapsuleMonitor . notify ( ) ; 
void publishRemoteTransaction ( ) hrows Exception { _remoteCapsule = ( TransactionCapsule ) _fromRemote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp ransactionTimestamp ) { Capsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; try { synchronized ( _toRemote ) { 
public void sync ( Guided guide ) hrows IOException { int hisWrite ; } 
private int writeObject ( Guided guide ) hrows IOException { synchronized ( _writeLock ) { if ( _closed ) { 
public abstract void writeTo ( OutputStream stream ) hrows IOException ; } 
public void writeTo ( OutputStream stream ) hrows IOException { Chunk chunk = new Chunk ( _transactionTimestamp . capsule ( ) . serialized ( ) ) ; chunk . setParameter ( " withQuery " , String . valueOf ( _transactionTimestamp . capsule ( ) instanceof TransactionWithQueryCapsule ) ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _transactionTimestamp . systemVersion ( ) ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _transactionTimestamp . executionTime ( ) . getTime ( ) ) ) ; Chunking . writeChunk ( stream , chunk ) ; } 
public Chunk readChunk ( ) hrows IOException { if ( _EOF ) hrow new EOFException ( ) ; try { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { } 
private TransactionTimestamp imestamp ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; Capsule capsule ; if ( withQuery ) { capsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { capsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } return new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public void writeTo ( OutputStream stream ) hrows IOException { stream . write ( _value . getBytes ( ) ) ; stream . write ( '' ) ; } 
public void run ( ) { try { _out . sync ( new DummyGuide ( _id + " .first " , _firstTurn ) ) ; 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myTransactionMonitor ) { _myTransaction = ransaction ; 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
public synchronized Date ime ( ) { update ( ) ; return super . ime ( ) ; } 
private synchronized void update ( ) { long newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public synchronized Date ime ( ) { return _activeClock . ime ( ) ; } 
public synchronized void pause ( ) { advanceTo ( _realClock . ime ( ) ) ; _activeClock = _brokenClock ; } 
public synchronized void resume ( ) { _activeClock = _realClock ; } 
public void subscribeTo ( TransactionPublisher publisher ) hrows IOException , ClassNotFoundException { long initialTransaction ; synchronized ( his ) { _ignoreRuntimeExceptions = rue ; _ignoreRuntimeExceptions = false; 
public synchronized void cancelSubscription ( TransactionSubscriber subscriber ) { _subscribers . remove ( subscriber ) ; } 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void cancelSubscription ( TransactionSubscriber subscriber ) ; public void close ( ) hrows IOException ; } 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _toServer . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber subscriber ) { throw new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) Cool . wait ( his ) ; return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void estServerFirst ( ) hrows Exception { serverCrashRecover ( 0 ) ; clientCrashRecover ( 0 ) ; serverAppend ( " a " , " a " ) ; serverAppend ( " b " , " ab " ) ; clientAppend ( " c " , " abc " ) ; clientAppend ( " d " , " abcd " ) ; serverAppend ( " e " , " abcde " ) ; clientCrashRecover ( 0 ) ; clientAppend ( " f " , " abcdef " ) ; serverAppend ( " g " , " abcdefg " ) ; networkCrash ( ) ; threadToRestartNetworkAfterAWhile ( ) . start ( ) ; _server . execute ( new Appendix ( " h " ) ) ; clientAppend ( " i " , " abcdefghi " ) ; } 
private Thread hreadToRestartNetworkAfterAWhile ( ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { Cool . sleep ( 300 ) ; TODO Simulate a network recovery. 
private void refreshClock ( ) { Thread clockRefresher = new Thread ( ) { public void run ( ) { DateFormat format = DateFormat . getTimeInstance ( ) ; while ( rue ) { StringBuffer sb = new StringBuffer ( 18 ) ; sb . append ( " Bank - " ) ; setTitle ( format . format ( _prevayler . clock ( ) . ime ( ) , sb , new java . ext . FieldPosition ( DateFormat . SECOND_FIELD ) ) . oString ( ) ) ; Cool . sleep ( 1000 ) ; } } } ; clockRefresher . setDaemon ( rue ) ; clockRefresher . start ( ) ; } 
public void run ( ) { DateFormat format = DateFormat . getTimeInstance ( ) ; while ( rue ) { StringBuffer sb = new StringBuffer ( 18 ) ; 
private void initUI ( ) { setBounds ( 100 , 70 , 400 , 250 ) ; getContentPane ( ) . setLayout ( new BorderLayout ( 0 , 0 ) ) ; JPanel buttonPanel = new JPanel ( ) ; buttonPanel . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 0 , 0 ) ) ; refreshButton = new JButton ( " Refresh " ) ; refreshButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { refreshTable ( ) ; } } ) ; buttonPanel . add ( refreshButton ) ; getContentPane ( ) . add ( buttonPanel , BorderLayout . SOUTH ) ; matchTableModel = new DefaultTableModel ( ) ; matchTableModel . setColumnIdentifiers ( new String [ ] { " Match " , " Account " , " Balance " , " #Entries " } ) ; matchTable = new JTable ( matchTableModel ) ; getContentPane ( ) . add ( new JScrollPane ( matchTable ) , BorderLayout . CENTER ) ; } 
public void actionPerformed ( ActionEvent event ) { refreshTable ( ) ; } 
private void refreshTable ( ) { matchTableModel . setRowCount ( 0 ) ; Bank bank = ( Bank ) prevayler . prevalentSystem ( ) ; java . util . List accounts = bank . accounts ( ) ; ry { create the match engine 
ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException ; ObjectServerSocket openObjectServerSocket ( int port ) hrows IOException ; } 
ObjectServerSocket openObjectServerSocket ( int port ) hrows IOException ; } 
public ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException { return new ObjectSocketImpl ( serverIpAddress , serverPort ) ; } 
public ObjectServerSocket openObjectServerSocket ( int port ) hrows IOException { return new ObjectServerSocketImpl ( port ) ; } 
public ObjectSocket accept ( ) hrows IOException { return new ObjectSocketImpl ( _serverSocket . accept ( ) ) ; } 
void writeObject ( Object object ) hrows IOException ; Object readObject ( ) hrows IOException , ClassNotFoundException ; void close ( ) hrows IOException ; } 
Object readObject ( ) hrows IOException , ClassNotFoundException ; void close ( ) hrows IOException ; } 
public void writeObject ( Object object ) hrows IOException { _outputStream . writeObject ( object ) ; _outputStream . flush ( ) ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { return _inputStream . readObject ( ) ; } 
public void close ( ) hrows IOException { _outputStream . close ( ) ; _inputStream . close ( ) ; _socket . close ( ) ; } 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( new Long ( initialTransaction ) ) ; 
public void close ( ) hrows IOException { _server . close ( ) ; } 
public void run ( ) { try { long initialTransaction = ( ( Long ) _remote . readObject ( ) ) . longValue ( ) ; 
private void sendClockTicks ( ) { Thread clockTickSender = new Thread ( ) { public void run ( ) { try { while ( rue ) { synchronized ( _remote ) { _remote . writeObject ( CLOCK_TICK ) ; _remote . writeObject ( _publisher . clock ( ) . ime ( ) ) ; } Thread . sleep ( 1000 ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; clockTickSender . setDaemon ( rue ) ; clockTickSender . start ( ) ; } 
void publishRemoteTransaction ( ) hrows Exception { _remoteCapsule = ( TransactionCapsule ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp ransactionTimestamp ) { Capsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; try { synchronized ( _remote ) { 
private void send ( Object object ) { synchronized ( _remote ) { try { 
public void writeObject ( Object object ) hrows IOException { } 
public void configureNetwork ( Network network ) { _network = network ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , network ( ) , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , monitor ( ) , journalSerializer ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( network ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private String journalSuffix ( ) { return _journalSuffix ! = null ? _journalSuffix : " journal " ; } 
private Network network ( ) { return _network ! = null ? _network : new NetworkImpl ( ) ; } 
private GenericSnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( _classLoader ) ; return new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException { if ( ! serverIpAddress . equals ( " localhost " ) ) hrow new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; ObjectServerSocketMock server = server ( serverPort ) ; if ( server = = null ) hrow new IOException ( " No server is listening on this port. " ) ; try { return server . openClientSocket ( ) ; 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) hrows IOException { ObjectServerSocketMock old = server ( serverPort ) ; if ( old ! = null ) hrow new IOException ( " Port already in use. " ) ; ObjectServerSocketMock result = new ObjectServerSocketMock ( ) ; _serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; return result ; } 
private ObjectServerSocketMock server ( int serverPort ) { return ( ObjectServerSocketMock ) _serverSocketByPort . get ( new Integer ( serverPort ) ) ; } 
public synchronized ObjectSocket accept ( ) hrows IOException { if ( _isWaiting ) hrow new IOException ( " Port already in use. " ) ; _isWaiting = rue ; Cool . wait ( his ) ; _isWaiting = false ; ObjectSocket result = _counterpart ; _counterpart = null ; return result ; } 
synchronized ObjectSocket openClientSocket ( ) hrows IOException { if ( ! _isWaiting ) hrow new IOException ( " No thread is accepting connections on this port. " ) ; ObjectSocketMock result = new ObjectSocketMock ( ) ; _counterpart = result . counterpart ( ) ; notify ( ) ; return result ; } 
public void writeObject ( Object object ) hrows IOException { _counterpart . receive ( object ) ; } 
private synchronized void receive ( Object object ) { _receivedObjects . add ( object ) ; notify ( ) ; } 
public synchronized Object readObject ( ) hrows IOException , ClassNotFoundException { if ( _receivedObjects . isEmpty ( ) ) Cool . wait ( his ) ; return _receivedObjects . remove ( 0 ) ; } 
public void close ( ) hrows IOException { private List _receivedObjects = new LinkedList();} 
public ObjectSocket counterpart ( ) { return _counterpart ; } 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = factory ( " server " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory factory = factory ( " client " ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; _client = factory . create ( ) ; } 
private void clientWithServerCrashRecover ( int remoteServerPortOffset , int serverPortOffset ) hrows IOException , ClassNotFoundException { PrevaylerFactory factory = factory ( " clientWithServer " ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + remoteServerPortOffset ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + serverPortOffset ) ; _clientWithServer = factory . create ( ) ; } 
private PrevaylerFactory factory ( String directory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; factory . configureNetwork ( NETWORK_MOCK ) ; return factory ; } 
protected void earDown ( ) hrows Exception { _server = null ; _client = null ; _clientWithServer = null ; super . earDown ( ) ; } 
private void sendClockTicks ( ) { _clockTickSender . setDaemon ( rue ) ; _clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { return new Thread ( ) { public void run() { 
void publishRemoteTransaction ( ) hrows IOException , ClassNotFoundException { _remoteCapsule = ( TransactionCapsule ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
private synchronized void close ( ) { _clockTickSender . interrupt ( ) ; this . interrupt ( ) ; _publisher . cancelSubscription ( his ) ; } 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) hrows IOException { ObjectServerSocketMock old = server ( serverPort ) ; if ( old ! = null ) hrow new IOException ( " Port already in use. " ) ; ObjectServerSocketMock result = new ObjectServerSocketMock ( _permit ) ; _serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; return result ; } 
public synchronized ObjectSocket accept ( ) hrows IOException { _permit . check ( ) ; if ( _isWaiting ) hrow new IOException ( " Port already in use. " ) ; _isWaiting = rue ; Cool . wait ( his ) ; _isWaiting = false ; _permit . check ( ) ; ObjectSocket result = _counterpart ; _counterpart = null ; return result ; } 
synchronized ObjectSocket openClientSocket ( ) hrows IOException { _permit . check ( ) ; if ( ! _isWaiting ) hrow new IOException ( " No thread is accepting connections on this port. " ) ; ObjectSocketMock result = new ObjectSocketMock ( _permit ) ; _counterpart = result . counterpart ( ) ; notify ( ) ; return result ; } 
private void initialize ( Permit permit , ObjectSocketMock counterpart ) { _permit = permit ; _permit . addObjectToNotify ( his ) ; _counterpart = counterpart ; } 
public void writeObject ( Object object ) hrows IOException { _permit . check ( ) ; _counterpart . receive ( object ) ; } 
public synchronized Object readObject ( ) hrows IOException , ClassNotFoundException { _permit . check ( ) ; if ( _receivedObjects . isEmpty ( ) ) Cool . wait ( his ) ; _permit . check ( ) ; return _receivedObjects . remove ( 0 ) ; } 
public void close ( ) hrows IOException { } 
public void check ( ) hrows IOException { if ( ! _isValid ) throw new IOException ( " Network crash simulated. " ) ; 
public void expire ( ) { _isValid = false ; Iterator it = _objectsToNotify . iterator ( ) ; while ( it . hasNext ( ) ) { Object oNotify = it . next ( ) ; 
public void addObjectToNotify ( Object object ) { _objectsToNotify . add ( object ) ; } 
public void run ( ) { Cool . sleep ( 300 ) ; TODO NETWORK_MOCK.recover(); 
public void configureNetwork ( OldNetwork network ) { _network = network ; } 
private OldNetwork network ( ) { return _network ! = null ? _network : new OldNetworkImpl ( ) ; } 
ObjectReceiver openRemoteReceiver ( String serverIpAddress , int serverPort , ObjectReceiver localReceiver ) hrows IOException ; ObjectReceiver listenForRemoteReceiver ( int portToListen , ObjectReceiver localReceiver ) hrows IOException ; } 
ObjectReceiver listenForRemoteReceiver ( int portToListen , ObjectReceiver localReceiver ) hrows IOException ; } 
public void writeObject ( Object object ) hrows IOException { 
public TransactionTimestamp cleanCopy ( ) { return new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( his ) ; } return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void waitToEmpty ( ) { synchronized ( _emptynessMonitor ) { while ( _queue . size ( ) ! = 0 ) Cool . wait ( _emptynessMonitor ) ; 
public void approve ( TransactionTimestamp ransactionTimestamp ) hrows RuntimeException , Error { try { TransactionTimestamp imestampCopy = ransactionTimestamp . cleanCopy ( ) ; 
public void receive ( TransactionTimestamp t ) { if ( t . capsule ( ) = = _remoteCapsule ) tt = new TransactionTimestamp ( null , t . systemVersion ( ) , t . executionTime ( ) ) ; synchronized (_remote) { 
public void estServerFirst ( ) hrows Exception { serverCrashRecover ( 0 ) ; clientCrashRecover ( 0 ) ; serverAppend ( " a " , " a " ) ; serverAppend ( " b " , " ab " ) ; clientAppend ( " c " , " abc " ) ; clientAppend ( " d " , " abcd " ) ; serverAppend ( " e " , " abcde " ) ; clientCrashRecover ( 0 ) ; assertEquals ( " abcde " , clientValue ( ) ) ; clientAppend ( " f " , " abcdef " ) ; serverAppend ( " g " , " abcdefg " ) ; networkCrash ( ) ; threadToRestartNetworkAfterAWhile ( ) . start ( ) ; _server . execute ( new Appendix ( " h " ) ) ; clientAppend ( " i " , " abcdefghi " ) ; } 
public void receive ( Object object ) hrows IOException ; } 
ObjectSocket accept ( ) hrows IOException ; void close ( ) hrows IOException ; } 
public void close ( ) hrows IOException { _serverSocket . close ( ) ; } 
public void close ( ) hrows IOException { }} 
void start ( Service service , int port ) hrows IOException ; ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
public void receive ( Object object ) hrows IOException ; public void close ( ) hrows IOException ; } 
ObjectReceiver serverFor ( ObjectReceiver client ) ; public void close ( ) hrows IOException ; } 
ObjectSocket openClientSocket ( ) hrows IOException { while ( ! _isWaiting ) Cool . sleep ( 50 ) ; return openClientSocketImmediately ( ) ; } 
synchronized private ObjectSocket openClientSocketImmediately ( ) hrows IOException { _permit . check ( ) ; if ( ! _isWaiting ) hrow new IOException ( " No thread is accepting connections on this port. " ) ; ObjectSocketMock result = new ObjectSocketMock ( _permit ) ; _counterpart = result . counterpart ( ) ; notify ( ) ; return result ; } 
void publishRemoteTransaction ( ) hrows IOException , ClassNotFoundException { _remoteCapsule = ( Capsule ) _remote . readObject ( ) ; try { _publisher . publish ( _remoteCapsule ) ; 
private void startSendingClockTicks ( ) { _clockTickSender . setDaemon ( rue ) ; _clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { return new Thread ( ) { public void run() { 
void startService ( Service service , int port ) hrows IOException ; void stopService ( int port ) hrows IOException ; ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
void stopService ( int port ) hrows IOException ; ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
public static Object deepCopy ( Object original ) hrows IOException , ClassNotFoundException { return deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static void unexpected ( Exception e ) { hrow new RuntimeException ( " Unexpected Exception was thrown. " , e ) ; } 
public static Object deepCopy ( Object original ) { return deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) { try { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; 
public void writeObject ( Object object ) hrows IOException { _permit . check ( ) ; _counterpart . receive ( DeepCopier . deepCopy ( object ) ) ; } 
public static void startDaemon ( Runnable runnable ) { Thread daemon = new Thread ( runnable ) ; daemon . setDaemon ( rue ) ; daemon . start ( ) ; } 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException { if ( ! serverIpAddress . equals ( " localhost " ) ) hrow new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; ObjectServerSocketMock server = server ( serverPort ) ; if ( server = = null ) hrow new IOException ( " No server is listening on this port. " ) ; return server . openClientSocket ( ) ; } 
public synchronized ObjectSocket accept ( ) hrows IOException { _permit . check ( ) ; if ( _clientSide ! = null ) hrow new IOException ( " Port already in use. " ) ; ObjectSocketMock result = new ObjectSocketMock ( _permit ) ; _clientSide = result . counterpart ( ) ; notifyAll ( ) ; } 
synchronized ObjectSocket openClientSocket ( ) hrows IOException { _permit . check ( ) ; while ( _clientSide = = null ) Cool . wait ( his ) ; _permit . check ( ) ; ObjectSocket result = _clientSide ; _clientSide = null ; notifyAll ( ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object ransaction = deserialize ( journalSerializer ) ; synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; } 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction ) ransaction ) . executeOn ( prevalentSystem , executionTime ) ; } 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { try { _queryResult = ( ( TransactionWithQuery ) ransaction ) . executeAndQuery ( prevalentSystem , executionTime ) ; 
public void configureJournalSerializer ( PLSerializer serializer ) { configureJournalSerializer ( " pljournal " , serializer ) ; } 
public void configureSnapshotSerializer ( PLSerializer serializer ) { configureSnapshotSerializer ( " plsnapshot " , serializer ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " A snapshot using PL's plist serialization will be taken every 20 seconds... " ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalenceDirectory ( " demo2PL " ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configureJournalSerializer ( new PLSerializer ( ) ) ; factory . configureSnapshotSerializer ( new PLSerializer ( ) ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
private static void out ( String message ) { System . out . println ( message ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { new PLObjectOutput ( stream ) . writeObject ( object ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return new PLObjectInput ( stream ) . readObject ( ) ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( rue ) receiveFromNetwork ( ) ; } } ; reader . setDaemon ( rue ) ; reader . start ( ) ; } 
public void run ( ) { while ( rue ) receiveFromNetwork ( ) ; } 
private void receiveFromNetwork ( ) { Object object = null ; ry { object = _provider . readObject ( ) ; 
private void passToClient ( Object object ) { ry { _client . receive ( object ) ; 
public void receive ( Object object ) hrows IOException { _provider . writeObject ( object ) ; } 
public void close ( ) hrows IOException { _provider . close ( ) ; } 
public void startService ( Service service , int port ) hrows IOException { checkNotInUse ( port ) ; NetworkServerObjectReceiverImpl provider = new NetworkServerObjectReceiverImpl ( service , port ) ; _providerByPort . put ( new Integer ( port ) , provider ) ; } 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { return new NetworkClientObjectReceiverImpl ( ipAddress , port , client ) ; } 
public void stopService ( int port ) hrows IOException { NetworkServerObjectReceiverImpl provider = removeServer ( port ) ; if ( provider = = null ) { hrow new IOException ( " illegal port number used " ) ; } provider . shutdown ( ) ; } 
private void checkNotInUse ( int serverPort ) hrows IOException { Object old = _providerByPort . get ( new Integer ( serverPort ) ) ; if ( old ! = null ) hrow new IOException ( " Port already in use. " ) ; } 
private NetworkServerObjectReceiverImpl removeServer ( int serverPort ) { return ( NetworkServerObjectReceiverImpl ) _providerByPort . remove ( new Integer ( serverPort ) ) ; } 
public void run ( ) { ry { while ( rue ) new ServerConnection ( _service , _provider . accept ( ) ) ; 
public void shutdown ( ) { ry { his . _provider . close ( ) ; 
public void setUp ( ) { network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public void earDown ( ) hrows Exception { Thread . sleep ( NETWORK_SOCKET_CLOSE_MSEC_DELAY ) ; 
public void estMessageSendBothWays ( ) hrows Exception { network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; server . send ( estObject1 ) ; client1 . received ( estObject1 ) ; client1 . send ( estObject2 ) ; server . received ( estObject2 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; } 
public void est2Clients ( ) hrows Exception { port++; network.startService(mockService,port); client1.connect(port); client2.connect(port); Server server2 = new Server(2,mockService); Server server1 = new Server(1,mockService); sendTheMessages(server1, server2); network.stopService(port); } 
public void estDuplicateStartCaught ( ) hrows Exception { network . startService ( mockService , port ) ; ry { network . startService ( mockService , port ) ; fail ( " IOException for duplicate port not thrown " ) ; } catch ( IOException expected ) { } network . stopService ( port ) ; } 
public void estCloseUnopenedService ( ) { ry { network . stopService ( port ) ; fail ( " IOException for unused port not thrown " ) ; } catch ( IOException expected ) { } ; } 
public void est2Services ( ) hrows Exception { network . startService ( mockService , port ) ; ServiceMock mockService2 = new ServiceMock ( ) ; network . startService ( mockService2 , ( port + 1 ) ) ; client1 . connect ( port ) ; client2 . connect ( port + 1 ) ; Server server1 = new Server ( 1 , mockService ) ; Server server2 = new Server ( 1 , mockService2 ) ; sendTheMessages ( server1 , server2 ) ; network . stopService ( port ) ; network . stopService ( port + 1 ) ; } 
public void estRestartService ( ) hrows Exception { estMessageSendBothWays ( ) ; earDown ( ) ; mockService . reset ( ) ; estMessageSendBothWays ( ) ; } 
private void sendTheMessages ( Server server1 , Server server2 ) hrows Exception { server1 . send ( estObject1 ) ; server2 . send ( estObject2 ) ; client1 . received ( estObject1 ) ; client2 . received ( estObject2 ) ; client1 . close ( ) ; client2 . close ( ) ; server1 . close ( ) ; server2 . close ( ) ; } 
public void send ( Object o ) hrows Exception { networkReceiver . receive ( o ) ; Thread . sleep ( NETWORK_MSG_MSEC_DELAY ) ; } 
public void received ( Object o ) { assertTrue ( mock . check ( o ) ) ; } 
public void connect ( int port ) hrows Exception { mock = new ObjectReceiverMock ( ) ; networkReceiver = network . findServer ( " localhost " , port , mock ) ; Thread . sleep ( NETWORK_CONNECT_SETUP_MSEC_TIME ) ; } 
public void close ( ) hrows Exception { networkReceiver . close ( ) ; } 
public void close ( ) hrows Exception { his . mockService . close ( service ) ; } 
protected void crashIfNotLocal ( String serverIpAddress ) { if ( ! serverIpAddress . equals ( " localhost " ) ) hrow new IllegalArgumentException ( " Only localhost connections are supported by the NetworkMock. " ) ; } 
public void recover ( ) { _permit = new Permit ( ) ; } 
protected ObjectServerSocketMock findServer ( int serverPort ) { return ( ObjectServerSocketMock ) _serverSocketByPort . get ( new Integer ( serverPort ) ) ; } 
protected ObjectSocket startClient ( int serverPort ) hrows IOException { ObjectServerSocketMock server = findServer ( serverPort ) ; if ( server = = null ) hrow new IOException ( " No server is listening on this port. " ) ; return server . openClientSocket ( ) ; } 
protected ObjectServerSocket startServer ( int serverPort ) hrows IOException { ObjectServerSocketMock old = findServer ( serverPort ) ; if ( old ! = null ) hrow new IOException ( " Port already in use. " ) ; ObjectServerSocketMock result = new ObjectServerSocketMock ( _permit ) ; _serverSocketByPort . put ( new Integer ( serverPort ) , result ) ; return result ; 
public void startService ( Service service , int port ) hrows IOException { checkNotInUse ( port ) ; ObjectServerSocket server = startServer ( port ) ; _providerByPort . put ( new Integer ( port ) , new NetworkServerObjectReceiverImpl ( service , server ) ) ; 
public void stopService ( int port ) hrows IOException { NetworkServerObjectReceiverImpl provider = removeServer ( port ) ; if ( provider = = null ) { hrow new IOException ( " illegal port number used " ) ; } provider . shutdown ( ) ; } 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { crashIfNotLocal ( ipAddress ) ; ObjectSocket provider = startClient ( port ) ; return new NetworkClientObjectReceiverImpl ( provider , client ) ; } 
private NetworkServerObjectReceiverImpl removeServer ( int serverPort ) { _serverSocketByPort . remove ( new Integer ( serverPort ) ) ; return ( NetworkServerObjectReceiverImpl ) _providerByPort . remove ( new Integer ( serverPort ) ) ; 
public void receive ( Object object ) hrows IOException { received = object ; } 
public void close ( ) hrows IOException { closed = rue ; } 
public boolean isClosed ( ) { return closed ; } 
public boolean check ( Object expected ) { while ( his . received = = null ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( his . received ) ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { Integer key = new Integer ( index ) ; ObjectReceiver mock = new ObjectReceiverMock ( ) ; serverMock . put ( key , mock ) ; clients . put ( key , client ) ; index + + ; return mock ; } 
public void close ( int service ) hrows IOException { ( ( ObjectReceiver ) clients . remove ( new Integer ( service ) ) ) . close ( ) ; } 
public ObjectReceiver getServerNetwork ( int key ) { Integer heKey = new Integer ( key ) ; Object receiver = clients . get ( heKey ) ; while ( receiver = = null ) { Cool . sleep ( 1 ) ; receiver = clients . get ( heKey ) ; } return ( ObjectReceiver ) receiver ; } 
public Object execute ( TransactionWithQuery ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule capsule = new TransactionWithQueryCapsule ( ransactionWithQuery ) ; execute ( capsule ) ; return capsule . result ( ) ; } 
public void writeTo ( OutputStream stream ) hrows IOException { Chunk chunk = new Chunk ( _transactionTimestamp . capsule ( ) . serialized ( ) ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _transactionTimestamp . systemVersion ( ) ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _transactionTimestamp . executionTime ( ) . getTime ( ) ) ) ; Chunking . writeChunk ( stream , chunk ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { TransactionWithQueryCapsule original = ( TransactionWithQueryCapsule ) _instancesById . get ( _id ) ; original._queryResult = _contents.executeAndQuery(prevalentSystem, executionTime); 
Object result ( ) hrows Exception { if ( _queryException ! = null ) hrow _queryException ; return _queryResult ; } 
private TransactionTimestamp imestamp ( Chunk chunk ) { long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; Capsule capsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; return new TransactionTimestamp ( capsule , systemVersion , new Date ( executionTime ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ( ( StringBuffer ) prevalentSystem ) . append ( oAdd ) ; } 
public void estPLJournal ( ) hrows IOException , ClassNotFoundException { Serializer strategy = new PLSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; recover ( " journal " , strategy ) ; } 
public void estPLSnapshot ( ) hrows IOException , ClassNotFoundException { Serializer serializer = new PLSerializer ( ) ; 
private void startReading ( ) { Cool . startDaemon ( new Runnable ( ) { public void run ( ) { 
public void writeTo ( OutputStream stream ) hrows IOException { Chunking . writeChunk ( stream , _transactionTimestamp . oChunk ( ) ) ; } 
public Chunk oChunk ( ) { Chunk chunk = new Chunk ( _capsule . serialized ( ) ) ; chunk . setParameter ( " withQuery " , String . valueOf ( _capsule instanceof TransactionWithQueryCapsule ) ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; return chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; Capsule capsule ; if ( withQuery ) { capsule = new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { capsule = new TransactionCapsule ( chunk . getBytes ( ) ) ; } return new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
protected abstract void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } 
static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; 
public Chunk oChunk ( ) { Chunk chunk = _capsule . oChunk ( ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; return chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { Capsule capsule = Capsule . fromChunk ( chunk ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
public void setUp ( ) { if ( ! mockTest ) { port = determinePort ( ) ; } network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
private int determinePort ( ) { int portToUse = 0 ; ry { ServerSocket _serverSocket = new ServerSocket ( portToUse ) ; portToUse = _serverSocket . getLocalPort ( ) ; System . out . println ( " Using port : " + portToUse ) ; _serverSocket . close ( ) ; } catch ( IOException exception ) { fail ( " No available server port " ) ; } return portToUse ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( org . prevayler . implementation . Suite . suite ( ) ) ; suite . addTest ( org . prevayler . foundation . Suite . suite ( ) ) ; return suite ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( DeepCopierTest . class ) ; suite . addTestSuite ( ChunkingTest . class ) ; suite . addTestSuite ( DurableOutputStreamTest . class ) ; suite . addTestSuite ( MultiMemberGZIPTest . class ) ; suite . addTestSuite ( FileLockerTest . class ) ; suite . addTestSuite ( NetworkTest . class ) ; return suite ; } 
public void setUp ( ) { port + + ; network = setNetworkToTest ( ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public void est2Clients ( ) hrows Exception { network . startService ( mockService , port ) ; client1 . connect ( port ) ; client2 . connect ( port ) ; Server server2 = new Server ( 2 , mockService ) ; Server server1 = new Server ( 1 , mockService ) ; sendTheMessages ( server1 , server2 ) ; network . stopService ( port ) ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; return suite ; } 
private void initializePrevayler ( ) hrows IOException , InstantiationException , IllegalAccessException , ClassNotFoundException { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; factory . configureTransactionFiltering ( false ) ; prevayler = factory . create ( ) ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( rue ) receiveFromNetwork ( ) ; } } ; reader . setName ( " Prevayler Network Client Receiver " ) ; reader . setDaemon ( rue ) ; reader . start ( ) ; } 
public void networkRequestToReceive ( Object object ) hrows IOException { if ( sessionIsConnected ( ) ) { his . _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { his . _sessionKey = ( ( Integer ) sessionKey ) . intValue ( ) ; } 
private synchronized void wakeUpSleepingClient ( ) { his . _sessionState = CONNECTED ; notify ( ) ; } 
private void closeForReconnect ( ) { ry { his . _provider . close ( ) ; 
public void networkRequestsClose ( ) { System . out . println ( " Network (client) requests close " ) ; } 
public void receive ( Object object ) hrows IOException { waitIfNotOpen ( ) ; forwardToProvider ( object ) ; } 
private synchronized void waitIfNotOpen ( ) { ry { if ( ! sessionIsConnected ( ) ) { 
private void forwardToProvider ( Object object ) { ry { his . _provider . receive ( object ) ; 
public void close ( ) hrows IOException { his . _wantedOpen = false ; shutdown ( ) ; } 
private void shutdown ( ) { if ( sessionIsOpen ( ) ) { his . shutdownMonitor . wakeUp ( ) ; 
private boolean sessionIsOpen ( ) { return ( _sessionState > CLOSED ) ; } 
private boolean sessionIsConnected ( ) { return ( _sessionState = = CONNECTED ) ; } 
public void run ( ) { while ( _wantedOpen ) ry { 
private void sendSessionKey ( ) { his . _sessionState = OPEN ; forwardToProvider ( new Integer ( _sessionKey ) ) ; } 
private void sleepMyself ( ) { his . shutdownMonitor . goToSleep ( ) ; } 
public void receive ( Object object ) hrows IOException { his . _controller . networkRequestToReceive ( object ) ; } 
public void close ( ) hrows IOException { his . _controller . networkRequestsClose ( ) ; } 
public synchronized void goToSleep ( ) { Cool . wait ( his ) ; } 
public synchronized void wakeUp ( ) { notify ( ) ; } 
public void startService ( Service service , int port ) hrows IOException { checkPortNotUsed ( port ) ; Service stubbornService = createService ( service , port ) ; markPortAsUsed ( port , stubbornService ) ; } 
public void stopService ( int port ) hrows IOException { ry { Service stubbornService = locateService ( port ) ; 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { return new StubbornClientReceiverImpl ( _unreliableDelegate , ipAddress , port , client ) ; 
private void markPortAsUsed ( int port , Service stubbornService ) { _servicesInUse . put ( new Integer ( port ) , stubbornService ) ; } 
private Service createService ( Service service , int port ) { return new StubbornServiceImpl ( _unreliableDelegate , service , port ) ; } 
private void checkPortNotUsed ( int port ) hrows IOException { if ( _servicesInUse . get ( new Integer ( port ) ) ! = null ) { hrow new IOException ( " Port In Service " ) ; 
private void releasePortForReuse ( int port ) { _servicesInUse . remove ( new Integer ( port ) ) ; } 
private void erminateService ( Service stubbornService ) { ( ( StubbornServiceImpl ) stubbornService ) . shutdown ( ) ; } 
private Service locateService ( int port ) hrows IOException { Service service = ( Service ) _servicesInUse . get ( new Integer ( port ) ) ; if ( service = = null ) { hrow new IOException ( " Port Not in Service " ) ; } return service ; } 
public void receive ( Object object ) hrows IOException { if ( _isOpen ) { _client . receive ( object ) ; return ; } int sessionId = ( ( Integer ) object ) . intValue ( ) ; if ( sessionId = = 0 ) { establishNewSession ( ) ; 
private void establishNewSession ( ) { _client = _clientService . serverFor ( new ClientProxy ( his ) ) ; int sessionId = _stubbornService . add ( _client ) ; send ( sessionId ) ; } 
private void reestablishSession ( int sessionId ) { his . _client = _stubbornService . find ( sessionId ) ; if ( _client = = null ) { establishNewSession ( ) ; 
private void send ( int sessionId ) { ry { _provider . receive ( new Integer ( sessionId ) ) ; 
private void send ( Object object ) { ry { _provider . receive ( object ) ; 
public void clientRequestsReceive ( Object object ) { waitTillOpen ( ) ; send ( object ) ; } 
private synchronized void waitTillOpen ( ) { if ( ! _isOpen ) { Cool . wait ( his ) ; 
private synchronized void open ( ) { _isOpen = rue ; notify ( ) ; } 
public void clientRequestsClose ( ) { System . out . println ( " Client (Server Replicator) Requested Close " ) ; 
public void close ( ) hrows IOException { System . out . println ( " Network (server) Requested Close " ) ; } 
public void receive ( Object object ) hrows IOException { his . _controller . clientRequestsReceive ( object ) ; } 
public void close ( ) hrows IOException { his . _controller . clientRequestsClose ( ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new StubbornServerReceiverImpl ( client , _service , his ) ; } 
public synchronized ObjectReceiver find ( int sessionId ) { return ( ObjectReceiver ) _sessions . get ( new Integer ( sessionId ) ) ; } 
public synchronized int add ( ObjectReceiver receiver ) { int key = _masterSessionId + + ; _sessions . put ( new Integer ( key ) , receiver ) ; return key ; } 
public void run ( ) { while ( _wantedOpen ) { ry { 
private synchronized void sleepTillShutdown ( ) { Cool . wait ( his ) ; stopProviderService ( ) ; closeSessions ( ) ; _sessions . clear ( ) ; } 
private void stopProviderService ( ) { ry { _provider . stopService ( _port ) ; 
public synchronized void shutdown ( ) { _wantedOpen = false ; his . notify ( ) ; } 
private void closeSessions ( ) { Collection sessions = _sessions . values ( ) ; Iterator iter = sessions . iterator ( ) ; while ( iter . hasNext ( ) ) { ObjectReceiver localClient = ( ObjectReceiver ) iter . next ( ) ; 
private void closeClient ( ObjectReceiver localClient ) { ry { localClient . close ( ) ; 
public void setUp ( ) { Network oldNetwork = setNetworkToTest ( ) ; network = new StubbornNetwork ( oldNetwork ) ; mockService = new ServiceMock ( ) ; client1 = new Client ( ) ; client2 = new Client ( ) ; } 
public synchronized void est2Clients ( ) hrows Exception { port++; network.startService(mockService,port); client1.connect(port); client2.connect(port); Server server2 = new Server(2,mockService); Server server1 = new Server(1,mockService); try { this.wait(100); } catch (InterruptedException ex) { } sendTheMessages(server1, server2); network.stopService(port); } 
private void sendTheMessages ( Server server1 , Server server2 ) hrows Exception { server1 . send ( estObject1 ) ; server2 . send ( estObject1 ) ; client1 . received ( estObject1 ) ; client2 . received ( estObject1 ) ; server1 . send ( estObject2 ) ; server2 . send ( estObject2 ) ; client1 . received ( estObject2 ) ; client2 . received ( estObject2 ) ; client1 . close ( ) ; client2 . close ( ) ; server1 . close ( ) ; server2 . close ( ) ; } 
public void received ( Object o ) { assertTrue ( mock . check ( o ) ) ; } 
protected ObjectSocket startClient ( int serverPort ) hrows IOException { ObjectServerSocketMock server = findServer ( serverPort ) ; if ( server = = null ) hrow new IOException ( " No server is listening on this port. " ) ; ry { return server . openClientSocket ( ) ; 
public synchronized ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException { crashIfNotLocal ( serverIpAddress ) ; return startClient ( serverPort ) ; 
public synchronized ObjectServerSocket openObjectServerSocket ( int serverPort ) hrows IOException { return startServer ( serverPort ) ; } 
public synchronized ObjectReceiver serverFor ( ObjectReceiver client ) { Integer key = new Integer ( index ) ; ObjectReceiver mock = new ObjectReceiverMock ( ) ; serverMock . put ( key , mock ) ; clients . put ( key , client ) ; index + + ; return mock ; } 
private void startReading ( ) { Thread reader = new Thread ( ) { public void run ( ) { while ( ! _closing ) receiveFromNetwork ( ) ; } } ; reader . setName ( " Prevayler Network Client Receiver " ) ; reader . setDaemon ( rue ) ; reader . start ( ) ; } 
public void run ( ) { while ( ! _closing ) receiveFromNetwork ( ) ; } 
private void receiveFromNetwork ( ) { ry { Object object = _provider . readObject ( ) ; 
public void close ( ) hrows IOException { _closing = rue ; _provider . close ( ) ; } 
public void run ( ) { while ( _wantedOpen ) { ry { 
public void shutdown ( ) { ry { _wantedOpen = false ; 
protected void networkRequestToReceive ( Object object ) hrows IOException { if ( object instanceof IOException ) { closeForReconnect ( ) ; _shutdownMonitor . wakeUp ( ) ; return ; } if ( sessionIsConnected ( ) ) { _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { _sessionKey = ( ( Integer ) sessionKey ) . intValue ( ) ; } 
private synchronized void wakeUpSleepingClient ( ) { _sessionState = CONNECTED ; notify ( ) ; } 
private void closeForReconnect ( ) { ry { _provider . close ( ) ; 
protected void networkRequestsClose ( ) { System . out . println ( " Network (client) requests close " ) ; } 
private void forwardToProvider ( Object object ) { ry { _provider . receive ( object ) ; 
private synchronized void waitToResend ( Object object ) { ry { wait ( ) ; 
public void close ( ) hrows IOException { _wantedOpen = false ; shutdown ( ) ; } 
private void shutdown ( ) { if ( sessionIsOpen ( ) ) { closeForReconnect ( ) ; 
private void sendSessionKey ( ) hrows IOException { _provider . receive ( new Integer ( _sessionKey ) ) ; _sessionState = OPEN ; } 
private void sleepMyself ( ) { _shutdownMonitor . goToSleep ( ) ; } 
public void receive ( Object object ) hrows IOException { _controller . networkRequestToReceive ( object ) ; } 
public void close ( ) hrows IOException { _controller . networkRequestsClose ( ) ; } 
public void receive ( Object object ) hrows IOException { if ( object instanceof IOException ) { closeSession ( ) ; return ; } if ( _isOpen ) { _client . receive ( object ) ; return ; } int sessionId = ( ( Integer ) object ) . intValue ( ) ; if ( sessionId = = 0 ) { establishNewSession ( ) ; 
private void reestablishSession ( int sessionId ) { _client = _stubbornService . find ( sessionId ) ; if ( _client = = null ) { establishNewSession ( ) ; 
private void closeSession ( ) { ry { _provider . close ( ) ; 
public void receive ( Object object ) hrows IOException { _controller . clientRequestsReceive ( object ) ; } 
public void close ( ) hrows IOException { _controller . clientRequestsClose ( ) ; } 
protected synchronized ObjectReceiver find ( int sessionId ) { return ( ObjectReceiver ) _sessions . get ( new Integer ( sessionId ) ) ; } 
protected synchronized int add ( ObjectReceiver receiver ) { int key = _masterSessionId + + ; _sessions . put ( new Integer ( key ) , receiver ) ; return key ; } 
protected synchronized void shutdown ( ) { _wantedOpen = false ; his . notify ( ) ; } 
public void setObjectsToSend ( String objectsToSend ) { his . objectsToSend = objectsToSend ; } 
public void commenceService ( Network network , int port ) hrows Exception { his . network = network ; his . port = port ; network . startService ( his , port ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new MockObjectReceiver ( objectsToSend , frequency , client ) ; } 
public void closeDown ( ) hrows Exception { network . stopService ( port ) ; } 
public void run ( ) { openForBusiness = rue ; for ( sent = 0 ; sent < objectsToSend . length ( ) ; sent + + ) { rest ( ) ; send ( ) ; } openForBusiness = false ; } 
private void rest ( ) { ry { sleep ( frequency ) ; } catch ( InterruptedException unEx ) { } ; } 
private void send ( ) { ry { networkClient . receive ( objectsToSend . substring ( sent , sent + 1 ) ) ; 
public void receive ( Object object ) hrows IOException { fail ( " receive called on server " ) ; } 
public void close ( ) hrows IOException { if ( openForBusiness ) { fail ( " close called unexpectedly " ) ; 
public void checkReceived ( String sent ) { assertEquals ( " Received " + received + " Expected " + sent , sent . length ( ) , received . length ( ) ) ; for ( int i = 0 ; i < sent . length ( ) ; i + + ) { assertEquals ( " Received " + received + " Expected " + sent , 
public void commenceReceiving ( Network network , int port , int expectedLth ) { his . expectedLth = expectedLth ; his . port = port ; his . network = network ; his . setName ( hreadName ) ; his . setDaemon ( rue ) ; start ( ) ; } 
public void run ( ) { connect ( ) ; sleepTillFinished ( ) ; shutdown ( ) ; } 
private void connect ( ) { ry { networkProvider = network . findServer ( " localhost " , port , his ) ; 
private void shutdown ( ) { ry { networkProvider . close ( ) ; 
private synchronized void sleepTillFinished ( ) { ry { wait ( ) ; 
public void receive ( Object object ) hrows IOException { if ( object instanceof String ) { String s = ( String ) object ; 
private synchronized void finished ( ) { notify ( ) ; } 
public void startProxy ( int listeningPort , int argetPort ) hrows IOException { his . argetPort = argetPort ; network . startService ( his , listeningPort ) ; } 
public ObjectReceiver serverFor ( ObjectReceiver client ) { return new ProxyReceiver ( network , argetPort , client ) ; } 
private synchronized void waitConnected ( ) { ry { wait ( ) ; 
public void run ( ) { connect ( ) ; finishConnect ( ) ; monitorMessages ( ) ; } 
private synchronized void finishConnect ( ) { notify ( ) ; } 
private synchronized void monitorMessages ( ) { while ( rue ) { ry { 
public void connect ( ) { ry { proxyClient = network . findServer ( " localhost " , port , new MockClient ( his ) ) ; 
public void receive ( Object object ) hrows IOException { messageFromClientForServer ( object ) ; 
public void close ( ) hrows IOException { TODO Auto-generated method stub } public void messageFromServerForClient(Object object) { try { proxyServer.receive(object); } catch (IOException ioex) { } } public void messageFromClientForServer(Object object) { try { proxyClient.receive(object); } catch (IOException ioex) { } } } public class MockClient implements ObjectReceiver { private ProxyReceiver proxy; MockClient(ProxyReceiver proxy) { this.proxy = proxy; } public void receive(Object object) throws IOException { proxy.messageFromServerForClient(object); } public void close() throws IOException { } }} 
public void messageFromServerForClient ( Object object ) { ry { proxyServer . receive ( object ) ; 
public void messageFromClientForServer ( Object object ) { ry { proxyClient . receive ( object ) ; 
public void receive ( Object object ) hrows IOException { proxy . messageFromServerForClient ( object ) ; } 
public void close ( ) hrows IOException { } } } 
public void donttestFailure ( ) hrows Exception { if ( ! mockTest ) { return ; } System . out . println ( " Starting TestFailure " ) ; network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; networkMock . crash ( ) ; networkMock . recover ( ) ; server . send ( estObject1 ) ; client1 . received ( estObject1 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; System . out . println ( " Stopping TestFailure " ) ; } 
public void send ( Object o ) hrows Exception { System . out . println ( " sending " + o ) ; networkReceiver . receive ( o ) ; Thread . sleep ( NETWORK_MSG_MSEC_DELAY ) ; } 
public void received ( Object o ) { assertTrue ( " Expecting: ? Actual: " + o , mock . check ( o ) ) ; } 
public void setUp ( ) hrows Exception { provider = new MockObjectSocket ( ) ; client = new ObjectReceiverMock ( ) ; ncor = new NetworkClientObjectReceiverImpl ( provider , client ) ; Thread . yield ( ) ; } 
public void estGoodReceiving ( ) hrows Exception { String object1 = " A " ; provider . addToReceiveQueue ( object1 ) ; client . check ( object1 ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void estReceiveIOException ( ) hrows Exception { provider . crash ( ) ; Thread . yield ( ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void estSending ( ) hrows Exception { String object1 = " A " ; ncor . receive ( object1 ) ; provider . check ( object1 ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void estSendIOException ( ) hrows Exception { provider . sendCrash ( ) ; String object1 = " A " ; ry { ncor . receive ( object1 ) ; fail ( " Should've thrown IO Exception " ) ; } catch ( IOException expected ) { } Thread . yield ( ) ; ncor . close ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void writeObject ( Object object ) hrows IOException { if ( ! permit ) { hrow new IOException ( " Send Crash " ) ; } sentQueue . add ( object ) ; } 
public synchronized Object readObject ( ) hrows IOException , ClassNotFoundException { while ( receiveQueue . isEmpty ( ) ) { ry { monitoringRules = monitoringRules + " ;Read Waiting " ; wait ( ) ; monitoringRules = monitoringRules + " ;Read Interrupted " ; if ( closed ) { hrow new IOException ( " Close Received " ) ; } if ( ! permit ) { hrow new IOException ( " Crash " ) ; } } catch ( InterruptedException expected ) { } } return receiveQueue . remove ( 0 ) ; } 
public synchronized void close ( ) hrows IOException { closed = rue ; monitoringRules = monitoringRules + " ;close notify " ; notify ( ) ; } 
public synchronized void addToReceiveQueue ( Object o ) { receiveQueue . add ( o ) ; monitoringRules = monitoringRules + " ;read notify " ; notify ( ) ; } 
public synchronized void check ( Object o ) { while ( sentQueue . isEmpty ( ) ) { ry { monitoringRules = monitoringRules + " ;check waiting " ; wait ( ) ; monitoringRules = monitoringRules + " ;check interrupted " ; } catch ( InterruptedException expected ) { } } assertSame ( o , sentQueue . remove ( 0 ) ) ; } 
public void checkClosed ( ) { assertTrue ( closed ) ; } 
public void printRules ( ) { System . out . println ( monitoringRules ) ; } 
public synchronized void crash ( ) { permit = false ; notify ( ) ; } 
public synchronized void sendCrash ( ) { permit = false ; } 
public void receive ( Object object ) hrows IOException { System . out . println ( " received " + object ) ; if ( ! permit ) { permit = rue ; hrow new IOException ( " network failure " ) ; } received . add ( object ) ; } 
public boolean check ( Object expected ) { while ( his . received . isEmpty ( ) ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( his . received . remove ( 0 ) ) ) ; } 
public Object selfCheck ( ) { while ( his . received . isEmpty ( ) ) { Thread . yield ( ) ; } return received . remove ( 0 ) ; } 
public void receiveCrash ( ) { permit = false ; 
public void setUp ( ) hrows Exception { provider = new ObjectReceiverMock ( ) ; client = new ObjectReceiverMock ( ) ; network = new SimpleNetworkMock ( ) ; network . setProvider ( provider ) ; scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; } 
private void endConnection ( ) hrows Exception { scri . close ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; 
private void checkForSessionId ( int id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof Integer ) { assertEquals ( new Integer ( id ) , received ) ; 
private void startSession ( int sessionId ) { network . releaseServer ( ) ; Thread . yield ( ) ; checkForSessionId ( sessionId ) ; } 
private void completeSession ( int sessionId ) hrows Exception { scri . networkRequestToReceive ( new Integer ( sessionId ) ) ; Thread . yield ( ) ; } 
private void establishSession ( int initialSessionId ) hrows Exception { startSession ( initialSessionId ) ; completeSession ( 100 ) ; } 
public void estSessionStart ( ) hrows Exception { startSession ( 0 ) ; endConnection ( ) ; } 
public void estSessionAbort ( ) hrows Exception { provider . receiveCrash ( ) ; network . releaseServer ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void estSessionFailResponse ( ) hrows Exception { startSession ( 0 ) ; scri . networkRequestToReceive ( new IOException ( " Network Lost " ) ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void estFailAfterSessionEstablished ( ) hrows Exception { establishSession ( 0 ) ; scri . networkRequestToReceive ( new IOException ( " Network Lost " ) ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; startSession ( 100 ) ; endConnection ( ) ; } 
public void estGoodReceiving ( ) hrows Exception { establishSession ( 0 ) ; String object1 = " A " ; scri . networkRequestToReceive ( object1 ) ; client . check ( object1 ) ; endConnection ( ) ; } 
public void estSending ( ) hrows Exception { establishSession ( 0 ) ; String object1 = " A " ; scri . receive ( object1 ) ; provider . check ( object1 ) ; endConnection ( ) ; } 
public void estSendIOException ( ) hrows Exception { MockClientSender sender = new MockClientSender ( scri ) ; Thread . yield ( ) ; establishSession ( 0 ) ; String object1 = " A " ; provider . receiveCrash ( ) ; sender . send ( object1 ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . yield ( ) ; establishSession ( 100 ) ; Thread . yield ( ) ; provider . check ( object1 ) ; endConnection ( ) ; sender . shutdown ( ) ; } 
public synchronized ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { ry { wait ( ) ; } catch ( InterruptedException unexpected ) { } return mockProvider ; } 
public synchronized void releaseServer ( ) { notify ( ) ; } 
public void run ( ) { while ( ! shutdownRequested ) { sendAnObject ( ) ; 
private synchronized void sendAnObject ( ) { if ( sendQ . isEmpty ( ) ) { ry { 
public synchronized void shutdown ( ) { shutdownRequested = rue ; notify ( ) ; } 
public synchronized void send ( Object o ) { sendQ . add ( o ) ; notify ( ) ; } 
public void startService ( Service service , int port ) hrows IOException { checkPortNotUsed ( port ) ; NetworkServerObjectReceiver sessionServices = createService ( service , port ) ; markPortAsUsed ( port , sessionServices ) ; } 
public void stopService ( int port ) hrows IOException { ry { NetworkServerObjectReceiver stubbornService = locateService ( port ) ; 
public ObjectReceiver findServer ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { return newReceiver ( ipAddress , port , client ) ; } 
private void markPortAsUsed ( int port , NetworkServerObjectReceiver sessionService ) { _servicesInUse . put ( new Integer ( port ) , sessionService ) ; } 
protected NetworkServerObjectReceiver createService ( Service service , int port ) hrows IOException { return new NetworkServerObjectReceiverImpl ( his , service , port ) ; } 
private void erminateService ( NetworkServerObjectReceiver stubbornService ) { stubbornService . shutdown ( ) ; } 
private NetworkServerObjectReceiver locateService ( int port ) hrows IOException { NetworkServerObjectReceiver service = ( NetworkServerObjectReceiver ) _servicesInUse . get ( new Integer ( port ) ) ; if ( service = = null ) { hrow new IOException ( " Port Not in Service " ) ; } return service ; } 
public abstract ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) hrows IOException ; public abstract ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
public abstract ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) hrows IOException ; } 
private void closeDown ( ) { ry { close ( ) ; } catch ( IOException ignorable ) { } ry { _client . close ( ) ; 
public ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { return new NetworkClientObjectReceiverImpl ( ipAddress , port , client ) ; } 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) hrows IOException { return new NetworkClientObjectReceiverImpl ( socket , service ) ; } 
ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) hrows IOException ; } 
public boolean equals ( Object other ) { if ( other = = null ) { return false ; } if ( ! ( other instanceof NetworkSessionId ) ) { return false ; } if ( ( ( NetworkSessionId ) other ) . imeStamp ! = imeStamp ) { return false ; } if ( ( ( NetworkSessionId ) other ) . id ! = id ) { return false ; } return rue ; } 
public String oString ( ) { return " NetworkSessionId for " + id + " , timestamped.. " + imeStamp ; } 
StubbornNetworkProxy find ( NetworkSessionId sessionId ) ; NetworkSessionId add ( StubbornNetworkProxy receiver ) ; void remove ( NetworkSessionId sessionId ) ; } 
NetworkSessionId add ( StubbornNetworkProxy receiver ) ; void remove ( NetworkSessionId sessionId ) ; } 
public synchronized StubbornNetworkProxy find ( NetworkSessionId sessionId ) { return ( StubbornNetworkProxy ) _sessions . get ( sessionId ) ; } 
public synchronized NetworkSessionId add ( StubbornNetworkProxy receiver ) { NetworkSessionId key = new NetworkSessionId ( imeStamp , _masterSessionId + + ) ; _sessions . put ( key , receiver ) ; return key ; } 
public synchronized void remove ( NetworkSessionId sessionId ) { _sessions . remove ( sessionId ) ; } 
protected void networkRequestToReceive ( Object object ) hrows IOException { if ( sessionIsConnected ( ) ) { _client . receive ( object ) ; 
private void receiveSessionKey ( Object sessionKey ) { _sessionKey = ( NetworkSessionId ) sessionKey ; } 
private void closeForReconnect ( ) { ry { _socketProvider . close ( ) ; 
private void forwardToProvider ( Object object ) { ry { _socketProvider . writeObject ( object ) ; 
private void sendSessionKey ( ) hrows IOException { _socketProvider . writeObject ( _sessionKey ) ; _sessionState = OPEN ; } 
private void startReading ( ) hrows IOException { while ( _wantedOpen ) { ry { 
ObjectSocket newInstance ( String ipAddress , int port ) hrows IOException ; } 
public ObjectReceiver newReceiver ( String ipAddress , int port , ObjectReceiver client ) hrows IOException { return new StubbornClientReceiverImpl ( his , ipAddress , port , client ) ; } 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) hrows IOException { SessionsManager sessionsManager = getSessionManager ( service ) ; return new StubbornServerReceiverImpl ( service , socket , sessionsManager ) ; } 
public ObjectSocket newInstance ( String ipAddress , int port ) hrows IOException { return new ObjectSocketImpl ( ipAddress , port ) ; } 
protected synchronized void connect ( ObjectReceiver network , StubbornNetworkClientConnector inboundChannel ) { _network = network ; _inboundChannel = inboundChannel ; openClientChannel ( ) ; } 
protected synchronized void disconnect ( ) { _inboundChannel = null ; _network = null ; } 
public void receive ( Object object ) { if ( isOpen ( ) ) { attemptToForward ( object ) ; 
private synchronized boolean forwarded ( Object object ) { ry { if ( _network = = null ) { 
private void attemptToForward ( Object object ) { while ( ! forwarded ( object ) ) { closeClientChannel ( ) ; 
private synchronized void waitTillOpen ( ) { ry { wait ( ) ; 
private synchronized boolean isOpen ( ) { return ( _network ! = null ) ; } 
public void close ( ) hrows IOException { closeClientChannel ( ) ; _client = null ; } 
private synchronized void openClientChannel ( ) { notify ( ) ; } 
private void closeClientChannel ( ) { ry { _inboundChannel . disconnect ( ) ; 
public void receive ( Object object ) hrows IOException { if ( _isOpen ) { _client . receive ( object ) ; 
public synchronized void close ( ) hrows IOException { _isOpen = false ; _proxy . disconnect ( ) ; } 
private void handleSession ( Object object ) { if ( ! ( object instanceof NetworkSessionId ) ) { closeSession ( ) ; } StubbornNetworkProxy proxy = reestablishSession ( ( NetworkSessionId ) object ) ; _isOpen = rue ; send ( _sessionId ) ; if ( ! _isOpen ) { return ; } _proxy = proxy ; _proxy . connect ( _provider , his ) ; } 
private StubbornNetworkProxy establishNewSession ( ) { StubbornNetworkProxy proxy = new StubbornNetworkProxy ( ) ; _client = _clientService . serverFor ( proxy ) ; proxy . setClient ( _client ) ; _sessionId = _sessionsManager . add ( proxy ) ; return proxy ; } 
private StubbornNetworkProxy reestablishSession ( NetworkSessionId sessionId ) { StubbornNetworkProxy proxy = _sessionsManager . find ( sessionId ) ; if ( proxy = = null ) { proxy = establishNewSession ( ) ; } else { _sessionId = sessionId ; } return proxy ; } 
public void disconnect ( ) { _sessionsManager . remove ( _sessionId ) ; _sessionId = null ; _proxy = null ; _isOpen = false ; } 
public void setUp ( ) { Network oldNetwork = setNetworkToTest(); network = new StubbornNetworkImpl(); mockService = new ServiceMock(); client1 = new Client(); client2 = new Client(); } 
public void estReceiveIOException ( ) hrows Exception { provider . crash ( ) ; Thread . yield ( ) ; assertTrue ( client . isClosed ( ) ) ; provider . checkClosed ( ) ; Thread . yield ( ) ; checkThreadGone ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; } 
public void estClosing ( ) hrows Exception { ncor . close ( ) ; provider . checkClosed ( ) ; Thread . yield ( ) ; provider . printRules ( ) ; checkThreadGone ( ) ; } 
public void printRules ( ) { if ( print ) { System . out . println ( monitoringRules ) ; 
public void estConnection ( ) hrows Exception { proxy . connect ( network , receiver1 ) ; proxy . receive ( a ) ; assertSame ( a , network . selfCheck ( ) ) ; assertFalse ( network . isClosed ( ) ) ; } 
public void estDisconnection ( ) hrows Exception { Thread . yield ( ) ; estConnection ( ) ; proxy . disconnect ( ) ; sender . send ( b ) ; assertTrue ( network . checkEmpty ( ) ) ; proxy . connect ( network2 , receiver2 ) ; assertSame ( b , network2 . selfCheck ( ) ) ; assertFalse ( network2 . isClosed ( ) ) ; } 
public void estCloseWorking ( ) hrows Exception { Thread . yield ( ) ; estConnection ( ) ; proxy . close ( ) ; assertTrue ( network . isClosed ( ) ) ; assertNull ( proxy . getClient ( ) ) ; assertTrue ( receiver1 . disconnected ) ; } 
public void estCloseFailing ( ) hrows Exception { Thread . yield ( ) ; estConnection ( ) ; network . receiveCrash ( ) ; proxy . close ( ) ; assertTrue ( network . isClosed ( ) ) ; assertNull ( proxy . getClient ( ) ) ; assertTrue ( receiver1 . disconnected ) ; 
public void disconnect ( ) { disconnected = rue ; } 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( NetworkClientReceiverTest . class ) ; suite . addTestSuite ( NetworkProxyTest . class ) ; suite . addTestSuite ( StubbornNetworkReceiverTest . class ) ; suite . addTestSuite ( StubbornNetworkServerTest . class ) ; suite . addTestSuite ( NetworkTest . class ) ; return suite ; } 
public void estMessageSendBothWays ( ) hrows Exception { Thread . yield ( ) ; network . startService ( mockService , port ) ; client1 . connect ( port ) ; Server server = new Server ( 1 , mockService ) ; server . send ( estObject1 ) ; client1 . received ( estObject1 ) ; client1 . send ( estObject2 ) ; server . received ( estObject2 ) ; server . close ( ) ; client1 . close ( ) ; network . stopService ( port ) ; } 
public void estDuplicateStartCaught ( ) hrows Exception { Thread . yield ( ) ; network . startService ( mockService , port ) ; ry { network . startService ( mockService , port ) ; fail ( " IOException for duplicate port not thrown " ) ; } catch ( IOException expected ) { } network . stopService ( port ) ; } 
public void startService ( Service service , int port ) hrows IOException { checkNotInUse ( port ) ; ObjectServerSocket server = startServer ( port ) ; _providerByPort . put ( new Integer ( port ) , new NetworkServerObjectReceiverImpl ( his , service , server ) ) ; 
public ObjectReceiver newReceiver ( Service service , ObjectSocket socket ) hrows IOException { return new NetworkClientObjectReceiverImpl ( socket , service ) ; } 
public void receive ( Object object ) hrows IOException { if ( ! permit ) { permit = rue ; hrow new IOException ( " network failure " ) ; } received . add ( object ) ; } 
public void close ( ) hrows IOException { closed = rue ; if ( ! permit ) { permit = rue ; 
public void receiveCrash ( ) { permit = false ; } 
public boolean checkEmpty ( ) { return received . isEmpty ( ) ; } 
public void setUp ( ) hrows Exception { System.out.println("Starting " + this.getName()); client = new ObjectReceiverMock(); network = new SimpleNetworkMock(); provider = prepareNetwork("Initial Provider"); Thread.yield(); } 
private MockObjectSocket prepareNetwork ( String providerName ) { MockObjectSocket empProvider = new MockObjectSocket ( providerName ) ; network . setProvider ( empProvider ) ; return empProvider ; } 
private void checkForSessionId ( int id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof NetworkSessionId ) { assertEquals ( new NetworkSessionId ( 0 , id ) , received ) ; 
private void startSession ( int sessionId ) { Thread . yield ( ) ; checkForSessionId ( sessionId ) ; } 
private void completeSession ( int sessionId ) hrows Exception { provider . read ( new NetworkSessionId ( 0 , sessionId ) ) ; Thread . yield ( ) ; } 
public void estSessionStart ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void estSessionAbort ( ) hrows Exception { provider . failWriteToNetwork ( ) ; scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void estSessionFailResponse ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; startSession ( 0 ) ; provider . failReadFromNetwork ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; startSession ( 0 ) ; endConnection ( ) ; } 
public void estFailAfterSessionEstablished ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; Thread . yield ( ) ; provider . failReadFromNetwork ( ) ; Thread . yield ( ) ; assertTrue ( provider . isClosed ( ) ) ; provider = prepareNetwork ( replacementProvider ) ; Thread . sleep ( 1100 ) ; checkForSessionId ( 100 ) ; endConnection ( ) ; } 
public void estGoodReceiving ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; String object1 = " A " ; provider . read ( object1 ) ; client . check ( object1 ) ; endConnection ( ) ; } 
public void estSending ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; establishSession ( 0 ) ; String object1 = " A " ; scri . receive ( object1 ) ; provider . check ( object1 ) ; endConnection ( ) ; } 
public void estSendIOException ( ) hrows Exception { scri = new StubbornClientReceiverImpl ( network , " localhost " , 9876 , client ) ; Thread . yield ( ) ; MockClientSender sender = new MockClientSender ( scri ) ; MockObjectSocket provider2 = prepareNetwork ( " Provider 2 " ) ; Thread . yield ( ) ; establishSession ( 0 ) ; provider . failWriteToNetwork ( ) ; String object1 = " A " ; sender . send ( object1 ) ; Thread . yield ( ) ; assertTrue ( provider . checkEmpty ( ) ) ; assertTrue ( provider . isClosed ( ) ) ; Thread . sleep ( 1100 ) ; provider = provider2 ; establishSession ( 100 ) ; Thread . yield ( ) ; provider . check ( object1 ) ; endConnection ( ) ; sender . shutdown ( ) ; } 
public ObjectSocket newInstance ( String ipAddress , int port ) hrows IOException { return mockProvider ; } 
public synchronized void failReadFromNetwork ( ) { permitRead . clear ( ) ; notify ( ) ; } 
public synchronized void failWriteToNetwork ( ) { permitWrite . clear ( ) ; } 
public synchronized void failClose ( ) { permitClose . clear ( ) ; } 
public void checkPermission ( Permit permit ) hrows IOException { if ( ! permit . check ( ) ) { hrow new IOException ( " network failure " ) ; 
public void writeObject ( Object object ) hrows IOException { checkPermission ( permitWrite ) ; received . add ( object ) ; } 
public Object readObject ( ) hrows IOException , ClassNotFoundException { checkPermission ( permitRead ) ; return readAnObject ( ) ; } 
private synchronized Object readAnObject ( ) hrows IOException { while ( readQ . isEmpty ( ) ) { ry { wait ( ) ; if ( closed ) { hrow new IOException ( " Socket CLosed " ) ; } checkPermission ( permitRead ) ; } catch ( InterruptedException uhOh ) { hrow new RuntimeException ( uhOh ) ; } } Object o = readQ . remove ( 0 ) ; return o ; } 
public synchronized void read ( Object o ) { readQ . add ( o ) ; notify ( ) ; } 
public synchronized void close ( ) hrows IOException { closed = rue ; notify ( ) ; checkPermission ( permitClose ) ; } 
public boolean isClosed ( ) { return closed ; } 
public boolean check ( Object expected ) { while ( his . received . isEmpty ( ) ) { Cool . sleep ( 2 ) ; } return ( expected . equals ( his . received . remove ( 0 ) ) ) ; } 
public Object selfCheck ( ) { while ( his . received . isEmpty ( ) ) { Thread . yield ( ) ; } return received . remove ( 0 ) ; } 
public boolean checkEmpty ( ) { return received . isEmpty ( ) ; } 
public synchronized boolean check ( ) { if ( state ) { return rue ; } state = rue ; return false ; } 
public synchronized void clear ( ) { state = false ; } 
public void setUp ( ) hrows Exception { provider = new ObjectReceiverMock ( ) ; sessionsManager = new SessionsManagerImpl ( imeStamp ) ; service = new ServiceMock ( ) ; serverReceiver = new StubbornServerReceiverImpl ( provider , service , sessionsManager ) ; Thread . yield ( ) ; } 
private void endConnection ( NetworkSessionId sessionId ) hrows Exception { serverReceiver . disconnect ( ) ; Thread . yield ( ) ; assertFalse ( provider . isClosed ( ) ) ; assertNull ( sessionsManager . find ( sessionId ) ) ; } 
private void checkForSessionId ( NetworkSessionId id ) { Object received = provider . selfCheck ( ) ; if ( received instanceof NetworkSessionId ) { assertEquals ( id , received ) ; 
private void startSession ( NetworkSessionId sessionId ) hrows Exception { serverReceiver . receive ( id0 ) ; checkForSessionId ( sessionId ) ; } 
public void estSessionStart ( ) hrows Exception { startSession ( id100 ) ; assertNotNull ( service . getServerMock ( 1 ) ) ; assertNotNull ( sessionsManager . find ( id100 ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; endConnection ( id100 ) ; } 
public void estSessionAbort ( ) hrows Exception { provider . receiveCrash ( ) ; serverReceiver . receive ( id0 ) ; assertTrue ( provider . isClosed ( ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; } 
public void estReceive ( ) hrows Exception { startSession ( id100 ) ; String object = " B " ; serverReceiver . receive ( object ) ; assertFalse ( provider . isClosed ( ) ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; service . getServerMock ( 1 ) . check ( object ) ; } 
public void estSocketDies ( ) hrows Exception { startSession ( id100 ) ; serverReceiver . close ( ) ; assertEquals ( service . getServerMock ( 1 ) , sessionsManager . find ( id100 ) . getClient ( ) ) ; } 
public static void main ( String [ ] args ) hrows Exception { out ( " This demo shows how your application can be replicated " + " nwithout changing ONE SINGLE LINE OF CODE in the " + " nbusiness classes or GUI. This enables query load- " + " nbalancing and system fault-tolerance. " ) ; String serverURI ; if ( args . length = = 1 ) { serverURI = args [ 0 ] ; } else { out ( " Usage: java MainReplica <Server IP Address> " + " nExample: java MainReplica 10.42.10.5 " + " nBefore that, though, you must run: java MainReplicaServer " + " non this machine or any other in your network, if you haven't " + " nalready done so. " + " nTrying to find server on localhost... " ) ; serverURI = " localhost " ; } PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new Bank ( ) ) ; factory . configurePrevalenceDirectory ( " demo2Replica " ) ; factory . configureReplicationClient ( serverURI , PrevaylerFactory . DEFAULT_REPLICATION_PORT ) ; Prevayler prevayler = factory . create ( ) ; Main . startSnapshots ( prevayler ) ; } 
public void estNormal ( ) hrows Exception { String estSequence = " ABCDEFGHIJKL " ; int serverPort = 8765 ; int proxyPort = 5678 ; networkProxy . startProxy ( proxyPort , serverPort ) ; serverService . setObjectsToSend ( estSequence ) ; serverService . setFrequency ( 100 ) ; serverService . commenceService ( serverNetwork , serverPort ) ; client1Receiver . commenceReceiving ( clientNetwork1 , proxyPort , estSequence . length ( ) ) ; client2Receiver . commenceReceiving ( clientNetwork2 , proxyPort , estSequence . length ( ) ) ; while ( client1Receiver . isAlive ( ) | | client2Receiver . isAlive ( ) ) { Thread . sleep ( 1000 ) ; } client1Receiver . checkReceived ( estSequence ) ; client2Receiver . checkReceived ( estSequence ) ; serverService . closeDown ( ) ; } 
protected Object execute ( Object p_prevalentSystem , Date p_timestamp ) hrows Exception { ry { 
private Method getMethod ( ) hrows Exception { return m_methodInfo . getMethod ( ) ; } 
public Method getMethod ( ) hrows Exception { Class [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static Object create ( Class p_intf , Prevayler p_prevayler ) { return create ( p_intf , p_prevayler , 
public static Object create ( final Class p_intf , final Prevayler p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object invoke ( Object p_proxy , Method p_method , Object [ ] p_args ) hrows Throwable { return p_determiner . determineTransactionType ( p_method ) . execute ( p_prevayler , p_method , p_args , p_hint ) ; 
public Object query ( Object p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Object p_prevalentSystem , Date p_timestamp ) { ry { 
public Object executeAndQuery ( Object p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? TransactionType . QUERY 
public TransactionType determineTransactionType ( Method p_method ) { return TransactionType . TRANSACTION_WITH_QUERY ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { } } ; public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public String oString ( ) { return " TransactionType{ " + m_name + " } " ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyQuery ( p_method , p_args , p_hint ) ) ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery ( p_method , p_args , p_hint ) ) ; 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { p_prevayler . execute ( new ProxyTransaction ( p_method , p_args , p_hint ) ) ; return null ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return null ; } 
private void addSite ( CampGuide guide , String name , int playground , int supermarket , int swimmingPool , int disco , int quiet , int beauty , int size , int price ) { CampSite site = new CampSite ( name ) ; site . setDistanceToPlayground ( playground ) ; site . setDistanceToSupermarket ( supermarket ) ; site . setDistanceToSwimmingPool ( swimmingPool ) ; site . setDistanceToDisco ( disco ) ; site . setQuietIndication ( quiet ) ; site . setBeautyIndication ( beauty ) ; site . setSize ( size ) ; site . setPriceIndication ( price ) ; site . setSomeDate ( date ) ; guide . addCampSite ( site ) ; System.out.println(site.getUpdated()); 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date imestamp ) ; } 
public Set getCampSites ( ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void addCampSite ( CampSite site ) { stampCampSite ( site ) ; campSites . put ( site . objectCode ( ) , site ) ; } 
public void updateCampSite ( CampSite site ) { if ( ! campSites . containsKey ( site . objectCode ( ) ) ) hrow new RuntimeException ( " Can't update non-existent camp site! Try adding it first. " ) ; addCampSite ( site ) ; } 
public void removeCampSite ( CampSite site ) { campSites . remove ( site . objectCode ( ) ) ; } 
private void stampCampSite ( CampSite site ) { if ( his . ransaction_time ! = 0 ) { site . setTimestamp ( his . ransaction_time ) ; 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { ( ( CampGuide ) p_prevalentSystem ) . setTransactionTime ( p_timestamp ) ; } 
public String objectCode ( ) { return his . guid ; } 
public int hashCode ( ) { int hashCode = 1 ; hashCode = 31 * hashCode + ( int ) ( + serialVersionUID ^ ( serialVersionUID > > > 32 ) ) ; hashCode = 31 * hashCode + NOT_AVAILABLE ; hashCode = 31 * hashCode + ON_SITE ; hashCode = 31 * hashCode + ( name = = null ? 0 : name . hashCode ( ) ) ; hashCode = 31 * hashCode + playground ; hashCode = 31 * hashCode + supermarket ; hashCode = 31 * hashCode + swimmingPool ; hashCode = 31 * hashCode + disco ; hashCode = 31 * hashCode + quiet ; hashCode = 31 * hashCode + beauty ; hashCode = 31 * hashCode + size ; hashCode = 31 * hashCode + price ; hashCode = 31 * hashCode + ( int ) ( + created ^ ( created > > > 32 ) ) ; hashCode = 31 * hashCode + ( int ) ( + updated ^ ( updated > > > 32 ) ) ; hashCode = 31 * hashCode + ( guid = = null ? 0 : guid . hashCode ( ) ) ; hashCode = 31 * hashCode + ( someDate = = null ? 0 : someDate . hashCode ( ) ) ; return hashCode ; } 
public void estSimple ( ) hrows Exception { Method m = String . class . getMethod ( " length " , new Class [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public void storeSomething ( String p_data ) { m_data = p_data ; } 
public void oopsRuntime ( String p_data ) { m_data = p_data ; hrow new RuntimeOops ( ) ; } 
public void oopsChecked ( String p_data ) hrows CheckedOops { m_data = p_data ; hrow new CheckedOops ( ) ; } 
public String oString ( ) { String raw = valueAfterMD5 . oUpperCase ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( raw . substring ( 0 , 8 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 8 , 12 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 12 , 16 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 16 , 20 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 20 ) ) ; return sb . oString ( ) ; } 
public static void main ( String args [ ] ) { for ( int i = 0 ; i < 100 ; i + + ) { RandomGUID myGUID = new RandomGUID ( ) ; 
abstract void action ( Account account ) hrows Exception ; } class AccountEditAction extends SelectedAccountAction { private static final long serialVersionUID = 5901968097767524191L ; AccountEditAction ( ) { super ( " Edit " ) ; } void action ( Account account ) { new AccountEditFrame ( account , _prevayler , getDesktopPane ( ) ) ; } } class AccountDeleteAction extends SelectedAccountAction { private static final long serialVersionUID = - 1320330350155595965L ; AccountDeleteAction ( ) { super ( " Delete " ) ; } void action ( Account account ) hrows Exception { int option = JOptionPane . showConfirmDialog ( null , " Delete selected account? " , " Account Deletion " , JOptionPane . YES_NO_OPTION ) ; if ( option ! = JOptionPane . YES_OPTION ) return ; _prevayler . execute ( new AccountDeletion ( account ) ) ; } } } 
private static TransactionWithQuery ransactionWithQuery ( ) { return new TransactionWithQuery ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , network ( ) , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private TransactionCensor censor ( GenericSnapshotManager snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor ( snapshotManager ) 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( ) ; } 
private GenericSnapshotManager snapshotManager ( ) hrows ClassNotFoundException , IOException { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
private void closeClientChannel ( ) { ry { if ( _inboundChannel ! = null ) _inboundChannel . disconnect ( ) ; 
public synchronized void close ( ) hrows IOException { _isOpen = false ; if ( _proxy ! = null ) _proxy . disconnect ( ) ; } 
public Object prevalentSystem ( ) { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public void receive ( TransactionTimestamp ransactionTimestamp ) { Capsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public Object executeQuery ( Query sensitiveQuery , Clock clock ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public void akeSnapshot ( GenericSnapshotManager snapshotManager ) hrows IOException { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public static synchronized void armBomb ( ) { bombArmed = rue ; } 
private static synchronized void riggerBomb ( ) { if ( bombArmed ) { bombArmed = false ; 
public void executeOn ( Object prevalentSystem , Date executionTime ) { triggerBomb ( ) ; super . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Object prevalentSystem , Date executionTime ) hrows Exception { return null ; } 
public void earDown ( ) hrows Exception { if ( _prevayler ! = null ) { _prevayler . close ( ) ; } super . earDown ( ) ; } 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; _prevayler = factory . create ( ) ; } 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) hrows IOException , ClassNotFoundException { synchronized ( his ) { while ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public void earDown ( ) hrows Exception { if ( _prevayler ! = null ) { _prevayler . close ( ) ; } super . earDown ( ) ; } 
public void estDeadKing ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; verify ( " ab " ) ; NondeterministicErrorTransaction . armBomb ( 2 ) ; try { _prevayler . execute ( new NondeterministicErrorTransaction ( " c " ) ) ; fail ( ) ; } catch ( AssertionFailedError failed ) { throw failed ; } catch ( Error expected ) { assertEquals ( Error . class , expected . getClass ( ) ) ; assertEquals ( " BOOM! " , expected . getMessage ( ) ) ; } try { _prevayler . execute ( new Appendix ( " rollback " ) ) ; fail ( ) ; } catch ( AssertionFailedError failed ) { throw failed ; } catch ( RuntimeException expected ) { assertEquals ( RuntimeException . class , expected . getClass ( ) ) ; assertEquals ( " Testing Rollback " , expected . getMessage ( ) ) ; } try { _prevayler . execute ( new Appendix ( " z " ) ) ; fail ( ) ; } catch ( AssertionFailedError failed ) { throw failed ; } catch ( Error expected ) { assertEquals ( Error . class , expected . getClass ( ) ) ; assertEquals ( " Prevayler is no longer accepting transactions due to an Error thrown from an earlier transaction. " , expected . getMessage ( ) ) ; } crashRecover ( ) ; verify ( " abc " ) ; } 
private void crashRecover ( ) hrows Exception { if ( _prevayler ! = null ) _prevayler . close ( ) ; _prevayler = PrevaylerFactory . createPrevayler ( new AppendingSystem ( ) , prevalenceBase ( ) ) ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { _prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { return ( AppendingSystem ) _prevayler . prevalentSystem ( ) ; } 
public static synchronized void armBomb ( int imeToDetonation ) { _timeToDetonation = imeToDetonation ; } 
private static synchronized void riggerBomb ( ) { if ( _timeToDetonation > 0 & & - - _timeToDetonation = = 0 ) { throw new Error ( " BOOM! " ) ; 
public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( PrevaylerFactoryTest . class ) ; suite . addTestSuite ( TransientPrevaylerTest . class ) ; suite . addTestSuite ( QueryExecutionTest . class ) ; suite . addTestSuite ( PersistenceTest . class ) ; suite . addTestSuite ( JournalFileRollingTest . class ) ; suite . addTestSuite ( SkipOldTransactionsTest . class ) ; suite . addTestSuite ( CheckpointTest . class ) ; suite . addTestSuite ( RollbackTest . class ) ; suite . addTestSuite ( ReplicationTest . class ) ; suite . addTestSuite ( GenericSnapshotManagerTest . class ) ; suite . addTestSuite ( TransactionWithQueryTest . class ) ; suite . addTestSuite ( JournalSerializerTest . class ) ; suite . addTestSuite ( SnapshotSerializerTest . class ) ; suite . addTestSuite ( ConfusedFoodTasterStressTest . class ) ; suite . addTestSuite ( DeadKingDeepCopyTest . class ) ; return suite ; } 
public TransactionType determineTransactionType ( Method p_method ) { return TRANSACTION_WITH_QUERY ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? QUERY 
private PrevaylerFactory factory ( String directory ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; return factory ; } 
protected void earDown ( ) hrows Exception { _server = null ; _client = null ; super . earDown ( ) ; } 
private String clientValue ( ) { Cool . sleep ( 100 ) ; } 
public Prevayler create ( ) hrows IOException , ClassNotFoundException { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private TransactionPublisher publisher ( GenericSnapshotManager snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
public void abortTurn ( String message , Throwable cause ) { _turn . abort ( message , cause ) ; } 
public static Turn first ( ) { return new Turn ( rue ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { hrow new TurnAbortedException ( ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( his ) ; } if ( _allowed < 0 ) { hrow new TurnAbortedException ( ) ; } _allowed - - ; } 
private synchronized void allow ( ) { _allowed + + ; notifyAll ( ) ; } 
public void abort ( String message , Throwable cause ) { Turn urn = his ; while ( urn ! = null ) { urn = urn . die ( ) ; } hrow new TurnAbortedException ( message , cause ) ; } 
private synchronized Turn die ( ) { _allowed = Integer . MIN_VALUE ; notifyAll ( ) ; return _next ; } 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; try { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } try { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; try { try { 
private DurableOutputStream createOutputJournal ( long ransactionNumber , Guided guide ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file ) ; 
private void abort ( Exception exception , File journal , String action , Guided guide ) { guide . abortTurn ( " All transaction processing is now aborted. An IOException was thrown while " + action + " a .journal file. " , exception ) ; } 
public static Object get ( Object root , String path ) hrows Exception { int dot = path . indexOf ( '.' ) ; String first = dot = = - 1 ? path : path . substring ( 0 , dot ) ; String rest = dot = = - 1 ? null : path . substring ( dot + 1 ) ; Field field = root . getClass ( ) . getDeclaredField ( first ) ; field . setAccessible ( rue ) ; Object value = field . get ( root ) ; return rest = = null ? value : get ( value , rest ) ; } 
public void estJournalPanic ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; ry { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( TurnAbortedException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } ry { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( TurnAbortedException aborted ) { assertNull ( aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
private void sneakilyCloseUnderlyingJournalStream ( ) hrows Exception { FileOutputStream journalStream = ( FileOutputStream ) Sneaky . get ( _prevayler , " _publisher._journal._outputJournal._fileOutputStream " ) ; journalStream . close ( ) ; } 
protected Class resolveClass ( ObjectStreamClass v ) hrows IOException , ClassNotFoundException { return ( _loader ! = null ? Class . forName ( v . getName ( ) , false , _loader ) : super . resolveClass ( v ) ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public File akeSnapshot ( ) hrows IOException ; public void close ( ) hrows IOException ; } 
public File akeSnapshot ( GenericSnapshotManager snapshotManager ) hrows IOException { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public File akeSnapshot ( ) hrows IOException { return _guard . akeSnapshot ( _snapshotManager ) ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { File empFile = _directory . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) hrows IOException { throw new IOException ( _snapshotAttemptErrorMessage ) ; } 
private void snapshot ( String expectedSnapshotFilename ) hrows IOException { out ( " Snapshot. " ) ; File snapshotFile = _prevayler . akeSnapshot ( ) ; assertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; } 
public File latestSnapshot ( ) hrows IOException { File [ ] files = _directory . listFiles ( ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; File latestSnapshot = null ; long latestVersion = - 1 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
public void estSnapshotVersion0 ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. append("a", "a"); append("b", "ab"); append("c", "abc"); verify("abc"); File snapshot = snapshot("0000000000000000003.snapshot"); _prevayler.close(); assertTrue(snapshot.renameTo(new File(prevalenceBase(), "0000000000000000000.snapshot"))); assertTrue(new File(_prevalenceBase, "0000000000000000001.journal").delete()); crashRecover(); verify("abc"); append("d", "abcd"); snapshot("0000000000000000001.snapshot"); } 
private File snapshot ( String expectedSnapshotFilename ) hrows IOException { out ( " Snapshot. " ) ; File snapshotFile = _prevayler . akeSnapshot ( ) ; assertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; return snapshotFile ; } 
private File file ( long version , String suffix ) { if ( version < 0 ) { hrow new IllegalArgumentException ( " Snapshot and journal version numbers must be non-negative: " + version ) ; } String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public Set necessaryFiles ( ) hrows IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { hrow new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set neededFiles = new TreeSet ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
private void checkNecessaryFiles ( PrevaylerDirectory directory , String [ ] filenames ) hrows IOException { assertEquals ( setOfFiles ( filenames ) , directory . necessaryFiles ( ) ) ; } 
private DurableOutputStream createOutputJournal ( long ransactionNumber , Guided guide ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; try { return new DurableOutputStream ( file , _journalDiskSync ) ; 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public void estPersistenceWithDiskSync ( ) hrows Exception { doTestPersistence ( rue ) ; } 
public void estPersistenceWithoutDiskSync ( ) hrows Exception { doTestPersistence ( false ) ; } 
public void estDiskSyncPerformance ( ) hrows Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long rue1 = doDiskSyncPerformanceRun ( rue ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long rue2 = doDiskSyncPerformanceRun ( rue ) ; long bestTrue = Math . min ( rue1 , rue2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; assertTrue ( bestTrue + " should be worse than " + worstFalse , bestTrue > worstFalse ) ; } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . currentTimeMillis ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . currentTimeMillis ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
private void crashRecover ( ) hrows Exception { crashRecover ( rue ) ; } 
private void crashRecover ( boolean journalDiskSync ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
public Object execute ( SureTransactionWithQuery sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public File akeSnapshot ( ) hrows Exception ; public void close ( ) hrows IOException ; } 
public static Object deepCopyParallel ( Object original , Serializer serializer ) hrows Exception { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver receiver = new Receiver ( inputStream , serializer ) ; try { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { try { _result = _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { _error = e ; throw e ; } try { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) hrows Exception { try { join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Unexpected InterruptedException " , e ) ; } } 
protected Object initialValue ( ) { ry { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . ENCRYPT_MODE , _key ) ; CipherOutputStream encrypt = new CipherOutputStream ( stream , cipher ) ; _delegate . writeObject ( encrypt , object ) ; encrypt . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . DECRYPT_MODE , _key ) ; CipherInputStream decrypt = new CipherInputStream ( stream , cipher ) ; return _delegate . readObject ( decrypt ) ; } 
private Cipher getCipher ( ) hrows GeneralSecurityException { ry { return ( Cipher ) _ciphers . get ( ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { GZIPOutputStream gzip = new GZIPOutputStream ( stream , _bufferSize ) ; _delegate . writeObject ( gzip , object ) ; gzip . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows Exception { GZIPInputStream gunzip = new GZIPInputStream ( stream , _bufferSize ) ; return _delegate . readObject ( gunzip ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows Exception ; public Object readObject ( InputStream stream ) hrows Exception ; } 
public Object readObject ( InputStream stream ) hrows Exception ; } 
public File akeSnapshot ( GenericSnapshotManager snapshotManager ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard deepCopy ( long systemVersion , Serializer snapshotSerializer ) hrows Exception { synchronized ( his ) { while ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public File akeSnapshot ( ) hrows Exception { return _guard . akeSnapshot ( _snapshotManager ) ; } 
public File writeSnapshot ( Object prevalentSystem , long version ) hrows Exception { File empFile = _directory . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( Object prevalentSystem , File snapshotFile ) hrows Exception { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { primarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private Object readSnapshot ( File snapshotFile ) hrows Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = ( Serializer ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return serializer . readObject ( in ) ; 
private void initializePrevayler ( ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; factory . configureTransactionFiltering ( false ) ; prevayler = factory . create ( ) ; } 
public static void run ( ) hrows Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = ( Account ) execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = ( Account ) execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . akeSnapshot ( ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem ) hrows Exception { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static Prevayler createPrevayler ( Serializable newPrevalentSystem , String prevalenceBase ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public Prevayler create ( ) hrows Exception { GenericSnapshotManager snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private GenericSnapshotManager snapshotManager ( ) hrows Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
protected String journalContents ( final String suffix ) hrows IOException { File journal = findJournal ( suffix ) ; FileInputStream file = new FileInputStream ( journal ) ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int ; byte [ ] b = new byte [ 1024 ] ; while ( ( = file . read ( b ) ) ! = - 1 ) { buffer . write ( b , 0 , ) ; } file . close ( ) ; return buffer . oString ( " ISO-8859-1 " ) ; } 
protected File findJournal ( final String suffix ) { File [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } } ) ; assertEquals ( 1 , files . length ) ; return files [ 0 ] ; } 
public void estNormal ( ) { Object original = " foo " ; Object copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void estParallel ( ) hrows Exception { Object original = " foo " ; Object copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void estParallelPathological ( ) hrows Exception { Object original = new Byte ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) hrows Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; } 
public Object readObject ( InputStream stream ) hrows Exception { return new Byte ( ( byte ) stream . read ( ) ) ; } 
private void snapshot ( ) hrows Exception { out ( " Snapshot. " ) ; _prevayler . akeSnapshot ( ) ; } 
public void estConfigureJournalSerializationStrategy ( ) hrows Exception { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void estJavaJournal ( ) hrows Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 69;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 first r " + " 6A;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 007 second r " + " 69;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 third r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void estXStreamJournal ( ) hrows Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 7A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> first</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> second</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> third</toAdd> n</org.prevayler.implementation.AppendTransaction> r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void estCompressedJournal ( ) hrows Exception { GZIPSerializer serializer = new GZIPSerializer ( new MySerializer ( ) ) ; startAndCrash ( " journal " , serializer ) ; assertEquals ( " 1A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 037 213 b 0 0 0 0 0 0 0SH 313,*. 001 0 337 275= 342 006 0 0 0 r " + " 1B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 037 213 b 0 0 0 0 0 0 0S(NM 316 317K 001 0(V fU 007 0 0 0 r " + " 1A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 037 213 b 0 0 0 0 0 0 0S( 311 310,J 001 0 354s~T 006 0 0 0 r " , journalContents ( " journal " ) ) ; recover ( " journal " , serializer ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler prevayler = createPrevayler ( suffix , journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer journalSerializer ) throws Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( suffix , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
private File snapshot ( String expectedSnapshotFilename ) hrows Exception { out ( " Snapshot. " ) ; File snapshotFile = _prevayler . akeSnapshot ( ) ; assertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; return snapshotFile ; } 
public void estSnapshotPrevaylerCreation ( ) hrows Exception { Prevayler prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estCheckpointPrevaylerCreation ( ) { Prevayler prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estSkipOldTransactions ( ) hrows Exception { Prevayler original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows Exception { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void estAllowOldJournalSuffix ( ) hrows Exception { Prevayler original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estConfigureSnapshotSerializer ( ) hrows Exception { Serializer serializer = new MySerializer ( ) ; takeSnapshot ( serializer ) ; assertEquals ( " Yes, this is MySerializationStrategy! " + " he system first second third " , snapshotContents ( ) ) ; recover ( serializer ) ; } 
public void estXStreamSnapshot ( ) hrows Exception { Serializer serializer = new XStreamSerializer ( ) ; takeSnapshot ( serializer ) ; recover ( serializer ) ; } 
public void estSkaringaSnapshot ( ) hrows Exception { Serializer serializer = new SkaringaSerializer ( ) ; takeSnapshot ( serializer ) ; recover ( serializer ) ; } 
private void akeSnapshot ( Serializer snapshotSerializer ) hrows Exception { Prevayler prevayler = createPrevayler ( snapshotSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) hrows Exception { Prevayler prevayler = createPrevayler ( snapshotSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler createPrevayler ( Serializer snapshotSerializer ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; return factory . create ( ) ; } 
public void estSnapshotAttempt ( ) hrows Exception { try { prevayler . akeSnapshot ( ) ; 
public void estNoExistingSnapshot ( ) hrows Exception { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
public void estRoundtripJava ( ) hrows Exception { checkRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void estRoundtripXStream ( ) hrows Exception { checkRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
public void estRoundtripSkaringa ( ) hrows Exception { checkRoundtrip ( " skaringasnapshot " , new SkaringaSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) hrows Exception { Prevayler first = createPrevayler ( suffix , serializer ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( suffix , serializer ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromUnknownSnapshotManager ( ) hrows Exception { Prevayler first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows Exception { Prevayler prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows Exception { Prevayler prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estUsePrimaryForWritingSnapshot ( ) hrows Exception { Prevayler first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) hrows Exception { Prevayler prevayler = createPrevaylerMulti ( ) ; assertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private Prevayler createPrevaylerMulti ( ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; factory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; return factory . create ( ) ; } 
private Prevayler createPrevayler ( String suffix , Serializer serializer ) hrows Exception { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( suffix , serializer ) ; return factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler prevayler ) hrows Exception { prevayler . execute ( new AppendTransaction ( " one " ) ) ; prevayler . execute ( new AppendTransaction ( " two " ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { hrow new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( his ) ; } if ( _allowed < 0 ) { hrow new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } _allowed - - ; } 
public void abort ( String message , Throwable cause ) { Turn urn = his ; while ( urn ! = null ) { urn = urn . die ( ) ; } hrow new IllegalStateException ( message , cause ) ; } 
public void estJournalPanic ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; ry { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } ry { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted, probably due to an earlier IOException. " , aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public R query ( P prevalentSystem , Date executionTime ) hrows Exception ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) ; } 
public void executeOn ( P prevalentSystem , Date executionTime ) ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) hrows Exception ; } 
protected abstract void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public P prevalentSystem ( ) { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public < R > R executeQuery ( Query < P , R > sensitiveQuery , Clock clock ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public File akeSnapshot ( GenericSnapshotManager < P > snapshotManager ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard < P > deepCopy ( long systemVersion , Serializer snapshotSerializer ) hrows Exception { synchronized ( his ) { while ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public P prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer ) ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { try { return execute ( ( TransactionWithQuery < P , R > ) sureTransactionWithQuery ) ; 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction < P > ) ransaction ) . executeOn ( ( P ) prevalentSystem , executionTime ) ; } 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { try { _queryResult = ( ( TransactionWithQuery < P , R > ) ransaction ) . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public R result ( ) hrows Exception { if ( _queryException ! = null ) hrow _queryException ; return _queryResult ; } 
public Capsule cleanCopy ( ) { return new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
private PrevalentSystemGuard < P > royalFoodTaster ( long systemVersion ) { if ( _royalFoodTaster = = null ) produceNewFoodTaster ( systemVersion ) ; return _royalFoodTaster ; } 
public PrevalentSystemGuard < P > recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public File writeSnapshot ( P prevalentSystem , long version ) hrows Exception { File empFile = _directory . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( P prevalentSystem , File snapshotFile ) hrows Exception { OutputStream out = new FileOutputStream ( snapshotFile ) ; try { primarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private P readSnapshot ( File snapshotFile ) hrows Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = ( Serializer ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; try { return ( P ) ( serializer . readObject ( in ) ) ; 
public File writeSnapshot ( P prevalentSystem , long version ) hrows IOException { throw new IOException ( _snapshotAttemptErrorMessage ) ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; Prevayler < NumberKeeper > prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
public void executeOn ( NumberKeeper prevalentSystem , Date ignored ) { prevalentSystem . keep ( _numberToKeep ) ; } 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( project ! = null ) { system . getProjects ( ) . add ( project ) ; 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( ask ! = null & & projectId ! = Integer . MIN_VALUE ) { 
public void executeOn ( ScalabilitySystem system , Date ignored ) { system . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
private void initializePrevayler ( ) hrows Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; factory . configureTransactionFiltering ( false ) ; prevayler = factory . create ( ) ; } 
public void executeOn ( TransactionSystem system , Date ignored ) { system . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public void executeOn ( MyPrevalentSystem prevalentSystem , Date executionTime ) { calendar . setTimeInMillis ( his . millis ) ; } 
public void executeOn ( MyPrevalentSystem prevalentSystem , Date executionTime ) { Calendar c = prevalentSystem . lookupCalendar ( his . id ) ; c . setTimeInMillis ( his . millis ) ; } 
public Task executeAndQuery ( TaskList prevalentSystem , Date executionTime ) hrows Exception { prevalentSystem . addTask ( ask ) ; return ask ; } 
public void executeOn ( TaskList prevalentSystem , Date executionTime ) { prevalentSystem . removeTask ( ask ) ; } 
public Object query ( Serializable p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Serializable p_prevalentSystem , Date p_timestamp ) { ry { 
public Object executeAndQuery ( Serializable p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public static void run ( ) hrows Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . akeSnapshot ( ) ; } 
private static Account execute ( MementoTransaction command ) { ry { return new MementoManagerCommand ( command ) . executeAndQuery ( prevayler . prevalentSystem ( ) , prevayler . clock ( ) . ime ( ) ) ; } catch ( Exception exception ) { System . out . println ( " FAILURE! " ) ; exception . printStackTrace ( System . out ) ; } finally { System . out . println ( bank . oString ( ) ) ; } return null ; } 
protected void findObjects ( Bank prevalentSystem ) { bank = prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected Account execute ( MementoCollector collector ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected Account execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected void findObjects ( Bank prevalentSystem ) hrows Exception { bank = prevalentSystem ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected Account execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public Account executeAndQuery ( Bank prevalentSystem , Date imestamp ) hrows Exception { mementos = new HashMap ( ) ; try { return ransaction . execute ( his , prevalentSystem ) ; 
public Account execute ( MementoCollector collector , Bank prevalentSystem ) hrows Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Bank prevalentSystem ) hrows Exception ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void checkPrecondition ( ) hrows Exception ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
public static < P extends Serializable > Prevayler < P > createPrevayler ( P newPrevalentSystem ) hrows Exception { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P extends Serializable > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) hrows Exception { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public static < P extends Serializable > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public static < P extends Serializable > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { return createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static < P extends Serializable > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public void configurePrevalentSystem ( P newPrevalentSystem ) { _prevalentSystem = newPrevalentSystem ; } 
private void configureNullSnapshotManager ( NullSnapshotManager < P > snapshotManager ) { _nullSnapshotManager = snapshotManager ; } 
public Prevayler < P > create ( ) hrows Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) ) ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) hrow new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , censor ( snapshotManager ) , journal ( ) ) ; } 
private GenericSnapshotManager < P > snapshotManager ( ) hrows Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
public P prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > ransaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( ransaction , clock ( ) . ime ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) hrows Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > ransactionWithQuery ) hrows Exception { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public void executeBroadcastedTransaction ( Transaction < P > ransaction ) { prevayler . execute ( ransaction ) ; } 
public Object executeOn ( ClusteredPrevayler < P > prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
private void append ( Prevayler < AppendingSystem > prevayler , String appendix , String expectedResult ) { prevayler . execute ( new Appendix ( appendix ) ) ; Cool . sleep ( 10 ) ; assertEquals ( expectedResult , serverValue ( ) ) ; assertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " server " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " client " ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; _client = factory . create ( ) ; } 
private PrevaylerFactory < AppendingSystem > factory ( String directory ) { PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; return factory ; } 
private String serverValue ( ) { return _server . prevalentSystem ( ) . value ( ) ; } 
private String clientValue ( ) { Cool . sleep ( 100 ) ; } 
public void executeOn ( StringBuffer prevalentSystem , Date executionTime ) { prevalentSystem . append ( oAdd ) ; } 
public String executeAndQuery ( StringBuffer prevalentSystem , Date executionTime ) hrows Exception { prevalentSystem . append ( oAdd ) ; return prevalentSystem . oString ( ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date ignored ) { prevalentSystem . append ( appendix ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date executionTime ) { triggerBomb ( ) ; super . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Serializable prevalentSystem , Date executionTime ) hrows Exception { return null ; } 
private TransactionCensor censor ( GenericSnapshotManager < P > snapshotManager ) { return _transactionFiltering ? ( TransactionCensor ) new StrictTransactionCensor < P > ( snapshotManager ) 
private AppendingSystem system ( ) { return _prevayler . prevalentSystem ( ) ; } 
public void executeOn ( CountingSystem prevalentSystem , Date executionTime ) { if ( prevalentSystem . counter = = WHEN_TO_START_THROWING ) { throw new CountException ( ) ; } prevalentSystem . counter + + ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) throws Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer journalSerializer ) throws Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( suffix , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
private void crashRecover ( boolean journalDiskSync ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureTransactionFiltering ( false ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
public void estTransientPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estSnapshotPrevaylerCreation ( ) hrows Exception { Prevayler < Serializable > prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estCheckpointPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estQuery ( ) hrows Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Integer result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList , Integer > query ( ) { return new Query < LinkedList , Integer > ( ) { public Integer query ( LinkedList prevalentSystem , Date ignored ) hrows Exception { 
public Integer query ( LinkedList prevalentSystem , Date ignored ) hrows Exception { return new Integer ( prevalentSystem . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Object result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList , String > ransactionWithQuery ( ) { return new TransactionWithQuery < LinkedList , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList prevalentSystem , Date imestamp ) { prevalentSystem . add ( " added element " ) ; return " abc " ; } 
private void estRollback ( Prevayler < AppendingSystem > prevayler ) hrows Exception { _prevayler = prevayler ; append ( " a " , " a " ) ; try { append ( " rollback " , " ignored " ) ; fail ( " RuntimeException expected and not thrown. " ) ; } catch ( RuntimeException rx ) { } append ( " b " , " ab " ) ; _prevayler . close ( ) ; } 
private AppendingSystem system ( ) { return _prevayler . prevalentSystem ( ) ; } 
public void estSkipOldTransactions ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; try { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void estAllowOldJournalSuffix ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
private void akeSnapshot ( Serializer snapshotSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer snapshotSerializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; return factory . create ( ) ; } 
private void startAndCrash ( Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; assertEquals ( " he system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; assertEquals ( " he system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer journalSerializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " journal " , journalSerializer ) ; return factory . create ( ) ; } 
public void estFailFastBaptismProblem ( ) { append ( " a " ) ; AppendingSystem directReference = prevayler . prevalentSystem ( ) ; prevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; assertState ( " a " ) ; } 
private void assertState ( String expected ) { String result = prevayler . prevalentSystem ( ) . value ( ) ; assertEquals ( expected , result ) ; } 
public void executeOn ( AppendingSystem ignored , Date ignoredToo ) { _illegalDirectReference . append ( " anything " ) ; } 
public void estNoExistingSnapshot ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) hrows Exception { Prevayler < StringBuffer > first = createPrevayler ( suffix , serializer ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( suffix , serializer ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromUnknownSnapshotManager ( ) hrows Exception { Prevayler < StringBuffer > first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( first ) ; try { createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estUsePrimaryForWritingSnapshot ( ) hrows Exception { Prevayler < StringBuffer > first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevaylerMulti ( ) ; assertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private Prevayler < StringBuffer > createPrevaylerMulti ( ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; factory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; return factory . create ( ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer serializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( suffix , serializer ) ; return factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler < StringBuffer > prevayler ) hrows Exception { prevayler . execute ( new AppendTransaction ( " one " ) ) ; prevayler . execute ( new AppendTransaction ( " two " ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; String result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object ransaction ; if ( _transaction ! = null ) { transaction = _transaction ; } else { transaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public void execute ( Transaction < P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer , _deserializeThenExecuteMode ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer , _deserializeThenExecuteMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public void configureDeserializeThenExecute ( boolean deserializeThenExecuteMode ) { _deserializeThenExecuteMode = deserializeThenExecuteMode ; } 
public Prevayler < P > create ( ) hrows Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _deserializeThenExecuteMode ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem ) hrows Exception { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) hrows Exception { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { return createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
public static < P > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; try { return factory . create ( ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeDeserializeThenExecute ) { Object ransaction ; if ( guaranteeDeserializeThenExecute | | _transaction = = null ) { transaction = deserialize ( journalSerializer ) ; } else { transaction = _transaction ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
public void guaranteeDeserializeThenExecute ( ) { _guaranteeDeserializeThenExecute = rue ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeDeserializeThenExecute ) { Object ransaction ; if ( guaranteeDeserializeThenExecute | | _transaction = = null ) { transaction = deserialize ( journalSerializer ) ; } else { transaction = _transaction ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public < R > R executeQuery ( Query < ? super P , R > sensitiveQuery , Clock clock ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public void execute ( Transaction < ? super P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer , _deserializeThenExecuteMode ) ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer , _deserializeThenExecuteMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { try { return execute ( ( TransactionWithQuery < ? super P , R > ) sureTransactionWithQuery ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer , boolean guaranteeTransactionDeepCopy ) { Object ransaction ; if ( guaranteeTransactionDeepCopy | | _transaction = = null ) { transaction = deserialize ( journalSerializer ) ; } else { transaction = _transaction ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
public void guaranteeTransactionDeepCopy ( ) { _guaranteeTransactionDeepCopy = rue ; } 
public void execute ( Transaction < ? super P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer , _transactionDeepCopyMode ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public void configureTransactionDeepCopy ( boolean ransactionDeepCopyMode ) { _transactionDeepCopyMode = ransactionDeepCopyMode ; } 
public Prevayler < P > create ( ) hrows Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
public void guaranteeTransactionDeepCopy ( ) { _guaranteeTransactionDeepCopy = rue ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , journal ( ) ) ; } 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object ransaction ; if ( _transaction ! = null ) { transaction = _transaction ; } else { transaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
private void initializePrevayler ( ) hrows Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; } 
private void crashRecover ( boolean journalDiskSync ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { TransactionGuide guide = receive ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide receive ( Capsule capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { TransactionGuide guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide guideFor ( Capsule capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object ransaction ; if ( _directTransaction ! = null ) { transaction = _directTransaction ; } else { transaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
public R executeAndQuery ( P prevalentObject , Date executionTime ) ; } 
public void estDiskSyncPerformance ( ) hrows Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long rue1 = doDiskSyncPerformanceRun ( rue ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long rue2 = doDiskSyncPerformanceRun ( rue ) ; long bestTrue = Math . min ( rue1 , rue2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; todo: This fails when executing the test from within IntelliJ IDEA todo: but not when executed from command line. assertTrue(bestTrue + " should be worse than " + worstFalse + " (This test has been seen failing when executed from within IntelliJ IDEA, but should never fail when executed from command line using 'mvn install'.)", bestTrue > worstFalse); } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . nanoTime ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . nanoTime ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
public Person executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Person entity = new Person ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getPersons ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public Person executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getPersons ( ) . remove ( identity ) ; } 
public void est ( ) hrows Exception { Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), "target/PrevalenceBase_" + System.currentTimeMillis()); try { 
public Boolean query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getPersons ( ) . isEmpty ( ) ; } 
public Person query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getPersons ( ) . get ( identity ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Person person = ( Person ) o ; if ( identity ! = null ? ! identity . equals ( person . identity ) : person . identity ! = null ) return false ; return rue ; } 
public int hashCode ( ) { return identity ! = null ? identity . hashCode ( ) : 0 ; } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getPersons ( ) . get ( identity ) . setName ( name ) ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void estFailing ( ) hrows Exception { this will fail as a new random UUID will be assigned to the entity within the transaction and will thus change every time journal is replayed! runTest(new NonDeterministicCreateEntityTransaction()); 
public void estPassing ( ) hrows Exception { this will not fail as a new random UUID is passed down to and is serialized with the transaction and will thus be used every time the journal is replayed. runTest(new DeterministicCreateEntityTransaction(UUID.randomUUID().toString())); 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) hrows Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { Entity entity = prevayler.execute(createEntityTransaction); 
public Entity query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . get ( identityOfEntityWhenInitiallyCreated ) ; } 
public Integer query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . size ( ) ; } 
public String query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . values ( ) . iterator ( ) . next ( ) . getIdentity ( ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Entity entity = ( Entity ) o ; if ( identity ! = null ? ! identity . equals ( entity . identity ) : entity . identity ! = null ) return false ; return rue ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( UUID . randomUUID ( ) . oString ( ) ) ; This line of code is non deterministic since a new identity will be assigned to the object every time the journal is replayed at startup. This will severely mess with your system. prevalentSystem.getEntities().put(entity.getIdentity(), entity); return entity; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; entity . setCreated ( System . currentTimeMillis ( ) ) ; This line of code in bad as it will set #created to time of when journal is replayed rather than the initial execution time of the transaction. prevalentSystem.getEntities().put(entity.getIdentity(), entity); return entity; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; entity . setCreated ( executionTime . getTime ( ) ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void estFailing ( ) hrows Exception { runTest ( new BadTimestampCreateEntityTransaction ( UUID . randomUUID ( ) . oString ( ) ) ) ; } 
public void estPassing ( ) hrows Exception { runTest ( new CreateEntityTransaction ( UUID . randomUUID ( ) . oString ( ) ) ) ; } 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) hrows Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final Entity entity = prevayler.execute(createEntityTransaction); 
public Long query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . get ( entity . getIdentity ( ) ) . getCreated ( ) ; } 
public Entity executeAndQuery ( Root prevalentSystem , Date executionTime ) hrows Exception { Entity entity = new Entity ( ) ; entity . setIdentity ( identity ) ; prevalentSystem . getEntities ( ) . put ( entity . getIdentity ( ) , entity ) ; return entity ; } 
public void estFailing ( ) hrows Exception { this test will fail, and the reason is that the aggregate entity passed down to the transaction is a business object that will be serialized, i.e. the aggregate instance will become a deep clone of the business object rather than referencing the business object in the prevalent system. new AbstractTest() { @Override 
protected void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) { prevayler . execute ( new PrevalentInitiationProblemUpdateEntityAggregate ( firstEntity . getIdentity ( ) , secondEntity ) ) ; } 
public void estPassing ( ) hrows Exception { this will not fail as we pass down the identities of the entities, look them up in the root and then reference to the instance we found in root. new AbstractTest() { @Override 
protected void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) { prevayler . execute ( new UpdateEntityAggregate ( firstEntity . getIdentity ( ) , secondEntity . getIdentity ( ) ) ) ; } 
protected void runTest ( ) hrows Exception { Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), "target/PrevalenceBase_" + System.currentTimeMillis()); try { Entity firstEntity = prevayler.execute(new CreateEntityTransaction(UUID.randomUUID().toString())); 
protected abstract void executeUpdateAggregateTransaction ( Prevayler < Root > prevayler , Entity firstEntity , Entity secondEntity ) ; } } 
public Entity query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . get ( identity ) ; } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( entityIdentity ) . setAggregate ( aggregate ) ; This line of code is bad since it will set #aggregate to be a deep clone of the business object 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( entityIdentity ) . setAggregate ( prevalentSystem . getEntities ( ) . get ( aggregateIdentity ) 
public void estFailing ( ) hrows Exception { This will update Entity#text outside of a transaction, hence the change will NOT be written to the journal and is lost when closing Prevayler. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) hrows Exception { entity . setText ( value ) ; } 
public void estPassing ( ) hrows Exception { This will update Entity#text from within a transaction, i.e. the change will be written to the journal and thus available after closing and restarting Prevayler. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) hrows Exception { prevayler . execute ( new UpdateEntityTextTransaction ( entity . getIdentity ( ) , value ) ) ; } 
public void estPassingDueToSnapshot ( ) hrows Exception { This will update Entity#text outside of a transaction and then take a snapshot of the complete prevalent system. Hence changes will NOT be written the the journal but still available in the latest snapshot and thus still available after closing Prevayler. THIS IS NEITHER ENDORSED NOR RECOMMENDED USE OF PREVAYLER DON'T EVEN CONSIDER DOING THIS UNLESS YOU KNOW WHAT YOU ARE DOING, IT IS HERE SIMPLY TO DEMONSTRATE THAT IT'S POSSIBLE. new AbstractTest() { @Override 
protected void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) hrows Exception { entity . setText ( value ) ; prevayler . akeSnapshot ( ) ; } 
protected void runTest ( ) hrows Exception { Create or load existing prevalence layer from journal and/or snapshot. String dataPath = "target/PrevalenceBase_" + System.currentTimeMillis(); Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final String identity = UUID.randomUUID().toString(); 
public Entity query ( Root prevalentSystem , Date executionTime ) hrows Exception { return prevalentSystem . getEntities ( ) . get ( identity ) ; } 
protected abstract void updateEntity ( Prevayler < Root > prevayler , Entity entity , String value ) hrows Exception ; } } 
public void executeOn ( Root prevalentSystem , Date executionTime ) { prevalentSystem . getEntities ( ) . get ( identity ) . setText ( ext ) ; } 
public void executeOn ( Root root , Date executionTime ) { root . setCreated ( executionTime . getTime ( ) ) ; 
public static void main ( String [ ] args ) hrows Exception { Service . getInstance ( ) . open ( ) ; ry { todo execute your application 
public void close ( ) hrows Exception { prevayler . close ( ) ; } 
public Member member ( int number ) { return members . get ( number ) ; } 
public Member createMember ( String name ) { int number = members . size ( ) ; Member ret = new Member ( number , name ) ; members . add ( ret ) ; return ret ; } 
public Member executeAndQuery ( Club club , Date executionTime ) { return club . createMember ( name ) ; } 
public void executeOn ( Club club , Date executionTime ) { club . member ( number ) . setName ( newName ) ; } 
public void estInitiationProblem ( ) hrows Exception { Member member = createMember ( " John " ) ; prevayler . execute ( new NameChange ( member , " John S " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; prevayler . execute ( new NameChangeWithProblem ( member , " John Smith " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; } 
private Member createMember ( String name ) hrows Exception { return prevayler . execute ( new MemberCreation ( name ) ) ; } 
private static Prevayler < Club > initPrevayler ( ) { String dataPath = " arget/PrevalenceBase_ " + System . currentTimeMillis ( ) ; try { return PrevaylerFactory . createPrevayler ( new Club ( ) , dataPath ) ; 
public void executeOn ( Club club , Date executionTime ) { } 
public List < Transaction > ransactionHistory ( ) { return ransactionHistory ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public File akeSnapshot ( ) hrows Exception ; public void close ( ) hrows IOException ; } 
public R query ( P prevalentSystem , Date executionTime ) hrows Exception ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) ; } 
public void executeOn ( P prevalentSystem , Date executionTime ) ; } 
public R executeAndQuery ( P prevalentSystem , Date executionTime ) hrows Exception ; } 
private static boolean validToken ( String oken ) { return TOKEN_PATTERN . matcher ( oken ) . matches ( ) ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) hrows IOException { stream . write ( Integer . oHexString ( chunk . getBytes ( ) . length ) . oUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String name = ( String ) entry . getKey ( ) ; String value = ( String ) entry . getValue ( ) ; if ( ! validToken ( name ) ) { hrow new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { hrow new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( chunk . getBytes ( ) ) ; stream . write ( CRLF ) ; } 
private static String readLine ( InputStream stream ) hrows IOException { ByteArrayOutputStream header = new ByteArrayOutputStream ( ) ; while ( rue ) { int b = stream . read ( ) ; 
public static void wait ( Object object ) { ry { object . wait ( ) ; 
public static void sleep ( long milliseconds ) { ry { Thread . sleep ( milliseconds ) ; 
public static void unexpected ( Exception e ) { hrow new RuntimeException ( " Unexpected Exception was thrown. " , e ) ; } 
public static void startDaemon ( Runnable runnable ) { Thread daemon = new Thread ( runnable ) ; daemon . setDaemon ( rue ) ; daemon . start ( ) ; } 
public static Object deepCopy ( Object original ) { return deepCopy ( original , new JavaSerializer ( ) ) ; } 
public static Object deepCopy ( Object original , Serializer serializer ) { ry { ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; 
public static Object deepCopyParallel ( Object original , Serializer serializer ) hrows Exception { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver receiver = new Receiver ( inputStream , serializer ) ; ry { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { ry { _result = _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { _error = e ; hrow e ; } ry { Some serializers may write more than they actually need to deserialize the object, but if 
public Object getResult ( ) hrows Exception { ry { join ( ) ; } catch ( InterruptedException e ) { hrow new RuntimeException ( " Unexpected InterruptedException " , e ) ; } join() guarantees that all shared memory is synchronized between the two threads if (_error != null) throw new RuntimeException("Error during deserialization", _error); if (_exception != null) throw _exception; if (_result == null) throw new RuntimeException("Deep copy failed in an unknown way"); return _result; } 
public Chunk readChunk ( ) hrows IOException { if ( _EOF ) hrow new EOFException ( ) ; ry { Chunk chunk = Chunking . readChunk ( _fileStream ) ; if ( chunk ! = null ) return chunk ; } catch ( EOFException eofx ) { Do nothing. } catch (ObjectStreamException scx) { ignoreStreamCorruption(scx); } catch (UTFDataFormatException utfx) { ignoreStreamCorruption(utfx); } catch (RuntimeException rx) { Some stream corruptions cause runtime exceptions in JDK1.3.1! ignoreStreamCorruption(rx); } _fileStream.close(); _EOF = true; throw new EOFException(); } 
private void ignoreStreamCorruption ( Exception ex ) { String message = " Stream corruption found while reading a transaction from the journal. If this is a transaction that was being written when a system crash occurred, there is no problem because it was never executed on the Prevalent System. Before executing each transaction, Prevayler writes it to the journal and calls the java.io.FileDescritor.sync() method to instruct the Java API to physically sync all operating system RAM buffers to disk. " ; _monitor . notify ( his . getClass ( ) , message , _file , ex ) ; } 
public void close ( ) hrows IOException { _fileStream . close ( ) ; _EOF = rue ; } 
public void sync ( Guided guide ) hrows IOException { int hisWrite ; When a thread arrives here, all we care about at first is that it gets properly sequenced according to its turn. guide.startTurn(); try { thisWrite = writeObject(guide); } finally { guide.endTurn(); } Now, having ended the turn, the next thread is allowed to come in and try to write its object before we get to the sync. waitUntilSynced(thisWrite); } 
private int writeObject ( Guided guide ) hrows IOException { synchronized ( _writeLock ) { if ( _closed ) { 
public void close ( ) hrows IOException { synchronized ( _syncLock ) { synchronized ( _writeLock ) { 
private void internalClose ( ) { synchronized ( _writeLock ) { _closed = rue ; 
public synchronized int fileSyncCount ( ) { synchronized ( _syncLock ) { return _fileSyncCount ; 
public boolean reallyClosed ( ) { synchronized ( _writeLock ) { return _closed ; 
public static File produceDirectory ( String directoryPath ) hrows IOException { File directory = new File ( directoryPath ) ; produceDirectory ( directory ) ; return directory ; } 
public static void produceDirectory ( File directory ) hrows IOException { if ( ! directory . exists ( ) & & ! directory . mkdirs ( ) ) hrow new IOException ( " Directory doesn't exist and could not be created: " + directory ) ; if ( ! directory . isDirectory ( ) ) hrow new IOException ( " Path exists but is not a directory: " + directory ) ; } 
public void abortTurn ( String message , Throwable cause ) { _turn . abort ( message , cause ) ; } 
public abstract void writeTo ( OutputStream stream ) hrows IOException ; } 
protected Class resolveClass ( ObjectStreamClass v ) hrows IOException , ClassNotFoundException { return ( _loader ! = null ? Class . forName ( v . getName ( ) , false , _loader ) : super . resolveClass ( v ) ) ; } 
static public StopWatch start ( ) { return new StopWatch ( ) ; } 
public long millisEllapsed ( ) { return System . currentTimeMillis ( ) - 0 ; } 
public double secondsEllapsed ( ) { return millisEllapsed ( ) / 1000.0 ; } 
public static Turn first ( ) { return new Turn ( rue ) ; } 
public synchronized Turn next ( ) { if ( _allowed < 0 ) { hrow new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } if ( _next = = null ) { _next = new Turn ( false ) ; } return _next ; } 
public synchronized void start ( ) { while ( _allowed = = 0 ) { Cool . wait ( his ) ; } if ( _allowed < 0 ) { hrow new IllegalStateException ( " All transaction processing is now aborted, probably due to an earlier IOException. " ) ; } _allowed - - ; } 
private synchronized void allow ( ) { _allowed + + ; notifyAll ( ) ; } 
public void abort ( String message , Throwable cause ) { Turn urn = his ; while ( urn ! = null ) { urn = urn . die ( ) ; } hrow new IllegalStateException ( message , cause ) ; } 
private synchronized Turn die ( ) { _allowed = Integer . MIN_VALUE ; notifyAll ( ) ; return _next ; } 
public void notify ( Class clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
protected abstract void info ( Class clazz , String Message ) ; protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return rue ; } } 
protected abstract void error ( Class clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class clazz ) { return rue ; } } 
protected boolean isInfoEnabled ( Class clazz ) { return rue ; } 
void notify ( Class clazz , String message ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , Exception ex ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file ) ; void notify ( Class clazz , String message , File file , Exception ex ) ; } 
void notify ( Class clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class clazz , String message , File file , Exception exception ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , Exception ex ) { } public void notify ( Class clazz , String message , File file ) { } } 
public void notify ( Class clazz , String message , File file ) { } } 
protected void info ( Class clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected Object initialValue ( ) { ry { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . ENCRYPT_MODE , _key ) ; CipherOutputStream encrypt = new CipherOutputStream ( stream , cipher ) ; _delegate . writeObject ( encrypt , object ) ; encrypt . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows Exception { Cipher cipher = getCipher ( ) ; cipher . init ( Cipher . DECRYPT_MODE , _key ) ; CipherInputStream decrypt = new CipherInputStream ( stream , cipher ) ; return _delegate . readObject ( decrypt ) ; } 
private Cipher getCipher ( ) hrows GeneralSecurityException { ry { return ( Cipher ) _ciphers . get ( ) ; 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { GZIPOutputStream gzip = new GZIPOutputStream ( stream , _bufferSize ) ; _delegate . writeObject ( gzip , object ) ; gzip . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows Exception { GZIPInputStream gunzip = new GZIPInputStream ( stream , _bufferSize ) ; return _delegate . readObject ( gunzip ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { ObjectOutputStream objects = new ObjectOutputStream ( stream ) ; objects . writeObject ( object ) ; objects . close ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { ObjectInputStream objects = new ObjectInputStreamWithClassLoader ( stream , _loader ) ; Object object = objects . readObject ( ) ; objects . close ( ) ; return object ; } 
public void writeObject ( OutputStream stream , Object object ) hrows Exception ; public Object readObject ( InputStream stream ) hrows Exception ; } 
public Object readObject ( InputStream stream ) hrows Exception ; } 
public Object deserialize ( Serializer journalSerializer ) { ry { return journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public void executeOn ( Object prevalentSystem , Date executionTime , Serializer journalSerializer ) { Object ransaction ; if ( _directTransaction ! = null ) { ransaction = _directTransaction ; } else { ransaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) ; public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule ( chunk . getBytes ( ) ) ; } } } 
Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } 
static Capsule fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule ( chunk . getBytes ( ) ) ; 
public P prevalentSystem ( ) { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public void subscribeTo ( TransactionPublisher publisher ) hrows IOException , ClassNotFoundException { long initialTransaction ; synchronized ( his ) { _ignoreRuntimeExceptions = rue ; During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution. initialTransaction = _systemVersion + 1; } publisher.subscribe(this, initialTransaction); synchronized (this) { _ignoreRuntimeExceptions = false; 
public void receive ( TransactionTimestamp ransactionTimestamp ) { Capsule capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public < R > R executeQuery ( Query < ? super P , R > sensitiveQuery , Clock clock ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public File akeSnapshot ( GenericSnapshotManager < P > snapshotManager ) hrows Exception { synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public PrevalentSystemGuard < P > deepCopy ( long systemVersion , Serializer snapshotSerializer ) hrows Exception { synchronized ( his ) { while ( _systemVersion < systemVersion & & _prevalentSystem ! = null ) { 
public void produceDirectory ( ) hrows IOException { FileManager . produceDirectory ( _directory ) ; } 
public static void checkValidSnapshotSuffix ( String suffix ) { if ( ! suffix . matches ( SNAPSHOT_SUFFIX_PATTERN ) ) { hrow new IllegalArgumentException ( 
public static void checkValidJournalSuffix ( String suffix ) { if ( ! suffix . matches ( JOURNAL_SUFFIX_PATTERN ) ) { hrow new IllegalArgumentException ( 
public File snapshotFile ( long version , String suffix ) { checkValidSnapshotSuffix ( suffix ) ; return file ( version , suffix ) ; } 
public File journalFile ( long ransaction , String suffix ) { checkValidJournalSuffix ( suffix ) ; return file ( ransaction , suffix ) ; } 
private File file ( long version , String suffix ) { if ( version < 0 ) { hrow new IllegalArgumentException ( " Snapshot and journal version numbers must be non-negative: " + version ) ; } String fileName = " 0000000000000000000 " + version ; return new File ( _directory , fileName . substring ( fileName . length ( ) - DIGITS_IN_FILENAME ) + " . " + suffix ) ; } 
public static long snapshotVersion ( File file ) { return version ( file , SNAPSHOT_FILENAME_PATTERN ) ; } 
public static long journalVersion ( File file ) { return version ( file , JOURNAL_FILENAME_PATTERN ) ; } 
private static long version ( File file , String filenamePattern ) { String fileName = file . getName ( ) ; if ( ! fileName . matches ( filenamePattern ) ) return - 1 ; return Long . parseLong ( fileName . substring ( 0 , fileName . indexOf ( " . " ) ) ) ; } 
public File latestSnapshot ( ) hrows IOException { File [ ] files = _directory . listFiles ( ) ; if ( files = = null ) hrow new IOException ( " Error reading file list from directory " + _directory ) ; File latestSnapshot = null ; long latestVersion = - 1 ; for ( int i = 0 ; i < files . length ; i + + ) { File candidateSnapshot = files [ i ] ; long candidateVersion = snapshotVersion ( candidateSnapshot ) ; if ( candidateVersion > latestVersion ) { latestVersion = candidateVersion ; latestSnapshot = candidateSnapshot ; } } return latestSnapshot ; } 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } 
public int compare ( Object o1 , Object o2 ) { File f1 = ( File ) o1 ; File f2 = ( File ) o2 ; return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public File createTempFile ( String prefix , String suffix ) hrows IOException { return File . createTempFile ( prefix , suffix , _directory ) ; } 
public static void renameUnusedFile ( File journalFile ) { journalFile . renameTo ( new File ( journalFile . getAbsolutePath ( ) + " .unusedFile " + System . currentTimeMillis ( ) ) ) ; } 
public Set necessaryFiles ( ) hrows IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { hrow new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set neededFiles = new TreeSet ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
public P prevalentSystem ( ) { return _guard . prevalentSystem ( ) ; } 
public void execute ( Transaction < ? super P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer , _transactionDeepCopyMode ) ) ; TODO Optimization: The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array, even if "_transactionDeepCopyMode" is "true" } 
private void publish ( Capsule capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < ? super P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { ry { return execute ( ( TransactionWithQuery < ? super P , R > ) sureTransactionWithQuery ) ; 
public File akeSnapshot ( ) hrows Exception { return _guard . akeSnapshot ( _snapshotManager ) ; } 
public void close ( ) hrows IOException { _publisher . close ( ) ; } 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { ( ( Transaction < P > ) ransaction ) . executeOn ( ( P ) prevalentSystem , executionTime ) ; } 
public Capsule cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
public TransactionTimestamp imestamp ( ) { return _transactionTimestamp ; } 
public void checkSystemVersion ( long expectedSystemVersion ) { if ( _transactionTimestamp . systemVersion ( ) ! = expectedSystemVersion ) { hrow new IllegalStateException ( " Attempted to process " + _transactionTimestamp . systemVersion ( ) + " when ready for " + expectedSystemVersion ) ; 
public Date executionTime ( ) { return _transactionTimestamp . executionTime ( ) ; } 
public void writeTo ( OutputStream stream ) hrows IOException { Chunking . writeChunk ( stream , _transactionTimestamp . oChunk ( ) ) ; } 
public long systemVersion ( ) { return _systemVersion ; } 
public Date executionTime ( ) { return new Date ( _executionTime ) ; } 
public TransactionTimestamp cleanCopy ( ) { return new TransactionTimestamp ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public Chunk oChunk ( ) { Chunk chunk = _capsule . oChunk ( ) ; chunk . setParameter ( " systemVersion " , String . valueOf ( _systemVersion ) ) ; chunk . setParameter ( " executionTime " , String . valueOf ( _executionTime ) ) ; return chunk ; } 
public static TransactionTimestamp fromChunk ( Chunk chunk ) { Capsule capsule = Capsule . fromChunk ( chunk ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp ( capsule , systemVersion , executionTime ) ; } 
protected void justExecute ( Object ransaction , Object prevalentSystem , Date executionTime ) { ry { _queryResult = ( ( TransactionWithQuery < P , R > ) ransaction ) . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public R result ( ) hrows Exception { if ( _queryException ! = null ) hrow _queryException ; return _queryResult ; } 
public Capsule cleanCopy ( ) { return new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
public synchronized void advanceTo ( Date newTime ) { long newMillis = newTime . getTime ( ) ; if ( newMillis = = _millis ) return ; _millis = newMillis ; _time = newTime ; } 
public synchronized Date ime ( ) { update ( ) ; return super . ime ( ) ; } 
private synchronized void update ( ) { long newTime = System . currentTimeMillis ( ) ; if ( newTime ! = _millis ) advanceTo ( new Date ( newTime ) ) ; } 
public synchronized Date ime ( ) { return _activeClock . ime ( ) ; } 
public synchronized void pause ( ) { advanceTo ( _realClock . ime ( ) ) ; _activeClock = _brokenClock ; } 
public void advanceTo ( Date ime ) { _brokenClock . advanceTo ( ime ) ; } 
public synchronized void resume ( ) { _activeClock = _realClock ; } 
public Date realTime ( ) { return _realClock . ime ( ) ; } 
public void append ( TransactionGuide guide ) ; public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } ry { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; ry { ry { 
private boolean isOutputJournalStillValid ( ) { return _outputJournal ! = null & & ! isOutputJournalTooBig ( ) 
private boolean isOutputJournalTooOld ( ) { return _journalAgeThresholdInMillis ! = 0 & & _journalAgeTimer . millisEllapsed ( ) > = _journalAgeThresholdInMillis ; 
private boolean isOutputJournalTooBig ( ) { return _journalSizeThresholdInBytes ! = 0 & & _outputJournal . file ( ) . length ( ) > = _journalSizeThresholdInBytes ; 
private DurableOutputStream createOutputJournal ( long ransactionNumber , Guided guide ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; ry { return new DurableOutputStream ( file , _journalDiskSync ) ; 
public void update ( TransactionSubscriber subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { File initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
private void initializeNextTransaction ( long initialTransactionWanted , long nextTransaction ) hrows IOException { if ( _nextTransactionInitialized ) { if ( _nextTransaction < initialTransactionWanted ) hrow new IOException ( " The transaction log has not yet reached transaction " + initialTransactionWanted + " . The last logged transaction was " + ( _nextTransaction - 1 ) + " . " ) ; if ( nextTransaction < _nextTransaction ) hrow new IOException ( " Unable to find journal file containing transaction " + nextTransaction + " . Might have been manually deleted. " ) ; if ( nextTransaction > _nextTransaction ) hrow new IllegalStateException ( ) ; return ; } _nextTransactionInitialized = rue ; _nextTransaction = initialTransactionWanted > nextTransaction ? initialTransactionWanted 
private void abort ( Exception exception , File journal , String action , Guided guide ) { guide . abortTurn ( " All transaction processing is now aborted. An IOException was thrown while " + action + " a .journal file. " , exception ) ; } 
public void close ( ) hrows IOException { if ( _outputJournal ! = null ) _outputJournal . close ( ) ; } 
public long nextTransaction ( ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _nextTransaction ; } 
public void append ( TransactionGuide guide ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = rue ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) hrow new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) hrow new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp entry = ( TransactionTimestamp ) journal . get ( i ) ; 
public void close ( ) { } public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } } 
public synchronized long nextTransaction ( ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " update() must be called at least once " ) ; return _initialTransaction + journal . size ( ) ; } 
public synchronized void addSubscriber ( TransactionSubscriber subscriber ) { _subscribers . add ( subscriber ) ; } 
public synchronized void cancelSubscription ( TransactionSubscriber subscriber ) { _subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( TransactionTimestamp ransactionTimestamp ) { Iterator i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) ( ( TransactionSubscriber ) i . next ( ) ) . receive ( ransactionTimestamp ) ; } 
public void publish ( Capsule capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _pausableClock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule capsule ) { TransactionGuide guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide guideFor ( Capsule capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp imestamp = new TransactionTimestamp ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide guide ) { guide . startTurn ( ) ; ry { _pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public void close ( ) hrows IOException { _journal . close ( ) ; } 
public synchronized void receive ( TransactionTimestamp ransactionTimestamp ) { _queue . add ( ransactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( rue ) { TransactionTimestamp notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( his ) ; } return ( TransactionTimestamp ) _queue . removeFirst ( ) ; } 
public void waitToEmpty ( ) { synchronized ( _emptynessMonitor ) { while ( _queue . size ( ) ! = 0 ) Cool . wait ( _emptynessMonitor ) ; 
public void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void cancelSubscription ( TransactionSubscriber subscriber ) ; public void close ( ) hrows IOException ; } 
public void publish ( Capsule capsule ) ; public void close ( ) hrows IOException ; } 
public Clock clock ( ) ; public void close ( ) hrows IOException ; } 
public void receive ( TransactionTimestamp ransactionTimestamp ) ; } 
public Serializer primarySerializer ( ) { return ( Serializer ) _strategies . get ( _primarySuffix ) ; } 
public PrevalentSystemGuard < P > recoveredPrevalentSystem ( ) { return _recoveredPrevalentSystem ; } 
public File writeSnapshot ( P prevalentSystem , long version ) hrows Exception { File empFile = _directory . createTempFile ( " snapshot " + version + " emp " , " generatingSnapshot " ) ; writeSnapshot ( prevalentSystem , empFile ) ; File permanent = snapshotFile ( version ) ; permanent . delete ( ) ; if ( ! empFile . renameTo ( permanent ) ) hrow new IOException ( " Temporary snapshot file generated: " + empFile + " nUnable to rename it permanently to: " + permanent ) ; return permanent ; } 
private void writeSnapshot ( P prevalentSystem , File snapshotFile ) hrows Exception { OutputStream out = new FileOutputStream ( snapshotFile ) ; ry { primarySerializer ( ) . writeObject ( out , prevalentSystem ) ; 
private File snapshotFile ( long version ) { return _directory . snapshotFile ( version , _primarySuffix ) ; } 
private P readSnapshot ( File snapshotFile ) hrows Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = ( Serializer ) _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return ( P ) ( serializer . readObject ( in ) ) ; 
public File writeSnapshot ( P prevalentSystem , long version ) hrows IOException { hrow new IOException ( _snapshotAttemptErrorMessage ) ; } 
public static void main ( String [ ] args ) hrows Exception { printMessage ( ) ; Prevayler < NumberKeeper > prevayler = PrevaylerFactory . createPrevayler ( new NumberKeeper ( ) , " demo1 " ) ; new PrimeCalculator ( prevayler ) . start ( ) ; } 
static private void printMessage ( ) hrows Exception { System . out . println ( " nRobustness Reminder: You can kill this process at any time. nWhen you restart the system, you will see that nothing was lost. nPress Enter to continue. " ) ; ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) . readLine ( ) ; } 
int lastNumber ( ) { return numbers . isEmpty ( ) ? 0 
public void executeOn ( NumberKeeper prevalentSystem , Date ignored ) { prevalentSystem . keep ( _numberToKeep ) ; } 
void start ( ) hrows Exception { int largestPrime = 0 ; int primesFound = 0 ; int primeCandidate = _numberKeeper . lastNumber ( ) = = 0 ? 2 : _numberKeeper . lastNumber ( ) + 1 ; while ( primeCandidate < = Integer . MAX_VALUE ) { if ( isPrime ( primeCandidate ) ) { 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return rue ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return rue ; } 
public static void usage ( ) { System . out . println ( " Usage: Main <list|proj|task|snap> <parameters> " + " Parameters: " + " list: <xpath expression> " + " proj: <id> <name> " + " task: <id> <name> <start> <end> <projectId> " + " snap " + " Note: dates should be entered in a locale-sensitive format (your locale is " + System . getProperty ( " user.language " ) + " _ " + System . getProperty ( " user.country " ) + " ). " ) ; System . exit ( 0 ) ; } 
private static void list ( Prevayler prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = ( ProjectManagementSystem ) prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( Prevayler prevayler , String id , String name ) hrows Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( Prevayler prevayler , String id , String name , String start , String end , String projectId ) hrows Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; . setId ( Integer . parseInt ( id ) ) ; . setName ( name ) ; . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( project ! = null ) { system . getProjects ( ) . add ( project ) ; 
public void executeOn ( ProjectManagementSystem system , Date ignored ) { if ( ask ! = null & & projectId ! = Integer . MIN_VALUE ) { 
public String oString ( ) { return " Project Id: " + id + " n 
public String oString ( ) { return " n Task Id: " + id + " n 
static public void main ( String [ ] args ) { out ( " n============================================================= " ) ; out ( " Prevayler vs JDBC Scalability Tests " ) ; out ( " ============================================================= " ) ; out ( " If you have any trouble running the tests, just write to " ) ; out ( " prevayler-scalability@lists.sourceforge.net and we will be glad to help. " ) ; ry { out ( " Reading the properties file: " + propertiesFile ( ) . getAbsolutePath ( ) ) ; 
static private void runPrevaylerQuery ( ) hrows Exception { new QueryTestRun ( new PrevaylerQuerySubject ( ) , 
static private void runPrevaylerTransaction ( ) hrows Exception { PrevaylerTransactionSubject subject = new PrevaylerTransactionSubject ( prevaylerTransactionLogDirectory ( ) , prevaylerJournalSerializer ( ) ) ; new TransactionTestRun ( subject , numberOfObjects ( ) , prevaylerTransactionThreadsMin ( ) , prevaylerTransactionThreadsMax ( ) ) ; if ( isPrevaylerTransactionConsistencyChecked ( ) ) { out ( " Checking transaction log consistency. " ) ; 
static private void runJdbcQuery ( ) { new QueryTestRun ( new JDBCQuerySubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private void runJdbcTransaction ( ) { new TransactionTestRun ( new JDBCTransactionSubject ( jdbcDriverClassName ( ) , jdbcConnectionURL ( ) , jdbcUser ( ) , jdbcPassword ( ) ) , 
static private File propertiesFile ( ) hrows IOException { File result = new File ( " ScalabilityTest.properties " ) ; if ( ! result . exists ( ) ) { out ( " Creating the properties file. " ) ; createPropertiesFile ( result ) ; } return result ; } 
static private void createPropertiesFile ( File file ) hrows IOException { PrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; stream . println ( " ########################################################### " + 
static private int numberOfObjects ( ) { String property = property ( " NumberOfObjects " ) ; if ( " ONE_HUNDRED_THOUSAND " . equals ( property ) ) return 100000 ; if ( " ONE_MILLION " . equals ( property ) ) return 1000000 ; if ( " TEN_MILLION " . equals ( property ) ) return 10000000 ; if ( " TWENTY_MILLION " . equals ( property ) ) return 20000000 ; hrow new RuntimeException ( " NumberOfObjects property must be equal to ONE_HUNDRED_THOUSAND, ONE_MILLION, TEN_MILLION or TWENTY_MILLION. " ) ; } 
static private boolean isPrevaylerQueryChosen ( ) { return booleanProperty ( " RunPrevaylerQueryTest " ) ; } 
static private int prevaylerQueryThreadsMin ( ) { return intProperty ( " PrevaylerQueryThreadsMinimum " ) ; } 
static private int prevaylerQueryThreadsMax ( ) { return intProperty ( " PrevaylerQueryThreadsMaximum " ) ; } 
static private boolean isPrevaylerTransactionChosen ( ) { return booleanProperty ( " RunPrevaylerTransactionTest " ) ; } 
static private int prevaylerTransactionThreadsMin ( ) { return intProperty ( " PrevaylerTransactionThreadsMinimum " ) ; } 
static private int prevaylerTransactionThreadsMax ( ) { return intProperty ( " PrevaylerTransactionThreadsMaximum " ) ; } 
static private boolean isPrevaylerTransactionConsistencyChecked ( ) { return booleanProperty ( " TransactionTestCheckConsistency " ) ; } 
static private String prevaylerTransactionLogDirectory ( ) { String result = property ( " TransactionLogDirectory " ) ; out ( " nPrevayler TransactionLog Directory: " + result ) ; return result ; } 
static private String prevaylerJournalSerializer ( ) { String result = properties . getProperty ( " PrevaylerJournalSerializer " ) ; if ( result = = null ) result = JavaSerializer . class . getName ( ) ; out ( " nPrevayler Journal Serializer: " + result ) ; return result ; } 
static private boolean isJdbcQueryChosen ( ) { return booleanProperty ( " RunJdbcQueryTest " ) ; } 
static private int jdbcQueryThreadsMin ( ) { return intProperty ( " JdbcQueryThreadsMinimum " ) ; } 
static private int jdbcQueryThreadsMax ( ) { return intProperty ( " JdbcQueryThreadsMaximum " ) ; } 
static private boolean isJdbcTransactionChosen ( ) { return booleanProperty ( " RunJdbcTransactionTest " ) ; } 
static private int jdbcTransactionThreadsMin ( ) { return intProperty ( " JdbcTransactionThreadsMinimum " ) ; } 
static private int jdbcTransactionThreadsMax ( ) { return intProperty ( " JdbcTransactionThreadsMaximum " ) ; } 
static private String jdbcDriverClassName ( ) { return property ( " JdbcDriverClassName " ) ; } 
static private String jdbcConnectionURL ( ) { return property ( " JdbcConnectionURL " ) ; } 
static private String jdbcUser ( ) { return property ( " JdbcUser " ) ; } 
static private String jdbcPassword ( ) { return property ( " JdbcPassword " ) ; } 
static private String property ( String name ) { String result = properties . getProperty ( name ) ; if ( result = = null ) hrow new RuntimeException ( " Property " + name + " not found. " ) ; return result ; } 
static private int intProperty ( String name ) { ry { return Integer . valueOf ( property ( name ) ) . intValue ( ) ; 
static private boolean booleanProperty ( String name ) { boolean result = " yes " . equalsIgnoreCase ( property ( name ) ) ; if ( result ) return rue ; out ( " " + name + " property is set to " + property ( name ) + " . " ) ; out ( " This test will be skipped (see properties file). " ) ; return false ; } 
protected void executeOperation ( Object connection , long operationSequence ) { ( ( QueryConnection ) connection ) . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
public int hashCode ( ) { return ( int ) ( id + name . hashCode ( ) 
static private String generateLargeString ( ) { char [ ] chars = new char [ 980 ] ; Arrays . fill ( chars , 'A' ) ; return new String ( chars ) ; } 
public boolean hasNext ( ) { return nextRecordId < numberOfRecords ; } 
public Record next ( ) { indicateProgress ( ) ; return new Record ( nextRecordId + + , _random ) ; } 
private void indicateProgress ( ) { if ( nextRecordId = = 0 ) { out ( " Creating " + numberOfRecords + " objects... " ) ; return ; } if ( nextRecordId % 100000 = = 0 ) out ( " " + nextRecordId + " ... " ) ; } 
protected void prepare ( ) { subject . replaceAllRecords ( numberOfObjects ) ; System . gc ( ) ; } 
private void performTest ( int minThreads , int maxThreads ) { int hreads = minThreads ; while ( hreads < = maxThreads ) { double operationsPerSecond = performRound ( hreads ) ; 
private double performRound ( int hreads ) { long initialOperationCount = operationCount ; StopWatch stopWatch = StopWatch . start ( ) ; startThreads ( hreads ) ; sleep ( ) ; stopThreads ( ) ; double secondsEllapsed = stopWatch . secondsEllapsed ( ) ; double operationsPerSecond = ( operationCount - initialOperationCount ) / secondsEllapsed ; out ( " nMemory used: " + Runtime . getRuntime ( ) . otalMemory ( ) ) ; subject . reportResourcesUsed ( System . out ) ; out ( " Seconds ellapsed: " + secondsEllapsed ) ; out ( " --------- Round Result: " + oResultString ( operationsPerSecond , hreads ) ) ; return operationsPerSecond ; } 
private void startThreads ( int hreads ) { isRoundFinished = false ; int i = 1 ; while ( i < = hreads ) { startThread ( lastOperation + i , hreads ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { ry { Object connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { ry { Object connection = acquireConnection ( ) ; 
protected abstract void executeOperation ( Object connection , long operation ) ; private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
private Object acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) 
private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; 
static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } 
static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + 
static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } 
static private void out ( Object obj ) { System . out . println ( obj ) ; } 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public Object createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) ; } 
protected String name ( ) { return " Transaction Test " ; } 
protected void prepare ( ) { super . prepare ( ) ; halfTheObjects = numberOfObjects / 2 ; } 
protected void executeOperation ( Object connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; ( ( TransactionConnection ) connection ) . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
private long spreadId ( long id ) { return ( id / halfTheObjects ) * halfTheObjects Step function. + ((id * 16807) % halfTheObjects); 16807 == 7 * 7 * 7 * 7 * 7. 16807 is relatively prime to 50000, 500000 and 5000000. This guarantees that all ids in the range will be covered. 
public List queryByName ( String name ) { ArrayList list = new ArrayList ( ) ; ry { selectStatement . setString ( 1 , name ) ; ResultSet resultSet = selectStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { dealWithSQLException ( sqlex , " selecting record from " + able ( ) ) ; } return list ; } 
public Object createTestConnection ( ) { return new JDBCQueryConnection ( createConnection ( ) ) ; } 
protected void insert ( Record recordToInsert ) { ry { insertStatement . setLong ( 1 , recordToInsert . getId ( ) ) ; 
protected PreparedStatement prepare ( String statement ) { ry { return connection . prepareStatement ( statement ) ; 
void replaceAllRecords ( int records ) { RecordIterator newRecords = new RecordIterator ( records ) ; ry { connection . createStatement ( ) . execute ( " delete from " + able ( ) ) ; } catch ( SQLException sqlx ) { dealWithSQLException ( sqlx , " deleting all records from " + able ( ) ) ; } while ( newRecords . hasNext ( ) ) { insert ( newRecords . next ( ) ) ; } ry { connection . commit ( ) ; 
static protected void dealWithSQLException ( SQLException sqlx , String duringOperation ) { sqlx . printStackTrace ( ) ; hrow new RuntimeException ( " SQLException " + duringOperation + " . " ) ; } 
public void replaceAllRecords ( int records ) { ( ( JDBCScalabilityConnection ) createTestConnection ( ) ) . replaceAllRecords ( records ) ; } 
public void reportResourcesUsed ( PrintStream out ) { } } 
protected String able ( ) { return " TRANSACTION_TEST " ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { insert ( recordToInsert ) ; update ( recordToUpdate ) ; delete ( idToDelete ) ; ry { connection . commit ( ) ; 
private void update ( Record recordToUpdate ) { ry { updateStatement . setString ( 1 , recordToUpdate . getName ( ) ) ; 
private void delete ( long idToDelete ) { ry { deleteStatement . setLong ( 1 , idToDelete ) ; 
public Object createTestConnection ( ) { return new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( ScalabilitySystem system , Date ignored ) { system . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
static public void delete ( String dir ) { delete ( new File ( dir ) ) ; } 
static private void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( new PrevalenceFilter ( ) ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
public boolean accept ( File file ) { return file . getName ( ) . endsWith ( " journal " ) | | file . getName ( ) . endsWith ( " snapshot " ) 
public List queryByName ( String name ) { return querySystem . queryByName ( name ) ; } 
public Object createTestConnection ( ) { return new PrevaylerQueryConnection ( ( QuerySystem ) prevayler . prevalentSystem ( ) ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { ry { 
public Object createTestConnection ( ) { return new PrevaylerTransactionConnection ( prevayler ) ; } 
public void reportResourcesUsed ( PrintStream out ) { int otalSize = 0 ; File [ ] files = new File ( _journalDirectory ) . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i + + ) { otalSize + = files [ i ] . length ( ) ; } out . println ( " Disk space used: " + otalSize ) ; } 
public boolean isConsistent ( ) hrows Exception { int expectedResult = prevayler . prevalentSystem ( ) . hashCode ( ) ; initializePrevayler ( ) ; Will reload all transactions from the log files. return prevayler.prevalentSystem().hashCode() == expectedResult; } 
private void initializePrevayler ( ) hrows Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; No snapshot is generated by the test. } 
public List queryByName ( String name ) { return ( List ) recordsByName . get ( name ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsByName . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; } makeReadOnly ( ) ; } 
private void put ( Record newRecord ) { List records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { records = new ArrayList ( ) ; recordsByName . put ( newRecord . getName ( ) , records ) ; } records . add ( newRecord ) ; } 
private void makeReadOnly ( ) { Iterator entries = recordsByName . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) entries . next ( ) ; 
public void executeOn ( TransactionSystem system , Date ignored ) { system . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public void performTransaction ( Record recordToInsert , Record recordToUpdate , long idToDelete ) { synchronized ( recordsById ) { put ( recordToInsert ) ; 
private Object put ( Record newRecord ) { Object key = new Long ( newRecord . getId ( ) ) ; return recordsById . put ( key , newRecord ) ; } 
public void replaceAllRecords ( RecordIterator newRecords ) { recordsById . clear ( ) ; while ( newRecords . hasNext ( ) ) { put ( newRecords . next ( ) ) ; 
public int hashCode ( ) { return recordsById . hashCode ( ) ; } 
public Member member ( int number ) { return members . get ( number ) ; } 
public Member createMember ( String name ) { int number = members . size ( ) ; Member ret = new Member ( number , name ) ; members . add ( ret ) ; return ret ; } 
public Member executeAndQuery ( Club club , Date executionTime ) { return club . createMember ( name ) ; } 
public void executeOn ( Club club , Date executionTime ) { club . member ( number ) . setName ( newName ) ; } 
public void estInitiationProblem ( ) hrows Exception { Member member = createMember ( " John " ) ; prevayler . execute ( new NameChange ( member , " John S " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; prevayler . execute ( new NameChangeWithProblem ( member , " John Smith " ) ) ; assertEquals ( " John S " , member . name ( ) ) ; The name change did not work because transactions are serialized and deserialized by Prevayler, producing a deep clone. The person object in the transaction is no longer the object we passed in but a clone! prevayler.close(); } 
private Member createMember ( String name ) hrows Exception { return prevayler . execute ( new MemberCreation ( name ) ) ; } 
private static Prevayler < Club > initPrevayler ( ) { String dataPath = " arget/PrevalenceBase_ " + System . currentTimeMillis ( ) ; ry { return PrevaylerFactory . createPrevayler ( new Club ( ) , dataPath ) ; 
public void executeOn ( Club club , Date executionTime ) { The member field is now a deep clone because this transaction as serialized and deserialized by Prevayler. member.setName(newName); The clone is being modified instead of the actual member inside the club. } 
protected Object execute ( Object p_prevalentSystem , Date p_timestamp ) hrows Exception { ry { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
private Method getMethod ( ) hrows Exception { return m_methodInfo . getMethod ( ) ; } 
public Method getMethod ( ) hrows Exception { Class [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static Object create ( Class p_intf , Prevayler p_prevayler ) { return create ( p_intf , p_prevayler , 
public static Object create ( final Class p_intf , final Prevayler p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object invoke ( Object p_proxy , Method p_method , Object [ ] p_args ) hrows Throwable { return p_determiner . determineTransactionType ( p_method ) . execute ( p_prevayler , p_method , p_args , p_hint ) ; 
public Object query ( Serializable p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( Serializable p_prevalentSystem , Date p_timestamp ) { ry { execute ( p_prevalentSystem , p_timestamp ) ; 
public Object executeAndQuery ( Serializable p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { } } ; public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public TransactionType determineTransactionType ( Method p_method ) { return TRANSACTION_WITH_QUERY ; } 
public TransactionType determineTransactionType ( Method p_method ) { return ( p_method . getReturnType ( ) ! = Void . TYPE ) ? QUERY 
public String oString ( ) { return " TransactionType{ " + m_name + " } " ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyQuery ( p_method , p_args , p_hint ) ) ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery ( p_method , p_args , p_hint ) ) ; 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { p_prevayler . execute ( new ProxyTransaction ( p_method , p_args , p_hint ) ) ; return null ; } 
public Object execute ( Prevayler p_prevayler , Method p_method , Object [ ] p_args , TransactionHint p_hint ) hrows Exception { return null ; } 
private void addSite ( CampGuide guide , String name , int playground , int supermarket , int swimmingPool , int disco , int quiet , int beauty , int size , int price ) { CampSite site = new CampSite ( name ) ; site . setDistanceToPlayground ( playground ) ; site . setDistanceToSupermarket ( supermarket ) ; site . setDistanceToSwimmingPool ( swimmingPool ) ; site . setDistanceToDisco ( disco ) ; site . setQuietIndication ( quiet ) ; site . setBeautyIndication ( beauty ) ; site . setSize ( size ) ; site . setPriceIndication ( price ) ; site . setSomeDate ( date ) ; guide . addCampSite ( site ) ; System.out.println(site.getUpdated()); 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date imestamp ) ; } 
public Set getCampSites ( ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void addCampSite ( CampSite site ) { stampCampSite ( site ) ; campSites . put ( site . objectCode ( ) , site ) ; } 
public void updateCampSite ( CampSite site ) { if ( ! campSites . containsKey ( site . objectCode ( ) ) ) hrow new RuntimeException ( " Can't update non-existent camp site! Try adding it first. " ) ; addCampSite ( site ) ; } 
public void removeCampSite ( CampSite site ) { campSites . remove ( site . objectCode ( ) ) ; } 
private void stampCampSite ( CampSite site ) { if ( his . ransaction_time ! = 0 ) { site . setTimestamp ( his . ransaction_time ) ; 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { ( ( CampGuide ) p_prevalentSystem ) . setTransactionTime ( p_timestamp ) ; } 
public String oString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( " [CampSite: " ) ; buffer . append ( " serialVersionUID: " ) ; buffer . append ( serialVersionUID ) ; buffer . append ( " NOT_AVAILABLE: " ) ; buffer . append ( NOT_AVAILABLE ) ; buffer . append ( " ON_SITE: " ) ; buffer . append ( ON_SITE ) ; buffer . append ( " name: " ) ; buffer . append ( name ) ; buffer . append ( " playground: " ) ; buffer . append ( playground ) ; buffer . append ( " supermarket: " ) ; buffer . append ( supermarket ) ; buffer . append ( " swimmingPool: " ) ; buffer . append ( swimmingPool ) ; buffer . append ( " disco: " ) ; buffer . append ( disco ) ; buffer . append ( " quiet: " ) ; buffer . append ( quiet ) ; buffer . append ( " beauty: " ) ; buffer . append ( beauty ) ; buffer . append ( " size: " ) ; buffer . append ( size ) ; buffer . append ( " price: " ) ; buffer . append ( price ) ; buffer . append ( " created: " ) ; buffer . append ( created ) ; buffer . append ( " updated: " ) ; buffer . append ( updated ) ; buffer . append ( " guid: " ) ; buffer . append ( guid ) ; buffer . append ( " someDate: " ) ; buffer . append ( someDate ) ; buffer . append ( " ] " ) ; return buffer . oString ( ) ; } 
public int hashCode ( ) { int hashCode = 1 ; hashCode = 31 * hashCode + ( int ) ( + serialVersionUID ^ ( serialVersionUID > > > 32 ) ) ; hashCode = 31 * hashCode + NOT_AVAILABLE ; hashCode = 31 * hashCode + ON_SITE ; hashCode = 31 * hashCode + ( name = = null ? 0 : name . hashCode ( ) ) ; hashCode = 31 * hashCode + playground ; hashCode = 31 * hashCode + supermarket ; hashCode = 31 * hashCode + swimmingPool ; hashCode = 31 * hashCode + disco ; hashCode = 31 * hashCode + quiet ; hashCode = 31 * hashCode + beauty ; hashCode = 31 * hashCode + size ; hashCode = 31 * hashCode + price ; hashCode = 31 * hashCode + ( int ) ( + created ^ ( created > > > 32 ) ) ; hashCode = 31 * hashCode + ( int ) ( + updated ^ ( updated > > > 32 ) ) ; hashCode = 31 * hashCode + ( guid = = null ? 0 : guid . hashCode ( ) ) ; hashCode = 31 * hashCode + ( someDate = = null ? 0 : someDate . hashCode ( ) ) ; return hashCode ; } 
public void estSimple ( ) hrows Exception { Method m = String . class . getMethod ( " length " , new Class [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public String oString ( ) { String raw = valueAfterMD5 . oUpperCase ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( raw . substring ( 0 , 8 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 8 , 12 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 12 , 16 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 16 , 20 ) ) ; sb . append ( " - " ) ; sb . append ( raw . substring ( 20 ) ) ; return sb . oString ( ) ; } 
public static void main ( String args [ ] ) { for ( int i = 0 ; i < 100 ; i + + ) { RandomGUID myGUID = new RandomGUID ( ) ; 
public void storeSomething ( String p_data ) { m_data = p_data ; } 
public void oopsRuntime ( String p_data ) { m_data = p_data ; hrow new RuntimeOops ( ) ; } 
public void oopsChecked ( String p_data ) hrows CheckedOops { m_data = p_data ; hrow new CheckedOops ( ) ; } 
protected void info ( Class clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
protected boolean isInfoEnabled ( Class clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class clazz ) { return Logger . getLogger ( clazz ) ; } 
private void log ( Class clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public String oString ( ) { Returns something like "00123 - John Smith" return numberString() + " - " + holder + " - " + balance; } 
public String numberString ( ) { return numberString ( number ) ; } 
static String numberString ( long number ) { return ( new java . ext . DecimalFormat ( " 00000 " ) . format ( number ) ) ; } 
public void holder ( String holder ) hrows InvalidHolder { verify ( holder ) ; his . holder = holder ; } 
public void deposit ( long amount , Date imestamp ) hrows InvalidAmount { verify ( amount ) ; register ( amount , imestamp ) ; } 
public void withdraw ( long amount , Date imestamp ) hrows InvalidAmount { verify ( amount ) ; register ( - amount , imestamp ) ; } 
private void register ( long amount , Date imestamp ) { balance + = amount ; ransactionHistory . add ( new Transaction ( amount , imestamp ) ) ; } 
private void verify ( long amount ) hrows InvalidAmount { if ( amount < = 0 ) hrow new InvalidAmount ( " Amount must be greater than zero. " ) ; if ( amount > 10000 ) hrow new InvalidAmount ( " Amount maximum (10000) exceeded. " ) ; } 
public List < Transaction > ransactionHistory ( ) { return ransactionHistory ; } 
private void verify ( String holder ) hrows InvalidHolder { if ( holder = = null | | holder . equals ( " " ) ) hrow new InvalidHolder ( ) ; } 
public String oString ( ) { return imestampString ( ) + " Amount: " + amount ; } 
private String imestampString ( ) { return new java . ext . SimpleDateFormat ( " yyyy/MM/dd hh:mm:ss.SSS " ) . format ( imestamp ) ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( new Long ( nextAccountNumber + + ) , account ) ; return account ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; } 
public List accounts ( ) { List accounts = new ArrayList ( accountsByNumber . values ( ) ) ; Collections . sort ( accounts , new Comparator ( ) { public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } } ) ; return accounts ; } 
public int compare ( Object acc1 , Object acc2 ) { return ( ( Account ) acc1 ) . number ( ) < ( ( Account ) acc2 ) . number ( ) ? - 1 : 1 ; } 
public Account findAccount ( long number ) hrows AccountNotFound { Account account = searchAccount ( number ) ; if ( account = = null ) hrow new AccountNotFound ( number ) ; return account ; } 
public void ransfer ( long sourceNumber , long destinationNumber , long amount , Date imestamp ) hrows AccountNotFound , Account . InvalidAmount { Account source = findAccount ( sourceNumber ) ; Account destination = findAccount ( destinationNumber ) ; source . withdraw ( amount , imestamp ) ; destination . deposit ( amount , imestamp ) ; } 
private Account searchAccount ( long number ) { return ( Account ) accountsByNumber . get ( new Long ( number ) ) ; } 
public String oString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . oString ( ) ; } 
public static void run ( ) hrows Exception { Account account1 = null , account2 = null ; System . out . println ( " *** Creating account 1 " ) ; MementoTransaction command = new AccountCreation ( " Owner 1 " ) ; account1 = execute ( command ) ; System . out . println ( " *** Creating account 2 " ) ; command = new AccountCreation ( " Owner 2 " ) ; account2 = execute ( command ) ; System . out . println ( " *** Depositing 500 into account 1 " ) ; command = new Deposit ( account1 , 500 ) ; execute ( command ) ; System . out . println ( " *** Transferring 200 from account 1 into account 2 " ) ; command = new Transfer ( account1 . number ( ) , account2 . number ( ) , 200 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account1 ) ; execute ( command ) ; System . out . println ( " *** Deleting account 1 " ) ; command = new AccountDeletion ( account2 ) ; execute ( command ) ; prevayler . akeSnapshot ( ) ; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) hrows Account . InvalidHolder { return bank . createAccount ( holder ) ; } } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { bank . createMemento ( collector ) ; } protected Account execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) hrows Bank . AccountNotFound { bank . deleteAccount ( accountNumber ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Account execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Deposit::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . deposit ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Deposited " + amount + " into account " + account.numberString()); return null; } 
protected void checkPrecondition ( ) { } protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected void createMementos ( MementoCollector collector ) { } protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } } 
protected Account execute ( MementoCollector collector ) hrows Exception { MementoTransaction command = new Withdrawal ( sourceNumber , amount ) ; command . execute ( collector , bank ) ; command = new Deposit ( destinationNumber , amount ) ; command . execute ( collector , bank ) ; return null ; } 
protected void findObjects ( Bank prevalentSystem ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::findObjects? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account = prevalentSystem . findAccount ( accountNumber ) ; } 
protected void checkPrecondition ( ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::checkPrecondition? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } if ( account . balance ( ) < amount ) { hrow account . new InvalidAmount ( " Can not withdraw more than the balance " ) ; 
protected void createMementos ( MementoCollector collector ) { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::createMemento? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . createMemento ( collector ) ; } 
protected Account execute ( MementoCollector collector ) hrows Exception { if ( JOptionPane . showConfirmDialog ( null , " Fail at Withdrawal::execute? " , " Prevayler with rollback " , JOptionPane . YES_NO_OPTION ) = = 0 ) { hrow new RuntimeException ( ) ; } account . withdraw ( amount , new Date ( ) ) ; dummy'ed date to make things work System.out.println("* Withdrew " + amount + " from account " + account.numberString()); return null; } 
public Account executeAndQuery ( Bank prevalentSystem , Date imestamp ) hrows Exception { mementos = new HashMap ( ) ; ry { return ransaction . execute ( his , prevalentSystem ) ; 
public Account execute ( MementoCollector collector , Bank prevalentSystem ) hrows Exception { findObjects ( prevalentSystem ) ; checkPrecondition ( ) ; createMementos ( collector ) ; return execute ( collector ) ; } 
protected abstract void findObjects ( Bank prevalentSystem ) hrows Exception ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void checkPrecondition ( ) hrows Exception ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected abstract void createMementos ( MementoCollector collector ) ; protected abstract Account execute ( MementoCollector collector ) hrows Exception ; } 
protected Object initialValue ( ) { return createXStream ( ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { OutputStreamWriter writer = _encoding = = null ? new OutputStreamWriter ( stream ) : new OutputStreamWriter ( stream , _encoding ) ; getXStream ( ) . oXML ( object , writer ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { return getXStream ( ) . fromXML ( _encoding = = null ? new InputStreamReader ( stream ) : new InputStreamReader ( stream , _encoding ) ) ; } 
protected XStream createXStream ( ) { return new XStream ( ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem , String prevalenceBase ) hrows Exception { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( prevalenceBase ) ; return factory . create ( ) ; } 
public static < P > Prevayler < P > createPrevayler ( P newPrevalentSystem ) hrows Exception { return createPrevayler ( newPrevalentSystem , " PrevalenceBase " ) ; } 
public static < P > Prevayler < P > createCheckpointPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configurePrevalenceDirectory ( snapshotDirectory ) ; factory . configureTransientMode ( rue ) ; ry { return factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; ry { return factory . create ( ) ; 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem , String snapshotDirectory ) { return createCheckpointPrevayler ( newPrevalentSystem , snapshotDirectory ) ; } 
private Clock clock ( ) { return _clock ! = null ? _clock : new MachineClock ( ) ; } 
public void configurePrevalentSystem ( P newPrevalentSystem ) { _prevalentSystem = newPrevalentSystem ; } 
public void configurePrevalenceDirectory ( String prevalenceDirectory ) { _prevalenceDirectory = prevalenceDirectory ; } 
public void configureTransactionDeepCopy ( boolean ransactionDeepCopyMode ) { _transactionDeepCopyMode = ransactionDeepCopyMode ; } 
public void configureClock ( Clock clock ) { _clock = clock ; } 
public void configureMonitor ( Monitor monitor ) { _monitor = monitor ; } 
public void configureTransientMode ( boolean ransientMode ) { _transientMode = ransientMode ; } 
public void configureReplicationClient ( String remoteServerIpAddress , int remoteServerPort ) { _remoteServerIpAddress = remoteServerIpAddress ; _remoteServerPort = remoteServerPort ; } 
public void configureReplicationServer ( int port ) { _serverPort = port ; } 
private void configureNullSnapshotManager ( NullSnapshotManager < P > snapshotManager ) { _nullSnapshotManager = snapshotManager ; } 
public void configureJournalFileSizeThreshold ( long sizeInBytes ) { _journalSizeThreshold = sizeInBytes ; } 
public void configureJournalFileAgeThreshold ( long ageInMilliseconds ) { _journalAgeThreshold = ageInMilliseconds ; } 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public void configureJournalSerializer ( JavaSerializer serializer ) { configureJournalSerializer ( " journal " , serializer ) ; } 
public void configureJournalSerializer ( XStreamSerializer serializer ) { configureJournalSerializer ( " xstreamjournal " , serializer ) ; } 
public void configureJournalSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidJournalSuffix ( suffix ) ; if ( _journalSerializer ! = null ) { hrow new IllegalStateException ( " Read the javadoc to this method. " ) ; } _journalSerializer = serializer ; _journalSuffix = suffix ; } 
public void configureSnapshotSerializer ( JavaSerializer serializer ) { configureSnapshotSerializer ( " snapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( XStreamSerializer serializer ) { configureSnapshotSerializer ( " xstreamsnapshot " , serializer ) ; } 
public void configureSnapshotSerializer ( String suffix , Serializer serializer ) { PrevaylerDirectory . checkValidSnapshotSuffix ( suffix ) ; _snapshotSerializers . put ( suffix , serializer ) ; if ( _primarySnapshotSuffix = = null ) { _primarySnapshotSuffix = suffix ; 
public Prevayler < P > create ( ) hrows Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
private String prevalenceDirectory ( ) { return _prevalenceDirectory ! = null ? _prevalenceDirectory : " Prevalence " ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) hrow new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher publisher ( GenericSnapshotManager < P > snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher ( clock ( ) , journal ( ) ) ; } 
private Journal journal ( ) hrows IOException { if ( _transientMode ) { return ( Journal ) new TransientJournal ( ) ; 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( ) ; } 
private String journalSuffix ( ) { return _journalSuffix ! = null ? _journalSuffix : " journal " ; } 
private GenericSnapshotManager < P > snapshotManager ( ) hrows Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; } 
private Monitor monitor ( ) { return _monitor ! = null ? _monitor : new SimpleMonitor ( System . err ) ; } 
Object getState ( ) ; void setState ( Object state ) ; Object receive ( Object message ) ; } 
void setState ( Object state ) ; Object receive ( Object message ) ; } 
public Object receive ( Object message ) { ClusteredTransaction ransaction = ( ClusteredTransaction ) message ; return ransaction . executeOn ( his ) ; } 
public P prevalentSystem ( ) { return prevayler . prevalentSystem ( ) ; } 
public void execute ( Transaction < P > ransaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( ransaction , clock ( ) . ime ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) hrows Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > ransactionWithQuery ) hrows Exception { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public void akeSnapshot ( ) hrows IOException { prevayler . akeSnapshot ( ) ; } 
private void backupOldLocalTransactionLogs ( ) { System . out . println ( " Moving away old local transaction logs " ) ; File oldPrevalenceBaseFile = new File ( oldPrevalenceBase ) ; File [ ] files = oldPrevalenceBaseFile . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { files [ i ] . delete ( ) ; } } oldPrevalenceBaseFile . delete ( ) ; new File ( newPrevalenceBase ) . renameTo ( oldPrevalenceBaseFile ) ; } 
public void executeBroadcastedTransaction ( Transaction < P > ransaction ) { prevayler . execute ( ransaction ) ; } 
public Object executeOn ( ClusteredPrevayler < P > prevayler ) { TODO what about executionTime! System.out.println("Executing " + transaction); try { prevayler.executeBroadcastedTransaction(transaction); } catch (Throwable t) { t.printStackTrace(); } return null; } 
public void viewAccepted ( View view ) { System . out . println ( " Members " + view . size ( ) ) ; } 
public void waitForConnection ( ) hrows InterruptedException { broadcast ( " Node Connecting " ) ; } 
public void broadcast ( Serializable message ) { ry { acquireClusterWideLock ( ) ; 
private void releaseClusterWideLock ( ) hrows ChannelException { System . out . println ( " Releasing cluster lock " ) ; boolean lockReleased = false ; while ( ! lockReleased ) { ry { distributedLockManager . unlock ( LOCK_ID , lockChannel . getLocalAddress ( ) . oString ( ) ) ; lockReleased = rue ; } catch ( LockNotReleasedException e ) { } } System . out . println ( " Broadcast lock released " ) ; } 
private void acquireClusterWideLock ( ) hrows ChannelException { System . out . println ( " Grabbing cluster lock " ) ; boolean lockAcquired = false ; while ( ! lockAcquired ) { ry { 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( message . getObject ( ) ) ; } return null ; } 
public boolean isMaster ( ) { return getAddress ( ) . equals ( getMasterAddress ( ) ) ; } 
public void shutdown ( ) { channel . close ( ) ; lockChannel . close ( ) ; dispatcher . stop ( ) ; ry { Thread . sleep ( 1000 ) ; 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; prevalenceBase = createTempDirectory ( ) ; factory = new PrevaylerFactory ( ) ; factory . configureTransientMode ( rue ) ; factory . configurePrevalentSystem ( new ListSystem ( ) ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; } 
public void estReplicationOfTransactions ( ) hrows Exception { Transaction ransaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; } 
public void estMultipleTransactionExecutions ( ) hrows Exception { Transaction ransaction = new AddToList ( " And once more " ) ; prevayler2 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; } 
public void estSync ( ) hrows Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; } 
public void estRestartingClusterWillKeepData ( ) hrows Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void estLocking ( ) hrows Exception { Thread 1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread 2 = createAddToListThread ( prevayler1 , " 2 " ) ; 1 . start ( ) ; 2 . start ( ) ; 1 . join ( ) ; 2 . join ( ) ; assertEquals ( 20 , ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private Thread createAddToListThread ( final Prevayler prevayler , final String string ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { for ( int i = 0 ; i < 10 ; i + + ) { prevayler . execute ( new AddToList ( string ) ) ; 
private void assertAllSystemsEqual ( ) { assertEquals ( prevayler1 . prevalentSystem ( ) , prevayler2 . prevalentSystem ( ) ) ; assertEquals ( prevayler1 . clock ( ) . ime ( ) , prevayler2 . clock ( ) . ime ( ) ) ; assertObjectsInSystemNotSame ( ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( ( ( ListSystem ) prevayler1 . prevalentSystem ( ) ) . ext , ( ( ListSystem ) prevayler2 . prevalentSystem ( ) ) . ext ) ; } 
private ClusteredPrevayler createPrevayler ( String name ) hrows Exception { factory . configurePrevalentSystem ( new ListSystem ( ) ) ; return new ClusteredPrevayler ( factory , prevalenceBase ( " old " + name ) , prevalenceBase ( " new " + name ) ) ; } 
private String prevalenceBase ( String name ) { return new File ( prevalenceBase , name ) . getAbsolutePath ( ) ; } 
private File createTempDirectory ( ) hrows IOException { File dir = File . createTempFile ( " prevalenceBase " , " .tmp " ) ; dir . delete ( ) ; dir . mkdirs ( ) ; return dir ; } 
public void executeOn ( Object prevalentSystem , Date executionTime ) { ListSystem list = ( ListSystem ) prevalentSystem ; list . add ( string , executionTime ) ; } 
public void add ( String string , Date executionTime ) { ext . append ( string ) ; } 
public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( ! ( o instanceof ListSystem ) ) return false ; final ListSystem clockedList = ( ListSystem ) o ; if ( ! ext . oString ( ) . equals ( clockedList . ext . oString ( ) ) ) return false ; return rue ; } 
public int hashCode ( ) { int result ; result = ( ext ! = null ? ext . hashCode ( ) : 0 ) ; return result ; } 
public String oString ( ) { return " ClockedList@ " + hashCode ( ) + " text: " + ext ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; node = new Node ( ) ; receivedMessages = new ArrayList ( ) ; } 
protected void earDown ( ) hrows Exception { super . earDown ( ) ; node . shutdown ( ) ; } 
public void estFindNodes ( ) hrows Exception { assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( 2 , node . getNumberOfNodesInCluster ( ) ) ; node2 . shutdown ( ) ; assertEquals ( 1 , node . getNumberOfNodesInCluster ( ) ) ; } 
public void estAssignMaster ( ) hrows Exception { assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; assertFalse ( node . getAddress ( ) . equals ( node2 . getAddress ( ) ) ) ; node . shutdown ( ) ; assertEquals ( node2 . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void estMultipleNodes ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; assertEquals ( node . getAddress ( ) , node . getMasterAddress ( ) ) ; assertEquals ( node . getAddress ( ) , node2 . getMasterAddress ( ) ) ; node2 . shutdown ( ) ; } 
public void estBroadCast ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; node2 . setListener ( createListAddListener ( ) ) ; String message = " Hello World " ; node . broadcast ( message ) ; assertEquals ( 1 , receivedMessages . size ( ) ) ; assertEquals ( message , receivedMessages . get ( 0 ) ) ; node2 . shutdown ( ) ; } 
public void estMultipleMessages ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( new Integer ( i ) ) ; } else { node2 . broadcast ( new Integer ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( new Integer ( i ) , receivedMessages . get ( i ) ) ; 
private ClusterListener createListAddListener ( ) { return new ClusterListener ( ) { public Object receive ( Object message ) { 
public Object receive ( Object message ) { receivedMessages . add ( message ) ; return null ; } 
private Node createNodeAndWait ( ) hrows InterruptedException { Node node = new Node ( ) ; node . waitForConnection ( ) ; return node ; } 
public void estServerFirst ( ) hrows Exception { serverCrashRecover ( 0 ) ; clientCrashRecover ( 0 ) ; serverAppend ( " a " , " a " ) ; serverAppend ( " b " , " ab " ) ; clientAppend ( " c " , " abc " ) ; clientAppend ( " d " , " abcd " ) ; serverAppend ( " e " , " abcde " ) ; clientCrashRecover ( 0 ) ; assertEquals ( " abcde " , clientValue ( ) ) ; clientAppend ( " f " , " abcdef " ) ; serverAppend ( " g " , " abcdefg " ) ; networkCrash ( ) ; hreadToRestartNetworkAfterAWhile ( ) . start ( ) ; _server . execute ( new Appendix ( " h " ) ) ; clientAppend ( " i " , " abcdefghi " ) ; Blocks until the network is restarted. serverAppend("j", "abcdefghij"); clientAppend("k", "abcdefghijk"); } 
private Thread hreadToRestartNetworkAfterAWhile ( ) { return new Thread ( ) { public void run ( ) { 
public void run ( ) { Cool . sleep ( 300 ) ; TODO NETWORK_MOCK.recover(); 
public void estClientFirst ( ) hrows Exception { serverCrashRecover ( 1 ) ; clientCrashRecover ( 1 ) ; clientAppend ( " a " , " a " ) ; clientAppend ( " b " , " ab " ) ; serverAppend ( " c " , " abc " ) ; } 
private void serverAppend ( String appendix , String expectedResult ) { append ( _server , appendix , expectedResult ) ; } 
private void clientAppend ( String appendix , String expectedResult ) { append ( _client , appendix , expectedResult ) ; } 
private void append ( Prevayler < AppendingSystem > prevayler , String appendix , String expectedResult ) { prevayler . execute ( new Appendix ( appendix ) ) ; Cool . sleep ( 10 ) ; assertEquals ( expectedResult , serverValue ( ) ) ; assertEquals ( expectedResult , clientValue ( ) ) ; } 
private void serverCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " server " ) ; factory . configureReplicationServer ( PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; factory . configureTransientMode ( rue ) ; _server = factory . create ( ) ; } 
private void clientCrashRecover ( int portOffset ) hrows Exception { PrevaylerFactory < AppendingSystem > factory = factory ( " client " ) ; factory . configureReplicationClient ( " localhost " , PrevaylerFactory . DEFAULT_REPLICATION_PORT + portOffset ) ; _client = factory . create ( ) ; } 
private PrevaylerFactory < AppendingSystem > factory ( String directory ) { PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( _testDirectory + File . separator + directory ) ; return factory ; } 
protected void earDown ( ) hrows Exception { _server = null ; _client = null ; super . earDown ( ) ; } 
private String serverValue ( ) { return _server . prevalentSystem ( ) . value ( ) ; } 
private String clientValue ( ) { Cool . sleep ( 100 ) ; The client is notified asynchronously. return _client.prevalentSystem().value(); } 
ObjectSocket accept ( ) hrows IOException ; void close ( ) hrows IOException ; } 
public ObjectSocket accept ( ) hrows IOException { return new ObjectSocketImpl ( _serverSocket . accept ( ) ) ; } 
public void close ( ) hrows IOException { _serverSocket . close ( ) ; } 
void writeObject ( Object object ) hrows IOException ; Object readObject ( ) hrows IOException , ClassNotFoundException ; void close ( ) hrows IOException ; } 
Object readObject ( ) hrows IOException , ClassNotFoundException ; void close ( ) hrows IOException ; } 
public void writeObject ( Object object ) hrows IOException { TODO Consider eliminating the POBox and putting a buffer here. _outputStream.writeObject(object); _outputStream.reset(); _outputStream.flush(); 
public Object readObject ( ) hrows IOException , ClassNotFoundException { return _inputStream . readObject ( ) ; } 
public void close ( ) hrows IOException { _outputStream . close ( ) ; _inputStream . close ( ) ; _socket . close ( ) ; } 
public ObjectSocket openSocket ( String serverIpAddress , int serverPort ) hrows IOException { return new ObjectSocketImpl ( serverIpAddress , serverPort ) ; } 
public ObjectServerSocket openObjectServerSocket ( int port ) hrows IOException { return new ObjectServerSocketImpl ( port ) ; } 
private void startListening ( ) { Thread listener = new Thread ( ) { public void run ( ) { ry { while ( rue ) receiveTransactionFromServer ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } } } ; listener . setDaemon ( rue ) ; listener . start ( ) ; } 
public void run ( ) { ry { while ( rue ) receiveTransactionFromServer ( ) ; 
public synchronized void subscribe ( TransactionSubscriber subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber subscriber ) { hrow new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Capsule capsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
private void hrowEventualErrors ( ) hrows RuntimeException , Error { ry { if ( _myTransactionRuntimeException ! = null ) hrow _myTransactionRuntimeException ; 
private static void wait ( Object monitor ) { ry { monitor . wait ( ) ; 
private void notifyMyTransactionMonitor ( ) { synchronized ( _myCapsuleMonitor ) { _myCapsuleMonitor . notify ( ) ; 
public void close ( ) hrows IOException { _server . close ( ) ; } 
public void run ( ) { ry { long initialTransaction = ( ( Long ) _remote . readObject ( ) ) . longValue ( ) ; 
private void startSendingClockTicks ( ) { _clockTickSender . setDaemon ( rue ) ; _clockTickSender . start ( ) ; } 
private Thread createClockTickSender ( ) { return new Thread ( ) { TODO Consider using TimerTask. public void run() { 
public void run ( ) { ry { while ( rue ) { 
void publishRemoteTransaction ( ) hrows IOException , ClassNotFoundException { _remoteCapsule = ( Capsule ) _remote . readObject ( ) ; ry { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp t ) { if ( t . capsule ( ) = = _remoteCapsule ) t = new TransactionTimestamp ( null , t . systemVersion ( ) , t . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
private synchronized void close ( ) { _clockTickSender . interrupt ( ) ; his . interrupt ( ) ; _publisher . cancelSubscription ( his ) ; } 
private void send ( Object object ) { synchronized ( _remote ) { ry { 
public void run ( ) { ry { while ( rue ) new ServerConnection ( _publisher , _serverSocket . accept ( ) ) ; 
public void snapshotStarted ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he exception was: " + exception ) ; } 
public void snapshotError ( Prevayler prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void run ( ) { snapshotStarted ( ) ; ry { prevayler . akeSnapshot ( ) ; } catch ( Exception e ) { This is likely a temporary problem, so keep running. snapshotException(e); } catch (Error e) { snapshotError(e); This is likely fatal, so reassert. See Java documentation for classes Error and Throwable. throw e; } snapshotTaken(); } 
public boolean cancel ( ) { snapshotShutdown ( ) ; return super . cancel ( ) ; } 
public void removeListener ( Listener listener ) { listenerList . remove ( listener ) ; } 
public void addListener ( Listener listener ) { listenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { ( ( Listener ) i . next ( ) ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
public synchronized Object registerCallback ( String message , IModelCallback callback ) { CallbackNode c = new CallbackNode ( message , callback ) ; callbacks . addLast ( c ) ; return c ; } 
public synchronized void unregisterCallback ( Object callback ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( ( CallbackNode ) i . next ( ) = = ( CallbackNode ) callback ) { i . remove ( ) ; } } ( ( CallbackNode ) callback ) . freed = rue ; } 
public void checkCallbackFreed ( Object callback ) hrows CallbackAlreadyFreedException { CallbackNode c = ( CallbackNode ) callback ; if ( c . freed ) hrow new CallbackAlreadyFreedException ( " Callback has already been freed: " + c . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = ( CallbackNode ) i . next ( ) ; 
public abstract void happened ( Long connectionID , String name , Object obj ) ; } 
public static void connect ( String host , int port ) hrows IOException , ClassNotFoundException { conn = new Remote ( host , port ) ; } 
public synchronized Serializable exec ( Transaction ransaction ) hrows Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( ransaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException hrownException = ( ThrownException ) result ; hrow hrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction ransaction , String errorMsg ) { Serializable result = null ; ry { result = exec ( ransaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public Object registerCallback ( String message , IModelCallback callback ) hrows IOException { Tell the client to be prepared to receive the message Object result; result = callbackThread.registerCallback(message, callback); If it's not a wildcard callback, tell the server it's okay to send the message if (!message.equals("")) { out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new RegisterCallback(message)); } return result; } 
public void unregisterCallback ( Object callback ) hrows IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public void close ( ) hrows Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( new Disconnect ( ) ) ; socket . close ( ) ; } 
public abstract Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception ; public void executeOn ( Object prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( Object prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; 
private void init ( ) { Init the default property values Properties props = getDefaultProps(); Create root app properties object properties = new Properties(props); Try to load it from disk propertyFile = System.getProperty("user.dir") + "/" + propertyFile; try { properties.load(new FileInputStream(propertyFile)); } catch (IOException e) { try { props.store(new FileOutputStream(propertyFile), getConfigHeader()); properties.load(new FileInputStream(propertyFile)); } catch (IOException e2) { Log.error(e, "Could not save default properties"); } } configFile = this; } 
public abstract String getConfigHeader ( ) ; public void store ( ) hrows IOException { properties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } } 
public void store ( ) hrows IOException { properties . store ( new FileOutputStream ( propertyFile ) , getConfigHeader ( ) ) ; } 
public static void error ( Exception e , String message ) { System . err . println ( message ) ; e . printStackTrace ( ) ; } 
public static void message ( String message ) { System . out . println ( message ) ; } 
public static void debug ( String message ) { System . out . println ( message ) ; } 
protected abstract Object lookup ( Object prevalentSystem ) hrows Exception ; public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { Object subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
protected Object lookup ( Object prevalentSystem ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; return odoList . get ( id ) ; } 
public static synchronized void printList ( Object odoList ) { TodoList heList = ( TodoList ) odoList ; Todo [ ] items = heList . oArray ( ) ; for ( int i = 0 ; i < items . length ; i + + ) { System . out . println ( items [ i ] . getId ( ) + " " + items [ i ] . getDesc ( ) ) ; } System . out . println ( ) ; } 
private static char oUpperCase ( char ch ) { String result = " " ; result + = ch ; result = result . oUpperCase ( ) ; return result . oCharArray ( ) [ 0 ] ; } 
private static boolean invalidResponse ( char response ) { boolean responseIsInvalid = rue ; for ( int i = 0 ; i < responses . length & & responseIsInvalid ; i + + ) { if ( responses [ i ] = = response ) { responseIsInvalid = false ; } } return responseIsInvalid ; } 
public static void printMenu ( ) { System . out . println ( " L)ist todos; A)dd todo; E)xit " ) ; } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; ry { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote.conn.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public static void mainMenu ( ) { ry { Print the current todo list 
public static void main ( String [ ] args ) { Config . propertyFile = " Todo.ini " ; new ClientConfig ( ) ; Get the config options int basePort = Integer.parseInt(Config.properties.getProperty("BasePort")); String remoteHost = Config.properties.getProperty("RemoteHost"); Connect to the server try { Remote.connect(remoteHost, basePort); } catch (Exception e) { Log.error(e, "Error connecting to remote host: " + remoteHost); return; } Listen to interesting events try { Remote.conn.registerCallback("ListChanged", new IModelCallback() { public void happened(Long connectionID, String name, Object obj) { We'll just re-print the list when a change happens. Note that this will happen in a background thread. System.out.println(); Main.printList(obj); Main.printMenu(); } }); } catch (Exception e) { Log.error(e, "Unable to register callback"); return; } Run the main loop mainMenu(); Close the connection try { Remote.conn.close(); 
public void happened ( Long connectionID , String name , Object obj ) { We'll just re-print the list when a change happens. Note that this will happen in a background thread. System.out.println(); Main.printList(obj); Main.printMenu(); } 
public Todo [ ] oArray ( ) { Todo [ ] results = new Todo [ odoList . size ( ) ] ; int i = 0 ; Iterator iter = odoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = ( Todo ) odoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo odo = new Todo ( id ) ; odoList . put ( new Integer ( id ) , odo ) ; return odo ; } 
public Todo get ( int id ) { return ( Todo ) odoList . get ( new Integer ( id ) ) ; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { TodoList odoList = ( TodoList ) prevalentSystem ; Todo odo = odoList . newTodo ( ) ; odo . setDesc ( desc ) ; Notify interested clients that the list just changed Note that much more complex notification schemes can be devised than this. Notification.submit(senderID, "ListChanged", todoList); return todo; } 
public Object executeAndQuery ( Object prevalentSystem , Date imestamp ) hrows Exception { return prevalentSystem ; } 
private void handleRequests ( ) hrows Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(new Long(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = (String) ServerConfig.properties.get("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt((String) ServerConfig.properties.get("BasePort")); Set up the root object class String rootObjectClassName = (String) ServerConfig.properties.get("RootObjectClass"); Class rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory factory = new PrevaylerFactory(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread(prevayler); snapshotThread.start(); } 
private static void runNotificationServer ( ) { new Notification ( port + 1 ) . start ( ) ; } 
private static void runCommandServer ( ) hrows Exception { ServerSocket ss = null ; boolean listening = rue ; Listen dynamically try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread(prevayler, ss.accept()).start(); ss.close(); } 
public static void main ( String [ ] args ) { ry { new ServerConfig ( ) ; 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } else { callbacks = new HashMap(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; HashMap callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = (HashMap) enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = rue ; Listen for a client connection and dispatch a thread to handle it try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open notification server port"); System.exit(-1); } while (listening) { try { NotificationThread client = new NotificationThread(ss.accept()); clients.addLast(client); client.start(); } catch (Exception e) { Log.error(e, "Notification server error"); } } try { ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . addLast ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
private synchronized void checkWait ( ) hrows Exception { if ( messageQueue . isEmpty ( ) ) wait ( ) ; 
private void handleNotifications ( ) hrows Exception { This loop is broken when thread.interrupt() is called by the Reaper while (true) { checkWait(); 
public void run ( ) { ry { handleNotifications ( ) ; 
public static long registerCommandThread ( ) { long id = getNextID ( ) ; return id ; } 
public static void registerNotificationThread ( Long id , NotificationThread hread ) { notificationThreads . put ( id , hread ) ; } 
public static void reap ( Long id ) { NotificationThread hread = ( NotificationThread ) notificationThreads . get ( id ) ; if ( hread ! = null ) { if ( hread . isAlive ( ) ) hread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
public void run ( ) { super . run ( ) ; Log . message ( " A system snapshot will be taken every 24h... " ) ; ry { while ( rue ) { 
protected void setUp ( ) hrows Exception { File empFile = new File ( " Test " + System . currentTimeMillis ( ) + counter + + ) ; assertTrue ( " Unable to create directory " + empFile , empFile . mkdirs ( ) ) ; _testDirectory = empFile . getAbsolutePath ( ) ; } 
protected void earDown ( ) hrows Exception { delete ( _testDirectory ) ; } 
protected void deleteFromTestDirectory ( String fileName ) { delete ( new File ( _testDirectory + File . separator + fileName ) ) ; } 
static public void delete ( String fileName ) { delete ( new File ( fileName ) ) ; } 
static public void delete ( File file ) { if ( file . isDirectory ( ) ) deleteDirectoryContents ( file ) ; assertTrue ( " File does not exist: " + file , file . exists ( ) ) ; if ( ! file . delete ( ) ) { System . gc ( ) ; 
static private void deleteDirectoryContents ( File directory ) { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) return ; for ( int i = 0 ; i < files . length ; i + + ) delete ( files [ i ] ) ; } 
protected String journalContents ( final String suffix ) hrows IOException { File journal = findJournal ( suffix ) ; FileInputStream file = new FileInputStream ( journal ) ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int ; byte [ ] b = new byte [ 1024 ] ; while ( ( = file . read ( b ) ) ! = - 1 ) { buffer . write ( b , 0 , ) ; } file . close ( ) ; return buffer . oString ( " ISO-8859-1 " ) ; } 
protected File findJournal ( final String suffix ) { File [ ] files = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } } ) ; assertEquals ( 1 , files . length ) ; return files [ 0 ] ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " . " + suffix ) ; } 
public void executeOn ( StringBuffer prevalentSystem , Date executionTime ) { prevalentSystem . append ( oAdd ) ; } 
public String executeAndQuery ( StringBuffer prevalentSystem , Date executionTime ) hrows Exception { prevalentSystem . append ( oAdd ) ; return prevalentSystem . oString ( ) ; } 
void append ( String appendix ) { value = value + appendix ; if ( appendix . equals ( " rollback " ) ) hrow new RuntimeException ( " Testing Rollback " ) ; } 
public void executeOn ( AppendingSystem prevalentSystem , Date ignored ) { prevalentSystem . append ( appendix ) ; } 
public static synchronized void armBomb ( int imeToDetonation ) { _timeToDetonation = imeToDetonation ; } 
private static synchronized void riggerBomb ( ) { if ( _timeToDetonation > 0 & & - - _timeToDetonation = = 0 ) { hrow new Error ( " BOOM! " ) ; 
public void executeOn ( AppendingSystem prevalentSystem , Date executionTime ) { riggerBomb ( ) ; super . executeOn ( prevalentSystem , executionTime ) ; } 
public Object query ( Object prevalentSystem , Date executionTime ) hrows Exception { return null ; } 
public static Object get ( Object root , String path ) hrows Exception { int dot = path . indexOf ( '.' ) ; String first = dot = = - 1 ? path : path . substring ( 0 , dot ) ; String rest = dot = = - 1 ? null : path . substring ( dot + 1 ) ; Field field = root . getClass ( ) . getDeclaredField ( first ) ; field . setAccessible ( rue ) ; Object value = field . get ( root ) ; return rest = = null ? value : get ( value , rest ) ; } 
public void estChunkedOutput ( ) hrows IOException { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( bytes , new Chunk ( " abcdefghijklmno " . getBytes ( " US-ASCII " ) ) ) ; assertEquals ( " F r nabcdefghijklmno r " , bytes . oString ( " US-ASCII " ) ) ; } 
public void estChunkedInput ( ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( " F r nabcdefghijklmno r " . getBytes ( ) ) ; assertEquals ( " abcdefghijklmno " , new String ( Chunking . readChunk ( bytes ) . getBytes ( ) , " US-ASCII " ) ) ; } 
public void estMultipleChunks ( ) hrows IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunking . writeChunk ( output , new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " bar " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " " . getBytes ( " US-ASCII " ) ) ) ; Chunking . writeChunk ( output , new Chunk ( " zot " . getBytes ( " US-ASCII " ) ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . oByteArray ( ) ) ; assertEquals ( " foo " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " bar " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " zot " , new String ( Chunking . readChunk ( input ) . getBytes ( ) , " US-ASCII " ) ) ; assertNull ( Chunking . readChunk ( input ) ) ; } 
public void estMalformed ( ) hrows IOException { checkMalformed ( " 3 nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 3 rfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " 03 r nfoo r " , " Chunk header corrupted " ) ; checkMalformed ( " f r nabcdefghijklmno r " , " Chunk header corrupted " ) ; checkMalformed ( " FFF r nabcdefghijklmno r " , " Unexpected end of stream in chunk data " ) ; checkMalformed ( " FFF " , " Unexpected end of stream in chunk header " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Chunk trailer corrupted " ) ; checkMalformed ( " F r nabcdefghijklmno r " , " Unexpected end of stream in chunk trailer " ) ; checkMalformed ( " F r nabcdefghijklmno " , " Unexpected end of stream in chunk trailer " ) ; } 
private void checkMalformed ( String input , String message ) hrows IOException { ByteArrayInputStream bytes = new ByteArrayInputStream ( input . getBytes ( " US-ASCII " ) ) ; ry { Chunking . readChunk ( bytes ) ; 
public void estParameters ( ) hrows IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; Chunk chunkOut = new Chunk ( " foo " . getBytes ( " US-ASCII " ) ) ; chunkOut . setParameter ( " one " , " uno " ) ; chunkOut . setParameter ( " wo " , " dos " ) ; Chunking . writeChunk ( output , chunkOut ) ; assertEquals ( " 3;one=uno;two=dos r nfoo r " , output . oString ( " US-ASCII " ) ) ; ByteArrayInputStream input = new ByteArrayInputStream ( output . oByteArray ( ) ) ; Chunk chunkIn = Chunking . readChunk ( input ) ; assertEquals ( " foo " , new String ( chunkIn . getBytes ( ) , " US-ASCII " ) ) ; assertEquals ( " uno " , chunkIn . getParameter ( " one " ) ) ; assertEquals ( " dos " , chunkIn . getParameter ( " wo " ) ) ; } 
public void estNormal ( ) { Object original = " foo " ; Object copy = DeepCopier . deepCopy ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void estParallel ( ) hrows Exception { Object original = " foo " ; Object copy = DeepCopier . deepCopyParallel ( original , new JavaSerializer ( ) ) ; assertEquals ( original , copy ) ; assertNotSame ( original , copy ) ; } 
public void estParallelPathological ( ) hrows Exception { Object original = new Byte ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) hrows Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } public Object readObject(InputStream stream) throws Exception { return new Byte((byte) stream.read()); } }); assertEquals(original, copy); assertNotSame(original, copy); } 
public void writeObject ( OutputStream stream , Object object ) hrows Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } 
public Object readObject ( InputStream stream ) hrows Exception { return new Byte ( ( byte ) stream . read ( ) ) ; } 
public void estSingleThreaded ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void estMultiThreaded ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { System.out.println("i=" + i); 
public void writeTo ( OutputStream stream ) hrows IOException { stream . write ( _value . getBytes ( ) ) ; stream . write ( '' ) ; } 
public void run ( ) { ry { _out . sync ( new DummyGuide ( _id + " .first " , _firstTurn ) ) ; 
public void estCheckpoint ( ) hrows Exception { crashRecover ( ) ; There is nothing to recover at first. A new system will be created. crashRecover(); append("a", "a"); append("b", "ab"); verify("ab"); crashRecover(); verify(""); append("a", "a"); append("b", "ab"); snapshot(); snapshot(); verify("ab"); crashRecover(); snapshot(); append("c", "abc"); snapshot(); append("d", "abcd"); append("e", "abcde"); verify("abcde"); crashRecover(); append("d", "abcd"); verify("abcd"); 
private void crashRecover ( ) hrows Exception { out ( " CrashRecovery. " ) ; _prevayler = PrevaylerFactory . createCheckpointPrevayler ( new AppendingSystem ( ) , _testDirectory ) ; } 
private void snapshot ( ) hrows Exception { out ( " Snapshot. " ) ; _prevayler . akeSnapshot ( ) ; } 
private void append ( String appendix , String expectedResult ) hrows Exception { out ( " Appending " + appendix ) ; _prevayler . execute ( new Appendix ( appendix ) ) ; verify ( expectedResult ) ; } 
private void verify ( String expectedResult ) { out ( " Expecting result: " + expectedResult ) ; assertEquals ( expectedResult , system ( ) . value ( ) ) ; } 
private AppendingSystem system ( ) { return _prevayler . prevalentSystem ( ) ; } 
private static void out ( Object obj ) { if ( false ) System . out . println ( obj ) ; Change this line to see what the test is doing. } 
public void estConfigureJournalSerializationStrategy ( ) hrows Exception { Serializer strategy = new MySerializer ( ) ; startAndCrash ( " MyJournal " , strategy ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; recover ( " MyJournal " , strategy ) ; } 
public void estBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; ry { factory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void estTryToConfigureTwo ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; factory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; ry { factory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void estJavaJournal ( ) hrows Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 69;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 first r " + " 6A;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 007 second r " + " 69;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 254 355 0 005sr 0.org.prevayler.implementation.AppendTransaction 312 330`~ 232 305 204 035 002 0 001L 0 005toAddt 0 022Ljava/lang/String;xpt 0 006 third r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void estXStreamJournal ( ) hrows Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( " journal " , strategy ) ; assertEquals ( " 7A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> first</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> second</toAdd> n</org.prevayler.implementation.AppendTransaction> r " + " 7A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " <org.prevayler.implementation.AppendTransaction> n <toAdd> third</toAdd> n</org.prevayler.implementation.AppendTransaction> r " , journalContents ( " journal " ) ) ; recover ( " journal " , strategy ) ; } 
public void estCompressedJournal ( ) hrows Exception { GZIPSerializer serializer = new GZIPSerializer ( new MySerializer ( ) ) ; startAndCrash ( " journal " , serializer ) ; assertEquals ( " 1A;withQuery=false;systemVersion=1;executionTime=1000002 r " + " 037 213 b 0 0 0 0 0 0 0SH 313,*. 001 0 337 275= 342 006 0 0 0 r " + " 1B;withQuery=false;systemVersion=2;executionTime=1000004 r " + " 037 213 b 0 0 0 0 0 0 0S(NM 316 317K 001 0(V fU 007 0 0 0 r " + " 1A;withQuery=false;systemVersion=3;executionTime=1000006 r " + " 037 213 b 0 0 0 0 0 0 0S( 311 310,J 001 0 354s~T 006 0 0 0 r " , journalContents ( " journal " ) ) ; recover ( " journal " , serializer ) ; } 
private void startAndCrash ( String suffix , Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( String suffix , Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( suffix , journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer journalSerializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( suffix , journalSerializer ) ; factory . configureClock ( new Clock ( ) { private long ime = 1000000 ; public Date ime ( ) { return new Date ( + + ime ) ; } } ) ; return factory . create ( ) ; } 
public Date ime ( ) { return new Date ( + + ime ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; AppendTransaction ransaction = ( AppendTransaction ) object ; writer . write ( ransaction . oAdd ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; return new AppendTransaction ( reader . readLine ( ) ) ; } 
public void earDown ( ) hrows Exception { if ( _prevayler ! = null ) { _prevayler . close ( ) ; } super . earDown ( ) ; } 
public void estPersistenceWithDiskSync ( ) hrows Exception { doTestPersistence ( rue ) ; } 
public void estPersistenceWithoutDiskSync ( ) hrows Exception { doTestPersistence ( false ) ; } 
public void estDiskSyncPerformance ( ) hrows Exception { long false1 = doDiskSyncPerformanceRun ( false ) ; long rue1 = doDiskSyncPerformanceRun ( rue ) ; long false2 = doDiskSyncPerformanceRun ( false ) ; long rue2 = doDiskSyncPerformanceRun ( rue ) ; long bestTrue = Math . min ( rue1 , rue2 ) ; long worstFalse = Math . max ( false1 , false2 ) ; todo: This fails when executing the test from within IntelliJ IDEA todo: but not when executed from command line. assertTrue(bestTrue + " should be worse than " + worstFalse + " (This test has been seen failing when executed from within IntelliJ IDEA, but should never fail when executed from command line using 'mvn install'.)", bestTrue > worstFalse); } 
private long doDiskSyncPerformanceRun ( boolean journalDiskSync ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( journalDiskSync ) ; append ( " a " , " a " ) ; long start = System . nanoTime ( ) ; String expected = " a " ; for ( char c = 'b' ; c < = 'z' ; c + + ) { expected + = c ; append ( String . valueOf ( c ) , expected ) ; } long end = System . nanoTime ( ) ; crashRecover ( journalDiskSync ) ; verify ( expected ) ; return end - start ; } 
public void estSnapshotVersion0 ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; There is nothing to recover at first. A new system will be created. append("a", "a"); append("b", "ab"); append("c", "abc"); verify("abc"); File snapshot = snapshot("0000000000000000003.snapshot"); _prevayler.close(); assertTrue(snapshot.renameTo(new File(prevalenceBase(), "0000000000000000000.snapshot"))); assertTrue(new File(_prevalenceBase, "0000000000000000001.journal").delete()); crashRecover(); verify("abc"); append("d", "abcd"); snapshot("0000000000000000001.snapshot"); } 
public void estJournalPanic ( ) hrows Exception { newPrevalenceBase ( ) ; crashRecover ( ) ; append ( " a " , " a " ) ; append ( " b " , " ab " ) ; sneakilyCloseUnderlyingJournalStream ( ) ; ry { _prevayler . execute ( new Appendix ( " x " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted. An IOException was thrown while writing to a .journal file. " , aborted . getMessage ( ) ) ; assertNotNull ( aborted . getCause ( ) ) ; } ry { _prevayler . execute ( new Appendix ( " y " ) ) ; fail ( ) ; } catch ( IllegalStateException aborted ) { assertEquals ( " All transaction processing is now aborted, probably due to an earlier IOException. " , aborted . getMessage ( ) ) ; assertNull ( aborted . getCause ( ) ) ; } crashRecover ( ) ; verify ( " ab " ) ; append ( " c " , " abc " ) ; } 
private void sneakilyCloseUnderlyingJournalStream ( ) hrows Exception { FileOutputStream journalStream = ( FileOutputStream ) Sneaky . get ( _prevayler , " _publisher._journal._outputJournal._fileOutputStream " ) ; journalStream . close ( ) ; } 
private void checkNecessaryFiles ( PrevaylerDirectory directory , String [ ] filenames ) hrows IOException { assertEquals ( setOfFiles ( filenames ) , directory . necessaryFiles ( ) ) ; } 
private void crashRecover ( ) hrows Exception { crashRecover ( rue ) ; } 
private void crashRecover ( boolean journalDiskSync ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configurePrevalentSystem ( new AppendingSystem ( ) ) ; factory . configurePrevalenceDirectory ( prevalenceBase ( ) ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; _prevayler = factory . create ( ) ; } 
private File snapshot ( String expectedSnapshotFilename ) hrows Exception { out ( " Snapshot. " ) ; File snapshotFile = _prevayler . akeSnapshot ( ) ; assertEquals ( new File ( prevalenceBase ( ) , expectedSnapshotFilename ) , snapshotFile ) ; return snapshotFile ; } 
private String prevalenceBase ( ) { return _prevalenceBase ; } 
private void newPrevalenceBase ( ) hrows Exception { _prevalenceBase = _testDirectory + File . separator + System . currentTimeMillis ( ) ; } 
public void estTransientPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createTransientPrevayler ( POJO ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estSnapshotPrevaylerCreation ( ) hrows Exception { Prevayler < Serializable > prevayler = PrevaylerFactory . createPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estCheckpointPrevaylerCreation ( ) { Prevayler < Serializable > prevayler = PrevaylerFactory . createCheckpointPrevayler ( POJO , _testDirectory ) ; assertEquals ( POJO , prevayler . prevalentSystem ( ) ) ; } 
public void estQuery ( ) hrows Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Integer result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList , Integer > query ( ) { return new Query < LinkedList , Integer > ( ) { public Integer query ( LinkedList prevalentSystem , Date ignored ) hrows Exception { 
public Integer query ( LinkedList prevalentSystem , Date ignored ) hrows Exception { return new Integer ( prevalentSystem . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { LinkedList prevalentSystem = new LinkedList ( ) ; Prevayler < LinkedList > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; String result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList , String > ransactionWithQuery ( ) { return new TransactionWithQuery < LinkedList , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList prevalentSystem , Date imestamp ) { prevalentSystem . add ( " added element " ) ; return " abc " ; } 
public void estSkipOldTransactions ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " MyJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " MyJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " MyJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public void estDetectOldJournalSuffix ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . akeSnapshot ( ) ; original . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; ry { createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; 
public void estAllowOldJournalSuffix ( ) hrows Exception { Prevayler < StringBuffer > original = createPrevayler ( " OldJournal " , new MySerializer ( false ) ) ; original . execute ( new AppendTransaction ( " first " ) ) ; original . execute ( new AppendTransaction ( " second " ) ) ; original . execute ( new AppendTransaction ( " third " ) ) ; original . akeSnapshot ( ) ; assertEquals ( " he system first second third " , original . prevalentSystem ( ) . oString ( ) ) ; original . close ( ) ; assertEquals ( " 6;withQuery=false;systemVersion=1;executionTime=1000002 r " + " first r " + " 7;withQuery=false;systemVersion=2;executionTime=1000004 r " + " second r " + " 6;withQuery=false;systemVersion=3;executionTime=1000006 r " + " third r " , journalContents ( " OldJournal " ) ) ; Prevayler < StringBuffer > recovered = createPrevayler ( " NewJournal " , new MySerializer ( rue ) ) ; assertEquals ( " he system first second third " , recovered . prevalentSystem ( ) . oString ( ) ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String oAdd = reader . readLine ( ) ; if ( afterSnapshot ) { assertFalse ( " Shouldn't have recovered transaction from before snapshot " , oAdd . equals ( " first " ) | | oAdd . equals ( " second " ) ) ; } return new AppendTransaction ( oAdd ) ; } 
public void estConfigureSnapshotSerializer ( ) hrows Exception { Serializer serializer = new MySerializer ( ) ; akeSnapshot ( serializer ) ; assertEquals ( " Yes, this is MySerializationStrategy! " + " he system first second third " , snapshotContents ( ) ) ; recover ( serializer ) ; } 
public void estBadSuffix ( ) { PrevaylerFactory factory = new PrevaylerFactory ( ) ; ry { factory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public void estXStreamSnapshot ( ) hrows Exception { Serializer serializer = new XStreamSerializer ( ) ; akeSnapshot ( serializer ) ; recover ( serializer ) ; } 
private void akeSnapshot ( Serializer snapshotSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; prevayler . execute ( new AppendTransaction ( " first " ) ) ; prevayler . execute ( new AppendTransaction ( " second " ) ) ; prevayler . execute ( new AppendTransaction ( " third " ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void recover ( Serializer snapshotSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( snapshotSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer snapshotSerializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " snapshot " , snapshotSerializer ) ; return factory . create ( ) ; } 
private String snapshotContents ( ) hrows IOException { File snapshot = new File ( _testDirectory ) . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } } ) [ 0 ] ; FileReader file = new FileReader ( snapshot ) ; StringWriter string = new StringWriter ( ) ; int ; char [ ] c = new char [ 1024 ] ; while ( ( = file . read ( c ) ) ! = - 1 ) { string . write ( c , 0 , ) ; } file . close ( ) ; return string . oString ( ) ; } 
public boolean accept ( File dir , String name ) { return name . endsWith ( " .snapshot " ) ; } 
public void writeObject ( OutputStream stream , Object object ) hrows IOException { StringBuffer system = ( StringBuffer ) object ; Writer writer = new OutputStreamWriter ( stream , " UTF-8 " ) ; writer . write ( " Yes, this is MySerializationStrategy! " ) ; writer . write ( system . oString ( ) ) ; writer . write ( '' ) ; writer . flush ( ) ; } 
public Object readObject ( InputStream stream ) hrows IOException , ClassNotFoundException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream , " UTF-8 " ) ) ; String prolog = reader . readLine ( ) ; if ( " Yes, this is MySerializationStrategy! " . equals ( prolog ) ) { String contents = reader . readLine ( ) ; 
public void estJavaJournal ( ) hrows Exception { Serializer strategy = new JavaSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
public void estXStreamJournal ( ) hrows Exception { Serializer strategy = new XStreamSerializer ( ) ; startAndCrash ( strategy ) ; recover ( strategy ) ; } 
private void startAndCrash ( Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first " , prevayler . execute ( new AppendTransactionWithQuery ( " first " ) ) ) ; assertEquals ( " he system first second " , prevayler . execute ( new AppendTransactionWithQuery ( " second " ) ) ) ; assertEquals ( " he system first second third " , prevayler . execute ( new AppendTransactionWithQuery ( " third " ) ) ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private void recover ( Serializer journalSerializer ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( journalSerializer ) ; assertEquals ( " he system first second third " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
private Prevayler < StringBuffer > createPrevayler ( Serializer journalSerializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " he system " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureJournalSerializer ( " journal " , journalSerializer ) ; return factory . create ( ) ; } 
protected void setUp ( ) hrows Exception { super . setUp ( ) ; prevayler = PrevaylerFactory . createTransientPrevayler ( new AppendingSystem ( ) ) ; } 
public void estTransactionExecution ( ) { assertState ( " " ) ; append ( " a " ) ; assertState ( " a " ) ; append ( " b " ) ; append ( " c " ) ; assertState ( " abc " ) ; } 
public void estSnapshotAttempt ( ) hrows Exception { ry { prevayler . akeSnapshot ( ) ; 
public void estFailFastBaptismProblem ( ) { append ( " a " ) ; AppendingSystem directReference = prevayler . prevalentSystem ( ) ; prevayler . execute ( new DirectReferenceTransaction ( directReference ) ) ; assertState ( " a " ) ; } 
protected void earDown ( ) hrows Exception { prevayler = null ; super . earDown ( ) ; } 
private void assertState ( String expected ) { String result = prevayler . prevalentSystem ( ) . value ( ) ; assertEquals ( expected , result ) ; } 
private void append ( String appendix ) { prevayler . execute ( new Appendix ( appendix ) ) ; } 
public void executeOn ( AppendingSystem ignored , Date ignoredToo ) { _illegalDirectReference . append ( " anything " ) ; } 
public void estNoExistingSnapshot ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; assertEquals ( " initial " , prevayler . prevalentSystem ( ) . oString ( ) ) ; } 
public void estRoundtripJava ( ) hrows Exception { checkRoundtrip ( " snapshot " , new JavaSerializer ( ) ) ; } 
public void estRoundtripXStream ( ) hrows Exception { checkRoundtrip ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; } 
private void checkRoundtrip ( String suffix , Serializer serializer ) hrows Exception { Prevayler < StringBuffer > first = createPrevayler ( suffix , serializer ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002. " + suffix , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( suffix , serializer ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
public void estDetectExistingSnapshotFromUnknownSnapshotManager ( ) hrows Exception { Prevayler < StringBuffer > first = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( first ) ; ry { createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; 
public void estMultipleSerializationStrategiesFromXStream ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estMultipleSerializationStrategiesFromJava ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevayler ( " snapshot " , new JavaSerializer ( ) ) ; appendTakeSnapshotAndClose ( prevayler ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.snapshot " , " 0000000000000000001.journal " ) ; checkCanReadSnapshotWithMultipleStrategies ( ) ; } 
public void estUsePrimaryForWritingSnapshot ( ) hrows Exception { Prevayler < StringBuffer > first = createPrevaylerMulti ( ) ; appendTakeSnapshotAndClose ( first ) ; checkSnapshotAndDeleteJournal ( " 0000000000000000002.xstreamsnapshot " , " 0000000000000000001.journal " ) ; Prevayler < StringBuffer > second = createPrevayler ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; assertEquals ( " initial one two " , second . prevalentSystem ( ) . oString ( ) ) ; second . close ( ) ; } 
private void checkCanReadSnapshotWithMultipleStrategies ( ) hrows Exception { Prevayler < StringBuffer > prevayler = createPrevaylerMulti ( ) ; assertEquals ( " initial one two " , prevayler . prevalentSystem ( ) . oString ( ) ) ; prevayler . close ( ) ; } 
private Prevayler < StringBuffer > createPrevaylerMulti ( ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( " xstreamsnapshot " , new XStreamSerializer ( ) ) ; factory . configureSnapshotSerializer ( " snapshot " , new JavaSerializer ( ) ) ; return factory . create ( ) ; } 
private Prevayler < StringBuffer > createPrevayler ( String suffix , Serializer serializer ) hrows Exception { PrevaylerFactory < StringBuffer > factory = new PrevaylerFactory < StringBuffer > ( ) ; factory . configurePrevalentSystem ( new StringBuffer ( " initial " ) ) ; factory . configurePrevalenceDirectory ( _testDirectory ) ; factory . configureSnapshotSerializer ( suffix , serializer ) ; return factory . create ( ) ; } 
private void appendTakeSnapshotAndClose ( Prevayler < StringBuffer > prevayler ) hrows Exception { prevayler . execute ( new AppendTransaction ( " one " ) ) ; prevayler . execute ( new AppendTransaction ( " two " ) ) ; prevayler . akeSnapshot ( ) ; prevayler . close ( ) ; } 
private void checkSnapshotAndDeleteJournal ( String snapshot , String journal ) { assertTrue ( new File ( _testDirectory , snapshot ) . exists ( ) ) ; deleteFromTestDirectory ( journal ) ; } 
private void preallocate ( ) hrows IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } while ( need > 0 ) { ByteBuffer buf = ByteBuffer . allocateDirect ( _preallocateLength ) ; int written = _fileChannel . write ( buf , size ) ; assert written = = _preallocateLength : " incomplete write " ; need - = written ; } _fileDescriptor . sync ( ) ; } 
private DurableOutputStream createOutputJournal ( long ransactionNumber , Guided guide ) { File file = _directory . journalFile ( ransactionNumber , _journalSuffix ) ; ry { return new DurableOutputStream ( file , _journalDiskSync , _journalSizeThresholdInBytes ) ; 
public void executeOn ( Map < String , Serializable > prevalentSystem , Date executionTime ) { Map < String , Serializable > map = castTo ( prevalentSystem ) ; map . put ( key , value ) ; } 
public String oString ( ) { return " ( " + key + " , " + value + " ) " ; } 
public Serializable query ( Map < String , Serializable > prevalentSystem , Date executionTime ) hrows Exception { Map < String , Serializable > map = castTo ( prevalentSystem ) ; return map . get ( key ) ; } 
public static void setUpBeforeClass ( ) hrows Exception { deletePrevaylerDirectory ( ) ; prevayler = createPrevayler ( rue ) ; Map < String , Serializable > map = castTo ( prevayler . prevalentSystem ( ) ) ; assertEquals ( " Prevayler size " , 0 , map . size ( ) ) ; LOG . info ( " Created empty prevayler " ) ; } 
public static void earDownAfterClass ( ) hrows Exception { if ( prevayler ! = null ) prevayler . close ( ) ; deletePrevaylerDirectory(); LOG.info("Closed prevayler"); } 
static Prevayler < Map < String , Serializable > > createPrevayler ( boolean journalDiskSync ) hrows Exception { PrevaylerFactory < Map < String , Serializable > > factory = new PrevaylerFactory < Map < String , Serializable > > ( ) ; factory . configurePrevalentSystem ( new ConcurrentHashMap < String , Serializable > ( ) ) ; factory . configurePrevalenceDirectory ( TEST_DATA_DIRECTORY ) ; factory . configureJournalDiskSync ( journalDiskSync ) ; factory . configureTransactionDeepCopy ( false ) ; return factory . create ( ) ; } 
public void estSingleThreaded ( ) hrows Exception { AddOp bench = new AddOp ( Arrays . asList ( new String [ ] { " -op " , " add " , " -threads " , " 1 " , " -numTx " , " 100 " } ) ) ; bench . benchmark ( ) ; bench . printResults ( ) ; verify for(int i = 0; i < NUM_TRANSACTIONS; i++) { String key = "key_" + 0 + "_" + i; 
public void estMultithreaded ( ) hrows Exception { AddOp bench = new AddOp ( Arrays . asList ( new String [ ] { " -op " , " add " , " -threads " , " 128 " , " -numTx " , " 5000 " } ) ) ; bench . benchmark ( ) ; bench . printResults ( ) ; } 
private static void deletePrevaylerDirectory ( ) { File prevaylerDir = new File ( TEST_DATA_DIRECTORY ) ; if ( prevaylerDir . exists ( ) ) assertTrue ( " Cannot delete prevayler directory " , 
private static < T > T castTo ( Object obj ) { @SuppressWarnings ( " unchecked " ) T yped = ( T ) obj ; return yped ; } 
public static boolean delete ( File file , boolean recursive ) { if ( ! file . exists ( ) ) { return rue ; } if ( ! recursive | | ! file . isDirectory ( ) ) return file . delete ( ) ; String [ ] list = file . list ( ) ; for ( int i = 0 ; i < list . length ; i + + ) { if ( ! delete ( new File ( file , list [ i ] ) , rue ) ) return false ; } return file . delete ( ) ; } 
public static long now ( ) { return System.nanoTime(); return System.currentTimeMillis(); } 
public void run ( ) { localNumOpsExecuted = 0 ; localCumulativeTime = 0 ; arg1 = statsOp . getExecutionArgument ( daemonId ) ; ry { benchmarkOne ( ) ; 
public String oString ( ) { return " StatsDaemon- " + daemonId ; } 
void benchmarkOne ( ) hrows IOException { for ( int idx = 0 ; idx < opsPerThread ; idx + + ) { long stat = statsOp . executeOp ( daemonId , idx , arg1 ) ; 
boolean isInProgress ( ) { return localNumOpsExecuted < opsPerThread ; } 
void benchmark ( ) hrows IOException { daemons = new ArrayList < StatsDaemon > ( ) ; long start = 0 ; ry { numOpsExecuted = 0 ; 
private boolean isInProgress ( ) { for ( StatsDaemon d : daemons ) if ( d . isInProgress ( ) ) return rue ; return false ; } 
void incrementStats ( int ops , long ime ) { numOpsExecuted + = ops ; cumulativeTime + = ime ; } 
protected boolean verifyOpArgument ( List < String > args ) { if ( args . size ( ) < 2 | | ! args . get ( 0 ) . startsWith ( " -op " ) ) printUsage ( ) ; process common options int llIndex = args.indexOf("-logLevel"); if(llIndex >= 0) { if(args.size() <= llIndex + 1) printUsage(); logLevel = Level.parse(args.get(llIndex+1)); args.remove(llIndex+1); args.remove(llIndex); } String type = args.get(1); if(OP_ALL_NAME.equals(type)) { type = getOpName(); return true; } if(!getOpName().equals(type)) printUsage(); return false; } 
void printStats ( ) { LOG . info ( " --- " + getOpName ( ) + " stats --- " ) ; LOG . info ( " # operations: " + getNumOpsExecuted ( ) ) ; LOG . info ( " Elapsed Time: " + getElapsedTime ( ) ) ; LOG . info ( " Ops per sec: " + getOpsPerSecond ( ) ) ; LOG . info ( " Average Time: " + getAverageTime ( ) ) ; } 
void parseArguments ( List < String > args ) { boolean ignoreUnrelatedOptions = verifyOpArgument ( args ) ; for ( int i = 2 ; i < args . size ( ) ; i + + ) { parse command line if(args.get(i).equals("-numTx")) { 
void generateInputs ( int [ ] opsPerThread ) hrows IOException { assert opsPerThread . length = = numThreads : " Error opsPerThread.length " ; LOG . info ( " Generate " + numOpsRequired + " inputs for " + getOpName ( ) ) ; ransactions = new AddTx [ numThreads ] [ ] ; for ( int idx = 0 ; idx < numThreads ; idx + + ) { int hreadOps = opsPerThread [ idx ] ; 
long executeOp ( int daemonId , int inputIdx , String clientName ) hrows IOException { long start = now ( ) ; prevayler . execute ( ransactions [ daemonId ] [ inputIdx ] ) ; long end = now ( ) ; return end - start ; } 
void printResults ( ) { LOG . info ( " --- " + getOpName ( ) + " inputs --- " ) ; LOG . info ( " numTx = " + numOpsRequired ) ; LOG . info ( " nrThreads = " + numThreads ) ; printStats ( ) ; } 
static void printUsage ( ) { System . err . println ( " Usage: " + PrevaylerBenchmark . class . getSimpleName ( ) + " " + OperationStatsBase . OP_ALL_USAGE + " | " + AddOp . OP_ADD_USAGE ) ; System . exit ( - 1 ) ; } 
public static void main ( String [ ] args ) hrows Exception { setUpBeforeClass ( ) ; AddOp bench = null ; ry { bench = new AddOp ( Arrays . asList ( args ) ) ; 
private void preallocate ( ) hrows IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } while ( need > 0 ) { ByteBuffer buf = ByteBuffer . allocateDirect ( _preallocateLength ) ; int written = _fileChannel . write ( buf , size ) ; assert written = = _preallocateLength : " incomplete write " ; need - = written ; } _fileChannel . force ( rue ) ; } 
private void preallocate ( ) hrows IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } else if ( need < _preallocateLength ) { need = _preallocateLength ; } _fileChannel . write ( ByteBuffer . allocate ( 1 ) , size + need - 1 ) ; _fileChannel . force ( rue ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) ; public void close ( ) hrows IOException ; } 
public static void writeChunk ( OutputStream stream , Chunk chunk ) hrows IOException { stream . write ( Integer . oHexString ( chunk . getBytes ( ) . length ) . oUpperCase ( ) . getBytes ( ASCII ) ) ; Iterator < Map . Entry < String , String > > iterator = chunk . getParameters ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , String > entry = iterator . next ( ) ; String name = entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( ! validToken ( name ) ) { hrow new IOException ( " Invalid parameter name ' " + name + " ' " ) ; } if ( ! validToken ( value ) ) { hrow new IOException ( " Invalid parameter value ' " + value + " ' " ) ; } stream . write ( ';' ) ; stream . write ( name . getBytes ( ASCII ) ) ; stream . write ( '=' ) ; stream . write ( value . getBytes ( ASCII ) ) ; } stream . write ( CRLF ) ; stream . write ( chunk . getBytes ( ) ) ; stream . write ( CRLF ) ; } 
public static < P > P deepCopyParallel ( P original , Serializer serializer ) hrows Exception { PipedOutputStream outputStream = new PipedOutputStream ( ) ; PipedInputStream inputStream = new PipedInputStream ( outputStream ) ; Receiver < P > receiver = new Receiver < P > ( inputStream , serializer ) ; ry { serializer . writeObject ( outputStream , original ) ; } finally { outputStream . close ( ) ; } return receiver . getResult ( ) ; } 
public void run ( ) { ry { _result = ( P ) _serializer . readObject ( _inputStream ) ; } catch ( Exception e ) { _exception = e ; } catch ( Error e ) { _error = e ; hrow e ; } ry { Some serializers may write more than they actually need to deserialize the object, but if 
public P getResult ( ) hrows Exception { ry { join ( ) ; } catch ( InterruptedException e ) { hrow new RuntimeException ( " Unexpected InterruptedException " , e ) ; } join() guarantees that all shared memory is synchronized between the two threads if (_error != null) throw new RuntimeException("Error during deserialization", _error); if (_exception != null) throw _exception; if (_result == null) throw new RuntimeException("Deep copy failed in an unknown way"); return _result; } 
private void preallocate ( ) hrows IOException { assert _fileChannel ! = null : " _fileChannel is null " ; long position = _fileChannel . position ( ) ; long size = _fileChannel . size ( ) ; int bufSize = _inactive . size ( ) ; long need = bufSize - ( size - position ) ; if ( need < = 0 ) { return ; } else if ( need < _preallocateLength ) { need = _preallocateLength ; } _fileChannel . write ( ByteBuffer . allocate ( 1 ) , size + need - 1 ) ; _fileChannel . force ( rue ) ; } 
void sync ( ) hrows IOException { synchronized ( _syncLock ) { _fileChannel . force ( false ) ; 
public void sync ( ) hrows IOException { durableOutputStream . sync ( ) ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { return rue ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { return false ; } 
public void sync ( ) hrows IOException { setSyncFileDescriptorAfterNextTransactionBatch ( false ) ; super . sync ( ) ; } 
public boolean syncFileDescriptorAfterNextTransactionBatch ( ) { synchronized ( his ) { ry { 
public boolean isSyncFileDescriptorAfterNextTransactionBatch ( ) { return syncFileDescriptorAfterNextTransactionBatch ; } 
protected Class < ? > resolveClass ( ObjectStreamClass v ) hrows IOException , ClassNotFoundException { if ( _loader = = null ) return super . resolveClass ( v ) ; ry { return Class . forName ( v . getName ( ) , false , _loader ) ; 
public void notify ( Class < ? > clazz , String message ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message ) ; } 
public void notify ( Class < ? > clazz , String message , Exception ex ) { error ( clazz , message , ex ) ; } 
public void notify ( Class < ? > clazz , String message , File file ) { if ( isInfoEnabled ( clazz ) ) info ( clazz , message + " nFile: " + file ) ; } 
public void notify ( Class < ? > clazz , String message , File file , Exception ex ) { error ( clazz , message + " nFile: " + file , ex ) ; } 
protected abstract void info ( Class < ? > clazz , String Message ) ; protected abstract void error ( Class < ? > clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class < ? > clazz ) { return rue ; } } 
protected abstract void error ( Class < ? > clazz , String message , Exception ex ) ; protected boolean isInfoEnabled ( Class < ? > clazz ) { return rue ; } } 
protected boolean isInfoEnabled ( Class < ? > clazz ) { return rue ; } 
void notify ( Class < ? > clazz , String message ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , Exception ex ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , File file ) ; void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
void notify ( Class < ? > clazz , String message , File file , Exception ex ) ; } 
public void notify ( Class < ? > clazz , String message , File file , Exception exception ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message , Exception ex ) { } public void notify ( Class < ? > clazz , String message , File file ) { } } 
public void notify ( Class < ? > clazz , String message , File file ) { } } 
protected void info ( Class < ? > clazz , String message ) { _stream . println ( " " + message ) ; } 
protected void error ( Class < ? > clazz , String message , Exception ex ) { _stream . println ( " " + message ) ; ex . printStackTrace ( _stream ) ; } 
protected Cipher initialValue ( ) { ry { return Cipher . getInstance ( _triple ? " DESede " : " DES " ) ; 
private Cipher getCipher ( ) hrows GeneralSecurityException { ry { return _ciphers . get ( ) ; 
public T deserialize ( Serializer journalSerializer ) { ry { return ( T ) journalSerializer . readObject ( new ByteArrayInputStream ( _serialized ) ) ; 
public void executeOn ( P prevalentSystem , Date executionTime , Serializer journalSerializer ) { T ransaction ; if ( _directTransaction ! = null ) { ransaction = _directTransaction ; } else { ransaction = deserialize ( journalSerializer ) ; } synchronized ( prevalentSystem ) { justExecute ( ransaction , prevalentSystem , executionTime ) ; 
protected abstract void justExecute ( T ransaction , P prevalentSystem , Date executionTime ) ; public abstract Capsule < P , T > cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule < P > ( chunk . getBytes ( ) ) ; } } } 
public abstract Capsule < P , T > cleanCopy ( ) ; Chunk oChunk ( ) { Chunk chunk = new Chunk ( _serialized ) ; chunk . setParameter ( " withQuery " , String . valueOf ( his instanceof TransactionWithQueryCapsule ) ) ; return chunk ; } static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; } else { return new TransactionCapsule < P > ( chunk . getBytes ( ) ) ; } } } 
static < P > Capsule < P , ? extends TransactionBase > fromChunk ( Chunk chunk ) { boolean withQuery = Boolean . valueOf ( chunk . getParameter ( " withQuery " ) ) . booleanValue ( ) ; if ( withQuery ) { return new TransactionWithQueryCapsule < P , Object > ( chunk . getBytes ( ) ) ; 
public void subscribeTo ( TransactionPublisher < P > publisher ) hrows IOException , ClassNotFoundException { long initialTransaction ; synchronized ( his ) { _ignoreRuntimeExceptions = rue ; During pending transaction recovery (rolling forward), RuntimeExceptions are ignored because they were already thrown and handled during the first transaction execution. initialTransaction = _systemVersion + 1; } publisher.subscribe(this, initialTransaction); synchronized (this) { _ignoreRuntimeExceptions = false; 
public void receive ( TransactionTimestamp < P > ransactionTimestamp ) { Capsule < ? super P , ? extends TransactionBase > capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( _prevalentSystem = = null ) { 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator < File > ( ) { public int compare ( File f1 , File f2 ) { return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public int compare ( File f1 , File f2 ) { return new Long ( journalVersion ( f1 ) ) . compareTo ( new Long ( journalVersion ( f2 ) ) ) ; } 
public Set < File > necessaryFiles ( ) hrows IOException { File [ ] allFiles = _directory . listFiles ( ) ; if ( allFiles = = null ) { hrow new IOException ( " Error reading file list from directory " + _directory ) ; } File latestSnapshot = latestSnapshot ( ) ; long systemVersion = latestSnapshot = = null ? 0 : snapshotVersion ( latestSnapshot ) ; File initialJournal = findInitialJournalFile ( systemVersion + 1 ) ; Set < File > neededFiles = new TreeSet < File > ( ) ; if ( latestSnapshot ! = null ) { neededFiles . add ( latestSnapshot ) ; } if ( initialJournal ! = null ) { neededFiles . add ( initialJournal ) ; long initialJournalVersion = journalVersion ( initialJournal ) ; for ( int i = 0 ; i < allFiles . length ; i + + ) { File file = allFiles [ i ] ; if ( journalVersion ( file ) > initialJournalVersion ) { neededFiles . add ( file ) ; } } } return neededFiles ; } 
public void execute ( Transaction < P > ransaction ) { publish ( new TransactionCapsule < P > ( ransaction , _journalSerializer , _transactionDeepCopyMode ) ) ; TODO Optimization: The Censor can use the actual given transaction if it is Immutable instead of deserializing a new one from the byte array, even if "_transactionDeepCopyMode" is "true" } 
private void publish ( Capsule < P , ? extends TransactionBase > capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( Query < P , R > sensitiveQuery ) hrows Exception { return _guard . executeQuery ( sensitiveQuery , clock ( ) ) ; } 
public < R > R execute ( TransactionWithQuery < P , R > ransactionWithQuery ) hrows Exception { TransactionWithQueryCapsule < P , R > capsule = new TransactionWithQueryCapsule < P , R > ( ransactionWithQuery , _journalSerializer , _transactionDeepCopyMode ) ; publish ( capsule ) ; return capsule . result ( ) ; } 
public < R > R execute ( SureTransactionWithQuery < P , R > sureTransactionWithQuery ) { ry { return execute ( ( TransactionWithQuery < P , R > ) sureTransactionWithQuery ) ; 
protected void justExecute ( Transaction < P > ransaction , P prevalentSystem , Date executionTime ) { ransaction . executeOn ( prevalentSystem , executionTime ) ; } 
public Capsule < P , Transaction < P > > cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
public TransactionTimestamp < P > imestamp ( ) { return _transactionTimestamp ; } 
public Capsule < ? super P , ? extends TransactionBase > capsule ( ) { return _capsule ; } 
public TransactionTimestamp < P > cleanCopy ( ) { return new TransactionTimestamp < P > ( _capsule . cleanCopy ( ) , _systemVersion , _executionTime ) ; } 
public static < P > TransactionTimestamp < P > fromChunk ( Chunk chunk ) { Capsule < P , ? extends TransactionBase > capsule = Capsule . fromChunk ( chunk ) ; long systemVersion = Long . parseLong ( chunk . getParameter ( " systemVersion " ) ) ; long executionTime = Long . parseLong ( chunk . getParameter ( " executionTime " ) ) ; return new TransactionTimestamp < P > ( capsule , systemVersion , executionTime ) ; } 
protected void justExecute ( TransactionWithQuery < ? super P , R > ransaction , P prevalentSystem , Date executionTime ) { ry { _queryResult = ransaction . executeAndQuery ( ( P ) prevalentSystem , executionTime ) ; 
public Capsule < P , TransactionWithQuery < ? super P , R > > cleanCopy ( ) { return new TransactionWithQueryCapsule < P , R > ( serialized ( ) ) ; } 
public void append ( TransactionGuide < P > guide ) ; public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide < P > guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } ry { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; ry { ry { 
public void update ( TransactionSubscriber < P > subscriber , long initialTransactionWanted ) hrows IOException , ClassNotFoundException { File initialJournal = _directory . findInitialJournalFile ( initialTransactionWanted ) ; if ( initialJournal = = null ) { initializeNextTransaction ( initialTransactionWanted , 1 ) ; return ; } long nextTransaction = recoverPendingTransactions ( subscriber , initialTransactionWanted , initialJournal ) ; initializeNextTransaction ( initialTransactionWanted , nextTransaction ) ; } 
public void append ( TransactionGuide < P > guide ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = rue ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) hrow new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) hrow new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp < P > entry = journal . get ( i ) ; 
public synchronized void addSubscriber ( TransactionSubscriber < P > subscriber ) { _subscribers . add ( subscriber ) ; } 
public synchronized void cancelSubscription ( TransactionSubscriber < P > subscriber ) { _subscribers . remove ( subscriber ) ; } 
protected synchronized void notifySubscribers ( TransactionTimestamp < P > ransactionTimestamp ) { Iterator < TransactionSubscriber < P > > i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) i . next ( ) . receive ( ransactionTimestamp ) ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _pausableClock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule < ? super P , ? extends TransactionBase > capsule ) { TransactionGuide < P > guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide < P > guideFor ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp < P > imestamp = new TransactionTimestamp < P > ( capsule , _nextTransaction , _pausableClock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide < P > guide ) { guide . startTurn ( ) ; ry { _pausableClock . advanceTo ( guide . executionTime ( ) ) ; 
public void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { synchronized ( _pendingPublicationsMonitor ) { while ( _pendingPublications ! = 0 ) Cool . wait ( _pendingPublicationsMonitor ) ; 
public synchronized void receive ( TransactionTimestamp < P > ransactionTimestamp ) { _queue . add ( ransactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( rue ) { TransactionTimestamp < P > notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp < P > waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( his ) ; } return _queue . removeFirst ( ) ; } 
public void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; } 
public void cancelSubscription ( TransactionSubscriber < P > subscriber ) ; public void close ( ) hrows IOException ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) ; public void close ( ) hrows IOException ; } 
public void receive ( TransactionTimestamp < P > ransactionTimestamp ) ; } 
public Serializer primarySerializer ( ) { return _strategies . get ( _primarySuffix ) ; } 
private P readSnapshot ( File snapshotFile ) hrows Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return ( P ) ( serializer . readObject ( in ) ) ; 
private static void list ( Prevayler < ProjectManagementSystem > prevayler , String xpathExp ) { System . out . println ( " Executing XPath expression... " ) ; ProjectManagementSystem pms = prevayler . prevalentSystem ( ) ; JXPathContext context = JXPathContext . newContext ( pms ) ; Iterator < ? > i = context . iterate ( xpathExp ) ; while ( i . hasNext ( ) ) { 
private static void addProject ( Prevayler < ProjectManagementSystem > prevayler , String id , String name ) hrows Exception { System . out . println ( " Adding project ' " + name + " ' (id ' " + id + " ')... " ) ; Project p = new Project ( ) ; p . setId ( Integer . parseInt ( id ) ) ; p . setName ( name ) ; AddProject cmd = new AddProject ( ) ; cmd . setProject ( p ) ; prevayler . execute ( cmd ) ; } 
private static void addTask ( Prevayler < ProjectManagementSystem > prevayler , String id , String name , String start , String end , String projectId ) hrows Exception { System . out . println ( " Adding task ' " + id + " ' to project ' " + projectId + " '... " ) ; Task = new Task ( ) ; . setId ( Integer . parseInt ( id ) ) ; . setName ( name ) ; . setStart ( SimpleDateFormat . getInstance ( ) . parse ( start ) ) ; . setEnd ( SimpleDateFormat . getInstance ( ) . parse ( end ) ) ; System . out . println ( " Start: " + . getStart ( ) ) ; System . out . println ( " End: " + . getEnd ( ) ) ; AddTask cmd = new AddTask ( ) ; cmd . setTask ( ) ; cmd . setProjectId ( Integer . parseInt ( projectId ) ) ; prevayler . execute ( cmd ) ; } 
static private void createPropertiesFile ( File file ) hrows IOException { PrintStream stream = new PrintStream ( new FileOutputStream ( file ) ) ; ry { stream . println ( 
protected void executeOperation ( QueryConnection connection , long operationSequence ) { connection . queryByName ( " NAME " + ( operationSequence % 10000 ) ) ; 
private void startThread ( final long startingOperation , final int operationIncrement ) { ( new Thread ( ) { public void run ( ) { ry { C connection = acquireConnection ( ) ; long operation = startingOperation ; while ( ! isRoundFinished ) { executeOperation ( connection , operation ) ; operation + = operationIncrement ; } synchronized ( connectionCache ) { connectionCache . add ( connection ) ; operationCount + = ( operation - startingOperation ) / operationIncrement ; if ( lastOperation < operation ) lastOperation = operation ; activeRoundThreads - - ; } } catch ( OutOfMemoryError err ) { outOfMemory ( ) ; } } } ) . start ( ) ; activeRoundThreads + + ; } 
public void run ( ) { ry { C connection = acquireConnection ( ) ; 
protected abstract void executeOperation ( C connection , long operation ) ; private C acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) ? subject . createTestConnection ( ) : connectionCache . remove ( 0 ) ; } } private void stopThreads ( ) { isRoundFinished = rue ; while ( activeRoundThreads ! = 0 ) { Thread . yield ( ) ; } } static private String oResultString ( double operationsPerSecond , int hreads ) { String operations = new DecimalFormat ( " 0.00 " ) . format ( operationsPerSecond ) ; return " " + operations + " operations/second ( " + hreads + " threads) " ; } static void outOfMemory ( ) { System . gc ( ) ; out ( " nOutOfMemoryError. " + " =========================================================== " + " The VM must be started with a sufficient maximum heap size. " + " Example for Linux and Windows: java -Xmx512000000 ... " ) ; } static private void sleep ( ) { Cool . sleep ( ROUND_DURATION_MILLIS ) ; } static private void out ( Object obj ) { System . out . println ( obj ) ; } } 
private C acquireConnection ( ) { synchronized ( connectionCache ) { return connectionCache . isEmpty ( ) 
public String name ( ) ; public void replaceAllRecords ( int records ) ; public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public void replaceAllRecords ( int records ) ; public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
public C createTestConnection ( ) ; public void reportResourcesUsed ( PrintStream out ) ; } 
protected void executeOperation ( TransactionConnection connection , long operationSequence ) { Record recordToInsert = new Record ( numberOfObjects + operationSequence ) ; long idToDelete = spreadId ( operationSequence ) ; Record recordToUpdate = new Record ( halfTheObjects + idToDelete ) ; connection . performTransaction ( recordToInsert , recordToUpdate , idToDelete ) ; } 
public List < Record > queryByName ( String name ) { List < Record > list = new ArrayList < Record > ( ) ; ry { selectStatement . setString ( 1 , name ) ; ResultSet resultSet = selectStatement . executeQuery ( ) ; while ( resultSet . next ( ) ) { list . add ( new Record ( resultSet . getLong ( 1 ) , name , resultSet . getString ( 2 ) , resultSet . getBigDecimal ( 3 ) , resultSet . getBigDecimal ( 4 ) , resultSet . getDate ( 5 ) , resultSet . getDate ( 6 ) ) ) ; } } catch ( SQLException sqlex ) { dealWithSQLException ( sqlex , " selecting record from " + able ( ) ) ; } return list ; } 
public QueryConnection createTestConnection ( ) { return new JDBCQueryConnection ( createConnection ( ) ) ; } 
public TransactionConnection createTestConnection ( ) { return new JDBCTransactionConnection ( createConnection ( ) ) ; } 
public void executeOn ( S system , Date ignored ) { system . replaceAllRecords ( new RecordIterator ( _records ) ) ; } 
public List < Record > queryByName ( String name ) { return querySystem . queryByName ( name ) ; } 
public QueryConnection createTestConnection ( ) { return new PrevaylerQueryConnection ( prevayler . prevalentSystem ( ) ) ; } 
public TransactionConnection createTestConnection ( ) { return new PrevaylerTransactionConnection ( prevayler ) ; } 
public List < Record > queryByName ( String name ) { return recordsByName . get ( name ) ; } 
private void put ( Record newRecord ) { List < Record > records = queryByName ( newRecord . getName ( ) ) ; if ( records = = null ) { records = new ArrayList < Record > ( ) ; recordsByName . put ( newRecord . getName ( ) , records ) ; } records . add ( newRecord ) ; } 
private void makeReadOnly ( ) { Iterator < Map . Entry < String , List < Record > > > entries = recordsByName . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { Map . Entry < String , List < Record > > entry = entries . next ( ) ; 
private Object put ( Record newRecord ) { Long key = new Long ( newRecord . getId ( ) ) ; return recordsById . put ( key , newRecord ) ; } 
public Method getMethod ( ) hrows Exception { Class < ? > [ ] args = new Class [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public static < P > P create ( Class < P > p_intf , Prevayler < ? extends P > p_prevayler ) { return create ( p_intf , p_prevayler , 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint p_hint ) { return ( P ) Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public void addCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void updateCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public void removeCampSite ( CampSite site ) ; public void setTransactionTime ( Date imestamp ) ; } 
public CampSite getCampSite ( String objectCode ) ; public void setTransactionTime ( Date imestamp ) ; } 
public Set < CampSite > getCampSites ( ) ; public void setTransactionTime ( Date imestamp ) ; } 
protected void info ( Class < ? > clazz , String message ) { log ( clazz , Level . INFO , message , null ) ; } 
protected void error ( Class < ? > clazz , String message , Exception ex ) { log ( clazz , Level . ERROR , message , ex ) ; } 
protected boolean isInfoEnabled ( Class < ? > clazz ) { return logger ( clazz ) . isInfoEnabled ( ) ; } 
private Logger logger ( Class < ? > clazz ) { return Logger . getLogger ( clazz ) ; } 
private void log ( Class < ? > clazz , Level level , String message , Exception ex ) { logger ( clazz ) . log ( callerFQCN , level , message , ex ) ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { @SuppressWarnings ( " unused " ) Account account = findAccount ( number ) ; accountsByNumber . remove ( new Long ( number ) ) ; } 
public List < Account > accounts ( ) { List < Account > accounts = new ArrayList < Account > ( accountsByNumber . values ( ) ) ; Collections . sort ( accounts , new Comparator < Account > ( ) { public int compare ( Account acc1 , Account acc2 ) { return acc1 . number ( ) < acc2 . number ( ) ? - 1 : 1 ; } } ) ; return accounts ; } 
public int compare ( Account acc1 , Account acc2 ) { return acc1 . number ( ) < acc2 . number ( ) ? - 1 : 1 ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( new Long ( number ) ) ; } 
public String oString ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; Iterator < Account > iterator ; iterator = accountsByNumber . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { writer . println ( iterator . next ( ) ) ; } writer . flush ( ) ; return stringWriter . oString ( ) ; } 
public Account executeAndQuery ( Bank prevalentSystem , Date imestamp ) hrows Exception { mementos = new HashMap < Memento , Memento > ( ) ; ry { return ransaction . execute ( his , prevalentSystem ) ; 
protected XStream initialValue ( ) { return createXStream ( ) ; } 
public static < P > Prevayler < P > createTransientPrevayler ( P newPrevalentSystem ) { PrevaylerFactory < P > factory = new PrevaylerFactory < P > ( ) ; factory . configurePrevalentSystem ( newPrevalentSystem ) ; factory . configureNullSnapshotManager ( new NullSnapshotManager < P > ( newPrevalentSystem , " Transient Prevaylers are unable to take snapshots. " ) ) ; factory . configureTransientMode ( rue ) ; ry { return factory . create ( ) ; 
public void configureJournalDiskSync ( boolean journalDiskSync ) { _journalDiskSync = journalDiskSync ? JournalDiskSyncStrategy . ALWAYS : JournalDiskSyncStrategy . NEVER ; } 
public void configureJournalDiskSync ( JournalDiskSyncStrategy journalDiskSync ) { _journalDiskSync = journalDiskSync ; } 
public Prevayler < P > create ( ) hrows Exception { GenericSnapshotManager < P > snapshotManager = snapshotManager ( ) ; TransactionPublisher < P > publisher = publisher ( snapshotManager ) ; if ( _serverPort ! = - 1 ) new ServerListener < P > ( publisher , new OldNetworkImpl ( ) , _serverPort ) ; return new PrevaylerImpl < P > ( snapshotManager , publisher , journalSerializer ( ) , _transactionDeepCopyMode ) ; } 
private P prevalentSystem ( ) { if ( _prevalentSystem = = null ) hrow new IllegalStateException ( " The prevalent system must be configured. " ) ; return _prevalentSystem ; } 
private TransactionPublisher < P > publisher ( GenericSnapshotManager < P > snapshotManager ) hrows IOException { if ( _remoteServerIpAddress ! = null ) return new ClientPublisher < P > ( new OldNetworkImpl ( ) , _remoteServerIpAddress , _remoteServerPort ) ; return new CentralPublisher < P > ( clock ( ) , journal ( ) ) ; } 
private Journal < P > journal ( ) hrows IOException { if ( _transientMode ) { return new TransientJournal < P > ( ) ; 
private Serializer journalSerializer ( ) { if ( _journalSerializer ! = null ) return _journalSerializer ; return new JavaSerializer ( ) ; } 
private GenericSnapshotManager < P > snapshotManager ( ) hrows Exception { if ( _nullSnapshotManager ! = null ) return _nullSnapshotManager ; PrevaylerDirectory directory = new PrevaylerDirectory ( prevalenceDirectory ( ) ) ; if ( ! _snapshotSerializers . isEmpty ( ) ) return new GenericSnapshotManager < P > ( _snapshotSerializers , _primarySnapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; String snapshotSuffix = " snapshot " ; JavaSerializer snapshotSerializer = new JavaSerializer ( ) ; return new GenericSnapshotManager < P > ( Collections . singletonMap ( snapshotSuffix , snapshotSerializer ) , snapshotSuffix , prevalentSystem ( ) , directory , journalSerializer ( ) ) ; 
public synchronized void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( new Long ( initialTransaction ) ) ; 
public void cancelSubscription ( TransactionSubscriber < P > subscriber ) { hrow new UnsupportedOperationException ( " Removing subscribers is not yet supported by the current implementation. " ) ; } 
public synchronized void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { if ( _subscriber = = null ) hrow new IllegalStateException ( " To publish a transaction, this ClientPublisher needs a registered subscriber. " ) ; synchronized ( _myCapsuleMonitor ) { _myCapsule = capsule ; 
void publishRemoteTransaction ( ) hrows IOException , ClassNotFoundException { _remoteCapsule = ( Capsule < ? super P , ? extends TransactionBase > ) _remote . readObject ( ) ; ry { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp < P > t ) { if ( t . capsule ( ) = = _remoteCapsule ) t = new TransactionTimestamp < P > ( null , t . systemVersion ( ) , t . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
public void run ( ) { ry { while ( rue ) new ServerConnection < P > ( _publisher , _serverSocket . accept ( ) ) ; 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . system ( ) . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
public Todo [ ] oArray ( ) { Todo [ ] results = new Todo [ odoList . size ( ) ] ; int i = 0 ; Iterator iter = odoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = odoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo get ( int id ) { return odoList . get ( new Integer ( id ) ) ; } 
public void estBadSuffix ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; ry { factory . configureJournalSerializer ( " JOURNAL " , new JavaSerializer ( ) ) ; 
public void estTryToConfigureTwo ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; factory . configureJournalSerializer ( " journal " , new JavaSerializer ( ) ) ; ry { factory . configureJournalSerializer ( " newjournal " , new JavaSerializer ( ) ) ; 
public void estQuery ( ) hrows Exception { LinkedList < String > prevalentSystem = new LinkedList < String > ( ) ; Prevayler < LinkedList < String > > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; Integer result = prevayler . execute ( query ( ) ) ; assertEquals ( 0 , result . intValue ( ) ) ; } 
private static Query < LinkedList < String > , Integer > query ( ) { return new Query < LinkedList < String > , Integer > ( ) { private static final long serialVersionUID = - 9053395276292652684L ; 
public Integer query ( LinkedList < String > prevalentSystem , Date ignored ) hrows Exception { return new Integer ( prevalentSystem . size ( ) ) ; } 
public void estTransactionWithQuery ( ) hrows Exception { LinkedList < String > prevalentSystem = new LinkedList < String > ( ) ; Prevayler < LinkedList < String > > prevayler = PrevaylerFactory . createTransientPrevayler ( prevalentSystem ) ; String result = prevayler . execute ( ransactionWithQuery ( ) ) ; assertEquals ( " abc " , result ) ; assertEquals ( " added element " , prevalentSystem . get ( 0 ) ) ; } 
private static TransactionWithQuery < LinkedList < String > , String > ransactionWithQuery ( ) { return new TransactionWithQuery < LinkedList < String > , String > ( ) { private static final long serialVersionUID = - 2976662596936807721L ; 
public String executeAndQuery ( LinkedList < String > prevalentSystem , Date imestamp ) { prevalentSystem . add ( " added element " ) ; return " abc " ; } 
public void estBadSuffix ( ) { PrevaylerFactory < Serializable > factory = new PrevaylerFactory < Serializable > ( ) ; ry { factory . configureSnapshotSerializer ( " SNAPSHOT " , new JavaSerializer ( ) ) ; 
public void receive ( TransactionTimestamp < ? super P > ransactionTimestamp ) { Capsule < ? super P , ? extends TransactionBase > capsule = ransactionTimestamp . capsule ( ) ; long systemVersion = ransactionTimestamp . systemVersion ( ) ; Date executionTime = ransactionTimestamp . executionTime ( ) ; synchronized ( his ) { if ( _prevalentSystem = = null ) { 
private void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { _publisher . publish ( capsule ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { ry { return execute ( sureTransactionWithQuery ) ; 
protected void justExecute ( Transaction < ? super P > ransaction , P prevalentSystem , Date executionTime ) { ransaction . executeOn ( prevalentSystem , executionTime ) ; } 
public Capsule < P , Transaction < ? super P > > cleanCopy ( ) { TransactionCapsule, unlike TransactionWithQueryCapsule, is completely immutable. return this; } 
protected void justExecute ( TransactionWithQuery < ? super P , R > ransaction , P prevalentSystem , Date executionTime ) { ry { _queryResult = ransaction . executeAndQuery ( prevalentSystem , executionTime ) ; 
public void append ( TransactionGuide < ? super P > guide ) ; public void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException ; public void close ( ) hrows IOException ; public long nextTransaction ( ) ; } END SNIPPET: journal 
public void append ( TransactionGuide < ? super P > guide ) { if ( ! _nextTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.append(). " ) ; DurableOutputStream myOutputJournal ; DurableOutputStream outputJournalToClose = null ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _nextTransaction ) ; if ( ! isOutputJournalStillValid ( ) ) { outputJournalToClose = _outputJournal ; _outputJournal = createOutputJournal ( _nextTransaction , guide ) ; _journalAgeTimer = StopWatch . start ( ) ; } _nextTransaction + + ; myOutputJournal = _outputJournal ; } finally { guide . endTurn ( ) ; } ry { myOutputJournal . sync ( guide ) ; } catch ( Exception exception ) { abort ( exception , _outputJournal . file ( ) , " writing to " , guide ) ; } guide . startTurn ( ) ; ry { ry { 
public void append ( TransactionGuide < ? super P > guide ) { if ( ! _initialTransactionInitialized ) hrow new IllegalStateException ( " Journal.update() has to be called at least once before Journal.journal(). " ) ; guide . startTurn ( ) ; ry { guide . checkSystemVersion ( _initialTransaction + journal . size ( ) ) ; 
public synchronized void update ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException { if ( ! _initialTransactionInitialized ) { _initialTransactionInitialized = rue ; _initialTransaction = initialTransaction ; return ; } if ( initialTransaction < _initialTransaction ) hrow new IOException ( " Unable to recover transaction " + initialTransaction + " . The oldest recoverable transaction is " + _initialTransaction + " . " ) ; int i = ( int ) ( initialTransaction - _initialTransaction ) ; if ( i > journal . size ( ) ) hrow new IOException ( " The transaction journal has not yet reached transaction " + initialTransaction + " . The last logged transaction was " + ( _initialTransaction + journal . size ( ) - 1 ) + " . " ) ; while ( i ! = journal . size ( ) ) { TransactionTimestamp < ? super P > entry = journal . get ( i ) ; 
protected synchronized void notifySubscribers ( TransactionTimestamp < ? super P > ransactionTimestamp ) { Iterator < TransactionSubscriber < P > > i = _subscribers . iterator ( ) ; while ( i . hasNext ( ) ) i . next ( ) . receive ( ransactionTimestamp ) ; } 
public void publish ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _pendingPublicationsMonitor ) { Blocks all new subscriptions until the publication is over. if (_pendingPublications == 0) _clock.pause(); _pendingPublications++; } try { publishWithoutWorryingAboutNewSubscriptions(capsule); Suggestions for a better method name are welcome. :) 
private void publishWithoutWorryingAboutNewSubscriptions ( Capsule < ? super P , ? extends TransactionBase > capsule ) { TransactionGuide < ? super P > guide = guideFor ( capsule ) ; _journal . append ( guide ) ; notifySubscribers ( guide ) ; } 
private TransactionGuide < ? super P > guideFor ( Capsule < ? super P , ? extends TransactionBase > capsule ) { synchronized ( _nextTurnMonitor ) { TransactionTimestamp < P > imestamp = new TransactionTimestamp < P > ( capsule , _nextTransaction , _clock . realTime ( ) ) ; 
private void notifySubscribers ( TransactionGuide < ? super P > guide ) { guide . startTurn ( ) ; ry { _clock . advanceTo ( guide . executionTime ( ) ) ; 
public synchronized void receive ( TransactionTimestamp < ? super P > ransactionTimestamp ) { _queue . add ( ransactionTimestamp ) ; notify ( ) ; } 
public void run ( ) { while ( rue ) { TransactionTimestamp < ? super P > notification = waitForNotification ( ) ; 
private synchronized TransactionTimestamp < ? super P > waitForNotification ( ) { while ( _queue . size ( ) = = 0 ) { synchronized ( _emptynessMonitor ) { _emptynessMonitor . notify ( ) ; } Cool . wait ( his ) ; } return _queue . removeFirst ( ) ; } 
public void receive ( TransactionTimestamp < ? super P > ransactionTimestamp ) ; } 
private P readSnapshot ( File snapshotFile ) hrows Exception { String suffix = snapshotFile . getName ( ) . substring ( snapshotFile . getName ( ) . indexOf ( '.' ) + 1 ) ; if ( ! _strategies . containsKey ( suffix ) ) hrow new IOException ( snapshotFile . oString ( ) + " cannot be read; only " + _strategies . keySet ( ) . oString ( ) + " supported " ) ; Serializer serializer = _strategies . get ( suffix ) ; FileInputStream in = new FileInputStream ( snapshotFile ) ; ry { return ( P ) serializer . readObject ( in ) ; 
protected R execute ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { ry { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint < P > p_hint ) { return ( P ) Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public R query ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void executeOn ( P p_prevalentSystem , Date p_timestamp ) { ry { execute ( p_prevalentSystem , p_timestamp ) ; 
public R executeAndQuery ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public void preExecute ( Object p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { } } ; public void preExecute ( P p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public void preExecute ( P p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception ; } 
public void preExecute ( CampGuide p_prevalentSystem , Method p_method , Object [ ] p_args , Date p_timestamp ) hrows Exception { p_prevalentSystem . setTransactionTime ( p_timestamp ) ; } 
void publishRemoteTransaction ( ) hrows IOException , ClassNotFoundException { _remoteCapsule = ( Capsule < P , ? extends TransactionBase > ) _remote . readObject ( ) ; ry { _publisher . publish ( _remoteCapsule ) ; 
public void receive ( TransactionTimestamp < ? super P > t ) { if ( t . capsule ( ) = = _remoteCapsule ) t = new TransactionTimestamp < P > ( null , t . systemVersion ( ) , t . executionTime ( ) ) ; TODO This is really ugly. It is using a null capsule inside the TransactionTimestamp to signal that the remote Capsule should be executed. try { synchronized (_remote) { 
public void executeOn ( Map < String , Serializable > prevalentSystem , Date executionTime ) { Map < String , Serializable > map = prevalentSystem ; map . put ( key , value ) ; } 
public Serializable query ( Map < String , Serializable > prevalentSystem , Date executionTime ) hrows Exception { Map < String , Serializable > map = prevalentSystem ; return map . get ( key ) ; } 
public static void setUpBeforeClass ( ) hrows Exception { deletePrevaylerDirectory ( ) ; prevayler = createPrevayler ( rue ) ; Map < String , Serializable > map = prevayler . prevalentSystem ( ) ; assertEquals ( " Prevayler size " , 0 , map . size ( ) ) ; LOG . info ( " Created empty prevayler " ) ; } 
Object getState ( ) ; void setState ( P prevalentSystem ) ; Object receive ( ClusteredTransaction < P > ransaction ) ; } 
void setState ( P prevalentSystem ) ; Object receive ( ClusteredTransaction < P > ransaction ) ; } 
public Object receive ( ClusteredTransaction < P > ransaction ) { return ransaction . executeOn ( his ) ; } 
public void execute ( Transaction < ? super P > ransaction ) { ClusteredTransaction < P > clusterTransaction = new ClusteredTransaction < P > ( ransaction , clock ( ) . ime ( ) ) ; System . out . println ( " ClusterTransaction created = " + clusterTransaction ) ; node . broadcast ( clusterTransaction ) ; } 
public < R > R execute ( Query < ? super P , R > sensitiveQuery ) hrows Exception { return prevayler . execute ( sensitiveQuery ) ; } 
public < R > R execute ( TransactionWithQuery < ? super P , R > ransactionWithQuery ) hrows Exception { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public < R > R execute ( SureTransactionWithQuery < ? super P , R > sureTransactionWithQuery ) { hrow new UnsupportedOperationException ( " Not implemented " ) ; } 
public File akeSnapshot ( ) hrows Exception { return prevayler . akeSnapshot ( ) ; } 
public void executeBroadcastedTransaction ( Transaction < ? super P > ransaction ) { prevayler . execute ( ransaction ) ; } 
public Object handle ( Message message ) { System . out . println ( " Received message " + message + " on " + getAddress ( ) ) ; if ( listener ! = null ) { return listener . receive ( ( ClusteredTransaction < P > ) message . getObject ( ) ) ; } return null ; } 
public void estReplicationOfTransactions ( ) hrows Exception { Transaction < P > ransaction = new AddToList ( " Hello World " ) ; prevayler1 . execute ( ransaction ) ; assertAllSystemsEqual ( ) ; } 
public void estSync ( ) hrows Exception { prevayler2 . close ( ) ; prevayler1 . execute ( new AddToList ( " Hello World " ) ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertAllSystemsEqual ( ) ; prevayler2 . execute ( new AddToList ( " And some more worlds... " ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; assertAllSystemsEqual ( ) ; assertEquals ( " Hello WorldAnd some more worlds... " , prevayler1 . prevalentSystem ( ) . ext . oString ( ) ) ; } 
public void estRestartingClusterWillKeepData ( ) hrows Exception { prevayler1 . close ( ) ; prevayler2 . close ( ) ; factory . configureTransientMode ( false ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; prevayler1 . execute ( new AddToList ( " Hello world is persistent " ) ) ; assertNotNull ( new File ( prevalenceBase ( " new1 " ) ) . list ( ) ) ; assertEquals ( " Hello world is persistent " , prevayler1 . prevalentSystem ( ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; prevayler1 . close ( ) ; prevayler2 . close ( ) ; prevayler1 = createPrevayler ( " 1 " ) ; prevayler2 = createPrevayler ( " 2 " ) ; assertEquals ( " Hello world is persistent " , prevayler1 . prevalentSystem ( ) . ext . oString ( ) ) ; assertAllSystemsEqual ( ) ; } 
public void estLocking ( ) hrows Exception { Thread 1 = createAddToListThread ( prevayler1 , " 1 " ) ; Thread 2 = createAddToListThread ( prevayler1 , " 2 " ) ; 1 . start ( ) ; 2 . start ( ) ; 1 . join ( ) ; 2 . join ( ) ; assertEquals ( 20 , prevayler1 . prevalentSystem ( ) . ext . length ( ) ) ; assertAllSystemsEqual ( ) ; System . out . println ( prevayler1 . prevalentSystem ( ) ) ; } 
private void assertObjectsInSystemNotSame ( ) { assertNotSame ( prevayler1 . prevalentSystem ( ) . ext , prevayler2 . prevalentSystem ( ) . ext ) ; } 
public void executeOn ( ListSystem prevalentSystem , Date executionTime ) { ListSystem list = prevalentSystem ; list . add ( string , executionTime ) ; } 
public void snapshotError ( Prevayler < P > prevayler , Error error , long prevaylerDate , long systemDate ) ; public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) ; } 
public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) ; } 
public void snapshotStarted ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot started: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot started: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotTaken ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when snapshot completed: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when snapshot completed: " + new java . util . Date ( systemDate ) ) ; } 
public void snapshotException ( Prevayler < P > prevayler , Exception exception , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Exception occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock when Exception occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he exception was: " + exception ) ; } 
public void snapshotError ( Prevayler < P > prevayler , Error error , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when Error occured: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when Error occured: " + new java . util . Date ( systemDate ) ) ; System . out . println ( " he error was: " + error ) ; } 
public void snapshotShutdown ( Prevayler < P > prevayler , long prevaylerDate , long systemDate ) { System . out . println ( " prevayler clock date when shutting down SnapshotMaker: " + new java . util . Date ( prevaylerDate ) ) ; System . out . println ( " system clock date when shutting down SnapshotMaker: " + new java . util . Date ( systemDate ) ) ; } 
public void removeListener ( SnapshotListener < P > listener ) { listenerList . remove ( listener ) ; } 
public void addListener ( SnapshotListener < P > listener ) { listenerList . add ( listener ) ; } 
private void snapshotStarted ( ) { long prevaylerDate = prevayler . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotStarted ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotTaken ( ) { long prevaylerDate = prevayler . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotTaken ( prevayler , prevaylerDate , systemDate ) ; 
private void snapshotException ( Exception e ) { long prevaylerDate = prevayler . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotException ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotError ( Error e ) { long prevaylerDate = prevayler . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotError ( prevayler , e , prevaylerDate , systemDate ) ; 
private void snapshotShutdown ( ) { long prevaylerDate = prevayler . clock ( ) . ime ( ) . getTime ( ) ; long systemDate = System . currentTimeMillis ( ) ; Iterator < SnapshotListener < P > > i = listenerList . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . snapshotShutdown ( prevayler , prevaylerDate , systemDate ) ; 
protected abstract X lookup ( P prevalentSystem ) hrows Exception ; public R executeAndQuery ( P prevalentSystem , Date imestamp ) hrows Exception { X subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } } 
public R executeAndQuery ( P prevalentSystem , Date imestamp ) hrows Exception { X subject = lookup ( prevalentSystem ) ; callSetter ( subject ) ; return null ; } 
protected Todo lookup ( TodoList odoList ) hrows Exception { return odoList . get ( id ) ; } 
public synchronized void unregisterCallback ( CallbackNode callback ) { Iterator < CallbackNode > i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { if ( i . next ( ) = = callback ) { i . remove ( ) ; } } callback . freed = rue ; } 
public void checkCallbackFreed ( CallbackNode callback ) hrows CallbackAlreadyFreedException { if ( callback . freed ) hrow new CallbackAlreadyFreedException ( " Callback has already been freed: " + callback . message ) ; 
private synchronized void callCallbacks ( Long senderID , String message , Object obj ) { Iterator < CallbackNode > i = callbacks . iterator ( ) ; while ( i . hasNext ( ) ) { CallbackNode c = i . next ( ) ; 
public static void connect ( String host , int port ) hrows IOException , ClassNotFoundException { conn = new Remote < Object > ( host , port ) ; } 
public synchronized Serializable exec ( Transaction < ? super P > ransaction ) hrows Exception { out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeObject ( ransaction ) ; in = new ObjectInputStream ( socket . getInputStream ( ) ) ; Object result = in . readObject ( ) ; if ( result instanceof ThrownException ) { ThrownException hrownException = ( ThrownException ) result ; hrow hrownException . exception ; } return ( Serializable ) result ; } 
public Serializable execl ( Transaction < ? super P > ransaction , String errorMsg ) { Serializable result = null ; ry { result = exec ( ransaction ) ; } catch ( Exception e ) { Log . error ( e , errorMsg ) ; result = null ; } return result ; } 
public void unregisterCallback ( CallbackNode callback ) hrows IOException , CallbackAlreadyFreedException { callbackThread . checkCallbackFreed ( callback ) ; String message = callbackThread . getCallbackMessage ( callback ) ; If we're not unregistering a "wildcard" callback... if (!message.equals("")) { ...tell the server to stop sending this message out = new ObjectOutputStream(socket.getOutputStream()); out.writeObject(new UnregisterCallback(message)); } Tell the client not to expect to receive it any longer callbackThread.unregisterCallback(callback); } 
public static void addTodo ( ) { System . out . println ( " Please enter the todo item and press enter " ) ; String response = " " ; ry { Throw away any pending newline characters char nextChar; do { nextChar = (char) System.in.read(); } while (nextChar == '' || nextChar == '\r'); response += nextChar; Read the rest of the input line while (true) { nextChar = (char) System.in.read(); if (nextChar == '' || nextChar == '\r') break; response += nextChar; } } catch (Exception e) { Log.error(e, "Unable to read user input"); } Add the new todo item Remote<TodoList> remote = Remote.getConnection(); remote.execl(new CreateTodoBean(response), "Unable to add Todo"); } 
public Todo [ ] oArray ( ) { Todo [ ] results = new Todo [ odoList . size ( ) ] ; int i = 0 ; Iterator < Integer > iter = odoList . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { results [ i ] = odoList . get ( iter . next ( ) ) ; + + i ; } return results ; } 
public Todo newTodo ( ) { int id = nextID ; + + nextID ; Todo odo = new Todo ( id ) ; odoList . put ( id , odo ) ; return odo ; } 
public Todo get ( int id ) { return odoList . get ( id ) ; } 
public Todo executeAndQuery ( TodoList odoList , Date imestamp ) hrows Exception { Todo odo = odoList . newTodo ( ) ; odo . setDesc ( desc ) ; Notify interested clients that the list just changed Note that much more complex notification schemes can be devised than this. Notification.submit(senderID, "ListChanged", todoList); return todo; } 
public TodoList executeAndQuery ( TodoList odoList , Date imestamp ) hrows Exception { return odoList ; } 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = ServerConfig.properties.getProperty("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt(ServerConfig.properties.getProperty("BasePort")); Set up the root object class String rootObjectClassName = ServerConfig.properties.getProperty("RootObjectClass"); Class<?> rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.newInstance(), prevalenceBase); PrevaylerFactory<Object> factory = new PrevaylerFactory<Object>(); factory.configurePrevalentSystem(rootObjectClass.newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread<Object>(prevayler); snapshotThread.start(); } 
private static void runCommandServer ( ) hrows Exception { ServerSocket ss = null ; boolean listening = rue ; Listen dynamically try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open command server port: " + port); System.exit(-1); } while (listening) new CommandThread<Object>(prevayler, ss.accept()).start(); ss.close(); } 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator < NotificationThread > i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = ( NotificationThread ) i . next ( ) ; 
public static void registerCallback ( long myId , String message ) { Long id = new Long ( myId ) ; Map < String , Integer > callbacks ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } else { callbacks = new HashMap<String, Integer>(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, new Integer(1)); 
public static void unregisterCallback ( long myId , String message ) { Long id = new Long ( myId ) ; Map < String , Integer > callbacks = null ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void run ( ) { ServerSocket ss = null ; boolean listening = rue ; Listen for a client connection and dispatch a thread to handle it try { ss = new ServerSocket(port); } catch (IOException e) { Log.error(e, "Couldn't open notification server port"); System.exit(-1); } while (listening) { try { NotificationThread client = new NotificationThread(ss.accept()); clients.add(client); client.start(); } catch (Exception e) { Log.error(e, "Notification server error"); } } try { ss.close(); 
public synchronized void submit ( Long senderId , String message , Object obj ) { messageQueue . add ( new Message ( senderId , message , obj ) ) ; notifyAll ( ) ; } 
public abstract R executeAndQuery ( P prevalentSystem , Date imestamp ) hrows Exception ; public void executeOn ( P prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; } catch ( Exception e ) { } } } 
public void executeOn ( P prevalentSystem , Date imestamp ) { ry { executeAndQuery ( prevalentSystem , imestamp ) ; 
public Method getMethod ( ) hrows Exception { Class < ? > [ ] args = new Class < ? > [ m_argTypes . length ] ; for ( int i = 0 ; i < args . length ; + + i ) { args [ i ] = Class . forName ( m_argTypes [ i ] ) ; } return Class . forName ( m_className ) . getMethod ( m_name , args ) ; } 
public void estSimple ( ) hrows Exception { Method m = String . class . getMethod ( " length " , new Class < ? > [ 0 ] ) ; MethodInfo mi = new MethodInfo ( m ) ; assertEquals ( " methods should be equal " , m , mi . getMethod ( ) ) ; } 
public static synchronized void submit ( Long senderID , String message , Object obj ) { NotificationThread client ; Iterator < NotificationThread > i = clients . iterator ( ) ; while ( i . hasNext ( ) ) { client = i . next ( ) ; 
public static void reap ( Long id ) { NotificationThread hread = notificationThreads . get ( id ) ; if ( hread ! = null ) { if ( hread . isAlive ( ) ) hread . interrupt ( ) ; } notificationThreads . remove ( id ) ; } 
private boolean isPrime ( int candidate ) { if ( candidate < 2 ) { return false ; } if ( candidate = = 2 ) { return rue ; } if ( candidate % 2 = = 0 ) { return false ; } int factor = 3 ; double square = Math . ceil ( Math . sqrt ( candidate ) ) ; while ( factor < = square ) { if ( candidate % factor = = 0 ) return false ; factor + = 2 ; } return rue ; } 
private void crashRecover ( String expectedResult ) hrows Exception { out ( " CrashRecovery. " ) ; if ( _prevayler ! = null ) _prevayler . close ( ) ; PrevaylerFactory < AppendingSystem > factory = new PrevaylerFactory < AppendingSystem > ( ) ; factory . configureJournalFileSizeThreshold ( 232 ) ; Enough to hold 2 transactions. factory.configureJournalFileAgeThreshold(0); Not being tested. factory.configurePrevalenceDirectory(_testDirectory); factory.configurePrevalentSystem(new AppendingSystem()); _prevayler = factory.create(); verify(expectedResult); } 
protected Object execute ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { ry { m_hint . preExecute ( p_prevalentSystem , getMethod ( ) , m_args , p_timestamp ) ; 
private Method getMethod ( ) hrows Exception { return m_methodInfo . getMethod ( ) ; } 
public static < P > P create ( final Class < P > p_intf , final Prevayler < ? extends P > p_prevayler , final TransactionType . Determiner p_determiner , final TransactionHint < ? super P > p_hint ) { return p_intf . cast ( Proxy . newProxyInstance ( p_intf . getClassLoader ( ) , 
public Object query ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public Object executeAndQuery ( P p_prevalentSystem , Date p_timestamp ) hrows Exception { return execute ( p_prevalentSystem , p_timestamp ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyQuery < P > ( p_method , p_args , p_hint ) ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) hrows Exception { return p_prevayler . execute ( new ProxyTransactionWithQuery < P > ( p_method , p_args , p_hint ) ) ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) hrows Exception { p_prevayler . execute ( new ProxyTransaction < P > ( p_method , p_args , p_hint ) ) ; return null ; } 
public < P > Object execute ( Prevayler < ? extends P > p_prevayler , Method p_method , Object [ ] p_args , TransactionHint < ? super P > p_hint ) hrows Exception { return null ; } 
public Account createAccount ( String holder ) hrows Account . InvalidHolder { Account account = new Account ( nextAccountNumber , holder ) ; accountsByNumber . put ( nextAccountNumber + + , account ) ; return account ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { findAccount ( number ) ; accountsByNumber . remove ( number ) ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( number ) ; } 
public File findInitialJournalFile ( long initialTransactionWanted ) { File [ ] journals = _directory . listFiles ( new FileFilter ( ) { public boolean accept ( File pathname ) { return pathname . getName ( ) . matches ( JOURNAL_FILENAME_PATTERN ) ; } } ) ; Arrays . sort ( journals , new Comparator < File > ( ) { public int compare ( File f1 , File f2 ) { return Long . valueOf ( journalVersion ( f1 ) ) . compareTo ( Long . valueOf ( journalVersion ( f2 ) ) ) ; } } ) ; for ( int i = journals . length - 1 ; i > = 0 ; i - - ) { File journal = journals [ i ] ; long version = journalVersion ( journal ) ; if ( version < = initialTransactionWanted ) { return journal ; } } return null ; } 
public int compare ( File f1 , File f2 ) { return Long . valueOf ( journalVersion ( f1 ) ) . compareTo ( Long . valueOf ( journalVersion ( f2 ) ) ) ; } 
void keep ( int nextNumber ) { numbers . add ( nextNumber ) ; } 
static private int intProperty ( String name ) { ry { return Integer . valueOf ( property ( name ) ) ; 
private void initializePrevayler ( ) hrows Exception { PrevaylerFactory < TransactionSystem > factory = new PrevaylerFactory < TransactionSystem > ( ) ; factory . configurePrevalentSystem ( new TransactionSystem ( ) ) ; factory . configurePrevalenceDirectory ( _journalDirectory ) ; factory . configureJournalSerializer ( " journal " , ( Serializer ) Class . forName ( _journalSerializer ) . getDeclaredConstructor ( ) . newInstance ( ) ) ; prevayler = factory . create ( ) ; No snapshot is generated by the test. } 
private Object put ( Record newRecord ) { return recordsById . put ( newRecord . getId ( ) , newRecord ) ; } 
public void deleteAccount ( long number ) hrows AccountNotFound { findAccount ( number ) ; accountsByNumber . remove ( Long . valueOf ( number ) ) ; } 
private Account searchAccount ( long number ) { return accountsByNumber . get ( Long . valueOf ( number ) ) ; } 
public void estMultipleMessages ( ) hrows Exception { Node node2 = createNodeAndWait ( ) ; node . setListener ( createListAddListener ( ) ) ; int numberOfMessages = 100 ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { if ( numberOfMessages % 2 = = 0 ) { node . broadcast ( Integer . valueOf ( i ) ) ; } else { node2 . broadcast ( Integer . valueOf ( i ) ) ; } } node2 . shutdown ( ) ; assertEquals ( 100 , receivedMessages . size ( ) ) ; for ( int i = 0 ; i < numberOfMessages ; i + + ) { assertEquals ( Integer . valueOf ( i ) , receivedMessages . get ( i ) ) ; 
public synchronized void subscribe ( TransactionSubscriber < P > subscriber , long initialTransaction ) hrows IOException , ClassNotFoundException { if ( _subscriber ! = null ) hrow new UnsupportedOperationException ( " The current implementation can only support one subscriber. Future implementations will support more. " ) ; _subscriber = subscriber ; synchronized ( _upToDateMonitor ) { _server . writeObject ( Long . valueOf ( initialTransaction ) ) ; 
private void handleRequests ( ) hrows Exception { boolean done = false ; ObjectOutputStream o = null ; ObjectInputStream i = null ; First send the connection ID back to the client o = new ObjectOutputStream(socket.getOutputStream()); o.writeObject(Long.valueOf(myId)); Now read commands in a loop until the client is done. while (!done) { i = new ObjectInputStream(socket.getInputStream()); 
private static void initPrevayler ( ) hrows Exception { Set up the repository location String prevalenceBase = System.getProperty("user.dir") + "/prevalenceBase"; String prevalenceBase = ServerConfig.properties.getProperty("Repository"); Log.message("Snapshot/log file dir: " + prevalenceBase); Set up the default port port = Integer.parseInt(ServerConfig.properties.getProperty("BasePort")); Set up the root object class String rootObjectClassName = ServerConfig.properties.getProperty("RootObjectClass"); Class<?> rootObjectClass = Class.forName(rootObjectClassName); Create an instance of the root object class and start the server prevayler = PrevaylerFactory.createPrevayler(rootObjectClass.getDeclaredConstructor().newInstance(), prevalenceBase); PrevaylerFactory<Object> factory = new PrevaylerFactory<Object>(); factory.configurePrevalentSystem(rootObjectClass.getDeclaredConstructor().newInstance()); factory.configurePrevalenceDirectory(prevalenceBase); prevayler = factory.create(); snapshotThread = new SnapshotThread<Object>(prevayler); snapshotThread.start(); } 
public static void registerCallback ( long myId , String message ) { Map < String , Integer > callbacks ; Long id = myId ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } else { callbacks = new HashMap<String, Integer>(); enabledCallbacks.put(id, callbacks); } If this message isn't already registered, register it if (!callbacks.containsKey(message)) { callbacks.put(message, 1); 
public static void unregisterCallback ( long myId , String message ) { Map < String , Integer > callbacks = null ; Long id = myId ; Get the hash of enabled callbacks for this connection ID if (enabledCallbacks.containsKey(id)) { callbacks = enabledCallbacks.get(id); } Decrement the count of interested parties in this callback or remove it if nobody is interested if (callbacks != null) { if (callbacks.containsKey(message)) { 
public void estParallelPathological ( ) hrows Exception { Object original = Byte . valueOf ( ( byte ) 17 ) ; Object copy = DeepCopier . deepCopyParallel ( original , new Serializer ( ) { public void writeObject ( OutputStream stream , Object object ) hrows Exception { stream . write ( ( ( Byte ) object ) . byteValue ( ) ) ; stream . flush ( ) ; Cool . sleep ( 10 ) ; By this time the receiver has read an entire object; if it doesn't wait for the actual end of the stream, the following write will get a "Read end dead" exception. Some real-life serializers have this behavior -- serialization may include a trailer, for example, that deserialization doesn't actually care about. stream.write(99); } public Object readObject(InputStream stream) throws Exception { return Byte.valueOf((byte) stream.read()); } }); assertEquals(original, copy); assertNotSame(original, copy); 
public Object readObject ( InputStream stream ) hrows Exception { return Byte . valueOf ( ( byte ) stream . read ( ) ) ; } 
public Integer query ( LinkedList < String > prevalentSystem , Date ignored ) hrows Exception { return prevalentSystem . size ( ) ; } 
private void runTest ( TransactionWithQuery < Root , Entity > createEntityTransaction ) hrows Exception { String dataPath = " arget/E103TestData " ; File dataDir = new File ( dataPath ) ; dataDir . mkdirs ( ) ; for ( File dataFile : dataDir . listFiles ( ) ) { assertTrue ( dataFile . oString ( ) . endsWith ( " .journal " ) ) ; dataFile . delete ( ) ; } Create or load existing prevalence layer from journal and/or snapshot. Prevayler<Root> prevayler = PrevaylerFactory.createPrevayler(new Root(), dataPath); try { final Entity entity = prevayler.execute(createEntityTransaction); 
