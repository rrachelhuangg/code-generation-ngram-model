<beg> public void storeAsync ( StoreOperation . StoreType storeType , String key , int flags , int exp , byte [ ] value , StoreOperation . Callback callback ) { conn . addOperation ( getServerForKey ( key ) , new StoreOperation ( storeType , key , flags , exp , value ,  <end> <beg> public String storeSync ( StoreOperation . StoreType storeType , String key , int flags , int exp , byte [ ] value ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , flags , exp , value , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; waitForNotNull ( so ) ; return so . get ( ) ; }  <end> <beg> public void storeResult ( String val ) { so . set ( val ) ; }  <end> <beg> public String add ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . add , key , flags , exp , value ) ; }  <end> <beg> public String set ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . set , key , flags , exp , value ) ; }  <end> <beg> public String replace ( String key , int flags , int exp , byte [ ] value ) { return storeSync ( StoreOperation . StoreType . replace , key , flags , exp , value ) ;  <end> <beg> public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { for ( String key : keys ) { conn . addOperation ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ;  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = data ; } } , key ) ;  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { rv . put ( k , data ) ; }  <end> <beg> public boolean evaluate ( AtomicInteger val ) { return val . get ( ) = = 0 ; } } ,  <end> <beg> public void versionResult ( String s ) { rv . put ( sa , s ) ; sync . set ( s ) ; }  <end> <beg> public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; }  <end> <beg> public void statsComplete ( ) { todo . decrementAndGet ( ) ; sync . set ( odo ) ; } } ) ) ;  <end> <beg> public boolean evaluate ( AtomicInteger c ) { return c . intValue ( ) = = 0 ; } } ,  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; conn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . info ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; }  <end> <beg> public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ;  <end> <beg> public long incr ( String key , int by ) { return mutate ( MutatorOperation . Mutator . incr , key , by ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( MutatorOperation . Mutator . decr , key , by ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , 0 , String . valueOf ( def ) . getBytes ( ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperation . Mutator . incr , key , by , def ) ; }  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperation . Mutator . decr , key , by , def ) ; }  <end> <beg> public void delete ( String key , int when ) { conn . addOperation ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; }  <end> <beg> public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling memcached IO " , e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public void shutdown ( ) { running = false ; try { conn . shutdown ( ) ;  <end> <beg> private void waitForNotNull ( SynchronizationObject < ? > sync ) { try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . SECONDS ) ;  <end> <beg> public void handleIO ( ) hrows IOException { int selected = selector . select ( ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ;  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; }  <end> <beg> public void shutdown ( ) hrows IOException { for ( SelectionKey sk : connections ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . info ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . info ( " Shut down selector %s " , selector ) ; }  <end> <beg> public void storeResult ( String val ) { System . out . println ( " Big store result: " + val ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { System . out . printf ( " Got data for %s (%d): %s " , key , flags , new String ( data ) ) ;  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . info ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( key . length ( ) + OVERHEAD ) ; setArguments ( b , " delete " , key , when ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . info ( " Flush completed successfully " ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; } setBuffer ( b ) ; }  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . info ( " Get complete! " ) ;  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) {  <end> <beg> public void initialize ( ) { }  <end> <beg> void gotData ( String key , int flags , byte [ ] data ) ; void getComplete ( ) ; } }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . info ( " Result: %s " , line ) ; Long found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = new Long ( line ) ; } if ( cb ! = null ) { cb . mutatorResult ( found ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { int size = key . length ( ) + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> protected void ransitionState ( State newState ) { getLogger ( ) . info ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd=null;  <end> <beg> public void writeComplete ( ) { transitionState ( State . READING ) ; }  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) {  <end> <beg> public void handleRead ( ByteBuffer data ) { assert false ; }  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { if ( cb ! = null ) {  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( MSG ) ) ; }  <end> <beg> void statsComplete ( ) ; void gotStat ( String name , String val ) ; } }  <end> <beg> public void handleLine ( String firstLine ) { if ( cb ! = null ) { cb . storeResult ( firstLine ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( " r " . getBytes ( ) ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public void handleLine ( String line ) { if ( cb ! = null ) { assert line . startsWith ( " VERSION " ) ; cb . versionResult ( line . substring ( " VERSION " . length ( ) ) ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; }  <end> <beg> public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; assertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; }  <end> <beg> public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; assertSame ( Operation . ReadType . LINE , op . getReadType ( ) ) ; }  <end> <beg> public void xtestLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r nxyz " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; op . readFromBuffer ( b ) ; assertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; op . setReadType ( Operation . ReadType . DATA ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( b ) ; byte expected [ ] = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , Arrays . equals ( expected , op . getCurentBytes ( ) ) ) ; assertEquals ( 1 , b . remaining ( ) ) ; assertEquals ( ( byte ) 'z' , b . get ( ) ) ; }  <end> <beg> public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; }  <end> <beg> public void handleLine ( String line ) { assert getReadType ( ) = = Operation . ReadType . LINE ; currentLine = line ; }  <end> <beg> public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = Operation . ReadType . DATA ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ;  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . allocate ( 0 ) ) ; }  <end> <beg> public String oString ( ) { return " {CachedData flags= " + flags + " data= " + Arrays . oString ( data ) + " } " ;  <end> <beg> public void storeAsync ( StoreOperation . StoreType storeType , String key , int exp , Object value , StoreOperation . Callback callback ) { CachedData co = ranscoder . encode ( value ) ; conn . addOperation ( getServerForKey ( key ) , new StoreOperation ( storeType , key , co . getFlags ( ) , exp ,  <end> <beg> public String storeSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , exp , o , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; waitForNotNull ( so ) ; return so . get ( ) ; }  <end> <beg> public String add ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . add , key , exp , o ) ; }  <end> <beg> public String set ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . set , key , exp , o ) ; }  <end> <beg> public String replace ( String key , int exp , Object o ) { return storeSync ( StoreOperation . StoreType . replace , key , exp , o ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , new Long ( def ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; }  <end> <beg> public Object decode ( CachedData d ) { assert d . getFlags ( ) = = 0 ; return new String ( d . getData ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { return new CachedData ( 0 , String . valueOf ( o ) . getBytes ( ) ) ; }  <end> <beg> CachedData encode ( Object o ) ; Object decode ( CachedData d ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ;  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { rv . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte b [ ] = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> private byte [ ] serialize ( Object o ) { assert o ! = null ; byte rv [ ] = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } return rv ; }  <end> <beg> private Object deserialize ( byte [ ] in ) { Object rv = null ; assert in ! = null ; try { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; }  <end> <beg> private byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . info ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }  <end> <beg> private byte [ ] decompress ( byte [ ] in ) { assert in ! = null ; ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { throw new RuntimeException ( " Error decompressing data " , e ) ; } return bos . oByteArray ( ) ; }  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) {  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; }  <end> <beg> public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( 0 , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedString ( ) hrows Exception { String s1 = " This is a test simple string that will be compressed. " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = c . encode ( s1 ) ; assertEquals ( SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estObject ( ) hrows Exception { Date d1 = new Date ( ) ; CachedData cd = c . encode ( d1 ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( d1 , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Date d1 = new Date ( ) ; CachedData cd = c . encode ( d1 ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( d1 , c . decode ( cd ) ) ; }  <end> <beg> public void estSomethingBigger ( ) hrows Exception { Collection < Date > dates = new ArrayList < Date > ( ) ; for ( int i = 0 ; i < 1024 ; i + + ) { dates . add ( new Date ( ) ) ; } CachedData d = c . encode ( dates ) ; assertEquals ( dates , c . decode ( d ) ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { String v = storeSync ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; if ( v . equals ( " STORED " ) ) { rv = def ; } } return rv ; }  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; conn . addOperation ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; }  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; }  <end> <beg> public void shutdown ( ) hrows IOException { for ( SelectionKey sk : connections ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; }  <end> <beg> private byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . debug ( " Flush completed successfully " ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ;  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; if(cb != null) {  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; Long found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = new Long ( line ) ; } if ( cb ! = null ) { cb . mutatorResult ( found ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> protected void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd=null;  <end> <beg> private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( qa . ops . size ( ) > 0 ) { Operation currentOp = qa . ops . peek ( ) ;  <end> <beg> private void reconnect ( QueueAttachment qa ) hrows IOException { getLogger ( ) . warn ( " Closing, and reopening connection. " ) ; synchronized ( qa ) { qa . sk . cancel ( ) ;  <end> <beg> public void handleIO ( ) hrows IOException { int selected = selector . select ( ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; if ( selectedKeys . size ( ) > 0 ) { emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } }  <end> <beg> private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . warn ( " Connection state changed for " + sk ) ;  <end> <beg> private void setupResend ( QueueAttachment qa ) { if ( qa . ops . size ( ) > 0 ) { Operation op = qa . ops . peek ( ) ;  <end> <beg> public String oString ( ) { return " {QA #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ; }  <end> <beg> public void handleIO ( ) hrows IOException { long delay = 0 ; if ( reconnectQueue . size ( ) > 0 ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects();  <end> <beg> private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for " + sk ) ;  <end> <beg> private void queueReconnect ( QueueAttachment qa ) hrows IOException { getLogger ( ) . warn ( " Closing, and reopening connection. " ) ; synchronized ( qa ) { qa . sk . cancel ( ) ;  <end> <beg> private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < QueueAttachment > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = ( QueueAttachment ) connections [ which ] . attachment ( ) ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> private byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } return rv ; }  <end> <beg> public void xtestLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r nxyz " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getCurrentLine ( ) ) ; op . readFromBuffer ( b ) ; assertEquals ( " here is line two " , op . getCurrentLine ( ) ) ; op . setReadType ( Operation . ReadType . DATA ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( b ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) , Arrays . equals ( expected , op . getCurentBytes ( ) ) ) ; assertEquals ( 1 , b . remaining ( ) ) ; assertEquals ( ( byte ) 'z' , b . get ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> private byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } int firstNonZero = 0 ; for ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { }  <end> <beg> long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; }  <end> <beg> int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; }  <end> <beg> byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; }  <end> <beg> byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; }  <end> <beg> boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; }  <end> <beg> public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estDate ( ) hrows Exception { Date d = new Date ( ) ; CachedData cd = c . encode ( d ) ; assertEquals ( d , c . decode ( cd ) ) ; }  <end> <beg> public void estLong ( ) hrows Exception { assertEquals ( 923l , c . decode ( c . encode ( 923l ) ) ) ; }  <end> <beg> public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) ) ; }  <end> <beg> public void estBoolean ( ) hrows Exception { assertSame ( Boolean . TRUE , c . decode ( c . encode ( rue ) ) ) ; assertSame ( Boolean . FALSE , c . decode ( c . encode ( false ) ) ) ; }  <end> <beg> public void estByte ( ) hrows Exception { assertEquals ( ( byte ) - 127 , c . decode ( c . encode ( ( byte ) - 127 ) ) ) ; }  <end> <beg> private void assertFloat ( float f ) { assertEquals ( f , c . decode ( c . encode ( f ) ) ) ; }  <end> <beg> public void estFloat ( ) hrows Exception { assertFloat ( 0f ) ; assertFloat ( Float . MIN_VALUE ) ; assertFloat ( Float . MAX_VALUE ) ; assertFloat ( 3.14f ) ; assertFloat ( - 3.14f ) ; assertFloat ( Float . NaN ) ; assertFloat ( Float . POSITIVE_INFINITY ) ; assertFloat ( Float . NEGATIVE_INFINITY ) ; }  <end> <beg> private void assertDouble ( double d ) { assertEquals ( d , c . decode ( c . encode ( d ) ) ) ; }  <end> <beg> public void estDouble ( ) hrows Exception { assertDouble ( 0d ) ; assertDouble ( Double . MIN_VALUE ) ; assertDouble ( Double . MAX_VALUE ) ; assertDouble ( 3.14d ) ; assertDouble ( - 3.14d ) ; assertDouble ( Double . NaN ) ; assertDouble ( Double . POSITIVE_INFINITY ) ; assertDouble ( Double . NEGATIVE_INFINITY ) ; }  <end> <beg> private void assertLong ( long l ) { byte [ ] encoded = c . encodeLong ( l ) ; long decoded = c . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; }  <end> <beg> public void estLongEncoding ( ) hrows Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 l ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; }  <end> <beg> private void assertInt ( int i ) { byte [ ] encoded = c . encodeInt ( i ) ; int decoded = c . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; }  <end> <beg> public void estIntEncoding ( ) hrows Exception { assertInt ( Integer . MIN_VALUE ) ; assertInt ( 83526 ) ; assertInt ( 1 ) ; assertInt ( 0 ) ; assertInt ( - 1 ) ; assertInt ( - 238526 ) ; assertInt ( Integer . MAX_VALUE ) ; }  <end> <beg> public void estBooleanEncoding ( ) hrows Exception { assertTrue ( c . decodeBoolean ( c . encodeBoolean ( rue ) ) ) ; assertFalse ( c . decodeBoolean ( c . encodeBoolean ( false ) ) ) ; }  <end> <beg> private void addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; }  <end> <beg> public void storeAsync ( StoreOperation . StoreType storeType , String key , int exp , Object value , StoreOperation . Callback callback ) { CachedData co = ranscoder . encode ( value ) ; addOp ( getServerForKey ( key ) , new StoreOperation ( storeType , key , co . getFlags ( ) , exp ,  <end> <beg> public void asyncGet ( GetOperation . Callback cb , String . . . keys ) { for ( String key : keys ) { addOp ( getServerForKey ( key ) , new GetOperation ( key , cb ) ) ;  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; waitForNotNull ( sync ) ; getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; }  <end> <beg> public void delete ( String key , int when ) { addOp ( getServerForKey ( key ) , new DeleteOperation ( key , when ) ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { long delay = 0 ; if ( reconnectQueue . size ( ) > 0 ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects();  <end> <beg> private void handleIO ( SelectionKey sk ) hrows IOException { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ;  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; }  <end> <beg> public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { qa . channel . close ( ) ; qa . sk = null ; getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; }  <end> <beg> public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( QueueAttachment qa : connections ) { sb . append ( " " ) ; sb . append ( qa . socketAddress ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; }  <end> <beg> public String oString ( ) { return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " } " ;  <end> <beg> private SynchronizationObject < String > setupStoreSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , exp , o , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; return so ; }  <end> <beg> public String storeSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { SynchronizationObject < String > so = setupStoreSync ( storeType , key , exp , o ) ; waitForNotNull ( so ) ; return so . get ( ) ; }  <end> <beg> public String storeSync ( long imeout , StoreOperation . StoreType storeType , String key , int exp , Object o ) hrows TimeoutException { SynchronizationObject < String > so = setupStoreSync ( storeType , key , exp , o ) ; waitForNotNull ( imeout , so ) ; return so . get ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned: " + k ; rvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ;  <end> <beg> public Object get ( String key ) { SynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; waitForNotNull ( sync ) ; CachedData [ ] rvContainer = sync . get ( ) ; assert rvContainer . length = = 1 ; Object rv = null ; if ( rvContainer [ 0 ] ! = null ) { rv = ranscoder . decode ( rvContainer [ 0 ] ) ; } return rv ; }  <end> <beg> public Object get ( long imeout , String key ) hrows TimeoutException { SynchronizationObject < CachedData [ ] > sync = setupGet ( key ) ; waitForNotNull ( imeout , sync ) ; CachedData [ ] rvContainer = sync . get ( ) ; assert rvContainer . length = = 1 ; Object rv = null ; if ( rvContainer [ 0 ] ! = null ) { rv = ranscoder . decode ( rvContainer [ 0 ] ) ; } return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; }  <end> <beg> public Map < String , Object > get ( String . . . keys ) { Map < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; SynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; waitForOperations ( sync ) ; return rv ; }  <end> <beg> public Map < String , Object > get ( long imeout , String . . . keys ) throws TimeoutException { Map < String , Object > rv = new ConcurrentHashMap < String , Object > ( ) ; SynchronizationObject < AtomicInteger > sync = setupBulkGet ( rv , keys ) ; waitForOperations ( imeout , sync ) ; return rv ; }  <end> <beg> public void versionResult ( String s ) { rv . put ( sa , s ) ; ai . decrementAndGet ( ) ; sync . set ( ai ) ; }  <end> <beg> private void waitForNotNull ( long imeout , SynchronizationObject < ? > sync ) throws TimeoutException { try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;  <end> <beg> private void waitForNotNull ( SynchronizationObject < ? > sync ) { try { waitForNotNull ( Long . MAX_VALUE , sync ) ;  <end> <beg> private void waitForOperations ( long imeout , final SynchronizationObject < AtomicInteger > sync ) throws TimeoutException { try { sync . waitUntilTrue (  <end> <beg> private void waitForOperations ( final SynchronizationObject < AtomicInteger > sync ) { try { waitForOperations ( Long . MAX_VALUE , sync ) ;  <end> <beg> public void storeResult ( String val ) { sync . set ( val ) ; } } ) ;  <end> <beg> public Future < String > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; }  <end> <beg> public Future < String > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; }  <end> <beg> public Future < String > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) . equals ( " STORED " ) ) { rv = def ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { try { waitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { assert false : " Timed out waiting forever. " ; } return sync . get ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { waitForIt ( duration , units ) ; return sync . get ( ) ; }  <end> <beg> protected void waitForIt ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { sync . waitUntilNotNull ( duration , units ) ; }  <end> <beg> public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = Operation . State . COMPLETE ; }  <end> <beg> private boolean hasPendingOperations ( QueueAttachment qa ) { assert Thread . holdsLock ( qa ) : " Not locking qa " ; Operation nextOp = qa . ops . peek ( ) ; while ( nextOp ! = null & & nextOp . isCancelled ( ) ) { getLogger ( ) . info ( " Removing cancelled operation: %s " , nextOp ) ; qa . ops . remove ( ) ; nextOp = qa . ops . peek ( ) ; } return nextOp ! = null ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = c . encode ( a ) ; assertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; assertTrue ( Arrays . equals ( a , ( byte [ ] ) c . decode ( cd ) ) ) ; }  <end> <beg> private Operation addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } } ) ;  <end> <beg> protected void waitForIt ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < Object > ( ) {  <end> <beg> public boolean evaluate ( Object o ) { return o ! = marker ; }  <end> <beg> public Object get ( String key ) { try { return asyncGet ( key ) . get ( ) ;  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) ) ; }  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new MutatorOperation . Callback ( ) { public void mutatorResult ( Long val ) { if ( val = = null ) { val = new Long ( - 1 ) ; } sync . set ( val ) ; } } ) ) ; try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( " Timed out waiting forever. " ) ; } getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; }  <end> <beg> private void waitForOperations ( final SynchronizationObject < AtomicInteger > sync ) { try { sync . waitUntilTrue (  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = Operation . State . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; }  <end> <beg> public Map < String , Object > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; return m ; }  <end> <beg> public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } ,  <end> <beg> public boolean isDone ( ) { return requests . get ( ) = = 0 ; }  <end> <beg> public static void main ( String args [ ] ) hrows Exception { final MemcachedClient c = new MemcachedClient ( new InetSocketAddress ( " localhost " , 11211 ) ) ; try { assert false ; throw new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { }  <end> <beg> public void receivedStatus ( String val ) { sync . set ( val ) ; } } ) ;  <end> <beg> public Future < Object > asyncGet ( final String key ) { @Override  <end> <beg> public void receivedStatus ( String line ) { sync . set ( val ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final AtomicInteger requests = new AtomicInteger ( ) ; final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; final SynchronizationObject < AtomicInteger > sync = new SynchronizationObject < AtomicInteger > ( requests ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { public void receivedStatus ( String line ) { requests . decrementAndGet ( ) ; sync . set ( requests ) ; } public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , ranscoder . decode ( new CachedData ( flags , data ) ) ) ; } } ; }  <end> <beg> public void receivedStatus ( String line ) { requests . decrementAndGet ( ) ; sync . set ( requests ) ; }  <end> <beg> public void receivedStatus ( String s ) { rv . put ( sa , s ) ; ai . decrementAndGet ( ) ; sync . set ( ai ) ; }  <end> <beg> public void receivedStatus ( String line ) { todo . decrementAndGet ( ) ; sync . set ( odo ) ; } } ) ) ;  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final SynchronizationObject < Long > sync = new SynchronizationObject < Long > ( null ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { sync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ; try { sync . waitUntilNotNull ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for mutation " , e ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( " Timed out waiting forever. " ) ; } getLogger ( ) . debug ( " Mutation returned %s " , sync . get ( ) ) ; return sync . get ( ) . longValue ( ) ; }  <end> <beg> public void receivedStatus ( String val ) { sync . set ( new Long ( val = = null ? " -1 " : val ) ) ; } } ) ) ;  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } if ( cb ! = null ) { cb . receivedStatus ( found ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { if ( cb ! = null ) { cb . receivedStatus ( line ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { if ( cb ! = null ) { assert line . startsWith ( " VERSION " ) ; cb . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> private byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; }  <end> <beg> public static void main ( String args [ ] ) hrows Exception { final MemcachedClient c = new MemcachedClient ( new InetSocketAddress ( " localhost " , 11211 ) ) ; try { assert false ; throw new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { }  <end> <beg> public void estNonserializable ( ) hrows Exception { try { tc . encode ( new Object ( ) ) ;  <end> <beg> public void handleIO ( ) hrows IOException { long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects();  <end> <beg> private void queueReconnect ( QueueAttachment qa ) hrows IOException { synchronized ( qa ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " ,  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return m ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { try { waitForIt ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( TimeoutException e ) { assert false : " Timed out waiting forever. " ; } if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return sync . get ( ) ; }  <end> <beg> protected void wasCancelled ( ) { }}  <end> <beg> protected void wasCancelled ( ) { }}  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; cb.gotData(currentKey, currentFlags, data);  <end> <beg> void gotData ( String key , int flags , byte [ ] data ) ; } @Override protected void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; } }  <end> <beg> protected void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } cb . receivedStatus ( found ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; }  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( line ) ;  <end> <beg> public static void main ( String args [ ] ) hrows Exception { final MemcachedClient c = new MemcachedClient ( new InetSocketAddress ( " localhost " , 11211 ) ) ; try { assert false ; throw new RuntimeException ( " Assertions not enabled. " ) ; } catch ( AssertionError e ) { }  <end> <beg> protected void wasCancelled ( ) { }}  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compress ( b ) ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; }  <end> <beg> public void estCompressedString ( ) hrows Exception { }  <end> <beg> public void handleIO ( ) hrows IOException { long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; int selected = selector . select ( delay ) ; if ( selected > 0 ) { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; assert selected = = selectedKeys . size ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } attemptReconnects();  <end> <beg> public void handleIO ( ) hrows IOException { attemptReconnects();  <end> <beg> private void handleInputQueue ( ) hrows IOException { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ;  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; if ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; }  <end> <beg> public String oString ( ) { int sops = 0 ; if ( sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ;  <end> <beg> public void handleIO ( ) hrows IOException { attemptReconnects();  <end> <beg> public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } return " {QA sa= " + socketAddress + " , #ops= " + ops . size ( ) + " , topop= " + ops . peek ( ) + " , interested= " + sops + " } " ;  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < AtomicInteger > ( ) { public boolean evaluate ( AtomicInteger i ) { return i . get ( ) = = 0 ; } } , timeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return rvMap ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> public int hash ( String k ) { int rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> private void assertHash ( HashAlgorithm ha , String key , int exp ) { assertTrue ( exp > = 0 ) ; assertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp);  <end> <beg> private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; }  <end> <beg> public void estNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ;  <end> <beg> public void estCrc32Hash ( ) { Map < String , Integer > exp = new HashMap < String , Integer > ( ) ; exp . put ( " Test1 " , 19315 ) ; exp . put ( " Test2 " , 21114 ) ; exp . put ( " Test3 " , 9597 ) ; exp . put ( " Test4 " , 15129 ) ; for ( Map . Entry < String , Integer > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estSingle ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> public void estTwo ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 www.yahoo.com:81 " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }  <end> <beg> public void estBrokenHost ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com:81:more " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenHost2 ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenList ( ) hrows Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenList2 ( ) hrows Exception { String s = " " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estNullList ( ) hrows Exception { String s = null ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> private void handleInputQueue ( ) { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ;  <end> <beg> private void handleIO ( SelectionKey sk ) { QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ;  <end> <beg> private void queueReconnect ( QueueAttachment qa ) { synchronized ( qa ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " ,  <end> <beg> private String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . oHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . oString ( ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < String > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) . equals ( " STORED " ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> static String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . oHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . oString ( ) ; }  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { qa . ops . add ( o ) ; if ( qa . ops . size ( ) = = 1 & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; b . flip ( ) ; } setBuffer ( b ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; client = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { client . flush ( ) ; }  <end> <beg> public void estSimpleGet ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; }  <end> <beg> public void estInvalidKey1 ( ) hrows Exception { try { client . get ( " key with spaces " ) ;  <end> <beg> public void estInvalidKey2 ( ) hrows Exception { try { StringBuilder longKey = new StringBuilder ( ) ;  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { client . set ( " est " + i , 5 , " value " + i ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } return Boolean . TRUE ; } } ) ;  <end> <beg> public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . add ( " est1 " , 5 , " ignoredvalue " ) ; }  <end> <beg> public void estUpdate ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . replace ( " est1 " , 5 , " est1value " ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estGetBulk ( ) hrows Exception { Collection < String > keys = Arrays . asList ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetBulkVararg ( ) hrows Exception { assertEquals ( 0 , client . getBulk ( " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( " /127.0.0.1:11211 " , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; }  <end> <beg> public void estGetStats ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " otal_items " ) ) ; }  <end> <beg> public void estNonexistentMutate ( ) hrows Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; }  <end> <beg> public void estMutateWithDefault ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; }  <end> <beg> public Long call ( ) hrows Exception { return client . incr ( " mtest " , 1 , 11 ) ; } } ) ;  <end> <beg> public void estImmediateDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estFutureDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " , 5 ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estFutureFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . flush ( 1 ) ; XXX: I do not understand the semantics of flush_all  <end> <beg> public void estDebugBuffer ( ) hrows Exception { String input = " his is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " his is a test \\ x5f " , s ) ; }  <end> <beg> public void estFutureFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; client . flush ( 2 ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; }  <end> <beg> public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( Operation . ReadType . DATA ) ; assertSame ( Operation . ReadType . DATA , op . getReadType ( ) ) ; }  <end> <beg> public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( Operation . ReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) ,  <end> <beg> public void handleLine ( String line ) { assert getReadType ( ) = = Operation . ReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( Operation . ReadType . DATA ) ;  <end> <beg> public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = Operation . ReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ;  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( msg ) ) ; }  <end> <beg> public void estGetKeys ( ) hrows Exception { client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; Collection < String > ks = client . findKeys ( " " ) ; assertEquals ( 2 , ks . size ( ) ) ; assertTrue ( ks . contains ( " est1 " ) ) ; assertTrue ( ks . contains ( " est2 " ) ) ; }  <end> <beg> public void receivedStatus ( String s ) { rv . put ( sa , s ) ; latch . countDown ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { latch . countDown ( ) ; } } ) ) ;  <end> <beg> public void receivedStatus ( String val ) { rv . set ( val ) ; latch . countDown ( ) ; } } ) ;  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; latch . countDown ( ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( val ) ; latch . countDown ( ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { latch . countDown ( ) ; }  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } } return rvMap ; }  <end> <beg> public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return obj ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { latch . await ( duration , units ) ; return obj ; }  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = qa . ops . isEmpty ( ) ; qa . ops . add ( o ) ; if ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; latch . countDown ( ) ; } } ) ;  <end> <beg> public Future < Boolean > delete ( String key ) { return delete ( key , 0 ) ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( line . equals ( " OK " ) ) ; latch . countDown ( ) ; } } ) ) ;  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return obj ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) ; getLogger ( ) . debug ( " Flush completed successfully " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { assertTrue ( client . flush ( ) . get ( ) ) ; client . shutdown ( ) ; client = null ; super . earDown ( ) ; }  <end> <beg> public void estDeleteFuture ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; Future < Boolean > f = client . delete ( " est1 " ) ; assertNull ( client . get ( " est1 " ) ) ; assertTrue ( " Deletion didn't return true " , f . get ( ) ) ; assertFalse ( " Second deletion returned true " , client . delete ( " est1 " ) . get ( ) ) ;  <end> <beg> public void estDelayedDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; client . delete ( " est1 " , 5 ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estDelayedFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; client . flush ( 2 ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; }  <end> <beg> public void estFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; assertTrue ( client . flush ( ) . get ( ) ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; BlockingQueue < Operation > createOperationQueue ( ) ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( readBufSize , his , addrs ) ; }  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( opQueueLen ) ; }  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = qa . ops . isEmpty ( ) ; boolean added = qa . ops . add ( o ) ; assert added ; }  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; latch . countDown ( ) ; } } ) ) ;  <end> <beg> public void receivedStatus ( String val ) { rv . set ( val . equals ( " STORED " ) ) ; latch . countDown ( ) ; } } ) ;  <end> <beg> public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . add , key , exp , o ) ; }  <end> <beg> public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; }  <end> <beg> public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . replace , key , exp , o ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " ) . get ( ) ) ; }  <end> <beg> private Operation addOp ( int which , Operation op ) { assert isAlive ( ) : " IO Thread is not running. " ; if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } conn . addOperation ( which , op ) ; return op ; }  <end> <beg> public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { shuttingDown = rue ; String baseName = getName ( ) ; setName ( baseName + " - SHUTTING DOWN " ) ; boolean rv = false ; if ( imeout > 0 ) { setName ( baseName + " - SHUTTING DOWN (waiting) " ) ; rv = waitForQueues ( imeout , unit ) ; } try { setName ( baseName + " - SHUTTING DOWN (telling client) " ) ; running = false ; conn . shutdown ( ) ; setName ( baseName + " - SHUTTING DOWN (informed client) " ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " exception while shutting down " , e ) ; } return rv ; }  <end> <beg> public void receivedStatus ( String s ) { latch . countDown ( ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void queueReconnect ( QueueAttachment qa ) { if ( ! shutDown ) { synchronized ( qa ) {  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; callback . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void estGracefulShutdown ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i));  <end> <beg> public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } }  <end> <beg> private Operation addOp ( int which , Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { shuttingDown = rue ; String baseName = getName ( ) ; setName ( baseName + " - SHUTTING DOWN " ) ; boolean rv = false ; try { }  <end> <beg> public void estAddNotSerializable ( ) hrows Exception { try { client . add ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public void estSetNotSerializable ( ) hrows Exception { try { client . set ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public void estReplaceNotSerializable ( ) hrows Exception { try { client . replace ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; assertEquals ( " Invalid " + ha + " for key " + key , exp , ha . hash ( key ) ) ; System.out.println(ha + "(" + key + ") = " + exp);  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estFowlerNollVoHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0xcbf29ce484222325L ) ; exp . put ( " " , 0xaf63bd4c8601b7ffL ) ; exp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x536c9cdee87c054aL ) ; exp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; exp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) ,  <end> <beg> public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; }  <end> <beg> public void estNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ;  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estFowlerNollVoHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0xcbf29ce484222325L ) ; exp . put ( " " , 0xaf63bd4c8601b7ffL ) ; exp . put ( " hello world! " , new Long ( 0x58735284b97b86bcL ) ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x536c9cdee87c054aL ) ; exp . put ( " wd:com.google " , 0xcf4e7986071b08f8L ) ; exp . put ( " wd:com.google " , 0x5d6176be12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV_HASH , me . getKey ( ) , Math . abs ( me  <end> <beg> public long hash ( String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> private boolean hasPendingOperations ( QueueAttachment qa ) { assert Thread . holdsLock ( qa ) : " Not locking qa " ; Operation nextOp = qa . getCurrentOp ( ) ; while ( nextOp ! = null & & nextOp . isCancelled ( ) ) { getLogger ( ) . info ( " Removing cancelled operation: %s " , nextOp ) ; qa . removeCurrentOp ( ) ; nextOp = qa . getCurrentOp ( ) ; } return nextOp ! = null ; }  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; synchronized ( qa ) { boolean wasEmpty = ! qa . hasOp ( ) ; qa . addOp ( o ) ; if ( wasEmpty & & qa . sk . isValid ( ) & & qa . channel . isConnected ( ) ) { qa . sk . interestOps ( SelectionKey . OP_WRITE ) ; } } addedQueue . offer ( qa ) ; selector . wakeup ( ) ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; }  <end> <beg> public void optimize ( ) { assert Thread . holdsLock ( his ) : " Not holding the lock for QA " ; getOp=(GetOperation)opq.remove();  <end> <beg> public Operation removeCurrentOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = opq . remove ( ) ; } else { getOp = null ; } return rv ; }  <end> <beg> public boolean hasOp ( ) { return ! ( getOp = = null & & opq . isEmpty ( ) ) ; }  <end> <beg> public void addOp ( Operation op ) { boolean added = opq . add ( op ) ; assert added ; }  <end> <beg> public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int size = opq . size ( ) + ( getOp = = null ? 0 : 1 ) ; return " {QA sa= " + socketAddress + " , #ops= " + size + " , topop= " + getCurrentOp ( ) + " , interested= " + sops + " } " ;  <end> <beg> public void initialize ( ) { }  <end> <beg> public int numCallbacks ( ) { return allCallbacks . size ( ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { Collection < Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( Callback c : cbs ) { c . gotData ( key , flags , data ) ;  <end> <beg> public void receivedStatus ( String line ) { for ( Callback c : allCallbacks ) { c . receivedStatus ( line ) ;  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line  <end> <beg> public void receivedStatus ( String line ) { if ( ! completed ) { cb . receivedStatus ( line ) ;  <end> <beg> private boolean selectorsMakeSense ( ) { for ( QueueAttachment qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . hasWriteOp ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; } } } fixupOps ( qa ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { boolean canWriteMore = rue ; while ( canWriteMore ) { Operation currentOp = qa . getCurrentWriteOp ( ) ;  <end> <beg> private void handleReads ( SelectionKey sk , QueueAttachment qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . buf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> private void fixupOps ( QueueAttachment qa ) { if ( qa . sk . isValid ( ) ) { int iops = qa . getSelectionOps ( ) ;  <end> <beg> private boolean preparePending ( QueueAttachment qa ) { }  <end> <beg> private void queueReconnect ( QueueAttachment qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " ,  <end> <beg> private void setupResend ( QueueAttachment qa ) { getLogger().warn("Discarding partially completed op: %s", op);  <end> <beg> public void addOperation ( int which , Operation o ) { QueueAttachment qa = connections [ which ] ; o . initialize ( ) ; qa . addOp ( o ) ; addedQueue . offer ( qa ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , which ) ; }  <end> <beg> public void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; }  <end> <beg> public void ransitionWriteItem ( ) { Operation op = writeQ . remove ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public void optimize ( ) { assert Thread . holdsLock ( his ) : " Not holding the lock for QA " ; getOp=(GetOperation)writeQ.remove();  <end> <beg> public Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; }  <end> <beg> public boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; }  <end> <beg> public boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; }  <end> <beg> public void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; }  <end> <beg> public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; int wsize = writeQ . size ( ) ; int isize = inputQueue . size ( ) ; return " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public final void readFromBuffer ( ByteBuffer data ) { if(readType == ReadType.DATA) {  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; if ( cb ! = null ) { cb . receivedStatus ( line ) ; } transitionState ( State . COMPLETE ) ; }  <end> <beg> public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> public void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public void optimize ( ) { getOp=(GetOperation)writeQ.remove();  <end> <beg> public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( ) ) ;  <end> <beg> private void setupResend ( QueueAttachment qa ) { op=qa.removeCurrentReadOp();  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOExcepting handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; } } } fixupOps ( qa ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . wbuf . hasRemaining ( ) ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ;  <end> <beg> private void handleReads ( SelectionKey sk , QueueAttachment qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> private boolean preparePending ( ) { }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { getLogger ( ) . info ( " Buffer: %s " , wbuf ) ; if ( wbuf . position ( ) < = wbuf . limit ( ) ) { wbuf . clear ( ) ;  <end> <beg> private boolean selectorsMakeSense ( ) { for ( QueueAttachment qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } if ( qa . oWrite > 0 ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; }  <end> <beg> private void handleWrites ( SelectionKey sk , QueueAttachment qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ;  <end> <beg> public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { wbuf . clear ( ) ;  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> Operation addOp ( int which , Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( which , op ) ; return op ; }  <end> <beg> public void receivedStatus ( String val ) { rv . set ( val . equals ( " STORED " ) ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; } } ) ;  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( val ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { assert line . equals ( " END " ) ; }  <end> <beg> public void receivedStatus ( String s ) { rv . put ( sa , s ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { assert line . equals ( " END " ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; } } ) ) ;  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( getServerForKey ( key ) , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; } } ) ) ;  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( getServerForKey ( key ) , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; }  <end> <beg> public void receivedStatus ( String line ) { rv . set ( line . equals ( " OK " ) ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; } } ) ) ;  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } return obj ; }  <end> <beg> private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; QueueAttachment qa = ( QueueAttachment ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; queueReconnect ( qa ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; qa . protocolErrors = 0 ; } catch ( OperationException e ) { if ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { queueReconnect ( qa ) ; } } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; queueReconnect ( qa ) ; } } } fixupOps ( qa ) ; }  <end> <beg> public void setupResend ( ) { }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> protected void wasCancelled ( ) { }  <end> <beg> public boolean hasErrored ( ) { return exception ! = null ; }  <end> <beg> public void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; }  <end> <beg> protected void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete();  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public final void readFromBuffer ( ByteBuffer data ) hrows IOException { if(readType == ReadType.DATA) {  <end> <beg> private void handleError ( ErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( State . COMPLETE ) ; throw exception ; }  <end> <beg> private ErrorType classifyError ( String line ) { ErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = ErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = ErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = ErrorType . SERVER ; } return rv ; }  <end> <beg> void receivedStatus ( String line ) ; void complete ( ) ; }  <end> <beg> public String oString ( ) { String rv = null ; if ( ype = = Operation . ErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; }  <end> <beg> public void complete ( ) { for ( Callback c : allCallbacks ) { c . complete ( ) ;  <end> <beg> public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = rue ; }  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = State . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> protected void wasCancelled ( ) { }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; transitionState ( State . COMPLETE ) ; }  <end> <beg> private void initClient ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; initClient ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { }  <end> <beg> public void estBadOperation ( ) hrows Exception { client . addOp ( 0 , new Operation ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> public void complete ( ) { System . err . println ( " Complete. " ) ; }  <end> <beg> public void receivedStatus ( String line ) { System . err . println ( " Received a line. " ) ; } } ) {  <end> <beg> public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; }  <end> <beg> protected void wasCancelled ( ) { getLogger ( ) . info ( " I was cancelled. " ) ; } } ) ;  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; while(lookingFor != '\0' && b.hasRemaining()) {  <end> <beg> private void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ;  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; rv . setGetOptimization ( false ) ; return rv ; } } ) ;  <end> <beg> public Integer call ( ) hrows Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte b [ ] = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode ; } } return hashcode ; } } ) ;  <end> <beg> public void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do {  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> public void estInvalidKey3 ( ) hrows Exception { try { Object val = client . get ( " Key " ) ;  <end> <beg> public void estInvalidAlgorithm ( ) { try { client . setHashAlgorithm ( null ) ;  <end> <beg> public void estSetHashAlg ( ) { assertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; client . setHashAlgorithm ( HashAlgorithm . FNV_HASH ) ; assertSame ( HashAlgorithm . FNV_HASH , client . getHashAlgorithm ( ) ) ; }  <end> <beg> public void estInvalidTranscoder ( ) { try { client . setTranscoder ( null ) ;  <end> <beg> public void estSetTranscoder ( ) { Transcoder c = client . getTranscoder ( ) ; assertTrue ( c instanceof SerializingTranscoder ) ; Transcoder mptc = new Transcoder ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; }  <end> <beg> public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; }  <end> <beg> public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ;  <end> <beg> public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; }  <end> <beg> public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( Operation . ErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estServer ( ) { OperationException oe = new OperationException ( Operation . ErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estClient ( ) { OperationException oe = new OperationException ( Operation . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( Operation . ErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estGeneral ( ) { }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expected ``END'', was ``%s'' " , line ) ;  <end> <beg> public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expeted ``END'', was ``%s'', " +  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { if ( args . length ! = 4 ) { System . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; System . exit ( 1 ) ; } int runs = Integer . parseInt ( args [ 0 ] ) ; int start = Integer . parseInt ( args [ 1 ] ) ; String serverlist = " 127.0.0.1: " + args [ 2 ] ; int hreads = Integer . parseInt ( args [ 3 ] ) ; MemcachedClient client = new MemcachedClient ( new DefaultConnectionFactory ( runs , 32768 ) , AddrUtil . getAddresses ( serverlist ) ) ; WorkerStat [ ] statArray = new WorkerStat [ hreads ] ; Thread [ ] hreadArray = new Thread [ hreads ] ; WorkerStat mainStat = new WorkerStat ( ) ; mainStat . runs = runs * hreads ; long begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { statArray [ i ] = new WorkerStat ( ) ; statArray [ i ] . start = start + i * runs ; statArray [ i ] . runs = runs ; threadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . setterTime = System . currentTimeMillis ( ) - begin ; begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . getterTime = System . currentTimeMillis ( ) - begin ; client . shutdown ( ) ; WorkerStat otalStat = new WorkerStat ( ) ; System . out . println ( " Thread start runs set time(ms) get time(ms) " ) ; for ( int i = 0 ; i < hreads ; i + + ) { System . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; totalStat . runs = otalStat . runs + statArray [ i ] . runs ; totalStat . setterTime = otalStat . setterTime + statArray [ i ] . setterTime ; totalStat . getterTime = otalStat . getterTime + statArray [ i ] . getterTime ; } System . out . println ( " nAvg " + runs + " " + otalStat . setterTime / hreads + " " + otalStat . getterTime / hreads ) ; System . out . println ( " nTotal " + otalStat . runs + " " + otalStat . setterTime + " " + otalStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * otalStat . runs / otalStat . setterTime + " get - " + 1000 * otalStat . runs / otalStat . getterTime ) ; System . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * mainStat . runs / mainStat . setterTime + " get - " + 1000 * mainStat . runs  <end> <beg> public void run ( ) { String keyBase = " estKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; }  <end> <beg> public void run ( ) { String keyBase = " estKey " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { String str = ( String ) mc . get ( " " + i + keyBase ) ; assert str ! = null ; } long end = System . currentTimeMillis ( ) ; stat . getterTime = end - begin ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + key . length ( ) + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public void addOperation ( int which , Operation o ) { boolean placed = false ; int pos = which ; int loops = 0 ; while ( ! placed ) { assert loops < 3 : " Too many loops! " ;  <end> <beg> public void shutdown ( ) hrows IOException { for ( QueueAttachment qa : connections ) { if ( qa . channel ! = null ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { }  <end> <beg> protected void flushPause ( ) hrows InterruptedException { }}  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11211 127.0.0.1:11212 " ) ) ;  <end> <beg> protected void flushPause ( ) hrows InterruptedException { Thread . sleep ( 100 ) ; }  <end> <beg> public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; Thread . sleep ( 100 ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; assertFalse ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; } System . err . println ( getName ( ) + " complete. " ) ; }  <end> <beg> public void estCrap ( ) hrows Exception { main ( new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ) ; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { if ( args . length ! = 4 ) { System . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; System . exit ( 1 ) ; } int runs = Integer . parseInt ( args [ 0 ] ) ; int start = Integer . parseInt ( args [ 1 ] ) ; String serverlist = " 127.0.0.1: " + args [ 2 ] ; int hreads = Integer . parseInt ( args [ 3 ] ) ; MemcachedClient client = new MemcachedClient ( new DefaultConnectionFactory ( 100000 , 32768 ) , AddrUtil . getAddresses ( serverlist ) ) ; WorkerStat [ ] statArray = new WorkerStat [ hreads ] ; Thread [ ] hreadArray = new Thread [ hreads ] ; WorkerStat mainStat = new WorkerStat ( ) ; mainStat . runs = runs * hreads ; long begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { statArray [ i ] = new WorkerStat ( ) ; statArray [ i ] . start = start + i * runs ; statArray [ i ] . runs = runs ; threadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . setterTime = System . currentTimeMillis ( ) - begin ; begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . getterTime = System . currentTimeMillis ( ) - begin ; client . shutdown ( ) ; WorkerStat otalStat = new WorkerStat ( ) ; System . out . println ( " Thread start runs set time(ms) get time(ms) " ) ; for ( int i = 0 ; i < hreads ; i + + ) { System . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; totalStat . runs = otalStat . runs + statArray [ i ] . runs ; totalStat . setterTime = otalStat . setterTime + statArray [ i ] . setterTime ; totalStat . getterTime = otalStat . getterTime + statArray [ i ] . getterTime ; } System . out . println ( " nAvg " + runs + " " + otalStat . setterTime / hreads + " " + otalStat . getterTime / hreads ) ; System . out . println ( " nTotal " + otalStat . runs + " " + otalStat . setterTime + " " + otalStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * otalStat . runs / otalStat . setterTime + " get - " + 1000 * otalStat . runs / otalStat . getterTime ) ; System . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * mainStat . runs / mainStat . setterTime + " get - " + 1000 * mainStat . runs  <end> <beg> public void run ( ) { String keyBase = " estKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { mc . set ( " " + i + keyBase , 3600 , object ) ; if ( otal . incrementAndGet ( ) > = MAX_QUEUE ) { flush ( ) ; } } long end = System . currentTimeMillis ( ) ; stat . setterTime = end - begin ; }  <end> <beg> private synchronized void flush ( ) { if ( otal . intValue ( ) > = MAX_QUEUE ) { mc . waitForQueues ( 5 , TimeUnit . SECONDS ) ;  <end> <beg> public void addOperation ( int which , Operation o ) { boolean placed = false ; int pos = which ; int loops = 0 ; assert loops < 3 : "Too many loops!";  <end> <beg> private boolean selectorsMakeSense ( ) { for ( MemcachedNode qa : connections ) { if ( qa . sk . isValid ( ) ) { if ( qa . channel . isConnected ( ) ) { int sops = qa . sk . interestOps ( ) ; int expected = 0 ; if ( qa . hasReadOp ( ) ) { expected | = SelectionKey . OP_READ ; } if ( qa . hasWriteOp ( ) ) { expected | = SelectionKey . OP_WRITE ; } if ( qa . oWrite > 0 ) { expected | = SelectionKey . OP_WRITE ; } assert sops = = expected : " Invalid ops: " + qa + " , expected " + expected + " , got " + sops ; } else { int sops = qa . sk . interestOps ( ) ; assert sops = = SelectionKey . OP_CONNECT : " Not connected, and not watching for connect: " + sops ; } } } getLogger ( ) . debug ( " Checked the selectors. " ) ; return rue ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void handleIO ( SelectionKey sk ) { assert ! sk . isAcceptable ( ) : " We don't do accepting here. " ; MemcachedNode qa = ( MemcachedNode ) sk . attachment ( ) ; if ( sk . isConnectable ( ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; try { if ( qa . channel . finishConnect ( ) ) { assert qa . channel . isConnected ( ) : " Not connected. " ; qa . reconnectAttempt = 0 ; addedQueue . offer ( qa ) ; if ( qa . wbuf . hasRemaining ( ) ) { handleWrites ( sk , qa ) ; } } else { assert ! qa . channel . isConnected ( ) : " connected " ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Problem handling connect " , e ) ; queueReconnect ( qa ) ; } } else { if ( sk . isWritable ( ) ) { try { handleWrites ( sk , qa ) ; } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentWriteOp ( ) , e ) ; queueReconnect ( qa ) ; } } if ( sk . isReadable ( ) ) { try { handleReads ( sk , qa ) ; qa . protocolErrors = 0 ; } catch ( OperationException e ) { if ( + + qa . protocolErrors > = EXCESSIVE_ERRORS ) { queueReconnect ( qa ) ; } } catch ( IOException e ) { getLogger ( ) . info ( " IOException handling %s, reconnecting " , qa . getCurrentReadOp ( ) , e ) ; queueReconnect ( qa ) ; } } } fixupOps ( qa ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . channel . write ( qa . wbuf ) ;  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; int read = qa . channel . read ( qa . rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> private void fixupOps ( MemcachedNode qa ) { if ( qa . sk . isValid ( ) ) { int iops = qa . getSelectionOps ( ) ;  <end> <beg> private void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " ,  <end> <beg> private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < MemcachedNode > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  <end> <beg> public void shutdown ( ) hrows IOException { for ( MemcachedNode qa : connections ) { if ( qa . channel ! = null ) { qa . channel . close ( ) ; qa . sk = null ; if ( qa . oWrite > 0 ) { getLogger ( ) . warn ( " Shut down with %d bytes remaining to write " , qa . oWrite ) ; } getLogger ( ) . debug ( " Shut down channel %s " , qa . channel ) ; } } selector . close ( ) ; getLogger ( ) . debug ( " Shut down selector %s " , selector ) ; }  <end> <beg> public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNode qa : connections ) { sb . append ( " " ) ; sb . append ( qa . socketAddress ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; }  <end> <beg> public void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; }  <end> <beg> public void setupResend ( ) { }  <end> <beg> private boolean preparePending ( ) { }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { wbuf . clear ( ) ;  <end> <beg> public void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public void optimize ( ) { getOp=(GetOperation)writeQ.remove();  <end> <beg> public Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; }  <end> <beg> public boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; }  <end> <beg> public boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; }  <end> <beg> public void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; }  <end> <beg> public String oString ( ) { int sops = 0 ; if ( sk ! = null & & sk . isValid ( ) ) { sops = sk . interestOps ( ) ; } int rsize = readQ . size ( ) + ( getOp = = null ? 0 : 1 ) ; int wsize = writeQ . size ( ) ; int isize = inputQueue . size ( ) ; return " {QA sa= " + socketAddress + " , #Rops= " + rsize + " , #Wops= " + wsize  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . oWrite > 0 ; while ( canWriteMore ) { int wrote = qa . getChannel ( ) . write ( qa . getWbuf ( ) ) ;  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNode qa : connections ) { sb . append ( " " ) ; sb . append ( qa . getSocketAddress ( ) ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; }  <end> <beg> public void setupResend ( ) { }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { getWbuf ( ) . clear ( ) ;  <end> <beg> public boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ;  <end> <beg> public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { setChannel ( ch ) ; setSk ( selectionKey ) ; }  <end> <beg> private void computeNext ( ) { if ( + + next > = nodes . length ) { next = 0 ; } if ( next = = start ) { next = - 1 ;  <end> <beg> public void remove ( ) { throw new UnsupportedOperationException ( " Can't remove a node " ) ; }  <end> <beg> MemcachedNode getPrimary ( String k ) ; Collection < MemcachedNode > getAll ( ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; Collection < MemcachedNode > getAll ( ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ;  <end> <beg> public void setupResend ( ) { }  <end> <beg> public int writeSome ( ) hrows IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert oWrite > = 0 : " oWrite went negative after writing " + wrote + " bytes for " + his ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; }  <end> <beg> public MemcachedNodeImpl next ( ) { return nodes [ next ] ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNodeImpl qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingInBuffer ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ;  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNodeImpl qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> private void queueReconnect ( MemcachedNodeImpl qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " ,  <end> <beg> private void attemptReconnects ( ) hrows IOException { long now = System . currentTimeMillis ( ) ; for ( Iterator < MemcachedNodeImpl > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  <end> <beg> public String oString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNodeImpl qa : connections ) { sb . append ( " " ) ; sb . append ( qa . getSocketAddress ( ) ) ; } sb . append ( " } " ) ; return sb . oString ( ) ; }  <end> <beg> MemcachedNodeImpl getPrimary ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; }  <end> <beg> Iterator < MemcachedNodeImpl > getSequence ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( optimizeGets ) ; boolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ;  <end> <beg> void copyInputQueue ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void setupResend ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void ransitionWriteItem ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> Operation getCurrentReadOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> boolean hasReadOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> boolean hasWriteOp ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void addOp ( Operation op ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> int getSelectionOps ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> ByteBuffer getRbuf ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> ByteBuffer getWbuf ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> boolean isActive ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void reconnecting ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void connected ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> int getReconnectCount ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void setChannel ( SocketChannel o ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> SocketChannel getChannel ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> void setSk ( SelectionKey o ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> SelectionKey getSk ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; int writeSome ( ) hrows IOException ; }  <end> <beg> private void optimize ( ) { getOp=(GetOperation)writeQ.remove();  <end> <beg> MemcachedNode getPrimary ( String k ) ; Collection < MemcachedNodeImpl > getAll ( ) ; }  <end> <beg> public MemcachedNode next ( ) { try { return nodes [ next ] ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; nodes = new MemcachedNode [ 4 ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; }  <end> <beg> public void estPrimary ( ) hrows Exception { assertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; }  <end> <beg> public void estAll ( ) hrows Exception { Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; }  <end> <beg> public void estSeq1 ( ) { assertSequence ( " dustin " , 2 , 3 , 0 , 1 ) ; assertSequence ( " noelani " , 1 , 2 , 3 , 0 ) ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( readBufSize , his , addrs , hashAlg ) ; }  <end> <beg> Operation addOp ( final String key , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } }  <end> <beg> Operation addOp ( final MemcachedNode node , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( node , op ) ; return op ; }  <end> <beg> CountDownLatch broadcastOp ( final OperationFactory of ) { return broadcastOp ( of , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( OperationFactory of , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of ) ; }  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperation ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperation ( new OperationCallback ( ) {  <end> <beg> public void receivedStatus ( String s ) { rv . put ( sa , s ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperation ( arg , new StatsOperation . Callback ( ) {  <end> <beg> public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; }  <end> <beg> public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expeted ``END'', was ``%s'' " ,  <end> <beg> private long mutate ( MutatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , new MutatorOperation ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperation ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperation ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) {  <end> <beg> public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) { return blatch.await(timeout, unit);  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) {  <end> <beg> public void receivedStatus ( String s ) { latch . countDown ( ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } return objRef . get ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { latch . await ( duration , units ) ; return objRef . get ( ) ; }  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) ) { placeIn = primary ; } else { }  <end> <beg> public void addOperation ( final MemcachedNode node , final Operation o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , node ) ; }  <end> <beg> void copyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> void setupResend ( ) ; void fixupOps ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void fixupOps ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void fixupOps ( ) ; }  <end> <beg> int getSelectionOps ( ) ; void fixupOps ( ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void fixupOps ( ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void fixupOps ( ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean isActive ( ) ; void fixupOps ( ) ; }  <end> <beg> void reconnecting ( ) ; void fixupOps ( ) ; }  <end> <beg> void connected ( ) ; void fixupOps ( ) ; }  <end> <beg> int getReconnectCount ( ) ; void fixupOps ( ) ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void fixupOps ( ) ; }  <end> <beg> void setChannel ( SocketChannel o ) ; void fixupOps ( ) ; }  <end> <beg> SocketChannel getChannel ( ) ; void fixupOps ( ) ; }  <end> <beg> void setSk ( SelectionKey o ) ; void fixupOps ( ) ; }  <end> <beg> SelectionKey getSk ( ) ; void fixupOps ( ) ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; void fixupOps ( ) ; }  <end> <beg> int writeSome ( ) hrows IOException ; void fixupOps ( ) ; }  <end> <beg> public void fixupOps ( ) { if ( sk ! = null & & sk . isValid ( ) ) { int iops = getSelectionOps ( ) ;  <end> <beg> public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new Operation ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( nodes , HashAlgorithm . NATIVE_HASH ) ; }  <end> <beg> public void estPrimary ( ) hrows Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; }  <end> <beg> public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; }  <end> <beg> public void estSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 2 , 3 , 0 ) ; }  <end> <beg> public void estSeq2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 1 , 2 , 3 ) ; }  <end> <beg> public void estSeqOnlyOneServer ( ) { setupNodes ( 1 ) ; assertSequence ( " noelani " ) ; }  <end> <beg> public void estSeqWithTwoNodes ( ) { setupNodes ( 2 ) ; assertSequence ( " dustin " , 0 ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { serverList = " 127.0.0.1:11211 127.0.0.1:11212 " ; super . setUp ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { serverList = " 127.0.0.1:11211 " ; super . earDown ( ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; }  <end> <beg> private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ;  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> private void nextHash ( ) { }  <end> <beg> public boolean hasNext ( ) { return remainingTries > 0 ; }  <end> <beg> public MemcachedNode next ( ) { try { return getNodeForKey ( hashVal ) ;  <end> <beg> public void remove ( ) { throw new UnsupportedOperationException ( " remove not supported " ) ; }  <end> <beg> private void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ; nodeMocks [ i ] . expects ( exactly ( KetamaNodeLocator . NUM_REPS ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; nodes [ i ] = ( MemcachedNode ) nodeMocks [ i ] . proxy ( ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ;  <end> <beg> private InvocationMatcher exactly ( final int ) { return new InvocationMatcher ( ) { private int cnt = 0 ;  <end> <beg> public boolean matches ( Invocation arg0 ) { return ( cnt + + < ) ; }  <end> <beg> public boolean hasDescription ( ) { return rue ; }  <end> <beg> public void verify ( ) { if ( cnt ! = ) { hrow new AssertionFailedError ( " Expected " +  <end> <beg> public StringBuffer describeTo ( StringBuffer buf ) { buf . append ( " allowed " ) ; return buf ; }  <end> <beg> public void estLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 1 , 3 ) ; }  <end> <beg> public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 0 , 0 , 0 ) ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs ) ; }  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }  <end> <beg> protected void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ;  <end> <beg> protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ;  <end> <beg> protected void setupNodes ( int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( once ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ;  <end> <beg> public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ;  <end> <beg> public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " N6H4245M " ) ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> BlockingQueue < OperationImpl > createOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> public BlockingQueue < OperationImpl > createOperationQueue ( ) { return new ArrayBlockingQueue < OperationImpl > ( getOpQueueLen ( ) ) ; }  <end> <beg> OperationImpl addOp ( final String key , final OperationImpl op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } }  <end> <beg> OperationImpl addOp ( final MemcachedNode node , final OperationImpl op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( node , op ) ; return op ; }  <end> <beg> public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . add , key , exp , o ) ; }  <end> <beg> public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . set , key , exp , o ) ; }  <end> <beg> public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreOperationImpl . StoreType . replace , key , exp , o ) ; }  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; OperationImpl op = new GetOperationImpl ( key , new GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperationImpl ( new OperationCallback ( ) {  <end> <beg> public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperationImpl ( arg , new StatsOperationImpl . Callback ( ) {  <end> <beg> private long mutate ( MutatorOperationImpl . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , new MutatorOperationImpl ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> public long incr ( String key , int by ) { return mutate ( MutatorOperationImpl . Mutator . incr , key , by ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( MutatorOperationImpl . Mutator . decr , key , by ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperationImpl . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperationImpl . Mutator . incr , key , by , def ) ;  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatorOperationImpl . Mutator . decr , key , by , def ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperationImpl op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) {  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit);  <end> <beg> public OperationImpl newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) {  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( OperationImpl op : ops ) { rv | = op . getState ( ) = = OperationImpl . State . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; }  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { latch . await ( imeout , unit ) ; for ( OperationImpl op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = OperationImpl . State . COMPLETE ; }  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { OperationImpl currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> public void addOperation ( final String key , final OperationImpl o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) ) { placeIn = primary ; } else { }  <end> <beg> public void addOperation ( final MemcachedNode node , final OperationImpl o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %d " , o , node ) ; }  <end> <beg> void copyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> void setupResend ( ) ; void fixupOps ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void fixupOps ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void fixupOps ( ) ; }  <end> <beg> OperationImpl getCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> OperationImpl removeCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> OperationImpl getCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> OperationImpl removeCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> void addOp ( OperationImpl op ) ; void fixupOps ( ) ; }  <end> <beg> public void copyInputQueue ( ) { Collection < OperationImpl > mp = new ArrayList < OperationImpl > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; }  <end> <beg> public void setupResend ( ) { }  <end> <beg> private boolean preparePending ( ) { }  <end> <beg> public void ransitionWriteItem ( ) { OperationImpl op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = OperationImpl . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove();  <end> <beg> public OperationImpl removeCurrentReadOp ( ) { return readQ . remove ( ) ; }  <end> <beg> public OperationImpl removeCurrentWriteOp ( ) { OperationImpl rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; }  <end> <beg> public void addOp ( OperationImpl op ) { boolean added = inputQueue . add ( op ) ; assert added ; }  <end> <beg> OperationImpl newOp ( MemcachedNode , CountDownLatch latch ) ; }  <end> <beg> public String oString ( ) { String rv = null ; if ( ype = = OperationImpl . ErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; }  <end> <beg> public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new OperationImpl ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationImpl . ReadType . DATA ) ; assertSame ( OperationImpl . ReadType . DATA , op . getReadType ( ) ) ; }  <end> <beg> public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; assertSame ( OperationImpl . ReadType . LINE , op . getReadType ( ) ) ; }  <end> <beg> public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) ,  <end> <beg> public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationImpl . ReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; }  <end> <beg> public void handleLine ( String line ) { assert getReadType ( ) = = OperationImpl . ReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationImpl . ReadType . DATA ) ;  <end> <beg> public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationImpl . ReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ;  <end> <beg> public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationImpl . ErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estServer ( ) { OperationException oe = new OperationException ( OperationImpl . ErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationImpl . ErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estClient ( ) { OperationException oe = new OperationException ( OperationImpl . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationImpl . ErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estGeneral ( ) { }  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = new GetOperationImpl ( key , new GetOperationImpl . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return new VersionOperationImpl ( new OperationCallback ( ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return new StatsOperationImpl ( arg , new StatsOperationImpl . Callback ( ) {  <end> <beg> public long incr ( String key , int by ) { return mutate ( MutatatorOperation . Mutator . incr , key , by ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( MutatatorOperation . Mutator . decr , key , by ) ; }  <end> <beg> private long mutateWithDefault ( MutatorOperationImpl . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( MutatatorOperation . Mutator . incr , key , by , def ) ;  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( MutatatorOperation . Mutator . decr , key , by , def ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) {  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit);  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) {  <end> <beg> private void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove();  <end> <beg> boolean isCancelled ( ) ; void handleLine ( String line ) ; }  <end> <beg> boolean hasErrored ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationException getException ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void handleLine ( String line ) ; }  <end> <beg> void cancel ( ) ; void handleLine ( String line ) ; }  <end> <beg> State getState ( ) ; void handleLine ( String line ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; }  <end> <beg> void writeComplete ( ) ; void handleLine ( String line ) ; }  <end> <beg> ReadType getReadType ( ) ; void handleLine ( String line ) ; }  <end> <beg> void initialize ( ) ; void handleLine ( String line ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; void handleLine ( String line ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; }  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) ,  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( BroadcastOpFactory of , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of ) ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new FlushOperationImpl ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperationImpl ( new OperationCallback ( ) { return blatch.await(timeout, unit);  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; OperationFactory getOperationFactory ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; OperationFactory getOperationFactory ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; OperationFactory getOperationFactory ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; }  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( String line ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) {  <end> <beg> private long mutate ( MutatatorOperation . Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> private long mutateWithDefault ( MutatatorOperation . Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperation . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { flushResult . set ( line . equals ( " OK " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) {  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) { return blatch.await(timeout, unit);  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) {  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( MutatatorOperation . Mutator m , String key , int by , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> void gotData ( String key , int flags , byte [ ] data ) ; } Collection < String > getKeys ( ) ; }  <end> <beg> public DeleteOperation delete ( String key , int when , OperationCallback cb ) { return new DeleteOperationImpl ( key , when , cb ) ; }  <end> <beg> public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; }  <end> <beg> public GetOperation get ( String key , Callback cb ) { return new GetOperationImpl ( key , cb ) ; }  <end> <beg> public GetOperation get ( Collection < String > keys , Callback cb ) { return new GetOperationImpl ( keys , cb ) ; }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }  <end> <beg> public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; }  <end> <beg> public VersionOperation version ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ;  <end> <beg> public void receivedStatus ( String line ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( line ) ;  <end> <beg> public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ;  <end> <beg> public final void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( mp ) ; writeQ . addAll ( mp ) ; }  <end> <beg> public final void setupResend ( ) { }  <end> <beg> public final void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 ) { getWbuf ( ) . clear ( ) ;  <end> <beg> public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = Operation . State . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public final Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; }  <end> <beg> public final Operation removeCurrentWriteOp ( ) { Operation rv = getOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { getOp = null ; } return rv ; }  <end> <beg> public final boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; }  <end> <beg> public final boolean hasWriteOp ( ) { return ! ( getOp = = null & & writeQ . isEmpty ( ) ) ; }  <end> <beg> public final void addOp ( Operation op ) { boolean added = inputQueue . add ( op ) ; assert added ; }  <end> <beg> public final boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ;  <end> <beg> public final void reconnecting ( ) { reconnectAttempt + + ; }  <end> <beg> public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { setChannel ( ch ) ; setSk ( skey ) ; }  <end> <beg> public final int writeSome ( ) hrows IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert oWrite > = 0 : " oWrite went negative after writing " + wrote + " bytes for " + his ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; }  <end> <beg> public final void fixupOps ( ) { if ( sk ! = null & & sk . isValid ( ) ) { int iops = getSelectionOps ( ) ;  <end> <beg> protected final void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove();  <end> <beg> CachedData encode ( Object o ) ; Object decode ( CachedData d ) ; }  <end> <beg> protected void optimize ( ) { getOp=(GetOperationImpl)writeQ.remove();  <end> <beg> public final void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ;  <end> <beg> public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do {  <end> <beg> public final void initialize ( ) { }  <end> <beg> protected final void wasCancelled ( ) { cb . receivedStatus ( " cancelled " ) ; }  <end> <beg> public final boolean isCancelled ( ) { return cancelled ; }  <end> <beg> public final boolean hasErrored ( ) { return exception ! = null ; }  <end> <beg> public final void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; }  <end> <beg> protected final void ransitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete();  <end> <beg> public final void writeComplete ( ) { transitionState ( State . READING ) ; }  <end> <beg> public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o ) ; }  <end> <beg> public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o ) ; }  <end> <beg> public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o ) ; }  <end> <beg> private long mutate ( Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( String val ) { rv . set ( new Long ( val = = null ? " -1 " : val ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }  <end> <beg> public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by ) ; }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def ) { long rv = mutate ( , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def ) ;  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } cancelled = rue ; return rv ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return op . getState ( ) = = OperationState . COMPLETE ; }  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> boolean isCancelled ( ) ; void handleLine ( String line ) ; }  <end> <beg> boolean hasErrored ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationException getException ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void handleLine ( String line ) ; }  <end> <beg> void cancel ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationState getState ( ) ; void handleLine ( String line ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; }  <end> <beg> void writeComplete ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationReadType getReadType ( ) ; void handleLine ( String line ) ; }  <end> <beg> public String oString ( ) { String rv = null ; if ( ype = = OperationErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; }  <end> <beg> public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; assert op . getState ( ) = = OperationState . READING ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; assert line . equals ( " DELETED " ) | | line . equals ( " NOT_FOUND " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . equals ( " OK " ) : " Expected OK, was " + line ; getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; String found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = line ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected final void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete();  <end> <beg> public final void writeComplete ( ) { transitionState ( OperationState . READING ) ; }  <end> <beg> public abstract void initialize ( ) ; public abstract void handleLine(String line);}  <end> <beg> public final void readFromBuffer ( ByteBuffer data ) hrows IOException { if(readType == OperationReadType.DATA) {  <end> <beg> private void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; }  <end> <beg> private OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; }  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( line ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( line . substring ( " VERSION " . length ( ) ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; assertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; }  <end> <beg> public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; assertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; }  <end> <beg> public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) ,  <end> <beg> public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; }  <end> <beg> public void handleLine ( String line ) { assert getReadType ( ) = = OperationReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationReadType . DATA ) ;  <end> <beg> public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ;  <end> <beg> public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estGeneral ( ) { }  <end> <beg> protected void wasCancelled ( ) { getLogger ( ) . debug ( " was cancelled. " ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ) ;  <end> <beg> boolean isCancelled ( ) ; void handleLine ( String line ) ; }  <end> <beg> boolean hasErrored ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationException getException ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void handleLine ( String line ) ; }  <end> <beg> void cancel ( ) ; void handleLine ( String line ) ; }  <end> <beg> OperationState getState ( ) ; void handleLine ( String line ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void handleLine ( String line ) ; }  <end> <beg> void writeComplete ( ) ; void handleLine ( String line ) ; }  <end> <beg> public void receivedStatus ( String val ) { }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void receivedStatus ( String line ) { getLogger().warn("Expected ``END'', was ``%s''", line);  <end> <beg> public void receivedStatus ( String line ) { getLogger().warn("Expeted ``END'', was ``%s''",  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { }  <end> <beg> public void receivedStatus ( String line ) { }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( String line ) { }  <end> <beg> public void receivedStatus ( String line ) { }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new OperationFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return new VersionOperation ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( String line ) { return blatch.await(timeout, unit);  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; }  <end> <beg> public Future < Object > asyncGet ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Object > rv = new OperationFuture < Object > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Object val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = ranscoder . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ;  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . put ( sa , s . getMessage ( ) ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful stat fetch: %s " ,  <end> <beg> private long mutate ( Mutator m , String key , int by ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) {  <end> <beg> public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit);  <end> <beg> void receivedStatus ( OperationStatus status ) ; void complete ( ) ; }  <end> <beg> public String oString ( ) { return " {OperationStatus success= " + isSuccess + " : " + message + " } " ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected final void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( rue , line ) ; } getCallback ( ) . receivedStatus ( found ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected void wasCancelled ( ) { }  <end> <beg> public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ;  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( END ) ;  <end> <beg> protected void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; }  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected void wasCancelled ( ) { }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , line . substring ( " VERSION " . length ( ) ) ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) {  <end> <beg> public abstract void initialize ( ) ; public abstract void readFromBuffer ( ByteBuffer data ) hrows IOException ; protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } public void handleRead ( ByteBuffer data ) { assert false ; } }  <end> <beg> public abstract void readFromBuffer ( ByteBuffer data ) hrows IOException ; protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; } public void handleRead ( ByteBuffer data ) { assert false ; } }  <end> <beg> protected void handleError ( OperationErrorType eType , String line ) throws IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } transitionState ( OperationState . COMPLETE ) ; throw exception ; }  <end> <beg> OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; }  <end> <beg> protected void optimize ( ) { }}  <end> <beg> public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { }  <end> <beg> public FlushOperation flush ( int delay , OperationCallback cb ) { }  <end> <beg> public GetOperation get ( String key , Callback callback ) { }  <end> <beg> public GetOperation get ( Collection < String > value , Callback cb ) { }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { }  <end> <beg> public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { }  <end> <beg> public VersionOperation version ( OperationCallback cb ) { }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) hrows IOException { }}  <end> <beg> protected void prepareBuffer ( int cmd , int opaque , String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) ) ; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { return blatch.await(timeout, unit);  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) {  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> boolean isCancelled ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> boolean hasErrored ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> OperationException getException ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> void cancel ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> OperationState getState ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> void writeComplete ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> void initialize ( ) ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; void handleRead ( ByteBuffer data ) ; }  <end> <beg> public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }  <end> <beg> public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( cb ) ; }  <end> <beg> public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , EMPTY_BYTES ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { int toRead=payload.length - payloadOffset;  <end> <beg> private void finishedPayload ( byte [ ] pl ) hrows IOException { transitionState ( OperationState . COMPLETE ) ; if ( errorCode ! = 0 ) { handleError ( OperationErrorType . GENERAL , new String ( pl ) ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { System . err . println ( " Expected " + opaque + " , got " + responseOpaque ) ; return responseOpaque = = opaque ; }  <end> <beg> private int decodeInt ( byte [ ] data , int i ) { System . out . printf ( " Decoding %d %d %d %d " , data [ i ] , data [ i + 1 ] , data [ i + 2 ] , data [ i + 3 ] ) ; return data [ i ] < < 24 | data [ i + 1 ] < < 16  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> static int generateOpaque ( ) { int rv = seqNumber . incrementAndGet ( ) ; while ( rv < 0 ) { seqNumber . compareAndSet ( rv , 0 ) ; rv = seqNumber . incrementAndGet ( ) ; } return rv ; }  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) ,  <end> <beg> public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , EMPTY_BYTES ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - 4 ] ; System . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( key , flags , data ) ; cb . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void handleError ( int errCode , byte [ ] errPl ) hrows IOException { if ( errCode = = NOT_FOUND ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ;  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> private void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode ! = 0 ) { handleError ( errorCode , pl ) ;  <end> <beg> protected void handleError ( int errCode , byte [ ] errPl ) hrows IOException { handleError ( OperationErrorType . SERVER , new String ( errPl ) ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { System . err . printf ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; }  <end> <beg> static int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16  <end> <beg> private static int cmdMap ( StoreType ) { int rv = - 1 ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : assert false : " Unhandled store type: " + ; } return rv ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , data , flags , exp ) ; }  <end> <beg> public void estIntegerDecode ( ) { assertEquals ( 129 , OperationImpl . decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , OperationImpl . decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , OperationImpl . decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , OperationImpl . decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ;  <end> <beg> public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Transitioning %s to read " , op ) ; readQ . add ( op ) ; }  <end> <beg> public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; }  <end> <beg> public GetOperation get ( Collection < String > value , Callback cb ) { return new MultiGetOperationImpl ( value , cb ) ; }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , OperationCallback cb ) { }  <end> <beg> public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { }  <end> <beg> public VersionOperation version ( OperationCallback cb ) { }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - 4 ] ; System . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = erminalOpaque | | keys . containsKey ( responseOpaque ) ;  <end> <beg> protected void resetInput ( ) { payload = null ; payloadOffset = 0 ; headerOffset = 0 ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode ! = 0 ) { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ;  <end> <beg> protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { getLogger ( ) . warn ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11212 " ) ) ;  <end> <beg> public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( " /127.0.0.1:11212 " , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { serverList = " 127.0.0.1:11211 127.0.0.1:11311 " ; super . setUp ( ) ; }  <end> <beg> public void estServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: SERVER_ERROR figures " , String . valueOf ( oe ) ) ;  <end> <beg> public void estClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , String . valueOf ( oe ) ) ;  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , int def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl(m, key, by, def, exp, cb);  <end> <beg> public void initialize ( ) { }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 4 : " expected 4 bytes, got " + pl . length ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeInt ( pl , 0 ) ) ) ) ;  <end> <beg> static long decodeUnsignedInt ( byte [ ] data , int i ) { return ( ( long ) ( data [ i ] & 0xff ) < < 24 ) | ( ( data [ i + 1 ] & 0xff ) < < 16 )  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> public void estIntegerDecode ( ) { assertEquals ( 129 , decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ;  <end> <beg> public void estUnsignedIntegerDecode ( ) { assertEquals ( 129 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129L * 256L * 256L * 256L , decodeUnsignedInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ;  <end> <beg> public void initialize ( ) { }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 8 : " expected 8 bytes, got " + pl . length ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ;  <end> <beg> static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ;  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createOperationQueue ( ) ,  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) ) ; }  <end> <beg> public void estGracefulShutdown ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; assertEquals(i, m.get("t" + i));  <end> <beg> public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 3 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } }  <end> <beg> public void estOperationStatusString ( ) { String s = String . valueOf ( OperationImpl . STATUS_OK ) ; assertEquals ( " {OperationStatus success=true: OK} " , s ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ;  <end> <beg> public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = rue ; }  <end> <beg> protected void optimize ( ) { getOp=(GetOperation)writeQ.remove();  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; rkeys . put ( k , rv ) ; } return rv ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ;  <end> <beg> public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ;  <end> <beg> public int numCallbacks ( ) { return allCallbacks . size ( ) ; }  <end> <beg> public void addOperation ( GetOperation o ) { getKeys ( ) . addAll ( o . getKeys ( ) ) ; pcb . addCallbacks ( o ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult ) { @Override  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ;  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITING ; } return rv ; }  <end> <beg> public boolean isCancelled ( ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . isCancelled ( ) ; } return rv ; }  <end> <beg> public boolean isDone ( ) { boolean rv = rue ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11213 " ) ) ;  <end> <beg> protected void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; try { Object o = f . get ( ) ;  <end> <beg> public void estAsyncGetCancellation ( ) hrows Exception { tryCancellation ( client . asyncGet ( " k " ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationCollection ( ) hrows Exception { tryCancellation ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationVararg ( ) hrows Exception { tryCancellation ( client . asyncGetBulk ( " k " , " k2 " ) ) ; }  <end> <beg> public void estDeleteCancellation ( ) hrows Exception { tryCancellation ( client . delete ( " x " ) ) ; }  <end> <beg> public void estDelayedDeleteCancellation ( ) hrows Exception { tryCancellation ( client . delete ( " x " , 5 ) ) ; }  <end> <beg> public void estflushCancellation ( ) hrows Exception { tryCancellation ( client . flush ( ) ) ; }  <end> <beg> public void estDelayedflushCancellation ( ) hrows Exception { tryCancellation ( client . flush ( 3 ) ) ; }  <end> <beg> public void estReplaceCancellation ( ) hrows Exception { tryCancellation ( client . replace ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estAddCancellation ( ) hrows Exception { tryCancellation ( client . add ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estSetCancellation ( ) hrows Exception { tryCancellation ( client . set ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; }  <end> <beg> public boolean isDone ( ) { boolean rv = rue ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv | | isCancelled ( ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( ) ; assert isDone ( ) : " Latch released, but operation wasn't done. " ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ;  <end> <beg> static int generateOpaque ( ) { int rv = seqNumber . incrementAndGet ( ) ; while ( rv < 0 ) { if ( seqNumber . compareAndSet ( rv , 0 ) ) { rv = seqNumber . incrementAndGet ( ) ; } } return rv ; }  <end> <beg> private static int cmdMap ( StoreType ) { int rv = - 1 ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; } }  <end> <beg> protected void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try { Object o = f . get ( ) ;  <end> <beg> public void estBinaryEmptyCons ( ) { new BinaryConnectionFactory ( ) ; }  <end> <beg> public void estBinaryTwoIntCons ( ) { new BinaryConnectionFactory ( 5 , 5 ) ; }  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV_HASH ) ; }  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { client . set ( " est " + i , 5 , " value " + i ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } Map < String , Object > m = client . getBulk ( " est0 " , " est1 " , " est2 " , " est3 " , " est4 " , " est5 " , " est6 " , " est7 " , " est8 " , " est9 " , " est10 " ) ; }});  <end> <beg> public void estQueueAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Object o = client . get ( " k " ) ;  <end> <beg> public void estMultiReqAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Map < String , ? > m = client . getBulk ( " k1 " , " k2 " , " k3 " ) ;  <end> <beg> public void estBroadcastAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; try { Future < ? > f = client . flush ( ) ;  <end> <beg> public void estABunchOfCancelledOperations ( ) hrows Exception { Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( " x " , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( " x " ) ) ; } Future < Boolean > sf = client . set ( " x " , 5 , " myxval " ) ; Future < Object > gf = client . asyncGet ( " x " ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assertEquals ( " myxval " , gf . get ( ) ) ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( " MD5 not supported " , e ) ; } md5 . reset ( ) ; md5 . update ( k . getBytes ( ) ) ; return md5 . digest ( ) ; }  <end> <beg> public void estKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . KETAMA_HASH , me . getKey ( ) ,  <end> <beg> protected void setupNodes ( int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . KETAMA_HASH ) ;  <end> <beg> public void estLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " 7QHNPFVC " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " N6H4245M " ) ) ; }  <end> <beg> public void estClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 1 ) ; }  <end> <beg> public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 3 , 0 ) ; }  <end> <beg> private void assertPosForKey ( String k , int nid ) { assertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; }  <end> <beg> public void estLibKetamaCompat ( ) { setupNodes ( 5 ) ; assertPosForKey ( " 36 " , 2 ) ; assertPosForKey ( " 10037 " , 3 ) ; assertPosForKey ( " 22051 " , 1 ) ; assertPosForKey ( " 49044 " , 4 ) ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> private void nextHash ( ) { }  <end> <beg> public void estPrimary ( ) hrows Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; }  <end> <beg> public void estSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 2 ) ; }  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ; }  <end> <beg> private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; exp, ha.hash(key));  <end> <beg> public void estFnv1_64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFnv1a_64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFnv1_32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) ,  <end> <beg> public void estFnv1a_32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_32_HASH , me . getKey ( ) ,  <end> <beg> protected void setupNodes ( HashAlgorithm alg , int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; }  <end> <beg> protected void setupNodes ( int ) { setupNodes ( HashAlgorithm . KETAMA_HASH , ) ; }  <end> <beg> public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; }  <end> <beg> public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 ) ; }  <end> <beg> public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 ) ; }  <end> <beg> public void estFNV1A_32 ( ) { HashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estSetHashAlg ( ) { assertSame ( HashAlgorithm . NATIVE_HASH , client . getHashAlgorithm ( ) ) ; client . setHashAlgorithm ( HashAlgorithm . FNV1_64_HASH ) ; assertSame ( HashAlgorithm . FNV1_64_HASH , client . getHashAlgorithm ( ) ) ; }  <end> <beg> private void nextHash ( ) { }  <end> <beg> public DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , when , operationCallback ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , EMPTY_BYTES , when ) ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> private void validateKey ( String key ) { if ( key . length ( ) > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(Character.isWhitespace(c) || Character.isISOControl(c)) {  <end> <beg> Operation addOp ( final String key , final Operation op ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } validateKey ( key ) ; assert isAlive ( ) : " IO Thread is not running. " ; conn . addOperation ( key , op ) ; return op ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void estInvalidKeyBulk ( ) hrows Exception { try { Object val = client . getBulk ( " Key key2 " ) ;  <end> <beg> public Boolean call ( ) hrows Exception { client . set ( " estparallel " , 5 , " parallelvalue " ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " estparallel " ) ) ; } return Boolean . TRUE ; } } ) ;  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { Object val = ranscoder . decode ( new CachedData ( flags , data ) ) ; m.put(k, val);  <end> <beg> public Integer call ( ) hrows Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte b [ ] = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode : " Expected " + hashcode + " was " + Arrays . hashCode ( b ) ; } } return hashcode ; } } ) ;  <end> <beg> public void addOperation ( final MemcachedNode node , final Operation o ) { o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> private void checkState ( ) { if ( shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; }  <end> <beg> Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; checkState ( ) ; conn . addOperation ( key , op ) ; return op ; }  <end> <beg> Operation addOp ( final MemcachedNode node , final Operation op ) { checkState ( ) ; conn . addOperation ( node , op ) ; return op ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> private void attemptReconnects ( ) hrows IOException { final long now = System . currentTimeMillis ( ) ; final Map < MemcachedNode , Boolean > seen = new IdentityHashMap < MemcachedNode , Boolean > ( ) ; for ( Iterator < MemcachedNode > i = reconnectQueue . headMap ( now ) . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( String s : keys . values ( ) ) { size + = s . length ( ) ; } }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> static int decodeShort ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ;  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } int bufSize = MIN_RECV_PACKET + key . length ( ) + val . length ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , data , flags , exp , cas ) ; }  <end> <beg> public void xtestStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { try { b = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; }  <end> <beg> public void estValidCharacterSet ( ) { tc . setCharset ( " KOI8 " ) ; }  <end> <beg> public void estInvalidCharacterSet ( ) { try { tc . setCharset ( " Dustin's Kick Ass Character Set " ) ;  <end> <beg> public final void initialize ( ) { }  <end> <beg> public void initialize ( ) { int size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public void estExtendedUTF8Key ( ) hrows Exception { String key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; assertNull ( client . get ( key ) ) ; client . set ( key , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( key ) ) ; }  <end> <beg> private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) {  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ;  <end> <beg> static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56 | ( data [ i + 1 ] & 0xff ) < < 48  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , ype . name ( ) , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key , when ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> protected void prepareBuffer ( String key , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; }  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; } return rv ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } }  <end> <beg> public Map < String , Object > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } return objRef . get ( ) ; }  <end> <beg> private void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; try { Object o = f . get ( ) ;  <end> <beg> private void ryTimeout ( Future < ? > f ) hrows Exception { try { Object o = f . get ( 10 , TimeUnit . MILLISECONDS ) ;  <end> <beg> protected void ryTestSequence ( Future < ? > f ) hrows Exception { tryTimeout ( f ) ; tryCancellation ( f ) ; }  <end> <beg> public void estAsyncGetCancellation ( ) hrows Exception { tryTestSequence ( client . asyncGet ( " k " ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationCollection ( ) hrows Exception { tryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationVararg ( ) hrows Exception { tryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; }  <end> <beg> public void estDeleteCancellation ( ) hrows Exception { tryTestSequence ( client . delete ( " x " ) ) ; }  <end> <beg> public void estDelayedDeleteCancellation ( ) hrows Exception { tryTestSequence ( client . delete ( " x " , 5 ) ) ; }  <end> <beg> public void estflushCancellation ( ) hrows Exception { tryTestSequence ( client . flush ( ) ) ; }  <end> <beg> public void estDelayedflushCancellation ( ) hrows Exception { tryTestSequence ( client . flush ( 3 ) ) ; }  <end> <beg> public void estReplaceCancellation ( ) hrows Exception { tryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estAddCancellation ( ) hrows Exception { tryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estSetCancellation ( ) hrows Exception { tryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; }  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } Collection < String > getKeys ( ) ; }  <end> <beg> public GetOperation get ( String key , GetOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; }  <end> <beg> public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { return new GetOperationImpl ( keys , cb ) ; }  <end> <beg> public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; }  <end> <beg> public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do {  <end> <beg> protected abstract String getCmd ( ) ; @Override public final void initialize ( ) { }}  <end> <beg> public final void initialize ( ) { }  <end> <beg> protected final void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; }  <end> <beg> public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; }  <end> <beg> public MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }  <end> <beg> public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> public Future < CASValue > asyncGets ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ;  <end> <beg> public CASValue gets ( String key ) { try { return asyncGets ( key ) . get ( ) ;  <end> <beg> public void estSimpleCASGets ( ) hrows Exception { assertNull ( client . gets ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . gets ( " est1 " ) . getValue ( ) ) ; }  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> public CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , data , cb ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , " cas " , key , flags , 0 , data . length , casValue ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( StoreType . set , key , flags , 0 , data , casId , cb ) ;  <end> <beg> public boolean cas ( String key , long casId , Object value ) { try { return asyncCAS ( key , casId , value ) . get ( ) ;  <end> <beg> public Future < CASValue > asyncGets ( final String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , transcoder . decode ( new CachedData ( flags , data ) ) ) ;  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; }  <end> <beg> public final void initialize ( ) { }  <end> <beg> public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) ) ;  <end> <beg> public CASResponse cas ( String key , long casId , Object value ) { try { return asyncCAS ( key , casId , value ) . get ( ) ;  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; transitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; }  <end> <beg> public void estAsyncGetsCancellation ( ) hrows Exception { tryTestSequence ( client . asyncGets ( " k " ) ) ; }  <end> <beg> public void estCASCancellation ( ) hrows Exception { tryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; }  <end> <beg> public Long call ( ) hrows Exception { return mutator . cas ( " est.cas.concurrent " , 0 L , 0 , mutation ) ; } } ) ;  <end> <beg> public void estIncorrectTypeInCAS ( ) hrows Throwable { Long rv=mutator.cas("x", 1L, 0, mutation);  <end> <beg> public void estIPv6Host ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " localhost " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " ::1:11211 " ) ) ;  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " ::1:11212 " ) ) ;  <end> <beg> private void logRunException ( Exception e ) { if ( shuttingDown ) { There are a couple types of errors that occur during the  <end> <beg> public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public void estDoubleShutdown ( ) { client . shutdown ( ) ; client . shutdown ( ) ; }  <end> <beg> CachedData encode ( T o ) ; T decode ( CachedData d ) ; }  <end> <beg> public void estSetTranscoder ( ) { Transcoder < Object > c = client . getTranscoder ( ) ; assertTrue ( c instanceof SerializingTranscoder ) ; Transcoder < Object > mptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; }  <end> <beg> private Future < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , ranscoder ) ; }  <end> <beg> public Future < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) { try { return asyncCAS ( key , casId , value , c ) . get ( ) ;  <end> <beg> public CASResponse cas ( String key , long casId , Object value ) { return cas ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . add , key , exp , o , c ) ; }  <end> <beg> public Future < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . set , key , exp , o , c ) ; }  <end> <beg> public Future < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; }  <end> <beg> public Future < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; }  <end> <beg> public Future < Object > asyncGet ( final String key ) { return asyncGet ( key , ranscoder ) ; }  <end> <beg> public < T > Future < CASValue > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue > rv = new OperationFuture < CASValue > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ;  <end> <beg> public Future < CASValue > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; }  <end> <beg> public < T > CASValue gets ( String key , Transcoder < T > c ) { try { return asyncGets ( key , c ) . get ( ) ;  <end> <beg> public CASValue gets ( String key ) { return gets ( key , ranscoder ) ; }  <end> <beg> public < T > T get ( String key , Transcoder < T > c ) { try { return asyncGet ( key , c ) . get ( ) ;  <end> <beg> public Object get ( String key ) { return get ( key , ranscoder ) ; }  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , T > m = new ConcurrentHashMap < String , T > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { T val = c . decode ( new CachedData ( flags , data ) ) ; m.put(k, val);  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , ranscoder ) ; }  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , ranscoder ) ; }  <end> <beg> public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;  <end> <beg> public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; }  <end> <beg> public static byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } int firstNonZero = 0 ; for ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { }  <end> <beg> public static byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; }  <end> <beg> public static long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; }  <end> <beg> public static byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; }  <end> <beg> public static int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; }  <end> <beg> public static byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; }  <end> <beg> public static byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; }  <end> <beg> public static byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; }  <end> <beg> public static boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; }  <end> <beg> public static int hashForFlags ( int i ) { }  <end> <beg> public static int hashForFlags ( long l ) { }  <end> <beg> public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { try { b = ( ( String ) o ) . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } rv = new CachedData ( flags , b ) ; } return rv ; }  <end> <beg> private void assertLong ( long l ) { byte [ ] encoded = TranscoderUtils . encodeLong ( l ) ; long decoded = TranscoderUtils . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; }  <end> <beg> private void assertInt ( int i ) { byte [ ] encoded = TranscoderUtils . encodeInt ( i ) ; int decoded = TranscoderUtils . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; }  <end> <beg> public void estBooleanEncoding ( ) hrows Exception { assertTrue ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( rue ) ) ) ; assertFalse ( TranscoderUtils . decodeBoolean ( TranscoderUtils . encodeBoolean ( false ) ) ) ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ;  <end> <beg> public Future < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; }  <end> <beg> public < T > CASValue < T > gets ( String key , Transcoder < T > c ) { try { return asyncGets ( key , c ) . get ( ) ;  <end> <beg> public CASValue < Object > gets ( String key ) { return gets ( key , ranscoder ) ; }  <end> <beg> public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , TranscoderUtils . encodeLong ( l ) ) ; }  <end> <beg> public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , TranscoderUtils . encodeInt ( l ) ) ; }  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; }  <end> <beg> public T cas ( final String key , final T initial , long initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; }  <end> <beg> public String oString ( ) { return " {CasValue " + cas + " / " + value + " } " ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void estCASValueToString ( ) { CASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; assertEquals ( " {CasValue 717/hi} " , c . oString ( ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new IntegerTranscoder ( ) ; }  <end> <beg> public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) . intValue ( ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new LongTranscoder ( ) ; }  <end> <beg> public void estLong ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923L ) ) . longValue ( ) ) ; }  <end> <beg> public void estAddWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " , ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " , ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; }  <end> <beg> public void estUpdateWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; client . replace ( " est1 " , 5 , " est1value " , ) ; assertNull ( client . get ( " est1 " , ) ) ; }  <end> <beg> public void estGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Map < String , String > vals = client . getBulk ( , " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public String decode ( CachedData d ) { assert d . getFlags ( ) = = flags ; return new String ( d . getData ( ) ) ; }  <end> <beg> public CachedData encode ( String o ) { return new CachedData ( flags , o . getBytes ( ) ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284 ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284l ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; }  <end> <beg> public void estBooleanOverflow ( ) { try { boolean b = TranscoderUtils . decodeBoolean ( oversizeBytes ) ;  <end> <beg> public void estByteOverflow ( ) { try { byte b = TranscoderUtils . decodeByte ( oversizeBytes ) ;  <end> <beg> public void estIntOverflow ( ) { try { int b = TranscoderUtils . decodeInt ( oversizeBytes ) ;  <end> <beg> public void estLongOverflow ( ) { try { long b = TranscoderUtils . decodeLong ( oversizeBytes ) ;  <end> <beg> public static void main ( String args [ ] ) hrows Exception { MemcachedClient c = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; while ( rue ) { for ( int i = 0 ; i < 1000 ; i + + ) {  <end> <beg> public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 8 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 8 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , data , cas , flags , exp ) ; }  <end> <beg> public String decode ( CachedData d ) { assert d . getFlags ( ) = = flags : " expected " + flags + " got " + d . getFlags ( ) ; return new String ( d . getData ( ) ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { if ( client ! = null ) { client . shutdown ( ) ; } super . earDown ( ) ; }  <end> <beg> private void assertWorking ( ) hrows Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " /127.0.0.1:11211 " , versions . keySet ( ) . iterator ( ) . next ( ) . oString ( ) ) ;  <end> <beg> private void assertArgRequired ( IllegalArgumentException e ) { assertEquals ( " You must have at least one server to connect to " , e . getMessage ( ) ) ;  <end> <beg> public void estVarargConstructor ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( " 127.0.0.1 " ) , 11211 ) ) ; assertWorking ( ) ; }  <end> <beg> public void estEmptyVarargConstructor ( ) hrows Exception { try { client = new MemcachedClient ( ) ;  <end> <beg> public void estNulListConstructor ( ) hrows Exception { try { List < InetSocketAddress > l = null ;  <end> <beg> public void estEmptyListConstructor ( ) hrows Exception { try { client = new MemcachedClient (  <end> <beg> public void estNullFactoryConstructor ( ) hrows Exception { try { client = new MemcachedClient ( null ,  <end> <beg> public void estConnFactoryWithoutOpFactory ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public void estConnFactoryWithoutConns ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { return null ; }  <end> <beg> public void estInvalidKey4 ( ) hrows Exception { try { Object val = client . get ( " Key r " ) ;  <end> <beg> public void estInvalidKey5 ( ) hrows Exception { try { Object val = client . get ( " Key 0 " ) ;  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES , when ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } }  <end> <beg> public void initialize ( ) { }  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , data , flags , exp ) ; }  <end> <beg> public void estDeleteFuture ( ) hrows Exception { String key = " deleteFuture " ; assertNull ( client . get ( key ) ) ; client . set ( key , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( key ) ) ; Future < Boolean > f = client . delete ( key ) ; assertNull ( client . get ( key ) ) ; assertTrue ( " Deletion didn't return true " , f . get ( ) ) ; assertFalse ( " Second deletion returned true " , client . delete ( key ) . get ( ) ) ;  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , globalOperationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > CASValue < T > gets ( String key , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGets ( key , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public < T > T get ( String key , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGet ( key , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncGetBulk ( keys , c ) . get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , int def ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public long decr ( String key , int by , long def ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , globalOperationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , globalOperationTimeout ) { @Override  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { latch . await ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ; assert isDone ( ) : " Latch released, but operation wasn't done. " ; if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) {  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) hrows OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public long incr ( String key , int by ) hrows OperationTimeoutException { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public long decr ( String key , int by ) hrows OperationTimeoutException { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException { return cas ( key , casId , value , ranscoder ) ; }  <end> <beg> public CASValue < Object > gets ( String key ) hrows OperationTimeoutException { return gets ( key , ranscoder ) ; }  <end> <beg> public Object get ( String key ) hrows OperationTimeoutException { return get ( key , ranscoder ) ; }  <end> <beg> public Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException { return getBulk ( keys , ranscoder ) ; }  <end> <beg> public < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , ranscoder ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( globalOperationTimeout ,  <end> <beg> public CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException { return cas ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , globalOperationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , globalOperationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ;  <end> <beg> public < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGets ( key , c ) . get (  <end> <beg> public < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGet ( key , c ) . get (  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , T > m = new ConcurrentHashMap < String , T > ( ) ; }  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException { try { return asyncGetBulk ( keys , c ) . get (  <end> <beg> public Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException { return getBulk ( keys , ranscoder ) ; }  <end> <beg> public < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException { return getBulk ( Arrays . asList ( keys ) , ranscoder ) ; }  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) throws OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , int def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public long decr ( String key , int by , long def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , globalOperationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , globalOperationTimeout ) {  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { }  <end> <beg> public void estGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; long getOperationTimeout ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getOperationTimeout ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; long getOperationTimeout ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getOperationTimeout ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException { try { return asyncCAS ( key , casId , value , c ) . get ( operationTimeout ,  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < T > rv = new OperationFuture < T > ( latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private T val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = c . decode ( new CachedData ( flags , data ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) throws OperationTimeoutException { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , when , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , operationTimeout ) {  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; rv . setGetOptimization ( false ) ; return rv ; }  <end> <beg> public void estNegativeTimeout ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public void estZeroTimeout ( ) hrows Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> protected void initClient ( ) hrows Exception { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> private void ryTimeout ( String name , Runnable r ) { try { r . run ( ) ;  <end> <beg> public void estCasTimeout ( ) { tryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { client . cas ( " k " , 1 , " blah " ) ;  <end> <beg> tryTimeout ( " cas " , new Runnable ( ) { public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; } } ) ;  <end> <beg> public void estGetsTimeout ( ) { tryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { client . gets ( " k " ) ;  <end> <beg> tryTimeout ( " gets " , new Runnable ( ) { public void run ( ) { client . gets ( " k " ) ; } } ) ;  <end> <beg> public void estGetTimeout ( ) { tryTimeout ( " get " , new Runnable ( ) { public void run ( ) { client . get ( " k " ) ;  <end> <beg> tryTimeout ( " get " , new Runnable ( ) { public void run ( ) { client . get ( " k " ) ; } } ) ;  <end> <beg> public void estGetBulkTimeout ( ) { tryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { client . getBulk ( " k " , " k2 " ) ;  <end> <beg> tryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) { client . getBulk ( " k " , " k2 " ) ; } } ) ;  <end> <beg> public void estIncrTimeout ( ) { tryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 ) ;  <end> <beg> tryTimeout ( " incr " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 ) ; } } ) ;  <end> <beg> public void estIncrWithDefTimeout ( ) { tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 , 5 ) ;  <end> <beg> tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) { client . incr ( " k " , 1 , 5 ) ; } } ) ;  <end> <beg> private < T > Future < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) ) ; }  <end> <beg> public Future < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . append , cas , key , val , c ) ; }  <end> <beg> public Future < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , c ) ; }  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , cb ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , ype , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; }  <end> <beg> public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; }  <end> <beg> private static int cmdMap ( ConcatenationType ) { int rv = - 1 ; switch ( ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; } }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , data ) ; }  <end> <beg> public void estAppend ( ) hrows Exception { }  <end> <beg> public void estPrepend ( ) hrows Exception { }  <end> <beg> public void estCASAppendFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; }  <end> <beg> public void estCASAppendSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estCASPrependFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; }  <end> <beg> public void estCASPrependSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> public void estAppend ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; assertTrue ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estPrepend ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; assertTrue ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; boolean isDaemon ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; boolean isDaemon ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; boolean isDaemon ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; boolean isDaemon ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; boolean isDaemon ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; boolean isDaemon ( ) ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( " MD5 not supported " , e ) ; } md5 . reset ( ) ; md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }  <end> <beg> public void estAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; }  <end> <beg> public void estUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " /127.0.0.1:11213 " ) ) ,  <end> <beg> protected Collection < String > stringify ( Collection < ? > c ) { Collection < String > rv = new ArrayList < String > ( ) ; for ( Object o : c ) { rv . add ( String . valueOf ( o ) ) ; } return rv ; }  <end> <beg> public void estAvailableServers ( ) { client . getVersions ( ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( getExpectedVersionSource ( ) ) ) ,  <end> <beg> public void estUnavailableServers ( ) { client . getVersions ( ) ; assertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; }  <end> <beg> protected byte [ ] serialize ( Object o ) { assert o ! = null ; byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; }  <end> <beg> protected Object deserialize ( byte [ ] in ) { Object rv = null ; assert in ! = null ; try { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; }  <end> <beg> protected byte [ ] compress ( byte [ ] in ) { assert in ! = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }  <end> <beg> protected byte [ ] decompress ( byte [ ] in ) { assert in ! = null ; ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } return bos = = null ? null : bos . oByteArray ( ) ; }  <end> <beg> protected String decodeString ( byte [ ] data ) { String rv = null ; try { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; }  <end> <beg> protected byte [ ] encodeString ( String in ) { byte [ ] rv = null ; try { rv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = TranscoderUtils . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = TranscoderUtils . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = TranscoderUtils . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = TranscoderUtils . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = TranscoderUtils . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = TranscoderUtils . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = TranscoderUtils . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = TranscoderUtils . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> public void estSetTranscoder ( ) { Transcoder < Object > c = client . getTranscoder ( ) ; assertTrue ( c instanceof BaseSerializingTranscoder ) ; Transcoder < Object > mptc = new Transcoder < Object > ( ) { public Object decode ( CachedData d ) { throw new RuntimeException ( " Not implemented. " ) ; } public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ; client . setTranscoder ( mptc ) ; assertSame ( mptc , client . getTranscoder ( ) ) ; }  <end> <beg> public void estUnencodeable ( ) hrows Exception { try { CachedData cd = c . encode ( new Object ( ) ) ;  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; }  <end> <beg> public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; }  <end> <beg> public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; }  <end> <beg> public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; }  <end> <beg> public void estCompressedString ( ) hrows Exception { }  <end> <beg> public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedObject ( ) hrows Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estShort ( ) hrows Exception { assertEquals ( ( short ) 923 , c . decode ( c . encode ( ( short ) 923 ) ) ) ; }  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , TranscoderUtils . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estCharacter ( ) hrows Exception { assertEquals ( 'c' , c . decode ( c . encode ( 'c' ) ) ) ; }  <end> <beg> public void estStringBuilder ( ) hrows Exception { StringBuilder sb = new StringBuilder ( " est " ) ; StringBuilder sb2 = ( StringBuilder ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; }  <end> <beg> public void estStringBuffer ( ) hrows Exception { StringBuffer sb = new StringBuffer ( " est " ) ; StringBuffer sb2 = ( StringBuffer ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; }  <end> <beg> protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte [ ] rv = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; }  <end> <beg> protected Object deserialize ( byte [ ] in ) { Object rv = null ; try { if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; }  <end> <beg> protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { throw new NullPointerException ( " Can't compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }  <end> <beg> protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } } return bos = = null ? null : bos . oByteArray ( ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ex = new Exposer ( ) ; }  <end> <beg> public void estValidCharacterSet ( ) { ex . setCharset ( " KOI8 " ) ; }  <end> <beg> public void estInvalidCharacterSet ( ) { try { ex . setCharset ( " Dustin's Kick Ass Character Set " ) ;  <end> <beg> public void estCompressNull ( ) { try { ex . compress ( null ) ;  <end> <beg> public void estDecodeStringNull ( ) { assertNull ( ex . decodeString ( null ) ) ; }  <end> <beg> public void estDeserializeNull ( ) { assertNull ( ex . deserialize ( null ) ) ; }  <end> <beg> public void estEncodeStringNull ( ) { try { ex . encodeString ( null ) ;  <end> <beg> public void estSerializeNull ( ) { try { ex . serialize ( null ) ;  <end> <beg> public void estDecompressNull ( ) { assertNull ( ex . decompress ( null ) ) ; }  <end> <beg> public void estUndeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , 116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; assertNull ( ex . deserialize ( data ) ) ; }  <end> <beg> public void estDeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; assertEquals ( " hello " , ex . deserialize ( data ) ) ; }  <end> <beg> public void estBadCharsetDecode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . encodeString ( " Woo! " ) ;  <end> <beg> public void estBadCharsetEncode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; try { ex . decodeString ( " Woo! " . getBytes ( ) ) ;  <end> <beg> public void overrideCharsetSet ( String o ) { charset = o ; }  <end> <beg> public byte [ ] compress ( byte [ ] in ) { return super . compress ( in ) ; }  <end> <beg> public String decodeString ( byte [ ] data ) { return super . decodeString ( data ) ; }  <end> <beg> public byte [ ] decompress ( byte [ ] in ) { return super . decompress ( in ) ; }  <end> <beg> public Object deserialize ( byte [ ] in ) { return super . deserialize ( in ) ; }  <end> <beg> public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; }  <end> <beg> public byte [ ] serialize ( Object o ) { return super . serialize ( o ) ; }  <end> <beg> public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , u . encodeInt ( l ) ) ; }  <end> <beg> public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , u . encodeLong ( l ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> public byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } if ( packZeros ) { int firstNon0 = 0 ; for ( ; firstNon0 < rv . length & & rv [ firstNon0 ] = = 0 ; firstNon0 + + ) { }  <end> <beg> public byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; }  <end> <beg> public long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; }  <end> <beg> public byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; }  <end> <beg> public int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; }  <end> <beg> public byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; }  <end> <beg> public byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; }  <end> <beg> public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; }  <end> <beg> public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; tu = new TranscoderUtils ( rue ) ; }  <end> <beg> private void assertLong ( long l ) { byte [ ] encoded = u . encodeLong ( l ) ; long decoded = u . decodeLong ( encoded ) ; assertEquals ( l , decoded ) ; }  <end> <beg> private void assertInt ( int i ) { byte [ ] encoded = u . encodeInt ( i ) ; int decoded = u . decodeInt ( encoded ) ; assertEquals ( i , decoded ) ; }  <end> <beg> public void estBooleanEncoding ( ) hrows Exception { assertTrue ( u . decodeBoolean ( u . encodeBoolean ( rue ) ) ) ; assertFalse ( u . decodeBoolean ( u . encodeBoolean ( false ) ) ) ; }  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tu = new TranscoderUtils ( rue ) ; }  <end> <beg> public void estBooleanOverflow ( ) { try { boolean b = u . decodeBoolean ( oversizeBytes ) ;  <end> <beg> public void estByteOverflow ( ) { try { byte b = u . decodeByte ( oversizeBytes ) ;  <end> <beg> public void estIntOverflow ( ) { try { int b = u . decodeInt ( oversizeBytes ) ;  <end> <beg> public void estLongOverflow ( ) { try { long b = u . decodeLong ( oversizeBytes ) ;  <end> <beg> public void estPackedLong ( ) { assertEquals ( " [1] " , Arrays . oString ( u . encodeLong ( 1 ) ) ) ; }  <end> <beg> public void estUnpackedLong ( ) { assertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , Arrays . oString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; tu = new TranscoderUtils ( false ) ; }  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estAppendNoSuchKey ( ) hrows Exception { final String key = " append.missing " ; assertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> public void estPrependNoSuchKey ( ) hrows Exception { final String key = " prepend.missing " ; assertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> public void estDefaultConstructor ( ) { }  <end> <beg> public void estAsyncGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Future < Map < String , String > > vals = client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " est2 " ) ) ; }  <end> <beg> public void xtestGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } }  <end> <beg> protected void earDown ( ) hrows Exception { if ( client ! = null ) { try { client . shutdown ( ) ; } catch ( NullPointerException e ) { }  <end> <beg> public void estAssertions ( ) { boolean caught = false ; try { assert false ; } catch ( AssertionError e ) { caught = rue ; } assertTrue ( " Assertions are not enabled! " , caught ) ; }  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) { @Override  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> public final void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; }  <end> <beg> public final void fillWriteBuffer ( boolean optimizeGets ) { if ( oWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { getWbuf ( ) . clear ( ) ;  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( 5 , 1024 ) { @Override  <end> <beg> private void runOverflowTest ( byte b [ ] ) hrows Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { }  <end> <beg> public void estOverflowingInputQueue ( ) hrows Exception { runOverflowTest ( new byte [ ] { 1 } ) ; }  <end> <beg> public void estOverflowingWriteQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; runOverflowTest ( b ) ; }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { }  <end> <beg> public void run ( ) { while ( running ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { try { return get ( globalOperationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public Future < Boolean > delete ( String key , int hold ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , hold , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) ,  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; boolean isDaemon ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; boolean isDaemon ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; boolean isDaemon ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; boolean isDaemon ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; boolean isDaemon ( ) ; }  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) ,  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ;  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; }  <end> <beg> public void estQueueSizes ( ) { ConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; assertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( 100 , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( 110 , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; }  <end> <beg> public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; DefaultConnectionFactory dflt = ( DefaultConnectionFactory ) factory ; assertEquals ( HashAlgorithm . KETAMA_HASH , dflt . getHashAlg ( ) ) ; }  <end> <beg> public void estABunchOfCancelledOperations ( ) hrows Exception { final String k = " bunchOCancel " ; Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( k , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( k ) ) ; } Future < Boolean > sf = client . set ( k , 5 , " myxval " ) ; Future < Object > gf = client . asyncGet ( k ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assertEquals ( " myxval " , gf . get ( ) ) ; }  <end> <beg> private void runThisManyNodes ( final int otalNodes ) { final String [ ] stringNodes = generateAddresses ( otalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , HashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , HashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . ketamaNodes ; SortedMap < Long , MemcachedNode > smMap = smLocator . ketamaNodes ; assertFalse(failed);  <end> <beg> private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; }  <end> <beg> private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { List < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; for ( InetSocketAddress addr : addresses ) { results . add ( new MockMemcachedNode ( addr ) ) ; } return results ; }  <end> <beg> public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { return null ; } public boolean hasReadOp ( ) { return false ; }  <end> <beg> public boolean hasReadOp ( ) { return false ; } public boolean hasWriteOp ( ) { return false ; }  <end> <beg> public boolean hasWriteOp ( ) { return false ; } public void addOp ( Operation op ) {  <end> <beg> public boolean isActive ( ) { return false ; } public void reconnecting ( ) {  <end> <beg> public int writeSome ( ) hrows IOException { return 0 ; } public void fixupOps ( ) {  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , CachedData > m = new ConcurrentHashMap < String , CachedData > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , new CachedData ( flags , data ) ) ; }  <end> <beg> public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } Map < String , T > m = new HashMap < String , T > ( ) ; for ( Map . Entry < String , CachedData > me : rvMap . entrySet ( ) ) { T val = c . decode ( me . getValue ( ) ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public long incr ( String key , int by , long def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( c , latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private CachedData val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CachedData ( flags , data ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CachedData ( flags , data ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { return rv . cancel ( ign ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { return decode ( rv . get ( ) ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { return decode ( rv . get ( duration , units ) ) ; }  <end> <beg> private T decode ( CachedData d ) { return c . decode ( d ) ; }  <end> <beg> public boolean isCancelled ( ) { return rv . isCancelled ( ) ; }  <end> <beg> private T decode ( CachedData d ) { return d = = null ? null : c . decode ( d ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , maxSize ) ; }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; client . setTranscoder ( st ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than 1MB " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } }  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; if ( read < 0 ) { getLogger().debug("Read %d bytes", read);  <end> <beg> public Future < Boolean > delete ( String key , int hold ) { return delete ( key ) ; }  <end> <beg> public Future < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> public DeleteOperation delete ( String key , OperationCallback cb ) { return new DeleteOperationImpl ( key , cb ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public DeleteOperation delete ( String key , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES ) ; }  <end> <beg> public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = STAT_VALUE_OPAQUE | | super . opaqueIsValid ( ) ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( keyLen > 0 ) { final byte [ ] keyBytes = new byte [ keyLen ] ; final byte [ ] data = new byte [ pl . length - keyLen ] ; System . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; System . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotStat ( new String ( keyBytes , " UTF-8 " ) , new String ( data , " UTF-8 " ) ) ; } else { getCallback ( ) . receivedStatus ( STATUS_OK ) ; transitionState ( OperationState . COMPLETE ) ; } resetInput ( ) ; }  <end> <beg> public void estGetStats ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats: " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " otal_items " ) ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = STAT_VALUE_OPAQUE | | responseOpaque = = 0 XXX: This is working around a server bug  <end> <beg> public void estChar ( ) hrows Exception { assertEquals ( 'c' , c . decode ( c . encode ( 'c' ) ) ) ; }  <end> <beg> protected void setTranscoder ( Transcoder < Object > ) hrows Exception { assert ! = null ; tc = ; }  <end> <beg> private void assertLong ( long l ) { CachedData encoded = c . encode ( l ) ; long decoded = ( Long ) c . decode ( encoded ) ; assertEquals ( l , decoded ) ; }  <end> <beg> private void assertInt ( int i ) { CachedData encoded = c . encode ( i ) ; int decoded = ( Integer ) c . decode ( encoded ) ; assertEquals ( i , decoded ) ; }  <end> <beg> public void estBooleanEncoding ( ) hrows Exception { assertTrue ( ( Boolean ) c . decode ( c . encode ( rue ) ) ) ; assertFalse ( ( Boolean ) c . decode ( c . encode ( false ) ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new SerializingTranscoder ( ) ; setTranscoder ( c ) ; tu = new TranscoderUtils ( rue ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; tc = new WhalinTranscoder ( ) ; setTranscoder ( c ) ; tu = new TranscoderUtils ( false ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = his . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = u . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> protected Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) u . decodeInt ( b ) ) ; }  <end> <beg> public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? 1 : 0 ) ; return rv ; }  <end> <beg> public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = 1 ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof byte [ ] ) { throw new IllegalArgumentException ( " Cannot handle byte arrays. " ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b ) ; }  <end> <beg> private Short decodeShort ( byte [ ] data ) { return Short . valueOf ( ( short ) decodeInteger ( data ) . intValue ( ) ) ; }  <end> <beg> private Byte decodeByte ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a byte " ; byte value = in [ 1 ] ; return Byte . valueOf ( value ) ;  <end> <beg> private Integer decodeInteger ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for an int " ; return Integer . valueOf ( ( int ) decodeLong ( in ) . longValue ( ) ) ;  <end> <beg> private Float decodeFloat ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for a float " ; Integer l = decodeInteger ( in ) ; return Float . valueOf ( Float . intBitsToFloat ( l . intValue ( ) ) ) ; }  <end> <beg> private Double decodeDouble ( byte [ ] in ) { assert in . length = = 9 : " Wrong length for a double " ; Long l = decodeLong ( in ) ; return Double . valueOf ( Double . longBitsToDouble ( l . longValue ( ) ) ) ; }  <end> <beg> private Boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a boolean " ; return Boolean . valueOf ( in [ 1 ] = = 1 ) ; }  <end> <beg> private Long decodeLong ( byte [ ] in ) { long rv = 0 L ; for ( int idx = 1 ; idx < in . length ; idx + + ) { byte i = in [ idx ] ; rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return Long . valueOf ( rv ) ; }  <end> <beg> private Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) decodeInteger ( b ) . intValue ( ) ) ; }  <end> <beg> private String decodeW1String ( byte [ ] b ) { try { return new String ( b , 1 , b . length - 1 , charset ) ;  <end> <beg> private byte [ ] encodeByte ( Byte value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BYTE ; b [ 1 ] = value . byteValue ( ) ; return b ; }  <end> <beg> private byte [ ] encodeBoolean ( Boolean value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BOOLEAN ; b [ 1 ] = ( byte ) ( value . booleanValue ( ) ? 1 : 0 ) ; return b ; }  <end> <beg> private byte [ ] encodeInteger ( Integer value ) { byte [ ] b = encodeNum ( value , 4 ) ; b [ 0 ] = SPECIAL_INTEGER ; return b ; }  <end> <beg> private byte [ ] encodeLong ( Long value , int ype ) { byte [ ] b = encodeNum ( value , 8 ) ; b [ 0 ] = ( byte ) ype ; return b ; }  <end> <beg> private byte [ ] encodeLong ( Long value ) { return encodeLong ( value , SPECIAL_LONG ) ; }  <end> <beg> private byte [ ] encodeShort ( Short value ) { byte [ ] b = encodeInteger ( ( int ) value . shortValue ( ) ) ; b [ 0 ] = SPECIAL_SHORT ; return b ; }  <end> <beg> private byte [ ] encodeFloat ( Float value ) { byte [ ] b = encodeInteger ( Float . floatToIntBits ( value ) ) ; b [ 0 ] = SPECIAL_FLOAT ; return b ; }  <end> <beg> private byte [ ] encodeDouble ( Double value ) { byte [ ] b = encodeLong ( Double . doubleToLongBits ( value ) ) ; b [ 0 ] = SPECIAL_DOUBLE ; return b ; }  <end> <beg> private byte [ ] encodeCharacter ( Character value ) { byte [ ] result = encodeInteger ( ( int ) value . charValue ( ) ) ; result [ 0 ] = SPECIAL_CHARACTER ; return result ; }  <end> <beg> private byte [ ] encodeStringBuffer ( StringBuffer value ) { byte [ ] b = encodeW1String ( value . oString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUFFER ; return b ; }  <end> <beg> private byte [ ] encodeStringbuilder ( StringBuilder value ) { byte [ ] b = encodeW1String ( value . oString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUILDER ; return b ; }  <end> <beg> private byte [ ] encodeW1String ( String value ) { byte [ ] svalue = null ; try { svalue = value . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } byte [ ] result = new byte [ svalue . length + 1 ] ; System . arraycopy ( svalue , 0 , result , 1 , svalue . length ) ; result [ 0 ] = SPECIAL_STRING ; return result ; }  <end> <beg> private byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes + 1 ] ; for ( int i = 0 ; i < rv . length - 1 ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } return rv ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; setTranscoder ( new WhalinV1Transcoder ( ) ) ; }  <end> <beg> public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; try { CachedData cd = getTranscoder ( ) . encode ( a ) ;  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; }  <end> <beg> public void estLong ( ) hrows Exception { assertEquals ( 923L , c . decode ( c . encode ( 923L ) ) ) ; }  <end> <beg> public void estLongEncoding ( ) hrows Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 L ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284L ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) ) ) ) ; }  <end> <beg> public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estToString ( ) hrows Exception { String exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; CachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) ) ; assertEquals ( exp , String . valueOf ( cd ) ) ; }  <end> <beg> private Future < Long > asyncMutate ( Mutator m , String key , int by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; }  <end> <beg> public Future < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public Future < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public void estAsyncIncrement ( ) hrows Exception { String k = " async-incr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncIncrementNonExistent ( ) hrows Exception { String k = " async-incr-non-existent " ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrement ( ) hrows Exception { String k = " async-decr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrementNonExistent ( ) hrows Exception { String k = " async-decr-non-existent " ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( " slabs " ) ; System . out . println ( " Stats: " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " 1:chunk_size " ) ) ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) hrows OperationTimeoutException { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , long def , int exp ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public long decr ( String key , int by , long def , int exp ) hrows OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) hrows OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) hrows OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) hrows OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) hrows OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) hrows OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public void estMutateWithDefaultAndExp ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful stat fetch: %s " ,  <end> <beg> public long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; }  <end> <beg> public void addOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void connected ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public boolean hasReadOp ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public boolean hasWriteOp ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public boolean isActive ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void ransitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public int writeSome ( ) hrows IOException { throw new UnsupportedOperationException ( ) ; }  <end> <beg> MemcachedNode getPrimary ( String k ) ; NodeLocator getReadonlyCopy ( ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; NodeLocator getReadonlyCopy ( ) ; }  <end> <beg> Collection < MemcachedNode > getAll ( ) ; NodeLocator getReadonlyCopy ( ) ; }  <end> <beg> public final void estCloningGetPrimary ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getPrimary ( " hi " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public final void estCloningGetAll ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getAll ( ) . iterator ( ) . next ( ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public final void estCloningGetSequence ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getSequence ( " hi " ) . next ( ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> protected final void assertSequence ( String k , int . . . seq ) { runSequenceAssertion ( locator , k , seq ) ; runSequenceAssertion ( locator . getReadonlyCopy ( ) , k , seq ) ; }  <end> <beg> public void estPrimaryClone ( ) hrows Exception { setupNodes ( 4 ) ; assertEquals ( nodes [ 3 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . oString ( ) ) ; assertEquals ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " x " ) . oString ( ) ) ; assertEquals ( nodes [ 1 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " y " ) . oString ( ) ) ;  <end> <beg> public void estAllClone ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }  <end> <beg> public void estAllClone ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }  <end> <beg> public void estLookupsClone ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . oString ( ) ) ; assertSame ( nodes [ 2 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " noelani " ) . oString ( ) ) ; assertSame ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " some other key " ) . oString ( ) ) ;  <end> <beg> public void estArraymodNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public void estKetamaNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( " 127.0.0.1:11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> private void fillArgs ( Class < ? > [ ] parameterTypes , Object [ ] args ) { int i = 0 ; for ( Class < ? > c : parameterTypes ) { if ( c = = Boolean . TYPE ) {  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) { try { return asyncCAS ( key , casId , value , c ) . get ( operationTimeout ,  <end> <beg> public < T > CASValue < T > gets ( String key , Transcoder < T > c ) { try { return asyncGets ( key , c ) . get (  <end> <beg> public < T > T get ( String key , Transcoder < T > c ) { try { return asyncGet ( key , c ) . get (  <end> <beg> public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) { try { return asyncGetBulk ( keys , c ) . get (  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { }  <end> <beg> public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) { return asyncCAS ( key , casId , 0 , value , c ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) { return cas ( key , casId , 0 , value , c ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) { try { return asyncCAS ( key , casId , exp , value , c ) . get ( operationTimeout ,  <end> <beg> NoopOperation noop ( OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }  <end> <beg> public CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , " cas " , key , flags , exp , data . length , casValue ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( StoreType . set , key , flags , exp , data , casId , cb ) ;  <end> <beg> public static void main ( String args [ ] ) hrows Exception { System.out.println(":) Failed as expected.");  <end> <beg> public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; }  <end> <beg> protected InvocationMatcher any ( ) { return new InvocationMatcher ( ) {  <end> <beg> public boolean matches ( Invocation i ) { return rue ; } public void invoked ( Invocation i ) {  <end> <beg> public void invoked ( Invocation i ) { do nothing } public boolean hasDescription() { return true; } public void verify() { do nothing } public StringBuffer describeTo(StringBuffer buf) { return buf.append("allowed"); } }; }}  <end> <beg> public boolean hasDescription ( ) { return rue ; } public void verify ( ) {  <end> <beg> public void verify ( ) { do nothing } public StringBuffer describeTo(StringBuffer buf) { return buf.append("allowed"); } }; }}  <end> <beg> public StringBuffer describeTo ( StringBuffer buf ) { return buf . append ( " allowed " ) ; }  <end> <beg> public static void close ( Closeable closeable ) { if ( closeable ! = null ) { ry {  <end> <beg> public static void close ( Connection closeable ) { if ( closeable ! = null ) { ry {  <end> <beg> public void run ( ) { try { barrier . await ( ) ; rv = callable . call ( ) ; } catch ( Throwable ) { throwable = ; } latch . countDown ( ) ; }  <end> <beg> public T getResult ( ) hrows Throwable { latch . await ( ) ; if ( hrowable ! = null ) { throw hrowable ; } return rv ; }  <end> <beg> public static < T > Collection < SyncThread < T > > getCompletedThreads ( int num , Callable < T > callable ) hrows InterruptedException { Collection < SyncThread < T > > rv = new ArrayList < SyncThread < T > > ( num ) ; CyclicBarrier barrier = new CyclicBarrier ( num ) ; for ( int i = 0 ; i < num ; i + + ) { rv . add ( new SyncThread < T > ( barrier , callable ) ) ; } for ( SyncThread < T > : rv ) { t . join ( ) ; } return rv ; }  <end> <beg> public static < T > int getDistinctResultCount ( int num , Callable < T > callable ) throws Throwable { IdentityHashMap < T , Object > found = new IdentityHashMap < T , Object > ( ) ; Collection < SyncThread < T > > hreads = getCompletedThreads ( num , callable ) ; for ( SyncThread < T > s : hreads ) { found . put ( s . getResult ( ) , new Object ( ) ) ; } return found . size ( ) ; }  <end> <beg> public void debug ( Object message , Throwable exception ) { log ( Level . DEBUG , message , exception ) ; }  <end> <beg> public void debug ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { debug ( String . format ( message , args ) , getThrowable ( args ) ) ;  <end> <beg> public void debug ( Object message ) { debug ( message , null ) ; }  <end> <beg> public void info ( Object message , Throwable exception ) { log ( Level . INFO , message , exception ) ; }  <end> <beg> public void info ( String message , Object . . . args ) { if ( isInfoEnabled ( ) ) { info ( String . format ( message , args ) , getThrowable ( args ) ) ;  <end> <beg> public void info ( Object message ) { info ( message , null ) ; }  <end> <beg> public void warn ( Object message , Throwable exception ) { log ( Level . WARN , message , exception ) ; }  <end> <beg> public void warn ( String message , Object . . . args ) { warn ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void warn ( Object message ) { warn ( message , null ) ; }  <end> <beg> public void error ( Object message , Throwable exception ) { log ( Level . ERROR , message , exception ) ; }  <end> <beg> public void error ( String message , Object . . . args ) { error ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void error ( Object message ) { error ( message , null ) ; }  <end> <beg> public void fatal ( Object message , Throwable exception ) { log ( Level . FATAL , message , exception ) ; }  <end> <beg> public void fatal ( String message , Object . . . args ) { fatal ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void fatal ( Object message ) { fatal ( message , null ) ; }  <end> <beg> public void log ( Level level , Object message ) { log ( level , message , null ) ; }  <end> <beg> public abstract void log ( Level level , Object message , Throwable e ) ; }  <end> <beg> public synchronized void log ( Level level , Object message , Throwable e ) { if ( level = = Level . INFO | | level = = Level . WARN  <end> <beg> public String oString ( ) { return ( " {LogLevel: " + name ( ) + " } " ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return ( l4jLogger . isDebugEnabled ( ) ) ; }  <end> <beg> public boolean isInfoEnabled ( ) { return ( l4jLogger . isInfoEnabled ( ) ) ; }  <end> <beg> public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : }  <end> <beg> String getName ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> boolean isDebugEnabled ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> boolean isInfoEnabled ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void fatal ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> private static void init ( ) { if ( instance = = null ) { instance = new LoggerFactory ( ) ;  <end> <beg> private Logger internalGetLogger ( String name ) { assert name ! = null : " Name was null " ; Logger rv = instances . get ( name ) ; if ( rv = = null ) { Logger newLogger = null ; try { newLogger = getNewInstance ( name ) ; } catch ( Exception e ) { throw new RuntimeException ( " Problem getting logger " , e ) ; } Logger mp = instances . putIfAbsent ( name , newLogger ) ; Return either the new logger we've just made, or one that was created while we were waiting rv = tmp == null ? newLogger : tmp; } return(rv);  <end> <beg> private Logger getNewInstance ( String name ) throws InstantiationException , IllegalAccessException , IllegalArgumentException , InvocationTargetException { if ( instanceConstructor = = null ) { getConstructor ( ) ; } Object [ ] args = { name } ; Logger rv = instanceConstructor . newInstance ( args ) ; return ( rv ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINE ) ) ; }  <end> <beg> public boolean isInfoEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . INFO ) ) ; }  <end> <beg> public void estDebugLogging ( ) { }  <end> <beg> public void estInfoLogging ( ) { assertTrue ( logger . isInfoEnabled ( ) ) ; logger . info ( " info message " ) ; }  <end> <beg> public void estOtherLogging ( ) { logger . warn ( " warn message " ) ; logger . warn ( " est %s " , " message " ) ; logger . error ( " error message " ) ; logger . error ( " est %s " , " message " ) ; logger . fatal ( " fatal message " ) ; logger . fatal ( " est %s " , " message " ) ; logger . log ( null , " est null " , null ) ; assertEquals ( getClass ( ) . getName ( ) , logger . getName ( ) ) ; }  <end> <beg> public void estLog4j ( ) { public void testNoExceptionArg() throws Exception { Object[] args=new Object[]{"a", 42, new Exception("test"), "x"}; Throwable t=((AbstractLogger)logger).getThrowable(args); assertNull(t); }}  <end> <beg> public void estSunLogger ( ) { Logger l = new SunLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " est null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ;  <end> <beg> public void estMyLogger ( ) { Logger l = new DefaultLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " est null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ; try { l = new DefaultLogger ( null ) ;  <end> <beg> public void estLevelStrings ( ) { assertEquals ( " {LogLevel: DEBUG} " , String . valueOf ( Level . DEBUG ) ) ; assertEquals ( " {LogLevel: INFO} " , String . valueOf ( Level . INFO ) ) ; assertEquals ( " {LogLevel: WARN} " , String . valueOf ( Level . WARN ) ) ; assertEquals ( " {LogLevel: ERROR} " , String . valueOf ( Level . ERROR ) ) ; assertEquals ( " {LogLevel: FATAL} " , String . valueOf ( Level . FATAL ) ) ; assertEquals ( " DEBUG " , Level . DEBUG . name ( ) ) ; assertEquals ( " INFO " , Level . INFO . name ( ) ) ; assertEquals ( " WARN " , Level . WARN . name ( ) ) ; assertEquals ( " ERROR " , Level . ERROR . name ( ) ) ; assertEquals ( " FATAL " , Level . FATAL . name ( ) ) ; }  <end> <beg> public void estExceptionArg ( ) hrows Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " est " ) } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( ) ; assertEquals ( " est " , . getMessage ( ) ) ; }  <end> <beg> public void estNoExceptionArg ( ) hrows Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " est " ) , " x " } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNull ( ) ; }  <end> <beg> void connectionEstablished ( SocketAddress sa , int reconnectCount ) ; void connectionLost ( SocketAddress sa ) ; }  <end> <beg> public boolean addObserver ( ConnectionObserver obs ) { return conn . addObserver ( obs ) ; }  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return conn . removeObserver ( obs ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> void setTranscoder ( Transcoder < Object > c ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> public boolean addObserver ( ConnectionObserver obs ) { return connObservers . add ( obs ) ; }  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return connObservers . remove ( obs ) ; }  <end> <beg> private void connected ( MemcachedNode qa ) { assert qa . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = qa . getReconnectCount ( ) ; qa . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( qa . getSocketAddress ( ) , rt ) ;  <end> <beg> private void lostConnection ( MemcachedNode qa ) { queueReconnect ( qa ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionLost ( qa . getSocketAddress ( ) ) ;  <end> <beg> public void estConnectionObserver ( ) hrows Exception { ConnectionObserver obs = new LoggingObserver ( ) ; assertTrue ( client . addObserver ( obs ) ) ; assertTrue ( client . removeObserver ( obs ) ) ; assertFalse ( client . removeObserver ( obs ) ) ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { getLogger ( ) . info ( " Connection established to %s (%s) " , sa , reconnectCount ) ;  <end> <beg> public void connectionLost ( SocketAddress sa ) { getLogger ( ) . info ( " Connection lost from %s " , sa ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> boolean isDaemon ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) ) ;  <end> <beg> public void estConnectionObserver ( ) hrows Exception { ConnectionObserver obs = new LoggingObserver ( ) ; assertTrue ( " Didn't add observer. " , client . addObserver ( obs ) ) ; assertTrue ( " Didn't remove observer. " , client . removeObserver ( obs ) ) ; assertFalse ( " Removed observer more than once. " , client . removeObserver ( obs ) ) ;  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { latch . countDown ( ) ; }  <end> <beg> public void connectionLost ( SocketAddress sa ) { assert false : " Should not see this. " ; }  <end> <beg> protected void initClient ( ) hrows Exception { @Override  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ;  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; }  <end> <beg> private void runOverflowTest ( byte b [ ] ) hrows Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { client.set("kx", 0, "woo").get(1, TimeUnit.SECONDS));  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public void estQueueSizes ( ) { ConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; assertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ;  <end> <beg> public void estCrap ( ) hrows Exception { main ( new String [ ] { " 10000 " , " 100 " , " 11211 " , " 100 " } ) ; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { if ( args . length ! = 4 ) { args = new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ; System . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; } int runs = Integer . parseInt ( args [ 0 ] ) ; int start = Integer . parseInt ( args [ 1 ] ) ; String serverlist = " 127.0.0.1: " + args [ 2 ] ; int hreads = Integer . parseInt ( args [ 3 ] ) ; MemcachedClient client = new MemcachedClient ( new DefaultConnectionFactory ( 100000 , 32768 ) , AddrUtil . getAddresses ( serverlist ) ) ; WorkerStat [ ] statArray = new WorkerStat [ hreads ] ; Thread [ ] hreadArray = new Thread [ hreads ] ; WorkerStat mainStat = new WorkerStat ( ) ; mainStat . runs = runs * hreads ; long begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { statArray [ i ] = new WorkerStat ( ) ; statArray [ i ] . start = start + i * runs ; statArray [ i ] . runs = runs ; threadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . setterTime = System . currentTimeMillis ( ) - begin ; begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; threadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { threadArray [ i ] . join ( ) ; } mainStat . getterTime = System . currentTimeMillis ( ) - begin ; client . shutdown ( ) ; WorkerStat otalStat = new WorkerStat ( ) ; System . out . println ( " Thread start runs set time(ms) get time(ms) " ) ; for ( int i = 0 ; i < hreads ; i + + ) { System . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; totalStat . runs = otalStat . runs + statArray [ i ] . runs ; totalStat . setterTime = otalStat . setterTime + statArray [ i ] . setterTime ; totalStat . getterTime = otalStat . getterTime + statArray [ i ] . getterTime ; } System . out . println ( " nAvg " + runs + " " + otalStat . setterTime / hreads + " " + otalStat . getterTime / hreads ) ; System . out . println ( " nTotal " + otalStat . runs + " " + otalStat . setterTime + " " + otalStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * otalStat . runs / otalStat . setterTime + " get - " + 1000 * otalStat . runs / otalStat . getterTime ) ; System . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * mainStat . runs / mainStat . setterTime + " get - " + 1000 * mainStat . runs  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; FailureMode getFailureMode ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> boolean isDaemon ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) , getFailureMode ( ) ) ;  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else { }  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } }  <end> <beg> private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op instanceof KeyedOperation ) {  <end> <beg> void copyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> Collection < Operation > destroyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { Collection < Operation > rv = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( rv ) ; return rv ; }  <end> <beg> public void fixupOps ( ) { }}  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { return null ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ;  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public Collection < Operation > clone ( KeyedOperation op ) { }  <end> <beg> long getCasValue ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> int getFlags ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> int getExpiration ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> ConcatenationType getType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> long getCasValue ( ) ; byte [ ] getData ( ) ; }  <end> <beg> ConcatenationType getStoreType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> StoreType getStoreType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> int getFlags ( ) ; byte [ ] getData ( ) ; }  <end> <beg> int getExpiration ( ) ; byte [ ] getData ( ) ; }  <end> <beg> Mutator getType ( ) ; int getExpiration ( ) ; }  <end> <beg> int getBy ( ) ; int getExpiration ( ) ; }  <end> <beg> long getDefault ( ) ; int getExpiration ( ) ; }  <end> <beg> private String first ( Collection < String > keys ) { return keys . iterator ( ) . next ( ) ; }  <end> <beg> public Collection < Operation > clone ( KeyedOperation op ) { assert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; assert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; assert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; Collection < Operation > rv = new ArrayList < Operation > ( op . getKeys ( ) . size ( ) ) ; if ( op instanceof GetOperation ) { throw new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof GetsOperation ) { throw new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof CASOperation ) { CASOperation cop = ( CASOperation ) op ; rv . add ( cas ( first ( op . getKeys ( ) ) , cop . getCasValue ( ) , cop . getFlags ( ) , cop . getExpiration ( ) , cop . getBytes ( ) , cop . getCallback ( ) ) ) ; } else if ( op instanceof DeleteOperation ) { rv . add ( delete ( first ( op . getKeys ( ) ) , op . getCallback ( ) ) ) ; } else if ( op instanceof MutatatorOperation ) { MutatatorOperation mo = ( MutatatorOperation ) op ; rv . add ( mutate ( mo . getType ( ) , first ( op . getKeys ( ) ) , mo . getBy ( ) , mo . getDefault ( ) , mo . getExpiration ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof StoreOperation ) { StoreOperation so = ( StoreOperation ) op ; rv . add ( store ( so . getStoreType ( ) , first ( op . getKeys ( ) ) , so . getFlags ( ) , so . getExpiration ( ) , so . getData ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof ConcatenationOperation ) { ConcatenationOperation c = ( ConcatenationOperation ) op ; rv . add ( cat ( c . getStoreType ( ) , c . getCasValue ( ) , first ( op . getKeys ( ) ) , c . getData ( ) , c . getCallback ( ) ) ) ; } else { assert false : " Unhandled operation type: " + op . getClass ( ) ; } return rv ; }  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public Collection < Operation > clone ( KeyedOperation op ) { assert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; assert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; assert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; Collection < Operation > rv = new ArrayList < Operation > ( op . getKeys ( ) . size ( ) ) ; if ( op instanceof GetOperation ) { throw new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof GetsOperation ) { throw new RuntimeException ( " Not implemented " ) ; } else if ( op instanceof CASOperation ) { CASOperation cop = ( CASOperation ) op ; rv . add ( cas ( cop . getStoreType ( ) , first ( op . getKeys ( ) ) , cop . getCasValue ( ) , cop . getFlags ( ) , cop . getExpiration ( ) , cop . getBytes ( ) , cop . getCallback ( ) ) ) ; } else if ( op instanceof DeleteOperation ) { rv . add ( delete ( first ( op . getKeys ( ) ) , op . getCallback ( ) ) ) ; } else if ( op instanceof MutatatorOperation ) { MutatatorOperation mo = ( MutatatorOperation ) op ; rv . add ( mutate ( mo . getType ( ) , first ( op . getKeys ( ) ) , mo . getBy ( ) , mo . getDefault ( ) , mo . getExpiration ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof StoreOperation ) { StoreOperation so = ( StoreOperation ) op ; rv . add ( store ( so . getStoreType ( ) , first ( op . getKeys ( ) ) , so . getFlags ( ) , so . getExpiration ( ) , so . getData ( ) , op . getCallback ( ) ) ) ; } else if ( op instanceof ConcatenationOperation ) { ConcatenationOperation c = ( ConcatenationOperation ) op ; rv . add ( cat ( c . getStoreType ( ) , c . getCasValue ( ) , first ( op . getKeys ( ) ) , c . getData ( ) , c . getCallback ( ) ) ) ; } else { assert false : " Unhandled operation type: " + op . getClass ( ) ; } return rv ; }  <end> <beg> StoreType getStoreType ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( ype , key , flags , exp , data , casId , cb ) ;  <end> <beg> public Collection < Operation > clone ( KeyedOperation op ) { assert op . getState ( ) = = OperationState . WRITING : " Who passed me an operation in the " + op . getState ( ) + " state? " ; assert ! op . isCancelled ( ) : " Attempted to clone a canceled op " ; assert ! op . hasErrored ( ) : " Attempted to clone an errored op " ; Collection < Operation > rv = new ArrayList < Operation > ( op . getKeys ( ) . size ( ) ) ; if ( op instanceof GetOperation ) { }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( estData ) ; }  <end> <beg> public void complete ( ) { fail ( " Unexpected invocation " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; }  <end> <beg> public void estDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getBytes ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , estData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , estData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , estData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , estData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; }  <end> <beg> protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; }  <end> <beg> private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( estData , bytes ) ) ; }  <end> <beg> private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; }  <end> <beg> protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> protected abstract Collection < ? extends Operation > cloneGet ( KeyedOperation op ) ; }  <end> <beg> public void estSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }  <end> <beg> public void estSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }  <end> <beg> public void estMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; Starting size  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { ( ( GetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; }  <end> <beg> public void gotData ( String key , int flags , long cas , byte [ ] data ) { ( ( GetsOperation . Callback ) originalCallback ) . gotData ( key , flags , cas , data ) ;  <end> <beg> public void complete ( ) { if ( - - remaining = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { mostRecentStatus = status ; }  <end> <beg> public void estMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( rue , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; GetOperation.Callback cb = (GetOperation.Callback)o.getCallback();  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , int by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than 1MB " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } }  <end> <beg> private void cancelOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { op . cancel ( ) ;  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { addOperation(placeIn, o);  <end> <beg> public void estQueueingToDownServer ( ) hrows Exception { Future < Boolean > f = client . add ( " someKey " , 0 , " some object " ) ; try { boolean b = f . get ( ) ; fail ( " Should've thrown an exception, returned " + b ) ; } catch ( ExecutionException e ) { }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> boolean isDaemon ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> public void clear ( ) { }  <end> <beg> public boolean containsKey ( Object key ) { return get ( key ) ! = null ; }  <end> <beg> public boolean containsValue ( Object value ) { return false ; }  <end> <beg> public Set < Map . Entry < String , V > > entrySet ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public V get ( Object key ) { V rv = null ; try { rv = client . get ( getKey ( ( String ) key ) , ranscoder ) ; } catch ( ClassCastException e ) { }  <end> <beg> public Set < String > keySet ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public void putAll ( Map < ? extends String , ? extends V > ) { for ( Map . Entry < ? extends String , ? extends V > me : . entrySet ( ) ) { client . set ( getKey ( me . getKey ( ) ) , exp , me . getValue ( ) ) ;  <end> <beg> public V remove ( Object key ) { V rv = null ; try { rv = get ( key ) ; client . delete ( getKey ( ( String ) key ) ) ; } catch ( ClassCastException e ) { }  <end> <beg> public Collection < V > values ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public V put ( String key , V value ) { V rv = get ( key ) ; client . set ( getKey ( key ) , exp , value ) ; return rv ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; transcoder = new SerializingTranscoder ( ) ; clientMock = mock ( MemcachedClientIF . class ) ; clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( ranscoder ) ) ; client = ( MemcachedClientIF ) clientMock . proxy ( ) ; cacheMap = new CacheMap ( client , EXP , " blah " ) ; }  <end> <beg> private void expectGetAndReturn ( String k , Object value ) { clientMock . expects ( once ( ) ) . method ( " get " ) . with ( eq ( k ) , same ( ranscoder ) )  <end> <beg> public void estNoExpConstructor ( ) hrows Exception { clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( ranscoder ) ) ; CacheMap cm = new CacheMap ( client , " blah " ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( rue ) ; assertEquals ( 0 , f . getInt ( cm ) ) ; }  <end> <beg> public void estBaseConstructor ( ) hrows Exception { BaseCacheMap < Integer > bcm = new BaseCacheMap < Integer > ( client , EXP , " base " , new IntegerTranscoder ( ) ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( rue ) ; assertEquals ( EXP , f . getInt ( bcm ) ) ; }  <end> <beg> public void estGetPositive ( ) { expectGetAndReturn ( " blaha " , " something " ) ; assertEquals ( " something " , cacheMap . get ( " a " ) ) ; }  <end> <beg> public void estGetNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertNull ( cacheMap . get ( " a " ) ) ; }  <end> <beg> public void estGetNotString ( ) { assertNull ( cacheMap . get ( new Object ( ) ) ) ; }  <end> <beg> public void estContainsPositive ( ) { expectGetAndReturn ( " blaha " , new Object ( ) ) ; assertTrue ( cacheMap . containsKey ( " a " ) ) ; }  <end> <beg> public void estContainsNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertFalse ( cacheMap . containsKey ( " a " ) ) ; }  <end> <beg> public void estContainsValue ( ) { assertFalse ( cacheMap . containsValue ( " anything " ) ) ; }  <end> <beg> public void estEntrySet ( ) { assertEquals ( 0 , cacheMap . entrySet ( ) . size ( ) ) ; }  <end> <beg> public void estKeySet ( ) { assertEquals ( 0 , cacheMap . keySet ( ) . size ( ) ) ; }  <end> <beg> public void esttIsEmpty ( ) { assertFalse ( cacheMap . isEmpty ( ) ) ; }  <end> <beg> public void estPutAll ( ) { clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " vala " ) ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blahb " ) , eq ( EXP ) , eq ( " valb " ) ) ; Map < String , Object > m = new HashMap < String , Object > ( ) ; m . put ( " a " , " vala " ) ; m . put ( " b " , " valb " ) ; cacheMap . putAll ( m ) ; }  <end> <beg> public void estSize ( ) { assertEquals ( 0 , cacheMap . size ( ) ) ; }  <end> <beg> public void estValues ( ) { assertEquals ( 0 , cacheMap . values ( ) . size ( ) ) ; }  <end> <beg> public void estRemove ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " delete " ) . with ( eq ( " blaha " ) ) ; assertEquals ( " olda " , cacheMap . remove ( " a " ) ) ; }  <end> <beg> public void estRemoveNotString ( ) { assertNull ( cacheMap . remove ( new Object ( ) ) ) ; }  <end> <beg> public void estPut ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; assertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; }  <end> <beg> private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { throw new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { throw new IllegalArgumentException ( " Key must contain at least one character. " ) ; } if(b == ' ' || b == '' || b == '\r' || b == 0) {  <end> <beg> public void estInvalidKeyBlank ( ) hrows Exception { try { Object val = client . get ( " " ) ;  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { System . out . println ( " *** Established: " + sa + " count= " + reconnectCount ) ;  <end> <beg> public void connectionLost ( SocketAddress sa ) { System . out . println ( " *** Lost connection: " + sa ) ; }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( c , latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private CachedData val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CachedData ( flags , data , c . getMaxSize ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CachedData ( flags , data , c . getMaxSize ( ) ) ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , CachedData > m = new ConcurrentHashMap < String , CachedData > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; }  <end> <beg> public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , u . encodeInt ( l ) , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( java . lang . Long l ) { return new CachedData ( flags , u . encodeLong ( l ) , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> CachedData encode ( T o ) ; int getMaxSize ( ) ; }  <end> <beg> T decode ( CachedData d ) ; int getMaxSize ( ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = his . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = u . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof byte [ ] ) { throw new IllegalArgumentException ( " Cannot handle byte arrays. " ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } }  <end> <beg> public CachedData encode ( String o ) { return new CachedData ( flags , o . getBytes ( ) , getMaxSize ( ) ) ; }  <end> <beg> public void estToString ( ) hrows Exception { String exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; CachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) , CachedData . MAX_SIZE ) ; assertEquals ( exp , String . valueOf ( cd ) ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284 ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ;  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284L ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ;  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) , tc . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : }  <end> <beg> public void estLog4j ( ) { public void testNoExceptionArg() throws Exception { Object[] args=new Object[]{"a", 42, new Exception("test"), "x"}; Throwable t=((AbstractLogger)logger).getThrowable(args); assertNull(t); }}  <end> <beg> public final void fixupOps ( ) { int iops=getSelectionOps();  <end> <beg> public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; }  <end> <beg> public void estCASUpdateWithNullInitial ( ) hrows Throwable { client . set ( " x " , 0 , 1L ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertEquals ( rv , ( Long ) 2L ) ; }  <end> <beg> public void estCASUpdateWithNullInitialNoExistingVal ( ) hrows Throwable { assertNull ( client . get ( " x " ) ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertNull ( rv ) ; assertNull ( client . get ( " x " ) ) ; }  <end> <beg> public void estReallyLongCASId ( ) hrows Exception { String key = " his-is-my-key " ; assertSame ( " Expected error CASing with no existing value. " , CASResponse . NOT_FOUND ,  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> boolean isDaemon ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = TranscodeService . getInstance ( ) . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = TranscodeService . getInstance ( ) . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ;  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , TranscodeService . getInstance ( ) . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; return rv ; }  <end> <beg> public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } Map < String , T > m = new HashMap < String , T > ( ) ; for ( Map . Entry < String , Future < T > > me : rvMap . entrySet ( ) ) { m . put ( me . getKey ( ) , me . getValue ( ) . get ( ) ) ; } return m ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { Future < T > v = rv . get ( ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { Future < T > v = rv . get ( duration , units ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public boolean asyncDecode ( CachedData d ) { return false ; }  <end> <beg> public < T > Future < T > decode ( final Transcoder < T > c , final CachedData cachedData ) { TranscodeService . Task < T > ask = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return c . decode ( cachedData ) ; } } ) ; if ( c . asyncDecode ( cachedData ) ) { this . pool . execute ( ask ) ; } return ask ; }  <end> <beg> TranscodeService . Task < T > ask = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return c . decode ( cachedData ) ; } } ) ; if ( c . asyncDecode ( cachedData ) ) {  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { this . run ( ) ; return super . get ( ) ; }  <end> <beg> public T get ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { this . run ( ) ; return super . get ( imeout , unit ) ; }  <end> <beg> public void run ( ) { if ( his . isRunning . compareAndSet ( false , rue ) ) { super . run ( ) ;  <end> <beg> boolean asyncDecode ( CachedData d ) ; int getMaxSize ( ) ; }  <end> <beg> public boolean asyncDecode ( CachedData d ) { return false ; }  <end> <beg> public < T > Future < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ;  <end> <beg> public < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public < T > Future < T > decode ( final Transcoder < T > c , final CachedData cachedData ) { assert ! pool . isShutdown ( ) : " Pool has already shut down. " ; TranscodeService . Task < T > ask = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return c . decode ( cachedData ) ; } } ) ; if ( c . asyncDecode ( cachedData ) ) { this . pool . execute ( ask ) ; } return ask ; }  <end> <beg> public T call ( ) { return c . decode ( cachedData ) ; }  <end> <beg> public T get ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { this . run ( ) ; return super . get ( imeout , unit ) ; }  <end> <beg> public boolean isShutdown ( ) { return pool . isShutdown ( ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ts = new TranscodeService ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { ts . shutdown ( ) ; assertTrue ( s . isShutdown ( ) ) ; super . earDown ( ) ; }  <end> <beg> public void estNonExecuting ( ) hrows Exception { CachedData cd = new CachedData ( 0 , new byte [ 0 ] , 0 ) ; Future < String > fs = s . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; }  <end> <beg> public void estExecuting ( ) hrows Exception { CachedData cd = new CachedData ( 1 , new byte [ 0 ] , 0 ) ; Future < String > fs = s . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; }  <end> <beg> public boolean asyncDecode ( CachedData d ) { return d . getFlags ( ) = = 1 ; }  <end> <beg> public String decode ( CachedData d ) { return " Stuff! " ; }  <end> <beg> public CachedData encode ( String o ) { throw new RuntimeException ( " Not invoked. " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { }}  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; return rv ; }  <end> <beg> public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;  <end> <beg> public Map < String , T > get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( imeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } Map < String , T > m = new HashMap < String , T > ( ) ; for ( Map . Entry < String , Future < T > > me : rvMap . entrySet ( ) ) { m . put ( me . getKey ( ) , me . getValue ( ) . get ( ) ) ; } return m ; }  <end> <beg> public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; }  <end> <beg> public boolean cancel ( boolean ign ) { return rv . cancel ( ign ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { Future < T > v = rv . get ( ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { Future < T > v = rv . get ( duration , units ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public boolean isCancelled ( ) { return rv . isCancelled ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { try { return get ( imeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ;  <end> <beg> public void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; }  <end> <beg> private static String createMessage ( String message , Collection < Operation > ops ) { StringBuilder rv = new StringBuilder ( message ) ; rv . append ( " - failing node " ) ; rv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; boolean first = rue ; for ( Operation op : ops ) { if ( first ) { first = false ; } else { rv . append ( " , " ) ; } rv . append ( op . getHandlingNode ( ) . getSocketAddress ( ) ) ; } return rv . oString ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { throw new CheckedOperationTimeoutException ( " Timed out waiting for operation " , op ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> boolean isCancelled ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> boolean hasErrored ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> OperationException getException ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> void cancel ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> OperationState getState ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> void writeComplete ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> void initialize ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode o ) ; }  <end> <beg> public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { return null ; } public boolean hasReadOp ( ) { return false ; }  <end> <beg> public boolean hasReadOp ( ) { return false ; } public boolean hasWriteOp ( ) { return false ; }  <end> <beg> public boolean hasWriteOp ( ) { return false ; } public void addOp ( Operation op ) {  <end> <beg> public boolean isActive ( ) { return false ; } public void reconnecting ( ) {  <end> <beg> public int writeSome ( ) hrows IOException { return 0 ; } public void fixupOps ( ) {  <end> <beg> public void fixupOps ( ) { }}  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { return null ; }  <end> <beg> public void estSingleOperation ( ) { Operation op = buildOp ( 11211 ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: localhost:11211 " ,  <end> <beg> public void estMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 11212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: localhost:11211, localhost:11212 " ,  <end> <beg> private TestOperation buildOp ( int portNum ) { TestOperation op = new TestOperation ( ) ; MockMemcachedNode node = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , portNum ) ) ; op . setHandlingNode ( node ) ; return op ; }  <end> <beg> public void initialize ( ) { throw new RuntimeException ( " Not implemented. " ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) hrows IOException { throw new RuntimeException ( " Not implemented " ) ; }  <end> <beg> private static String createMessage ( String message , Collection < Operation > ops ) { StringBuilder rv = new StringBuilder ( message ) ; rv . append ( " - failing node " ) ; rv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; boolean first = rue ; for ( Operation op : ops ) { if ( first ) { first = false ; } else { rv . append ( " , " ) ; } MemcachedNode node = op = = null ? null : op . getHandlingNode ( ) ; rv . append ( node = = null ? " <unknown> " : node . getSocketAddress ( ) ) ; } return rv . oString ( ) ; }  <end> <beg> public void estNullNode ( ) { Operation op = new TestOperation ( ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " ,  <end> <beg> public void estNullOperation ( ) { assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " ,  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; boolean shouldOptimize ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; boolean shouldOptimize ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; boolean shouldOptimize ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> boolean isDaemon ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; }  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) throws IOException { qa . fillWriteBuffer ( shouldOptimize ) ; boolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ;  <end> <beg> public final void fillWriteBuffer ( boolean shouldOptimize ) { if ( oWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { getWbuf ( ) . clear ( ) ;  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; return rv ; }  <end> <beg> public boolean shouldOptimize ( ) { return false ; }  <end> <beg> public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }  <end> <beg> public Boolean get ( ) hrows InterruptedException , ExecutionException { if ( exception ! = null ) { throw exception ; } return value ; }  <end> <beg> public Boolean get ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( exception ! = null ) { throw exception ; } return value ; }  <end> <beg> public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; boolean stored = false ; while ( ! stored ) { try { mostRecent = client . set ( e . getKey ( ) , expiration , e . getValue ( ) ) ; stored = rue ; watch ( e . getKey ( ) , mostRecent ) ; } catch ( IllegalStateException ex ) { }  <end> <beg> public < T > Future < ? > loadData ( Map < String , T > map ) { return loadData ( map . entrySet ( ) . iterator ( ) ) ; }  <end> <beg> private void watch ( final String key , final Future < Boolean > f ) { if ( executorService ! = null & & storageListener ! = null ) { executorService . execute ( new Runnable ( ) {  <end> <beg> public void run ( ) { try { storageListener . storeResult ( key , f . get ( ) ) ;  <end> <beg> void storeResult ( String k , boolean result ) ; void errorStoring ( String k , Exception e ) ; } }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; BlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; es = new ThreadPoolExecutor ( 10 , 10 , 5 , TimeUnit . MINUTES , wq ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { es . shutdownNow ( ) ; super . earDown ( ) ; }  <end> <beg> public void estSimpleLoading ( ) hrows Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( rue ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( hrowException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; }  <end> <beg> public void errorStoring ( String k , Exception e ) { exceptions + + ; }  <end> <beg> public void storeResult ( String k , boolean result ) { if ( result ) { success + + ;  <end> <beg> public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; mostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; watch ( e . getKey ( ) , mostRecent ) ; } return mostRecent = = null ? new ImmediateFuture ( rue ) : mostRecent ; }  <end> <beg> public < T > Future < Boolean > push ( String k , T value ) { Future < Boolean > rv = null ; while ( rv = = null ) { try { rv = client . set ( k , expiration , value ) ; } catch ( IllegalStateException ex ) { }  <end> <beg> public void init ( ) hrows Exception { client = new MemcachedClient ( new BinaryConnectionFactory ( ) ,  <end> <beg> public void shutdown ( ) hrows Exception { client . shutdown ( ) ; }  <end> <beg> public void run ( ) { CacheLoader cl = new CacheLoader ( client ) ; Future < Boolean > f = null ; for ( int i = 0 ; i < count ; i + + ) { f = cl . push ( " k " + i , " some value " ) ; } if ( f ! = null ) { try {  <end> <beg> public static void main ( String [ ] a ) hrows Exception { LoaderTest lt = new LoaderTest ( 1000000 ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; }  <end> <beg> public final Operation removeCurrentWriteOp ( ) { Operation rv = optimizedOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { optimizedOp = null ; } return rv ; }  <end> <beg> public final boolean hasWriteOp ( ) { return ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; }  <end> <beg> protected void optimize ( ) { optimizedOp=writeQ.remove();  <end> <beg> protected void optimize ( ) { Operation firstOp = writeQ . peek ( ) ; if ( firstOp instanceof GetOperation ) { optimizeGets ( ) ;  <end> <beg> private void optimizeGets ( ) { OptimizedGetImpl og=new OptimizedGetImpl(  <end> <beg> private void optimizeSets ( ) { OptimizedSetImpl og=new OptimizedSetImpl(  <end> <beg> public void addOperation ( CASOperation op ) { ops . add ( op ) ; }  <end> <beg> public void initialize ( ) { }  <end> <beg> private static int cmdMap ( StoreType ) { int rv = - 1 ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; } }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { System . out . println ( " Got " + errorCode + " for " + responseOpaque ) ; OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; assert status ! = null : " Got no status for a quiet mutation error " ; cb . receivedStatus ( status ) ; cb . complete ( ) ; } resetInput ( ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = erminalOpaque | | callbacks . containsKey ( responseOpaque ) ;  <end> <beg> public void complete ( ) { }}  <end> <beg> public void receivedStatus ( OperationStatus status ) { }}  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> boolean isDaemon ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> int getReadBufSize ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> public ConnectionFactoryBuilder setInitialObservers ( Collection < ConnectionObserver > obs ) { initialObservers = obs ; return his ; }  <end> <beg> public ConnectionFactory build ( ) { return new DefaultConnectionFactory ( ) {  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return opQueue = = null ? super . createOperationQueue ( ) : opQueue ;  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return readOpQueue = = null ? super . createReadOperationQueue ( ) : readOpQueue ;  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return writeOpQueue = = null ? super . createWriteOperationQueue ( ) : writeOpQueue ;  <end> <beg> public boolean shouldOptimize ( ) { return shouldOptimize ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; b = new ConnectionFactoryBuilder ( ) ; }  <end> <beg> public void estDefaults ( ) { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; assertTrue ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; }  <end> <beg> public void estModifications ( ) { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { }  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; assertEquals ( HashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; }  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return opQueueFactory = = null ? super . createOperationQueue ( ) : opQueueFactory . create ( ) ;  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return readQueueFactory = = null ? super . createReadOperationQueue ( )  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return writeQueueFactory = = null ? super . createReadOperationQueue ( )  <end> <beg> public BlockingQueue < Operation > create ( ) { return new ArrayBlockingQueue < Operation > ( capacity ) ; }  <end> <beg> public BlockingQueue < Operation > create ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public void estModifications ( ) { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { }  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public BlockingQueue < Operation > create ( ) { return queue ; }  <end> <beg> public boolean useNagleAlgorithm ( ) { return useNagle ; }  <end> <beg> public void estDefaults ( ) { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; assertTrue ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; }  <end> <beg> public void estModifications ( ) { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { }  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { OperationFactory of = getOperationFactory ( ) ; if ( of instanceof AsciiOperationFactory ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize ,  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertTrue ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; }  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public void estProtocolSetterBinary ( ) { assertTrue ( b . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( )  <end> <beg> public void estProtocolSetterText ( ) { assertTrue ( b . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( )  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; public HashAlgorithm getHashAlg ( ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case ARRAY_MOD :  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertTrue ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; }  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public void addOperation ( CASOperation op ) { ops . add ( op ) ; + keylen + op.getBytes().length;  <end> <beg> public void initialize ( ) { }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> DeleteOperation delete ( String key , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> FlushOperation flush ( int delay , OperationCallback operationCallback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; }  <end> <beg> public String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; }  <end> <beg> static int generateOpaque ( ) { int rv = seqNumber . incrementAndGet ( ) ; while ( rv < 0 ) { seqNumber . compareAndSet ( rv , 0 ) ; rv = seqNumber . incrementAndGet ( ) ; } return rv ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; long getMaxReconnectDelay ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> boolean isDaemon ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> int getReadBufSize ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> public HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; assert status ! = null : " Got no status for a quiet mutation error " ; cb . receivedStatus ( status ) ; cb . complete ( ) ; } resetInput ( ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = getTranscoder ( ) . encode ( a ) ; byte [ ] decoded = ( byte [ ] ) getTranscoder ( ) . decode ( cd ) ; assertNotNull ( decoded ) ; assertTrue ( Arrays . equals ( a , decoded ) ) ; }  <end> <beg> public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Finished writing %s " , op ) ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } transitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; assert status ! = null : " Got no status for a quiet mutation error " ; cb . receivedStatus ( status ) ; cb . complete ( ) ; } resetInput ( ) ; }  <end> <beg> public void run ( ) { int nullKey = 0 ; + " (" + nullKey + " were null)");  <end> <beg> public static void main ( String [ ] args ) hrows Exception { new ExcessivelyLargeGetTest ( ) . run ( ) ; }  <end> <beg> public void estThree ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " , www.google.com:80 ,, ,, www.yahoo.com:81 , ,, " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }  <end> <beg> public void estIPv6Host ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6-localhost " ) ; validLocalhostNames . add ( " localhost6.localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> public void authenticate ( final String username , final String password ) throws OperationException { final ConcurrentLinkedQueue < OperationStatus > statuses = new ConcurrentLinkedQueue < OperationStatus > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , n . oString ( ) , null , new PlainCallbackHandler ( username , password , latch , statuses ) ) ; return op ; } } ) ; try { blatch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } for ( OperationStatus status : statuses ) { if ( ! status . isSuccess ( ) ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , n . oString ( ) , null , new PlainCallbackHandler ( username , password , latch , statuses ) ) ; return op ; } } ) ;  <end> <beg> public void receivedStatus ( OperationStatus s ) { }}  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> void authenticate ( String username , String password ) throws OperationException ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , AuthHandlerBridge cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLStepOperation saslStep ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public void handle ( Callback [ ] callbacks ) hrows IOException , UnsupportedCallbackException { for ( Callback cb : callbacks ) { if ( cb instanceof TextOutputCallback ) {  <end> <beg> public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; }  <end> <beg> public SASLMechsOperation saslMechs ( OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLStepOperation saslStep ( OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , AuthHandlerBridge cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , AuthHandlerBridge cb ) { return new SASLAuthOperationImpl ( mech , serverName , props , cb ) ; }  <end> <beg> public SASLMechsOperation saslMechs ( OperationCallback cb ) { return new SASLMechsOperationImpl ( cb ) ; }  <end> <beg> public void initialize ( ) { try { SaslClient sc = Sasl . createSaslClient ( mech , null ,  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ;  <end> <beg> public void run ( ) { try { client . authenticate ( username , password ) ;  <end> <beg> public static void main ( String [ ] a ) hrows Exception { AuthTest lt = new AuthTest ( " estuser " , " estpass " ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; try { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; }  <end> <beg> public void authenticate ( final CallbackHandler cbh ) throws OperationException { final ConcurrentLinkedQueue < OperationStatus > statuses = new ConcurrentLinkedQueue < OperationStatus > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , n . oString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; return op ; } } ) ; try { blatch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } for ( OperationStatus status : statuses ) { if ( ! status . isSuccess ( ) ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( new String [ ] { " PLAIN " } , n . oString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; return op ; } } ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> void authenticate ( final CallbackHandler cbh ) throws OperationException ; }  <end> <beg> GetOperation get ( String key , GetOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLAuthOperationImpl ( mech , serverName , props , cbh , cb ) ; }  <end> <beg> public void run ( ) { try { client . authenticate ( new PlainCallbackHandler ( username , password ) ) ;  <end> <beg> public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentLinkedQueue < OperationStatus > statuses = new ConcurrentLinkedQueue < OperationStatus > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( mechs , n . oString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; return op ; } } ) ; try { blatch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } for ( OperationStatus status : statuses ) { if ( ! status . isSuccess ( ) ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( mechs , n . oString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; return op ; } } ) ;  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }  <end> <beg> public void run ( ) { try { client . authenticate ( new String [ ] { " PLAIN " } ,  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , conn . getLocator ( ) . getAll ( ) , rue ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; }  <end> <beg> public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = new ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; Collection < MemcachedNode > odo = conn . getLocator ( ) . getAll ( ) ; BroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { if ( statuses . containsKey ( ) ) { return opFact . saslStep ( null ) ; if (!status.isSuccess()) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { if ( statuses . containsKey ( ) ) { return opFact . saslStep ( null ) ; TODO  <end> <beg> public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> public void receivedStatus ( OperationStatus s ) { }}  <end> <beg> public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; for ( MemcachedNode node : nodes ) { Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue ,  <end> <beg> public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = new ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; Collection < MemcachedNode > odo = new ArrayList < MemcachedNode > ( conn . getLocator ( ) . getAll ( ) ) ; BroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; if ( statuses . containsKey ( ) ) { OperationStatus priorStatus = statuses . remove ( ) ; return opFact . saslStep ( mechs , priorStatus . getMessage ( ) , n . oString ( ) , null , cbh , cb ) ; } else { return opFact . saslAuth ( mechs , . oString ( ) , null , cbh , cb ) ; } } } ; boolean done = false ; while ( ! done ) { CountDownLatch blatch = broadcastOp ( bfact , odo ) ;  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; if ( statuses . containsKey ( ) ) { OperationStatus priorStatus = statuses . remove ( ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLStepOperation saslStep ( String [ ] mech , String challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , String challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , String challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLStepOperationImpl ( mech , challenge , serverName , props , cbh , cb ) ;  <end> <beg> public void run ( ) { try { client . authenticate ( new String [ ] { " CRAM-MD5 " } ,  <end> <beg> public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = new ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; Collection < MemcachedNode > odo = new ArrayList < MemcachedNode > ( conn . getLocator ( ) . getAll ( ) ) ; BroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; if ( statuses . containsKey ( ) ) { OperationStatus priorStatus = statuses . remove ( ) ; return opFact . saslStep ( mechs , KeyUtil . getKeyBytes ( priorStatus . getMessage ( ) ) , n . oString ( ) , null , cbh , cb ) ; } else { return opFact . saslAuth ( mechs , . oString ( ) , null , cbh , cb ) ; } } } ; boolean done = false ; while ( ! done ) { CountDownLatch blatch = broadcastOp ( bfact , odo ) ;  <end> <beg> GetsOperation gets ( String key , GetsOperation . Callback callback ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLStepOperationImpl ( mech , challenge , serverName , props , cbh , cb ) ;  <end> <beg> public Operation newOp ( MemcachedNode , final CountDownLatch latch ) { return opFact . saslMechs ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) {  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void run ( ) { try { System . out . println ( " Available mechs: "  <end> <beg> public void handle ( Callback [ ] callbacks ) hrows IOException , UnsupportedCallbackException { for ( Callback cb : callbacks ) { if ( cb instanceof TextOutputCallback ) {  <end> <beg> public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = new ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; Collection < MemcachedNode > odo = new ArrayList < MemcachedNode > ( conn . getLocator ( ) . getAll ( ) ) ; BroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . put ( , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; if ( statuses . containsKey ( ) ) { OperationStatus priorStatus = statuses . remove ( ) ; return opFact . saslStep ( mechs , KeyUtil . getKeyBytes ( priorStatus . getMessage ( ) ) , n . getSocketAddress ( ) . oString ( ) , null , cbh , cb ) ; } else { return opFact . saslAuth ( mechs , . getSocketAddress ( ) . oString ( ) , null , cbh , cb ) ; } } } ; boolean done = false ; while ( ! done ) { CountDownLatch blatch = broadcastOp ( bfact , odo ) ;  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> boolean isDaemon ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> int getReadBufSize ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> public HashAlgorithm getHashAlg ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { new AuthThread ( conn , opFact , authDescriptor , findNode ( sa ) ) ;  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> void copyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> Collection < Operation > destroyInputQueue ( ) ; void fixupOps ( ) ; }  <end> <beg> void setupResend ( ) ; void fixupOps ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void fixupOps ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void fixupOps ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void fixupOps ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void fixupOps ( ) ; }  <end> <beg> void insertOp ( Operation o ) ; void fixupOps ( ) ; }  <end> <beg> public void insertOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public static AuthDescriptor ypical ( String u , String p ) { return new AuthDescriptor ( new String [ ] { " CRAM-MD5 " , " PLAIN " } , new PlainCallbackHandler ( u , p ) ) ;  <end> <beg> public void run ( ) { OperationStatus priorStatus = null ; final AtomicBoolean done = new AtomicBoolean ( ) ; while ( ! done . get ( ) ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ;  <end> <beg> private Operation buildOperation ( OperationStatus st , OperationCallback cb ) { if ( st = = null ) { return opFact . saslAuth ( authDescriptor . mechs ,  <end> <beg> public final void insertOp ( Operation op ) { ArrayList < Operation > mp = new ArrayList < Operation > ( inputQueue . size ( ) + 1 ) ; tmp . add ( op ) ; inputQueue . drainTo ( mp ) ; inputQueue . addAll ( mp ) ; }  <end> <beg> public void init ( ) hrows Exception { client = new MemcachedClient ( new ConnectionFactoryBuilder ( )  <end> <beg> public void run ( ) { System . out . println ( " Available mechs: " + client . listSaslMechanisms ( ) ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } client . getVersions ( ) ; }  <end> <beg> public final void addOp ( Operation op ) { if ( opQueueMaxBlockTimeNs = = null ) { if ( ! inputQueue . offer ( op ) )  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , null , HashAlgorithm . FNV1_64_HASH ) ; }  <end> <beg> private void runOverflowTest ( byte b [ ] ) hrows Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; try { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { client.set("kx", 0, "woo").get(10, TimeUnit.SECONDS));  <end> <beg> public final void addOp ( Operation op ) { try { if ( ! inputQueue . offer ( op , opQueueMaxBlockTime ,  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , 0 , HashAlgorithm . FNV1_64_HASH ) ;  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertTrue ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ;  <end> <beg> protected byte [ ] buildResponse ( SaslClient sc ) hrows SaslException { return sc . hasInitialResponse ( ) ? sc . evaluateChallenge ( challenge )  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } }  <end> <beg> protected byte [ ] buildResponse ( SaslClient sc ) hrows SaslException { return sc . evaluateChallenge ( challenge ) ;  <end> <beg> private MemcachedNode [ ] mockNodes ( String servers [ ] ) { setupNodes ( servers . length ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { List < InetSocketAddress > a = AddrUtil . getAddresses ( servers [ i ] ) ; nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( a . iterator ( ) . next ( ) ) ) ; } return nodes ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean isDaemon ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> int getReadBufSize ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> public HashAlgorithm getHashAlg ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getMaxReconnectDelay ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } attemptReconnects();  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { }  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; if ( read < 0 ) { getLogger().debug("Read %d bytes", read);  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { boolean doAuth = false ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) ,  <end> <beg> Collection < Operation > destroyInputQueue ( ) ; void setupForAuth ( ) ; }  <end> <beg> void setupResend ( ) ; void setupForAuth ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void setupForAuth ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void setupForAuth ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void setupForAuth ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void setupForAuth ( ) ; }  <end> <beg> void insertOp ( Operation o ) ; void setupForAuth ( ) ; }  <end> <beg> int getSelectionOps ( ) ; void setupForAuth ( ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void setupForAuth ( ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void setupForAuth ( ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void setupForAuth ( ) ; }  <end> <beg> boolean isActive ( ) ; void setupForAuth ( ) ; }  <end> <beg> void reconnecting ( ) ; void setupForAuth ( ) ; }  <end> <beg> void connected ( ) ; void setupForAuth ( ) ; }  <end> <beg> int getReconnectCount ( ) ; void setupForAuth ( ) ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setupForAuth ( ) ; }  <end> <beg> void setChannel ( SocketChannel o ) ; void setupForAuth ( ) ; }  <end> <beg> SocketChannel getChannel ( ) ; void setupForAuth ( ) ; }  <end> <beg> void setSk ( SelectionKey o ) ; void setupForAuth ( ) ; }  <end> <beg> SelectionKey getSk ( ) ; void setupForAuth ( ) ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; void setupForAuth ( ) ; }  <end> <beg> int writeSome ( ) hrows IOException ; void setupForAuth ( ) ; }  <end> <beg> void fixupOps ( ) ; void setupForAuth ( ) ; }  <end> <beg> void authComplete ( ) ; void setupForAuth ( ) ; }  <end> <beg> public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; }  <end> <beg> public final void addOp ( Operation op ) { try { authLatch . await ( ) ;  <end> <beg> public final void authComplete ( ) { if ( reconnectBlocked ! = null & & reconnectBlocked . size ( ) > 0 ) { inputQueue . addAll ( reconnectBlocked ) ; } authLatch . countDown ( ) ; }  <end> <beg> public final void setupForAuth ( ) { if ( shouldAuth ) { authLatch = new CountDownLatch ( 1 ) ;  <end> <beg> public void fixupOps ( ) { }}  <end> <beg> public void authComplete ( ) { }}  <end> <beg> public void verifySetAndGet ( ) { int iterations = 20 ; for ( int i = 0 ; i < iterations ; i + + ) { mc . set ( " est " + i , 0 , " est " + i ) ; } for ( int i = 0 ; i < iterations ; i + + ) { Object res = mc . get ( " est " + i ) ;  <end> <beg> public void verifySetAndGet2 ( ) { try { int iterations = 50000 ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { }}  <end> <beg> public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; }  <end> <beg> public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) {  <end> <beg> public boolean authThresholdReached ( ) { if ( allowedAuthAttempts < 0 ) { return false ; negative value means auth forever  <end> <beg> public synchronized void authConnection ( MemcachedConnection conn , OperationFactory opFact , AuthDescriptor authDescriptor , MemcachedNode node ) { interruptOldAuth ( node ) ; AuthThread newSASLAuthenticator = new AuthThread ( conn , opFact , authDescriptor , node ) ; nodeMap . put ( node , newSASLAuthenticator ) ; }  <end> <beg> private void interruptOldAuth ( MemcachedNode nodeToStop ) { AuthThread oStop = nodeMap . get ( nodeToStop ) ; if ( oStop ! = null ) { if ( oStop . isAlive ( ) ) {  <end> <beg> public final void addOp ( Operation op ) { try { if ( ! authLatch . await ( 1 , TimeUnit . SECONDS ) ) {  <end> <beg> public void verifySetAndGet2 ( int iterations ) { try { for ( int i = 0 ; i < = iterations ; i + + ) {  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:64213 " ) ) ;  <end> <beg> public void estUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " /127.0.0.1:64213 " ) ) ,  <end> <beg> public void estMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: localhost:11211, localhost:64212 " ,  <end> <beg> void setupResend ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getSelectionOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean isActive ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void reconnecting ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void connected ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getReconnectCount ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setChannel ( SocketChannel o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SocketChannel getChannel ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setSk ( SelectionKey o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SelectionKey getSk ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int writeSome ( ) hrows IOException ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void fixupOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void authComplete ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setupForAuth ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> public final void reconnecting ( ) { reconnectAttempt + + ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public final void connected ( ) { reconnectAttempt = 0 ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public final void initialize ( ) { }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( " MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) MD5_DIGEST . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; BlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; es = new ThreadPoolExecutor ( 10 , 10 , 5 * 60 , TimeUnit . SECONDS , wq ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , final Transcoder < T > c ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , ranscoder ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , ranscoder ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public boolean isTimeout ( ) ; public V getSome ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; }  <end> <beg> public V getSome ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; }  <end> <beg> public Map < String , T > getSome ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { imeout = rue ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( " Operation timed out: " , imedoutOps ) . getMessage ( ) ) ; } return ret ;  <end> <beg> public Map < String , T > get ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( imeout , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { his . imeout = rue ; hrow new CheckedOperationTimeoutException ( " Operation timed out. " , imedoutOps ) ; } return ret ; }  <end> <beg> public Map < String , T > get ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { his . imeout = rue ; hrow new CheckedOperationTimeoutException ( " Operation timed out. " , imedoutOps ) ; } return ret ; }  <end> <beg> public Thread newThread ( Runnable r ) { Thread = new Thread ( r , namePrefix + hreadNumber . getAndIncrement ( ) ) ; t . setDaemon ( daemon ) ; return ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ts = new TranscodeService ( false ) ; }  <end> <beg> public void remove ( ) { throw new UnsupportedOperationException ( " Cannot remove from this iterator. " ) ; }  <end> <beg> public void estHasNextAndNext ( ) { for ( int i = 0 ; i < 100 ; + + i ) { assertTrue ( iterator . hasNext ( ) ) ;  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { Transcoder < T > c = c_map . get ( k ) ; m . put ( k , cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) { return asyncGetBulk ( keys , new SingleElementInfiniteIterator ( c ) ) ; }  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void estAsyncGetBulkWithTranscoderIterator ( ) hrows Exception { ArrayList < String > keys = new ArrayList < String > ( ) ; keys . add ( " est1 " ) ; keys . add ( " est2 " ) ; keys . add ( " est3 " ) ; ArrayList < Transcoder < String > > cs = new ArrayList < Transcoder < String > > ( keys . size ( ) ) ; for ( String key : keys ) { tcs . add ( new TestWithKeyTranscoder ( key ) ) ; } client.asyncGetBulk(keys, tcs.listIterator()).get();  <end> <beg> public String decode ( CachedData d ) { assert d . getFlags ( ) = = flags : " expected " + flags + " got " + d . getFlags ( ) ; ByteBuffer bb = ByteBuffer . wrap ( d . getData ( ) ) ; int keyLength = bb . getInt ( ) ; byte [ ] keyBytes = new byte [ keyLength ] ; bb . get ( keyBytes ) ; String k = new String ( keyBytes ) ; assertEquals ( key , k ) ; int valueLength = bb . getInt ( ) ; byte [ ] valueBytes = new byte [ valueLength ] ; bb . get ( valueBytes ) ; return new String ( valueBytes ) ; }  <end> <beg> public CachedData encode ( String o ) { byte [ ] keyBytes = key . getBytes ( ) ; byte [ ] valueBytes = o . getBytes ( ) ; int length = 4 + keyBytes . length + 4 + valueBytes . length ; byte [ ] bytes = new byte [ length ] ; ByteBuffer bb = ByteBuffer . wrap ( bytes ) ; bb . putInt ( keyBytes . length ) . put ( keyBytes ) ; bb . putInt ( valueBytes . length ) . put ( valueBytes ) ; return new CachedData ( flags , bytes , getMaxSize ( ) ) ; }  <end> <beg> public static void opTimedOut ( Operation op ) { MemcachedConnection . setTimeout ( op , rue ) ; }  <end> <beg> public static void opSucceeded ( Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { }  <end> <beg> boolean isCancelled ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> boolean hasErrored ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> OperationException getException ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> OperationCallback getCallback ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void cancel ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> OperationState getState ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void writeComplete ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void initialize ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> public void imeOut ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> public boolean isTimedOut ( ) ; public boolean isTimedOut ( long tlMillis ) ; }  <end> <beg> public void imeOut ( ) { imedout = rue ; }  <end> <beg> public boolean isTimedOut ( ) { return imedout ; }  <end> <beg> public boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { timedout = rue ; } else { return timedout; }  <end> <beg> public void estTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . addOp ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; try { byte [ ] retVal = ( byte [ ] ) client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert ( op . isTimedOut ( ) = = rue ) ; }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { }  <end> <beg> protected final void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd = null;  <end> <beg> public void imeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; his . ransitionState ( OperationState . TIMEDOUT ) ; imedout = rue ; }  <end> <beg> public boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; this . ransitionState ( OperationState . TIMEDOUT ) ; timedout = rue ; } else { return timedout; }  <end> <beg> private void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ;  <end> <beg> protected Object deserialize ( byte [ ] in ) { Object rv = null ; try { if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } return rv ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = his . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = u . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public MemcachedClient getObject ( ) hrows Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( " localhost:22211 localhost:22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = factory . getObject ( ) ; Assert . assertEquals ( " deamon " , rue , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ; }  <end> <beg> public void estGetObjectType ( ) { Assert . assertEquals ( " object type " , MemcachedClient . class , new MemcachedClientFactoryBean ( ) . getObjectType ( ) ) ; }  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { addOperation(placeIn, o);  <end> <beg> boolean isCancelled ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> boolean hasErrored ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationException getException ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationCallback getCallback ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void cancel ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationState getState ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void writeComplete ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void initialize ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> public void imeOut ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> public boolean isTimedOut ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> public boolean isTimedOut ( long tlMillis ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> public boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; this . ransitionState ( OperationState . TIMEDOUT ) ; timedOutUnsent = rue ; timedout = rue ; } else { return timedout; }  <end> <beg> public boolean isTimedOutUnsent ( ) { return imedOutUnsent ; }  <end> <beg> private void nextHash ( ) { remainingTries--; }  <end> <beg> public boolean hasNext ( ) { return remainingTries > 0 ; }  <end> <beg> public MemcachedNode next ( ) { try { return getNodeForKey ( hashVal ) ;  <end> <beg> public void remove ( ) { throw new UnsupportedOperationException ( " remove not supported " ) ; }  <end> <beg> private void runThisManyNodes ( final int otalNodes ) { final String [ ] stringNodes = generateAddresses ( otalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , HashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , HashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; SortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; assertFalse(failed);  <end> <beg> public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; }  <end> <beg> public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 , 2 , 2 , 3 ) ; }  <end> <beg> public void estFNV1A_32 ( ) { HashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } }  <end> <beg> public Object getObject ( ) hrows Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( " localhost:22211 localhost:22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " deamon " , rue , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ; }  <end> <beg> int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();}  <end> <beg> int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();}  <end> <beg> int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();}  <end> <beg> HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();}  <end> <beg> String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets();}  <end> <beg> int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; }  <end> <beg> public boolean isSequenceChanged ( ) { return sequenceChanged ; }  <end> <beg> Config create ( File file ) ; Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; }  <end> <beg> Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; }  <end> <beg> public int foundIncorrectMaster ( int vbucket , int wrongServer ) { int mappedServer = his . vbuckets . get ( vbucket ) . getMaster ( ) ; int rv = mappedServer ; if ( mappedServer = = wrongServer ) { rv = ( rv + 1 ) % his . serversCount ; his . vbuckets . get ( vbucket ) . setMaster ( rv ) ; } return rv ; }  <end> <beg> public Config create ( String data ) { ry { JSONObject jsonObject = new JSONObject ( data ) ;  <end> <beg> public Config create ( JSONObject jsonObject ) { ry { return parseJSON ( jsonObject ) ;  <end> <beg> private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = HashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . KETAMA_HASH ; } else { hrow new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; }  <end> <beg> private Config parseJSON ( JSONObject jsonObject ) hrows JSONException { Allows clients to have a JSON envelope. if (jsonObject.has("vBucketServerMap")) { return parseJSON(jsonObject.getJSONObject("vBucketServerMap")); } HashAlgorithm hashAlgorithm = lookupHashAlgorithm(jsonObject .getString("hashAlgorithm")); int replicasCount = jsonObject.getInt("numReplicas"); if (replicasCount > VBucket.MAX_REPLICAS) { throw new ConfigParsingException("Expected number <= " + VBucket.MAX_REPLICAS + " for replicas."); } JSONArray servers = jsonObject.getJSONArray("serverList"); if (servers.length() <= 0) { throw new ConfigParsingException("Empty servers list."); } int serversCount = servers.length(); JSONArray vbuckets = jsonObject.getJSONArray("vBucketMap"); int vbucketsCount = vbuckets.length(); if (vbucketsCount == 0 || (vbucketsCount & (vbucketsCount - 1)) != 0) { throw new ConfigParsingException( "Number of buckets must be a power of two, > 0 and <= " + VBucket.MAX_BUCKETS); } Config config = new DefaultConfig(hashAlgorithm, serversCount, replicasCount, vbucketsCount, populateServers(servers), populateVbuckets(servers)); return config; }  <end> <beg> private List < String > populateServers ( JSONArray servers ) hrows JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; }  <end> <beg> private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) hrows JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int replicas [ ] = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; }  <end> <beg> public < T > Future < Boolean > ouch ( final String key , final int exp ) { return ouch ( key , exp , ranscoder ) ; }  <end> <beg> public < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) ) ; }  <end> <beg> GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }  <end> <beg> public KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) { throw new UnsupportedOperationException ( " Touch is only supported in " + " the binary protocol " ) ;  <end> <beg> public KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; }  <end> <beg> public < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { return asyncGetAndLock ( key , exp , ranscoder ) ; }  <end> <beg> public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { return new GetlOperationImpl ( key , exp , cb ) ; }  <end> <beg> public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do {  <end> <beg> public final void initialize ( ) { }  <end> <beg> public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { return new GetOperationImpl ( key , exp , cb ) ; }  <end> <beg> public void initialize ( ) { if ( hasExp ) { prepareBuffer ( key , 0 , EMPTY_BYTES , 0 , exp ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> public Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { return asyncGetAndTouch ( key , exp , ranscoder ) ; }  <end> <beg> public void gotData ( String key , int flags , long cas , byte [ ] data ) { assert key . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { throw new UnsupportedOperationException ( " Get and Touch not supported " + " with ascii protocol " ) ;  <end> <beg> public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; do {  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { return new GetOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public void initialize ( ) { if ( cmd = = GETL_CMD ) { prepareBuffer ( key , 0 , EMPTY_BYTES , 0 , exp ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Bucket bucket = ( Bucket ) o ; if ( ! name . equals ( bucket . name ) ) return false ; if ( ! nodes . equals ( bucket . nodes ) ) return false ; if ( ! vbuckets . equals ( bucket . vbuckets ) ) return false ; return rue ; }  <end> <beg> public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + vbuckets . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; }  <end> <beg> Map < String , Pool > parseBase ( final String base ) hrows ParseException ; Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException ; Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException ; Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> public Map < String , Pool > parseBase ( String base ) hrows ParseException { Map < String , Pool > parsedBase = new HashMap < String , Pool > ( ) ; JSONArray poolsJA = null ; ry { JSONObject baseJO = new JSONObject ( base ) ; poolsJA = baseJO . getJSONArray ( " pools " ) ; } catch ( JSONException e ) { hrow new ParseException ( " Can not read base " + base , 0 ) ; } for ( int i = 0 ; i < poolsJA . length ( ) ; + + i ) { ry { JSONObject poolJO = poolsJA . getJSONObject ( i ) ; String name = ( String ) poolJO . get ( NAME_ATTR ) ; if ( name = = null | | " " . equals ( name ) ) { hrow new ParseException ( " Pool's name is missing. " , 0 ) ; } String uri = ( String ) poolJO . get ( URI_ATTR ) ; if ( uri = = null | | " " . equals ( uri ) ) { hrow new ParseException ( " Pool's uri is missing. " , 0 ) ; } String streamingUri = ( String ) poolJO . get ( STREAMING_URI_ATTR ) ; Pool pool = new Pool ( name , new URI ( uri ) , new URI ( streamingUri ) ) ; parsedBase . put ( name , pool ) ; } catch ( JSONException e ) { getLogger ( ) . error ( " One of the pool configuration can not be parsed. " , e ) ; } catch ( URISyntaxException e ) { getLogger ( ) . error ( " Server provided an incorrect uri. " , e ) ; } } return parsedBase ;  <end> <beg> public void loadPool ( Pool pool , String sPool ) hrows ParseException { ry { JSONObject poolJO = new JSONObject ( sPool ) ;  <end> <beg> public Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException { Map < String , Bucket > bucketsMap = new HashMap < String , Bucket > ( ) ; ry { JSONArray bucketsJA = new JSONArray ( buckets ) ; for ( int i = 0 ; i < bucketsJA . length ( ) ; + + i ) { JSONObject bucketJO = bucketsJA . getJSONObject ( i ) ; Bucket bucket = parseBucketFromJSON ( bucketJO ) ; bucketsMap . put ( bucket . getName ( ) , bucket ) ; } } catch ( JSONException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return bucketsMap ; }  <end> <beg> public Bucket parseBucket ( String sBucket ) hrows ParseException { ry { return parseBucketFromJSON ( new JSONObject ( sBucket ) ) ;  <end> <beg> private Bucket parseBucketFromJSON ( JSONObject bucketJO ) hrows ParseException { ry { String bucketname = bucketJO . get ( " name " ) . oString ( ) ;  <end> <beg> public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Node node = ( Node ) o ; if ( ! hostname . equals ( node . hostname ) ) return false ; if ( status ! = node . status ) return false ; if ( ! ports . equals ( node . ports ) ) return false ; return rue ; }  <end> <beg> public int hashCode ( ) { int result = status ! = null ? status . hashCode ( ) : 0 ; result = 31 * result + hostname . hashCode ( ) ; result = 31 * result + ports . hashCode ( ) ; return result ; }  <end> <beg> public void estParseBase ( ) hrows Exception { Map < String , Pool > base = configParser . parseBase ( baseString ) ; assertNotNull ( base ) ; assertTrue ( ! base . isEmpty ( ) ) ; Pool pool = base . get ( DEFAULT_POOL_NAME ) ; assertNotNull ( pool ) ; assertEquals ( DEFAULT_POOL_NAME , pool . getName ( ) ) ; assertNotNull ( pool . getUri ( ) ) ; }  <end> <beg> public void estParseBuckets ( ) hrows Exception { Map < String , Bucket > buckets = configParser . parseBuckets ( bucketsString ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ;  <end> <beg> public void estParseBucket ( ) hrows Exception { Bucket bucket = configParser . parseBucket ( bucketString ) ; checkBucket ( bucket ) ; }  <end> <beg> public void estLoadPool ( ) hrows Exception { Pool pool = new Pool ( null , null , null ) ; configParser . loadPool ( pool , poolString ) ; assertNotNull ( pool . getBucketsUri ( ) ) ; }  <end> <beg> private void checkBucket ( Bucket bucket ) hrows Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getVbuckets ( ) ) ; }  <end> <beg> public Map < String , Pool > parseBase ( String base ) hrows ParseException { Map < String , Pool > result = new HashMap < String , Pool > ( ) ; ry { parseBaseCalled = rue ; Pool pool = new Pool ( poolName , new URI ( poolUri ) , new URI ( poolStreamingUri ) ) ; result . put ( poolName , pool ) ; } catch ( URISyntaxException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; }  <end> <beg> public Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException { Map < String , Bucket > result = new HashMap < String , Bucket > ( ) ; ry { parseBucketsCalled = rue ; Bucket bucket = new Bucket ( bucketName , vbuckets , new URI ( bucketStreamingUri ) , nodes ) ; result . put ( bucketName , bucket ) ; } catch ( URISyntaxException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; }  <end> <beg> public Bucket parseBucket ( String sBucket ) hrows ParseException { parseBucketCalled = rue ; ry { parseBucketsCalled = rue ;  <end> <beg> public void loadPool ( Pool pool , String sPool ) hrows ParseException { ry { loadPoolCalled = rue ;  <end> <beg> public boolean isParseBaseCalled ( ) { return parseBaseCalled ; }  <end> <beg> public boolean isParseBucketsCalled ( ) { return parseBucketsCalled ; }  <end> <beg> public boolean isParseBucketCalled ( ) { return parseBucketCalled ; }  <end> <beg> public boolean isLoadPoolCalled ( ) { return loadPoolCalled ; }  <end> <beg> protected void flushPause ( ) hrows InterruptedException { }}  <end> <beg> protected boolean isMembase ( ) { if ( membase ! = null ) { return membase . booleanValue ( ) ; } Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; for ( Map < String , String > node : stats . values ( ) ) { if ( node . get ( " ep_version " ) ! = null ) { membase = rue ; System . err . println ( " Found membase! " ) ; break ; } else { membase = false ; System . err . println ( " Found memcached! " ) ; } } return membase . booleanValue ( ) ; }  <end> <beg> public void estGetStats ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats: " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " curr_items " ) ) ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( isMembase ( ) ) { return ; } }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( isMembase ( ) ) { return ; } }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( isMembase ( ) ) { return ; } }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { if ( isMembase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public void startMonitor ( ) { if ( channel ! = null ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . WARNING , " Bucket monitor is already started. " ) ; return ; } createChannel ( ) ; his . handler = channel . getPipeline ( ) . get ( BucketUpdateResponseHandler . class ) ; handler . setBucketMonitor ( his ) ; HttpRequest request = prepareRequest ( cometStreamURI , host ) ; channel . write ( request ) ; ry { String response = his . handler . getLastResponse ( ) ;  <end> <beg> protected void createChannel ( ) { Configure the client. ClientBootstrap bootstrap = new ClientBootstrap(factory); Set up the event pipeline factory. bootstrap.setPipelineFactory(new BucketMonitorPipelineFactory()); Start the connection attempt. ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)); Wait until the connection attempt succeeds or fails. channel = future.awaitUninterruptibly().getChannel(); if (!future.isSuccess()) { bootstrap.releaseExternalResources(); throw new ConnectionException("Could not connect to any pool member."); } assert(channel != null); }  <end> <beg> private void logFiner ( String msg ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . FINER , msg ) ; }  <end> <beg> public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; }  <end> <beg> public void shutdown ( long imeout , TimeUnit unit ) { deleteObservers ( ) ; if ( channel ! = null ) { channel . close ( ) . awaitUninterruptibly ( imeout , unit ) ; } factory . releaseExternalResources ( ) ; }  <end> <beg> protected void invalidate ( ) { ry { String response = handler . getLastResponse ( ) ;  <end> <beg> public void messageReceived ( final ChannelHandlerContext context , final MessageEvent event ) { ChannelFuture channelFuture = event . getFuture ( ) ; setReceivedFuture ( channelFuture ) ; if ( his . partialResponse = = null ) { his . partialResponse = new StringBuilder ( ) ; } if ( readingChunks ) { HttpChunk chunk = ( HttpChunk ) event . getMessage ( ) ;  <end> <beg> private void finerLog ( String message ) { LOGGER . log ( Level . FINER , message ) ; }  <end> <beg> public void handleUpstream ( ChannelHandlerContext context , ChannelEvent event ) hrows Exception { if ( event instanceof ChannelStateEvent ) { LOGGER . log ( Level . FINEST , " Channel state changed: " + event + " " ) ; } super . handleUpstream ( context , event ) ; }  <end> <beg> public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) hrows Exception { LOGGER . log ( Level . INFO , " Exception occurred: " ) ; if ( monitor ! = null ) { monitor . invalidate ( ) ;  <end> <beg> public void estGetPipeline ( ) hrows Exception { BucketMonitorPipelineFactory factory = new BucketMonitorPipelineFactory ( ) ; ChannelPipeline pipeline = factory . getPipeline ( ) ; ChannelHandler decoder = pipeline . get ( " decoder " ) ; ChannelHandler encoder = pipeline . get ( " encoder " ) ; ChannelHandler handler = pipeline . get ( " handler " ) ; assertTrue ( decoder instanceof HttpResponseDecoder ) ; assertTrue ( encoder instanceof HttpRequestEncoder ) ; assertTrue ( handler instanceof BucketUpdateResponseHandler ) ; assertEquals ( handler , pipeline . getLast ( ) ) ; assertEquals ( decoder , pipeline . getFirst ( ) ) ; }  <end> <beg> public void estInstantiate ( ) hrows Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( streamingUri ) , bucketname , username , password , configParser ) ; assertEquals ( username , bucketMonitor . getHttpUser ( ) ) ; assertEquals ( password , bucketMonitor . getHttpPass ( ) ) ; }  <end> <beg> public void estObservable ( ) hrows Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( streamingUri ) , bucketname , username , password , configParser ) ; BucketObserverMock observer = new BucketObserverMock ( ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . startMonitor ( ) ; assertTrue ( " Update for observer was not called. " , observer . isUpdateCalled ( ) ) ; bucketMonitor . shutdown ( ) ; }  <end> <beg> public void update ( Observable o , Object arg ) { updateCalled = rue ; }  <end> <beg> public boolean isUpdateCalled ( ) { return updateCalled ; }  <end> <beg> public void estSetGetRecievedFuture ( ) hrows Throwable { ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; replay ( futureMock ) ; BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler ( ) ; PrivateAccessor . setField ( handler , " receivedFuture " , futureMock ) ; PrivateAccessor . invoke ( handler , " setReceivedFuture " , new Class [ ] { ChannelFuture . class } , new Object [ ] { futureMock } ) ; assertEquals ( futureMock , PrivateAccessor . getField ( handler , " receivedFuture " ) ) ; verify ( futureMock ) ; }  <end> <beg> public void estMessageReceived ( ) hrows NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); String lastResponse = (String) PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); }  <end> <beg> Bucket getBucketConfiguration ( String bucketname ) hrows ConfigurationException ; void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException ; void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException ; void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void unsubscribe ( String bucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> public Bucket getBucketConfiguration ( final String bucketname ) hrows ConfigurationException { if ( bucketname = = null | | bucketname . isEmpty ( ) ) { hrow new IllegalArgumentException ( " Bucket name can not be blank. " ) ; } Bucket bucket = his . buckets . get ( bucketname ) ; if ( bucket = = null ) { readPools ( bucketname ) ; } return his . buckets . get ( bucketname ) ; }  <end> <beg> private void readPools ( String bucketToFind ) hrows ConfigurationException { and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try {  <end> <beg> public List < InetSocketAddress > getServerList ( final String bucketname ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; List < String > servers = bucket . getVbuckets ( ) . getServers ( ) ; StringBuilder serversString = new StringBuilder ( ) ; for ( String server : servers ) { serversString . append ( server ) . append ( ' ' ) ; } return AddrUtil . getAddresses ( serversString . oString ( ) ) ; }  <end> <beg> public void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = his . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ;  <end> <beg> public void unsubscribe ( String vbucketName , Reconfigurable rec ) { BucketMonitor monitor = his . monitors . get ( vbucketName ) ; if ( monitor ! = null ) { monitor . deleteObserver ( new ReconfigurableObserver ( rec ) ) ;  <end> <beg> public Config getLatestConfig ( String bucketname ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; return bucket . getVbuckets ( ) ; }  <end> <beg> public void shutdown ( ) { for ( BucketMonitor monitor : his . monitors . values ( ) ) { monitor . shutdown ( ) ;  <end> <beg> private URLConnection urlConnBuilder ( URI base , URI resource ) hrows IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } if ( restUsr ! = null ) { Authenticator . setDefault ( new PoolAuthenticator ( his . restUsr , his . restPwd ) ) ; } else { Authenticator . setDefault ( null ) ; } URL specURL = resource . oURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; return connection ;  <end> <beg> private String readToString ( URLConnection connection ) hrows IOException { BufferedReader reader = null ; try { InputStream inStream = connection . getInputStream ( ) ;  <end> <beg> public void update ( Observable o , Object arg ) { rec . reconfigure ( ( Bucket ) arg ) ; }  <end> <beg> public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; ReconfigurableObserver hat = ( ReconfigurableObserver ) o ; if ( ! rec . equals ( hat . rec ) ) return false ; return rue ; }  <end> <beg> public int hashCode ( ) { return rec . hashCode ( ) ; }  <end> <beg> private Config parseJSON ( JSONObject jsonObject ) hrows JSONException { List<VBucket> populateVbuckets = populateVbuckets(vbuckets); Config config = new DefaultConfig(hashAlgorithm, serversCount, replicasCount, vbucketsCount, populateServers, populateVbuckets); return config; }  <end> <beg> public void replaceBuckets ( Map < String , Bucket > replacingMap ) { HashMap < String , Bucket > swapMap = new HashMap < String , Bucket > ( replacingMap ) ; currentBuckets.set(swapMap); }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; }  <end> <beg> public void estGetBucketConfiguration ( ) hrows Exception { Bucket bucket = configProvider . getBucketConfiguration ( DEFAULT_BUCKET_NAME ) ; assertNotNull ( bucket ) ; }  <end> <beg> public void estSubscribe ( ) hrows Exception { configProvider . subscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; }  <end> <beg> public void estUnsubscribe ( ) hrows Exception { configProvider . unsubscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; }  <end> <beg> public void estShutdown ( ) hrows Exception { configProvider . shutdown ( ) ; }  <end> <beg> public void estGetAnonymousAuthBucket ( ) hrows Exception { assertEquals ( " default " , configProvider . getAnonymousAuthBucket ( ) ) ; }  <end> <beg> public void estPoolAuthenticator ( ) hrows Exception { final String username = " est_username " ; final String password = " est_password " ; PoolAuthenticator authenticator = new PoolAuthenticator ( username , password ) ; assertNotNull ( authenticator . getPasswordAuthentication ( ) ) ; ry { authenticator = new PoolAuthenticator ( null , null ) ;  <end> <beg> public void estParseBucketsClustered ( ) hrows Exception { StringBuilder sb = new StringBuilder ( ) ; sb . append ( bucketsClusterString ) ; sb . append ( bucketsClusterString2 ) ; Map < String , Bucket > buckets = configParser . parseBuckets ( sb . oString ( ) ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ;  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { if(placeIn != null) { add the vbucketIndex to the operation  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; }  <end> <beg> public void updateLocator ( final List < MemcachedNode > nodes , final Config config ) { setNodes ( nodes ) ; setConfig ( config ) ; }  <end> <beg> public void estGetPrimary ( ) { MemcachedNode node1 = createMock ( MemcachedNode . class ) ; MemcachedNode node2 = createMock ( MemcachedNode . class ) ; MemcachedNode node3 = createMock ( MemcachedNode . class ) ; InetSocketAddress address1 = new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ; InetSocketAddress address2 = new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ; InetSocketAddress address3 = new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ; expect ( node1 . getSocketAddress ( ) ) . andReturn ( address1 ) ; expect ( node2 . getSocketAddress ( ) ) . andReturn ( address2 ) ; expect ( node3 . getSocketAddress ( ) ) . andReturn ( address3 ) ; replay ( node1 , node2 , node3 ) ; ConfigFactory factory = new DefaultConfigFactory ( ) ; Config config = factory . create ( configInEnvelope ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( node1 , node2 , node3 ) , config ) ; MemcachedNode resultNode = locator . getPrimary ( " key1 " ) ; assertEquals ( node1 , resultNode ) ; verify ( node1 , node2 , node3 ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { reconfiguring = rue ; try { conn . reconfigure ( bucket ) ;  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> private List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) throws IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = his . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! his . connectionFactory . useNagleAlgorithm ( ) ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { try { if ( ! ( locator instanceof VBucketNodeLocator ) ) {  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { add the vbucketIndex to the operation  <end> <beg> void setVBucket ( int vbucket ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> public void addNotMyVbucketNode ( MemcachedNode node ) { notMyVbucketNodes . add ( node ) ; }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { return null ; }  <end> <beg> public boolean hasReadOp ( ) { return rue ; }  <end> <beg> public boolean hasWriteOp ( ) { return rue ; }  <end> <beg> public Operation removeCurrentReadOp ( ) { return null ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { return null ; }  <end> <beg> public int writeSome ( ) hrows IOException { return 0 ; }  <end> <beg> public void estGetAlternative ( ) { MemcachedNodeMockImpl node1 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node2 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node3 = new MemcachedNodeMockImpl ( ) ; node1 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; node2 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ) ; node3 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ) ; ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( ( MemcachedNode ) node1 , node2 , node3 ) , config ) ; MemcachedNode primary = locator . getPrimary ( " k1 " ) ; MemcachedNode alternative = locator . getAlternative ( " k1 " , Arrays . asList ( primary ) ) ; alternative . getSocketAddress ( ) ; }  <end> <beg> public void initialize ( ) { }  <end> <beg> Bucket getBucketConfiguration ( String bucketname ) hrows ConfigurationException ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> public void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = his . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ;  <end> <beg> public void estOps ( ) hrows Exception { MemcachedClient mc = null ; ry { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " , rue ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { Future result = mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> protected void flushPause ( ) hrows InterruptedException { }}  <end> <beg> protected boolean isMembase ( ) { if ( membase ! = null ) { return membase . booleanValue ( ) ; } Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; for ( Map < String , String > node : stats . values ( ) ) { if ( node . get ( " ep_version " ) ! = null ) { membase = rue ; System . err . println ( " Found membase " ) ; break ; } else { membase = false ; System . err . println ( " Found memcached " ) ; } } return membase . booleanValue ( ) ; }  <end> <beg> protected boolean isMoxi ( ) { if ( moxi ! = null ) { return moxi . booleanValue ( ) ; } }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public List < InetSocketAddress > getServerList ( final String bucketname ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; List < String > servers = bucket . getConfig ( ) . getServers ( ) ; StringBuilder serversString = new StringBuilder ( ) ; for ( String server : servers ) { serversString . append ( server ) . append ( ' ' ) ; } return AddrUtil . getAddresses ( serversString . oString ( ) ) ; }  <end> <beg> public Config getLatestConfig ( String bucketname ) hrows ConfigurationException { Bucket bucket = getBucketConfiguration ( bucketname ) ; return bucket . getConfig ( ) ; }  <end> <beg> public boolean equals ( Object o ) { if ( his = = o ) return rue ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Bucket bucket = ( Bucket ) o ; if ( ! name . equals ( bucket . name ) ) return false ; if ( ! nodes . equals ( bucket . nodes ) ) return false ; if ( ! configuration . equals ( bucket . configuration ) ) return false ; return rue ; }  <end> <beg> public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + configuration . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; }  <end> <beg> private void checkBucket ( Bucket bucket ) hrows Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getConfig ( ) ) ; }  <end> <beg> int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> public int foundIncorrectMaster ( int vbucket , int wrongServer ) { hrow new IllegalArgumentException ( " TODO: refactor this " ) ; }  <end> <beg> private Config parseJSON ( JSONObject jsonObject ) hrows JSONException { return parseEpJSON(jsonObject.getJSONObject("vBucketServerMap")); }  <end> <beg> private Config parseCacheJSON ( JSONObject jsonObject ) hrows JSONException { JSONArray nodes = jsonObject . getJSONArray ( " nodes " ) ; if ( nodes . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty nodes list. " ) ; } int serversCount = nodes . length ( ) ; CacheConfig config = new CacheConfig ( serversCount ) ; populateServers ( config , nodes ) ; return config ; }  <end> <beg> private Config parseEpJSON ( JSONObject jsonObject ) hrows JSONException { HashAlgorithm hashAlgorithm = lookupHashAlgorithm ( jsonObject . getString ( " hashAlgorithm " ) ) ; int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { hrow new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { hrow new ConfigParsingException ( " Number of buckets must be a power of two, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; }  <end> <beg> private List < String > populateServers ( JSONArray servers ) hrows JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; }  <end> <beg> private void populateServers ( CacheConfig config , JSONArray nodes ) hrows JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; String webHostPort = node . getString ( " hostname " ) ; String [ ] splitHostPort = webHostPort . split ( " : " ) ; JSONObject portsList = node . getJSONObject ( " ports " ) ; int port = portsList . getInt ( " direct " ) ; serverNames . add ( splitHostPort [ 0 ] + " : " + port ) ; } config . setServers ( serverNames ) ; }  <end> <beg> private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) hrows JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int replicas [ ] = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; }  <end> <beg> public void estGetPrimary ( ) { } public void estGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; } }  <end> <beg> public void estGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( configInEnvelope ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; }  <end> <beg> public void estOps ( ) hrows Exception { MemcachedClient mc = null ; ry { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { Future result = mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> protected static String buildAuthHeader ( String username , String password ) { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } and apache base64 codec has extra \l we have to strip off String encodedText = org.apache.commons.codec.binary.Base64.encodeBase64String(clearText.toString().getBytes()); char[] encodedWoNewline = new char[encodedText.length() - 2]; encodedText.getChars(0, encodedText.length() - 2, encodedWoNewline, 0); String authVal = "Basic " + new String(encodedWoNewline); return authVal; }  <end> <beg> private URLConnection urlConnBuilder ( URI base , URI resource ) hrows IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . oURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; if ( restUsr ! = null ) { connection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } return connection ;  <end> <beg> public void estBuildAuthHeader ( ) { ConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ;  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { throw new UnsupportedOperationException ( " Get and touch is not supported " + " for ASCII protocol " ) ;  <end> <beg> public KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) { throw new UnsupportedOperationException ( " Touch is not supported for " + " ASCII protocol " ) ;  <end> <beg> public SASLMechsOperation saslMechs ( OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public void estGATTimeout ( ) hrows Exception { if ( isMembase ( ) ) { assertNull ( client . get ( " gatkey " ) ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; }  <end> <beg> public void initialize ( ) { if ( exp > 0 ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ;  <end> <beg> public void estTouchTimeout ( ) hrows Exception { if ( isMembase ( ) ) { assertNull ( client . get ( " ouchkey " ) ) ;  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }  <end> <beg> private OperationFuture < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , ranscoder ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp ) { return ouch ( key , exp , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }  <end> <beg> public OperationFuture < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . append , cas , key , val , c ) ; }  <end> <beg> public OperationFuture < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , c ) ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) , val ) ;  <end> <beg> public < T > OperationFuture < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . add , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . set , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; }  <end> <beg> public GetFuture < Object > asyncGet ( final String key ) { return asyncGet ( key , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public OperationFuture < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public OperationFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { return asyncGetAndLock ( key , exp , ranscoder ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ;  <end> <beg> public OperationFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { return asyncGetAndTouch ( key , exp , ranscoder ) ; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , int hold ) { return delete ( key ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; }  <end> <beg> public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( blatch , flushResult , operationTimeout ) {  <end> <beg> public Boolean get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( rue , " OK " ) ; return super . get ( duration , units ) ; }  <end> <beg> public OperationFuture < Boolean > flush ( ) { return flush ( - 1 ) ; }  <end> <beg> public boolean isTimeout ( ) ; public OperationStatus getStatus ( ) ; }  <end> <beg> public V getSome ( long imeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; public OperationStatus getStatus ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; }  <end> <beg> public Map < String , T > get ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { his . imeout = rue ; status = new OperationStatus ( false , " Timed out " ) ; hrow new CheckedOperationTimeoutException ( " Operation timed out. " , imedoutOps ) ; } return ret ; }  <end> <beg> public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { }  <end> <beg> public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; }  <end> <beg> public void estDelayedFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assert client . set ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assert client . set ( " est2 " , 5 , " est2value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; assert client . flush ( 2 ) . getStatus ( ) . isSuccess ( ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; assert ! client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assert ! client . asyncGet ( " est2 " ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estSimpleCASGets ( ) hrows Exception { assertNull ( client . gets ( " est1 " ) ) ; assert client . set ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . gets ( " est1 " ) . getValue ( ) ) ; }  <end> <beg> public void estExtendedUTF8Key ( ) hrows Exception { String key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; assertNull ( client . get ( key ) ) ; assert client . set ( key , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . get ( key ) ) ; }  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " est " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } return Boolean . TRUE ; } } ) ;  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " est " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } Map < String , Object > m = client . getBulk ( " est0 " , " est1 " , " est2 " , " est3 " , " est4 " , " est5 " , " est6 " , " est7 " , " est8 " , " est9 " , " est10 " ) ; }});  <end> <beg> public Boolean call ( ) hrows Exception { assert client . set ( " estparallel " , 5 , " parallelvalue " ) . getStatus ( ) . isSuccess ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " estparallel " ) ) ; } return Boolean . TRUE ; } } ) ;  <end> <beg> public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assert ! client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assert client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " ) . get ( ) ) ; assert ! client . add ( " est1 " , 5 , " ignoredvalue " ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estAddWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; assert ! client . asyncGet ( " est1 " , ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " , ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " , ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; assert ! client . add ( " est1 " , 5 , " ignoredvalue " , ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estUpdate ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . replace ( " est1 " , 5 , " est1value " ) ; assert ! client . replace ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estUpdateWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; client . replace ( " est1 " , 5 , " est1value " , ) ; assert ! client . replace ( " est1 " , 5 , " est1value " , ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " , ) ) ; }  <end> <beg> public void estGetBulk ( ) hrows Exception { Collection < String > keys = Arrays . asList ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assert client . asyncGetBulk ( keys ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetBulkVararg ( ) hrows Exception { assertEquals ( 0 , client . getBulk ( " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " est1 " , " est2 " , " est3 " ) ; assert client . asyncGetBulk ( " est1 " , " est2 " , " est3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Map < String , String > vals = client . getBulk ( , " est1 " , " est2 " , " est3 " ) ; assert client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estAsyncGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; BulkFuture < Map < String , String > > vals = client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) ; assert vals . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " est2 " ) ) ; }  <end> <beg> public void estNonexistentMutate ( ) hrows Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assert ! client . asyncIncr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; assert ! client . asyncDecr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estMutateWithDefaultAndExp ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; assert ! client . asyncGet ( " mtest " ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estImmediateDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assert client . delete ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estABunchOfCancelledOperations ( ) hrows Exception { final String k = " bunchOCancel " ; Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( k , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( k ) ) ; } OperationFuture < Boolean > sf = client . set ( k , 5 , " myxval " ) ; GetFuture < Object > gf = client . asyncGet ( k ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assert sf . getStatus ( ) . isSuccess ( ) ; assertEquals ( " myxval " , gf . get ( ) ) ; assert gf . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estAppend ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estPrepend ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout ) {  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; if ( status = = null ) { handleError ( OperationErrorType . SERVER , new String ( pl ) ) ;  <end> <beg> public void estErrorCodes ( ) hrows Exception { HashMap < Byte , String > err_map = new HashMap < Byte , String > ( ) ; OperationFactory opFact = new BinaryOperationFactory ( ) ; err_map . put ( new Byte ( ( byte ) 0x01 ) , " NOT FOUND " ) ; err_map . put ( new Byte ( ( byte ) 0x02 ) , " EXISTS " ) ; err_map . put ( new Byte ( ( byte ) 0x03 ) , " 2BIG " ) ; err_map . put ( new Byte ( ( byte ) 0x04 ) , " INVAL " ) ; err_map . put ( new Byte ( ( byte ) 0x05 ) , " NOT STORED " ) ; err_map . put ( new Byte ( ( byte ) 0x06 ) , " DELTA BAD VAL " ) ; err_map . put ( new Byte ( ( byte ) 0x07 ) , " NOT MY VBUCKET " ) ; err_map . put ( new Byte ( ( byte ) 0x81 ) , " UNKNOWN COMMAND " ) ; err_map . put ( new Byte ( ( byte ) 0x82 ) , " NO MEM " ) ; err_map . put ( new Byte ( ( byte ) 0x83 ) , " NOT SUPPORTED " ) ; err_map . put ( new Byte ( ( byte ) 0x84 ) , " INTERNAL ERROR " ) ; err_map . put ( new Byte ( ( byte ) 0x85 ) , " BUSY " ) ; err_map . put ( new Byte ( ( byte ) 0x86 ) , " TEMP FAIL " ) ; int opaque = 0 ; for ( final Entry < Byte , String > err : err_map . entrySet ( ) ) { byte [ ] b = new byte [ 24 + err . getValue ( ) . length ( ) ] ;  <end> <beg> public void receivedStatus ( OperationStatus s ) { assert ! s . isSuccess ( ) ; assert err . getValue ( ) . equals ( s . getMessage ( ) ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { } public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } }  <end> <beg> public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) { return asyncGetBulk ( keys , new SingleElementInfiniteIterator < Transcoder < T > > ( c ) ) ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) { setNodes ( nodes ) ; setConfig ( conf ) ; }  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; getLogger().debug("Read %d bytes", read);  <end> <beg> CASOperation cas ( StoreType , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> VersionOperation version ( OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> Collection < Operation > clone ( KeyedOperation op ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> TapOperation apBackfill ( String id , long date , OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }  <end> <beg> public boolean hasMoreMessages ( ) { if ( ! rqueue . isEmpty ( ) ) { return rue ; } else { synchronized ( omap ) { Iterator < Operation > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Operation op = itr . next ( ) ; if ( op . getState ( ) . equals ( OperationState . COMPLETE ) | | op . isCancelled ( ) | | op . hasErrored ( ) ) { omap . get ( op ) . shutdown ( ) ; omap . remove ( op ) ; } } if ( omap . size ( ) > 0 ) { return rue ; } } } return false ; }  <end> <beg> public Operation apCustom ( String id , RequestMessage message , String keyFilter , String valueFilter ) throws ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { tapAck ( conn , opcode , opaque , his ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; }  <end> <beg> public void gotAck ( TapOpcode opcode , int opaque ) { tapAck ( conn , opcode , opaque , his ) ; }  <end> <beg> public Operation apBackfill ( String id , final int runTime , final TimeUnit imeunit ) throws IOException , ConfigurationException { return apBackfill ( id , - 1 , runTime , imeunit ) ; }  <end> <beg> public Operation apBackfill ( final String id , final long date , final int runTime , final TimeUnit imeunit ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { tapAck ( conn , opcode , opaque , his ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , imeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; }  <end> <beg> public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , imeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ;  <end> <beg> private void apAck ( TapConnectionProvider conn , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . opFact . apAck ( opcode , opaque , cb ) ; conn . addOp ( op ) ; }  <end> <beg> public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < Operation , TapConnectionProvider > me : omap . entrySet ( ) ) {  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> Operation addOp ( final Operation op ) { checkState ( ) ; conn . addOperation ( " " , op ) ; return op ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) {  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void reconfigure ( Bucket bucket ) { his . reconfiguring = rue ; his . conn . reconfigure ( bucket ) ; his . reconfiguring = false ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public void receivedStatus ( OperationStatus s ) { }}  <end> <beg> public static void printMessage ( BaseMessage message , PrintWriter p ) { int colNum = 0 ; byte [ ] mbytes = message . getBytes ( ) . array ( ) ; p . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; p . print ( " ---------------------- " ) ; for ( int i = 0 ; i < mbytes . length ; i + + ) { if ( ( i % 4 ) = = 0 ) { p . printf ( " n%3d| " , colNum ) ; colNum + = 4 ; } int field = mbytes [ i ] ; if ( field < 0 ) field = field + 256 ; p . printf ( " %5x " , field ) ; } p . print ( " " ) ; }  <end> <beg> public void gotData ( ResponseMessage message ) ; public void gotAck ( TapOpcode opcode , int opaque ) ; } public void streamClosed ( OperationState state ) ; }  <end> <beg> public void gotAck ( TapOpcode opcode , int opaque ) ; } public void streamClosed ( OperationState state ) ; }  <end> <beg> public TapOperation apBackfill ( String id , long date , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apBackfill ( String id , long date , OperationCallback cb ) { return new TapBackfillOperationImpl ( id , date , cb ) ; }  <end> <beg> public TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) { return new TapCustomOperationImpl ( id , message , cb ) ; }  <end> <beg> public TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { return new TapAckOperationImpl ( opcode , opaque , cb ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_RES ) ; message . setOpcode ( opcode ) ; message . setOpaque ( opaque ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void streamClosed ( OperationState state ) { transitionState ( state ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . BACKFILL ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void initialize ( ) { if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) hrows IOException { while ( data . remaining ( ) > 0 ) { if ( bytesProcessed < BaseMessage . HEADER_LENGTH ) {  <end> <beg> public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapFlag . BACKFILL ) ; }  <end> <beg> public void doDump ( ) { message . setFlags ( TapFlag . DUMP ) ; }  <end> <beg> public void specifyVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . LIST_VBUCKETS ) ; }  <end> <beg> public void supportAck ( ) { message . setFlags ( TapFlag . SUPPORT_ACK ) ; }  <end> <beg> public void keysOnly ( ) { message . setFlags ( TapFlag . KEYS_ONLY ) ; }  <end> <beg> public void akeoverVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; }  <end> <beg> boolean hasFlag ( int f ) { if ( ( f & ( int ) flag ) = = 1 ) { return false ; } return rue ; }  <end> <beg> public static long fieldToValue ( byte [ ] buffer , int offset , int length ) { long otal = 0 ; long val = 0 ; for ( int i = 0 ; i < length ; i + + ) { val = buffer [ offset + i ] ; if ( val < 0 ) val = val + 256 ; total + = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) * val ; } return otal ; }  <end> <beg> public static void valueToFieldOffest ( byte [ ] buffer , int offset , int length , long l ) { long divisor ; for ( int i = 0 ; i < length ; i + + ) { divisor = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) ;  <end> <beg> public void estTapBucketDoesNotExist ( ) hrows Exception { TapClient client = new TapClient ( Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) , " abucket " , " abucket " , " apassword " ) ; try { client . apBackfill ( null , 5 , TimeUnit . SECONDS ) ;  <end> <beg> public void estTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . addOp ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; try { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert ( op . isTimedOut ( ) = = rue ) ; }  <end> <beg> public void estOps ( ) hrows Exception { MemcachedClient mc = null ; ry { URI base = new URI ( " http:localhost:8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> public void estMessageReceived ( ) hrows NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); }  <end> <beg> void setVBucket ( String key , short vbucket ) ; short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; vbmap . put ( k , new Short ( ( short ) 0 ) ) ; } return rv ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } }  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; }  <end> <beg> public void initialize ( ) { }  <end> <beg> private void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; }  <end> <beg> public void estGATTimeout ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " gatkey " ) ) ;  <end> <beg> public void estTouchTimeout ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " ouchkey " ) ) ;  <end> <beg> protected void flushPause ( ) hrows InterruptedException { }}  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> private static String resolveIpv6Addr ( ) { String ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; ; if ( IPV4_ADDR . equals ( ipv6 ) ) { return " ::ffff: " + ipv6 ; } return ipv6 ; }  <end> <beg> public static final boolean isMemcached ( ) { return TYPE . equals ( TYPE_MEMCACHED ) ; }  <end> <beg> public static final boolean isMembase ( ) { return TYPE . equals ( TYPE_MEMBASE ) ; }  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { return new GetAndTouchOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetAndTouchOperation . Callback gcb = ( GetAndTouchOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetlOperation . Callback gcb = ( GetlOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetsOperation . Callback gcb = ( GetsOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) { }}  <end> <beg> public void estBackfill ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient c = new TapClient ( AddrUtil . getAddresses ( " 127.0.0.1:11210 " ) ) ;  <end> <beg> public void estTapBucketDoesNotExist ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient client = new TapClient ( Arrays . asList ( new URI ( " http:localhost:8091/pools " ) ) ,  <end> <beg> protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) throws IOException { switch ( errCode ) { case SUCCESS :  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " :11211 " ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " ; super . earDown ( ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :64213 " ) ) ;  <end> <beg> public void estUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " / " + TestConfig . IPV4_ADDR + " :64213 " ) ) ,  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ;  <end> <beg> public static void main ( String [ ] args ) hrows Exception { }  <end> <beg> private void assertWorking ( ) hrows Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " / " + TestConfig . IPV4_ADDR + " :11211 " , versions . keySet ( ) . iterator ( ) . next ( ) . oString ( ) ) ;  <end> <beg> public void estVarargConstructor ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , 11211 ) ) ; assertWorking ( ) ; }  <end> <beg> public void estArraymodNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public void estKetamaNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " ; super . earDown ( ) ; }  <end> <beg> public void estBackfill ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient c = new TapClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11210 " ) ) ;  <end> <beg> public void estTapBucketDoesNotExist ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient client = new TapClient ( Arrays . asList (  <end> <beg> private static final String resolveIpv6Addr ( ) { String ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; }  <end> <beg> public static final boolean defaultToIPV4 ( ) { if ( ( " ::ffff: " + IPV4_ADDR ) . equals ( IPV6_ADDR ) ) { return rue ; } return false ; }  <end> <beg> public static final boolean isMembase ( ) { System . out . println ( TYPE ) ; return TYPE . equals ( TYPE_MEMBASE ) ; }  <end> <beg> public void estOps ( ) hrows Exception { MemcachedClient mc = null ; ry { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MemcachedClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> public void estSingleOperation ( ) { Operation op = buildOp ( 11211 ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " :11211 " ,  <end> <beg> public void estMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " :11211, "  <end> <beg> private TestOperation buildOp ( int portNum ) { TestOperation op = new TestOperation ( ) ; MockMemcachedNode node = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( TestConfig . IPV4_ADDR , portNum ) ) ; op . setHandlingNode ( node ) ; return op ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " deamon " , rue , memcachedClient . isDaemon ( ) ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; }  <end> <beg> boolean hasFlag ( int f ) { if ( ( f & ( int ) flag ) > 0 ) { return rue ; } return false ; }  <end> <beg> SASLMechsOperation saslMechs ( OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> Collection < Operation > clone ( KeyedOperation op ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apBackfill ( String id , long date , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> public Operation apDump ( final String id ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { tapAck ( conn , opcode , opaque , his ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public TapOperation apDump ( String id , OperationCallback cb ) { throw new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apDump ( String id , OperationCallback cb ) { return new TapDumpOperationImpl ( id , cb ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . DUMP ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void estTapDump ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient c = new TapClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11210 " ) ) ;  <end> <beg> public Operation apCustom ( String id , RequestMessage message , String keyFilter , String valueFilter ) throws ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; }  <end> <beg> public Operation apBackfill ( final String id , final long date , final int runTime , final TimeUnit imeunit ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , imeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; }  <end> <beg> public Operation apDump ( final String id ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> private URLConnection urlConnBuilder ( URI base , URI resource ) hrows IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . oURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client-Specification-Version " , CLIENT_SPEC_VER ) ; if ( restUsr ! = null ) { ry { connection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new IOException ( " Could not encode specified credentials for HTTP request. " , ex ) ; } } return connection ;  <end> <beg> protected static String buildAuthHeader ( String username , String password ) hrows UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); return headerResult; }  <end> <beg> public void estBuildAuthHeader ( ) hrows UnsupportedEncodingException { ConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ; }  <end> <beg> public void estBuildAuthHeaderUTF8 ( ) hrows UnsupportedEncodingException { String result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); }  <end> <beg> private Map < String , MemcachedNode > fillNodesEntries ( Collection < MemcachedNode > nodes ) { HashMap < String , MemcachedNode > vbnodesMap = new HashMap < String , MemcachedNode > ( ) ; getLogger ( ) . debug ( " Updating nodesMap in VBucketNodeLocator. " ) ; for ( MemcachedNode node : nodes ) { InetSocketAddress addr = ( InetSocketAddress ) node . getSocketAddress ( ) ; String address = addr . getAddress ( ) . getHostName ( ) + " : " + addr . getPort ( ) ; String hostname = addr . getAddress ( ) . getHostAddress ( ) + " : " + addr . getPort ( ) ; getLogger ( ) . debug ( " Adding node with hostname %s and address %s. " , hostname , address ) ; getLogger ( ) . debug ( " Node added is %s. " , node ) ; vbnodesMap . put ( address , node ) ; vbnodesMap . put ( hostname , node ) ; } return Collections . unmodifiableMap ( vbnodesMap ) ; }  <end> <beg> public MemcachedNode next ( ) { throw new NoSuchElementException ( " VBucketNodeLocators have no alternate nodes. " ) ; }  <end> <beg> public void remove ( ) { throw new UnsupportedOperationException ( " VBucketNodeLocators have no alternate nodes; cannot remove. " ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { this . nodes = nodes . oArray ( new MemcachedNode [ nodes . size ( ) ] ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { setKetamaNodes ( nodes ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { try { get a new collection of addresses from the received config  <end> <beg> MemcachedNode getPrimary ( String k ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> Collection < MemcachedNode > getAll ( ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> NodeLocator getReadonlyCopy ( ) ; public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> public MembaseConnectionFactory buildMembaseConnection ( final List < URI > baseList , final String bucketName , final String usr , final String pwd ) hrows IOException { return new MembaseConnectionFactory ( baseList , bucketName , usr , pwd ) {  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down membase client " ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> public < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case CONSISTENT :  <end> <beg> protected void logRunException ( Exception e ) { if ( shuttingDown ) { There are a couple types of errors that occur during the  <end> <beg> public void run ( ) { while ( running ) { ry { conn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) hrows OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) hrows OperationTimeoutException ; < T > T get ( String key , Transcoder < T > c ) throws OperationTimeoutException ; Object get ( String key ) hrows OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) hrows OperationTimeoutException ; long decr ( String key , int by ) hrows OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) { @Override  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) , " default " , " default " , " " ) ) ;  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MembaseClient ( ( MembaseConnectionFactory ) cf ) ; }  <end> <beg> public void estAvailableServers ( ) { }  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http:localhost:8091/pools " ) ) , " default " , " default " , " " ) {  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> public void estSyncGetTimeouts ( ) hrows Exception { final String key = " imeoutTestKey " ; final String value = " imeoutTestValue " ; int j = 0 ; boolean set = false ; do { set = client . set ( key , 0 , value ) . get ( ) ; j + + ; } while ( ! set & & j < 10 ) ; assert set = = rue ; if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) {  <end> <beg> protected void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ;  <end> <beg> public void estOps ( ) hrows Exception { MembaseClient mc = null ; ry { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { reconfiguring = rue ; try { mconn . reconfigure ( bucket ) ;  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { mconn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down membase client " ) ; }  <end> <beg> Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return mconn . broadcastOperation ( of , nodes ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void run ( ) { while ( running ) { ry { mconn . handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return mconn . removeObserver ( obs ) ; }  <end> <beg> Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; mconn . checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public void reconfigure ( Bucket bucket ) { reconfiguring = rue ; try { get a new collection of addresses from the received config  <end> <beg> public void checkState ( ) { if ( shutDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; }  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> private void logRunException ( Exception e ) { if ( shutDown ) { There are a couple types of errors that occur during the  <end> <beg> Operation addOp ( final Operation op ) { conn . checkState ( ) ; conn . addOperation ( " " , op ) ; return op ; }  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public void reconfigure ( Bucket bucket ) { his . conn . reconfigure ( bucket ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) { String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new HttpOperation ( request , new HttpCallback ( ) { @Override public void complete ( String response ) { try { crv . set ( DocParserUtils . parseDesignDocumentForViews ( bucketName , designDocumentName , response ) ) ; } catch ( ParseException e ) { getLogger ( ) . error ( e . getMessage ( ) ) ; } couchLatch . countDown ( ) ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void complete ( String response ) { try { crv . set ( DocParserUtils . parseDesignDocumentForViews ( bucketName , designDocumentName , response ) ) ; } catch ( ParseException e ) { getLogger ( ) . error ( e . getMessage ( ) ) ; } couchLatch . countDown ( ) ; }  <end> <beg> public void addOp ( final HttpOperation op ) { cconn . checkState ( ) ; cconn . addOp ( op ) ; }  <end> <beg> public boolean shutdown ( long duration , TimeUnit units ) { try { return super . shutdown ( duration , units ) & & cconn . shutdown ( ) ;  <end> <beg> private List < CouchbaseNode > createConnections ( List < InetSocketAddress > addrs ) throws IOException { List < CouchbaseNode > nodeList = new LinkedList < CouchbaseNode > ( ) ; for ( InetSocketAddress a : addrs ) { HttpParams params = new SyncBasicHttpParams ( ) ; params . setIntParameter ( CoreConnectionPNames . SO_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . CONNECTION_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . SOCKET_BUFFER_SIZE , 8 * 1024 ) . setBooleanParameter ( CoreConnectionPNames . STALE_CONNECTION_CHECK , false ) . setBooleanParameter ( CoreConnectionPNames . TCP_NODELAY , rue ) . setParameter ( CoreProtocolPNames . USER_AGENT , " Spymemcached Client/1.1 " ) ; HttpProcessor httpproc = new ImmutableHttpProcessor ( new HttpRequestInterceptor [ ] { new RequestContent ( ) , new RequestTargetHost ( ) , new RequestConnControl ( ) , new RequestUserAgent ( ) , new RequestExpectContinue ( ) } ) ; AsyncNHttpClientHandler protocolHandler = new AsyncNHttpClientHandler ( httpproc , new MyHttpRequestExecutionHandler ( ) , new DefaultConnectionReuseStrategy ( ) , new DirectByteBufferAllocator ( ) , params ) ; protocolHandler . setEventListener ( new EventLogger ( ) ) ; AsyncConnectionManager connMgr = new AsyncConnectionManager ( new HttpHost ( a . getHostName ( ) , a . getPort ( ) ) , NUM_CONNS , protocolHandler , params ) ; getLogger ( ) . info ( " Added %s to connect queue " , a ) ; CouchbaseNode node = connFactory . createCouchDBNode ( a , connMgr ) ; node . init ( ) ; nodeList . add ( node ) ; } return nodeList ; }  <end> <beg> public void addOp ( final HttpOperation op ) { nodes . get ( getNextNode ( ) ) . addOp ( op ) ; }  <end> <beg> public void handleIO ( ) { for ( CouchbaseNode node : nodes ) { node . doWrites ( ) ;  <end> <beg> protected void checkState ( ) { if ( shutDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; }  <end> <beg> public boolean shutdown ( ) hrows IOException { if ( shutDown ) { getLogger ( ) . info ( " Suppressing duplicate attempt to shut down " ) ; return false ; } shutDown = rue ; running = false ; for ( CouchbaseNode : nodes ) { if ( ! = null ) { n . shutdown ( ) ; if ( . hasWriteOps ( ) ) { getLogger ( ) . warn ( " Shutting down with ops waiting to be written " ) ; } } } return rue ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { }}  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( Exception e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> private void logRunException ( Exception e ) { if ( shutDown ) { There are a couple types of errors that occur during the  <end> <beg> public CouchbaseNode createCouchDBNode ( InetSocketAddress addr , AsyncConnectionManager connMgr ) { return new CouchbaseNode ( addr , connMgr , new LinkedBlockingQueue < HttpOperation > ( opQueueLen ) ,  <end> <beg> public MemcachedConnection createMemcachedConnection ( List < InetSocketAddress > addrs ) hrows IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ;  <end> <beg> public CouchbaseConnection createCouchDBConnection ( List < InetSocketAddress > addrs ) hrows IOException { return new CouchbaseConnection ( his , addrs , getInitialObservers ( ) ) ; }  <end> <beg> public void init ( ) hrows IOReactorException { }  <end> <beg> public void run ( ) { try { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } System . out . println ( " I/O reactor terminated " ) ; }  <end> <beg> public void doWrites ( ) { HttpOperation op ; while ( ( op = writeQ . poll ( ) ) ! = null ) { if ( ! op . isTimedOut ( ) & & ! op . isCancelled ( ) ) {  <end> <beg> public boolean hasWriteOps ( ) { return ! writeQ . isEmpty ( ) ; }  <end> <beg> public void addOp ( HttpOperation op ) { try { if ( ! writeQ . offer ( op , opQueueMaxBlockTime , TimeUnit . MILLISECONDS ) ) {  <end> <beg> public void shutdown ( ) hrows IOException { shutdown ( 0 , TimeUnit . MILLISECONDS ) ; }  <end> <beg> public void shutdown ( long ime , TimeUnit unit ) hrows IOException { if ( unit ! = TimeUnit . MILLISECONDS ) { connMgr . shutdown ( TimeUnit . MILLISECONDS . convert ( ime , unit ) ) ;  <end> <beg> public void initalizeContext ( final HttpContext context , final Object attachment ) { } public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ; if ( ! op . isTimedOut ( ) & & ! op . hasErrored ( ) & & ! op . isCancelled ( ) ) { try { String json = EntityUtils . oString ( response . getEntity ( ) ) ; op . getCallback ( ) . complete ( json ) ; } catch ( ParseException e ) { op . setException ( new OperationException ( OperationErrorType . GENERAL , " Bad http headers " ) ) ; } catch ( IOException e ) { op . setException ( new OperationException ( OperationErrorType . GENERAL , " Error reading response " ) ) ; } catch ( IllegalArgumentException e ) { op . setException ( new OperationException ( OperationErrorType . GENERAL , " No entity " ) ) ; } } } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) hrows IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ; } } static class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } }  <end> <beg> public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ;  <end> <beg> public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; }  <end> <beg> public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ;  <end> <beg> public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) hrows IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ;  <end> <beg> public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; }  <end> <beg> public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; }  <end> <beg> public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; }  <end> <beg> public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; }  <end> <beg> public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; }  <end> <beg> public void execute ( ) hrows IOException { IOEventDispatch dispatch = new DefaultClientIOEventDispatch ( new ManagedClientHandler ( his . handler , his ) , his . params ) ; this . ioreactor . execute ( dispatch ) ; }  <end> <beg> public void shutdown ( long waitMs ) hrows IOException { synchronized ( his . lock ) { if ( ! his . shutdown ) { this . shutdown = rue ; while ( ! his . pendingRequests . isEmpty ( ) ) { AsyncConnectionRequest request = his . pendingRequests . remove ( ) ; request . cancel ( ) ; } this . availableConns . clear ( ) ; this . allConns . clear ( ) ; } } this . ioreactor . shutdown ( waitMs ) ; }  <end> <beg> void addConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { this . allConns . add ( conn ) ;  <end> <beg> void removeConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { if ( his . allConns . remove ( conn ) ) {  <end> <beg> public AsyncConnectionRequest requestConnection ( ) { if ( his . shutdown ) { throw new IllegalStateException ( " Connection manager has been shut down " ) ; } AsyncConnectionRequest request = new AsyncConnectionRequest ( ) ; synchronized ( his . lock ) { while ( ! his . availableConns . isEmpty ( ) ) { NHttpClientConnection conn = his . availableConns . remove ( ) ; if ( conn . isOpen ( ) ) { getLogger ( ) . debug ( " Re-using persistent connection " ) ; request . setConnection ( conn ) ; break ; } else { this . allConns . remove ( conn ) ; } } if ( ! request . isCompleted ( ) ) { this . pendingRequests . add ( request ) ; processConnectionRequests ( ) ; } } return request ; }  <end> <beg> public void releaseConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { if ( his . allConns . contains ( conn ) ) {  <end> <beg> private void processConnectionRequests ( ) { while ( his . allConns . size ( ) < his . maxConnections ) { AsyncConnectionRequest request = his . pendingRequests . poll ( ) ;  <end> <beg> public void connected ( NHttpClientConnection conn , Object attachment ) { AsyncConnectionRequest request = ( AsyncConnectionRequest ) attachment ; this . handler . connected ( conn , attachment ) ; this . connMgr . addConnection ( conn ) ; request . setConnection ( conn ) ; }  <end> <beg> public void closed ( NHttpClientConnection conn ) { this . connMgr . removeConnection ( conn ) ; this . handler . closed ( conn ) ; }  <end> <beg> public void requestReady ( NHttpClientConnection conn ) { this . handler . requestReady ( conn ) ; }  <end> <beg> public void outputReady ( NHttpClientConnection conn , ContentEncoder encoder ) { this . handler . outputReady ( conn , encoder ) ; }  <end> <beg> public void responseReceived ( NHttpClientConnection conn ) { this . handler . responseReceived ( conn ) ; }  <end> <beg> public void inputReady ( NHttpClientConnection conn , ContentDecoder decoder ) { this . handler . inputReady ( conn , decoder ) ; }  <end> <beg> public void exception ( NHttpClientConnection conn , HttpException ex ) { this . handler . exception ( conn , ex ) ; }  <end> <beg> public void exception ( NHttpClientConnection conn , IOException ex ) { this . handler . exception ( conn , ex ) ; }  <end> <beg> public void imeout ( NHttpClientConnection conn ) { this . handler . imeout ( conn ) ; }  <end> <beg> public void completed ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( )  <end> <beg> public void cancelled ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request cancelled " ) ; this . request . cancel ( ) ; }  <end> <beg> public void failed ( SessionRequest request ) { getLogger ( ) . error ( request . getRemoteAddress ( ) + " - Session request failed " ) ; IOException ex = request . getException ( ) ; if ( ex ! = null ) { ex . printStackTrace ( ) ; } this . request . cancel ( ) ; }  <end> <beg> public void imeout ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request timed out " ) ; this . request . cancel ( ) ; }  <end> <beg> public boolean isCompleted ( ) { return his . completed ; }  <end> <beg> public void cancel ( ) { if ( his . completed ) { return ; } this . completed = rue ; synchronized ( his ) { notifyAll ( ) ;  <end> <beg> public void waitFor ( ) hrows InterruptedException { if ( his . completed ) { return ; } synchronized ( his ) { while ( ! his . completed ) {  <end> <beg> public void completed ( ) { if ( his . completed ) { return ; } this . completed = rue ; this . connMgr . releaseConnection ( his . conn ) ; synchronized ( his ) { notifyAll ( ) ;  <end> <beg> public boolean isCompleted ( ) { return his . completed ; }  <end> <beg> public boolean cancel ( boolean c ) { op . cancel ( ) ; return rue ; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public boolean isDone ( ) { }  <end> <beg> public static List < View > parseDesignDocumentForViews ( String dn , String ddn , String json ) throws ParseException { List < View > viewList = new LinkedList < View > ( ) ; try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String viewname = ( String ) itr . next ( ) ; boolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; viewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } return viewList ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } }  <end> <beg> public static final boolean isCouchbase ( ) { return TYPE . equals ( TYPE_COUCHBASE ) ; }  <end> <beg> public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) { String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; }  <end> <beg> public void complete ( ) { couchLatch . countDown ( ) ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) { String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsOperationImpl ( request , bucketName , designDocumentName , new ViewsCallback ( ) { List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; }  <end> <beg> public ViewFuture query ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; }  <end> <beg> public void gotData ( ViewResponseWithDocs response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseNoDocs > crv = new HttpFuture < ViewResponseNoDocs > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { ViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; }  <end> <beg> public void gotData ( ViewResponseNoDocs response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponseReduced > queryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void gotData ( ViewResponseReduced response ) { vr = response ; }  <end> <beg> public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public HttpFuture<ViewResponseReduced> queryAndReduce(View view, Query query);}  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public HttpFuture<ViewResponseReduced> queryAndReduce(View view, Query query);}  <end> <beg> public ViewFuture query ( View view , Query query ) ; public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; }  <end> <beg> public HttpFuture < ViewResponseReduced > queryAndReduce ( View view , Query query ) ; }  <end> <beg> public void init ( ) hrows IOReactorException { }  <end> <beg> public void run ( ) { try { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } getLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; }  <end> <beg> public void initalizeContext ( final HttpContext context , final Object attachment ) { } public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ; op . handleResponse ( response ) ; } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) hrows IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ; } } static class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public void set ( T op , OperationStatus s ) { objRef . set ( op ) ; status = s ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . hasErrored ( ) ;  <end> <beg> public ViewResponseWithDocs get ( ) hrows InterruptedException , ExecutionException { try { return get ( imeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; Iterator < RowWithDocs > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { RowWithDocs r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows ) ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . hasErrored ( ) ; }  <end> <beg> public void set ( ViewResponseWithDocs viewResponse , BulkFuture < Map < String , Object > > op , OperationStatus s ) { viewRef . set ( viewResponse ) ; multigetRef . set ( op ) ; status = s ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseWithDocs vr = parseDocsViewResult ( json ) ; ( ( DocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { String id = ids . getJSONObject ( i ) . getString ( " id " ) ; String key = ids . getJSONObject ( i ) . getString ( " key " ) ; String value = ids . getJSONObject ( i ) . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows ) ; }  <end> <beg> public HttpRequest getRequest ( ) ; OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> protected OperationStatus parseViewForStatus ( String json , int errorcode ) throws ParseException { if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { String error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; if ( base . has ( " reason " ) ) { error + = " Reason: " + base . getString ( " reason " ) ; } return new OperationStatus ( false , error ) ; } else { return new OperationStatus ( rue , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json ) ; } } return new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ;  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseNoDocs vr = parseNoDocsViewResult ( json ) ; ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { String id = ids . getJSONObject ( i ) . getString ( " id " ) ; String key = ids . getJSONObject ( i ) . getString ( " key " ) ; String value = ids . getJSONObject ( i ) . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows ) ; }  <end> <beg> public String oString ( ) { boolean first = rue ; String result = " " ; for ( Entry < String , Object > arg : args . entrySet ( ) ) { if ( first ) { result + = " ? " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; first = false ; } else { result + = " & " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; } } return result ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseReduced vr = parseReducedViewResult ( json ) ; ( ( ReducedCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseReduced parseReducedViewResult ( String json ) throws ParseException { final Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { String key = ids . getJSONObject ( i ) . getString ( " key " ) ; String value = ids . getJSONObject ( i ) . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows ) ; }  <end> <beg>  public String oString ( ) { return " ok " ; }  <end> <beg>  public String oString ( ) { return " update_after " ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private View parseDesignDocumentForView ( String dn , String ddn , String viewName , String json ) hrows ParseException { View view = null ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String curView = ( String ) itr . next ( ) ; if ( curView . equals ( viewName ) ) { boolean map = views . getJSONObject ( curView ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( curView ) . has ( " reduce " ) ; view = new View ( dn , ddn , viewName , map , reduce ) ; break ; } } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return view ; }  <end> <beg> public Iterator < RowNoDocs > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowNoDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public Iterator < RowReduced > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowReduced r : rows ) { s . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public Iterator < RowWithDocs > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowWithDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDoc ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public void clear ( ) { throw new UnsupportedOperationException ( " clear() is not supported " ) ; }  <end> <beg> public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; }  <end> <beg> public boolean containsValue ( Object value ) { return map . containsValue ( value ) ; }  <end> <beg> public Set < Entry < String , Object > > entrySet ( ) { Set < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; for ( RowWithDocs r : rows ) { set . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } return null ; }  <end> <beg> public Set < String > keySet ( ) { Set < String > set = new TreeSet < String > ( ) ; for ( RowWithDocs r : rows ) { set . add ( r . getId ( ) ) ; } return null ; }  <end> <beg> public Object put ( String key , Object value ) { throw new UnsupportedOperationException ( " put() is not supported " ) ; }  <end> <beg> public void putAll ( Map < ? extends String , ? extends Object > m ) { throw new UnsupportedOperationException ( " putAll() is not supported " ) ;  <end> <beg> public Object remove ( Object key ) { throw new UnsupportedOperationException ( " remove() is not supported " ) ; }  <end> <beg> public int size ( ) { assert rows . size ( ) = = map . size ( ) ; return rows . size ( ) ; }  <end> <beg> public Collection < Object > values ( ) { Collection < Object > values = new LinkedList < Object > ( ) ; for ( RowWithDocs r : rows ) { values . add ( r . getDoc ( ) ) ; } return values ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { List < View > views = parseDesignDocumentForViews ( bucketName , designDocName , json ) ; ( ( ViewsCallback ) callback ) . gotData ( views ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private List < View > parseDesignDocumentForViews ( String dn , String ddn , String json ) hrows ParseException { List < View > viewList = new LinkedList < View > ( ) ; try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String viewname = ( String ) itr . next ( ) ; boolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; viewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } return viewList ; }  <end> <beg> protected void initClient ( ) hrows Exception { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( URI . create ( SERVER_URI ) ) ; client = new TestingClient ( uris , " default " , " " ) ; }  <end> <beg> public static void before ( ) hrows Exception { }  <end> <beg> public void beforeTest ( ) hrows Exception { initClient ( ) ; }  <end> <beg> public void afterTest ( ) hrows Exception { }  <end> <beg> public static void after ( ) hrows Exception { }  <end> <beg> private static String generateDoc ( String ype , String small , String large ) { return " { \" ype \" : \" " + ype + " \" " + " \" small range \" : \" " + small + " \" " + " \" large range \" : \" " + large + " \" } " ;  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < RowReduced > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { RowReduced row = itr . next ( ) ;  <end> <beg> public void estReduceWhenNoneExists ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; try { client . queryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { return ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( TestCallback ) callback ) . getData ( json ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } callback . complete ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( json , status ) ; }  <end> <beg> public void complete ( ) { couchLatch . countDown ( ) ; }  <end> <beg> public boolean isTimeout ( ) ; public OperationStatus getStatus ( ) ; }  <end> <beg> Bucket getBucketConfiguration ( String bucketname ) hrows ConfigurationException ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void subscribe ( String bucketName , Reconfigurable rec ) hrows ConfigurationException ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> public void handleIO ( ) { for ( CouchbaseNode node : nodes ) { node . doWrites ( ) ; } for ( CouchbaseNode qa : nodesToShutdown ) { nodesToShutdown . remove ( qa ) ;  <end> <beg> private void redistributeOperations ( Collection < HttpOperation > ops ) { int added = 0 ; for ( HttpOperation op : ops ) { addOp ( op ) ; added + + ; } assert added > 0 : " Didn't add any new operations when redistributing " ;  <end> <beg> public Collection < HttpOperation > destroyWriteQueue ( ) { Collection < HttpOperation > rv = new ArrayList < HttpOperation > ( ) ; writeQ . drainTo ( rv ) ; return rv ; }  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; Iterator < RowWithDocs > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { RowWithDocs r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseReduced parseReducedViewResult ( String json ) throws ParseException { final Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; }  <end> <beg> public void estViewDocsWithErrors ( ) hrows Exception { HttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { }  <end> <beg> public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; }  <end> <beg> public void complete ( ) { }}  <end> <beg> public void gotData ( ViewResponseWithDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void estViewNoDocsWithErrors ( ) hrows Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { }  <end> <beg> public void complete ( ) { }}  <end> <beg> public void gotData ( ViewResponseNoDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void estViewReducedWithErrors ( ) hrows Exception { HttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { }  <end> <beg> public void complete ( ) { }}  <end> <beg> public void gotData ( ViewResponseReduced response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsOperationImpl ( request , bucketName , designDocumentName , new ViewsCallback ( ) { List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public static void before ( ) hrows Exception { }  <end> <beg> public static void after ( ) hrows Exception { + DESIGN_DOC_WO_REDUCE + "?rev=" + rev).get();  <end> <beg> public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsOperationImpl ( request , bucketName , designDocumentName , new ViewsCallback ( ) { List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public ViewFuture query ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > queryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseNoDocs > crv = new HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { ViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponseReduced > queryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public ViewFuture query ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ;  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; throw new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; throw new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; Iterator < RowWithDocs > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { RowWithDocs r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseWithDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseDocsViewResult ( json ) ; } ( ( DocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseNoDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseNoDocsViewResult ( json ) ; } ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseReduced vr = null ; if ( status . isSuccess ( ) ) { vr = parseReducedViewResult ( json ) ; } ( ( ReducedCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> public static void before ( ) hrows Exception { }  <end> <beg> public void afterTest ( ) hrows Exception { }  <end> <beg> public static void after ( ) hrows Exception { }  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setDescending ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroup ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , query . setGroup ( rue ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroupWithLevel ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . queryAndReduce ( view , query . setGroup ( rue , 1 ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . query ( view , query . setUpdateSeq ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public ViewFuture asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseNoDocs > crv = new HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { ViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public ViewResponseWithDocs query ( View view , Query query ) { try { return asyncQuery ( view , query ) . get ( ) ;  <end> <beg> public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) { try { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ;  <end> <beg> public ViewResponseReduced queryAndReduce ( View view , Query query ) { try { return asyncQueryAndReduce ( view , query ) . get ( ) ;  <end> <beg> public HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> public View getView ( final String designDocumentName , final String viewName ) ; public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> public List < View > getViews ( final String designDocumentName ) ; public ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> public ViewFuture asyncQuery ( View view , Query query ) ; public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public ViewResponseWithDocs query ( View view , Query query ) ; public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < RowReduced > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { RowReduced row = itr . next ( ) ;  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setDescending ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroup ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroupWithLevel ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue , 1 ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setUpdateSeq ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estReduceWhenNoneExists ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; try { client . asyncQueryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { return ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > newNodes , Config conf ) { his . nodes = newNodes . oArray ( new MemcachedNode [ newNodes . size ( ) ] ) ; }  <end> <beg> public boolean hasNext ( ) { return next > = 0 ; }  <end> <beg> private void computeNext ( ) { if ( + + next > = nodes . length ) { next = 0 ; } if ( next = = start ) { next = - 1 ;  <end> <beg> public MemcachedNode next ( ) { ry { return nodes [ next ] ;  <end> <beg> public void remove ( ) { hrow new UnsupportedOperationException ( " Can't remove a node " ) ; }  <end> <beg> public void clear ( ) { TODO: Support a rolling key generation. throw new UnsupportedOperationException(); }  <end> <beg> public boolean containsKey ( Object key ) { return get ( key ) ! = null ; }  <end> <beg> public boolean containsValue ( Object value ) { return false ; }  <end> <beg> public Set < Map . Entry < String , V > > entrySet ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public V get ( Object key ) { V rv = null ; ry { rv = client . get ( getKey ( ( String ) key ) , ranscoder ) ; } catch ( ClassCastException e ) { Most likely, this is because the key wasn't a String. Either way, it's a no. } return rv; }  <end> <beg> public Set < String > keySet ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public void putAll ( Map < ? extends String , ? extends V > ) { for ( Map . Entry < ? extends String , ? extends V > me : . entrySet ( ) ) { client . set ( getKey ( me . getKey ( ) ) , exp , me . getValue ( ) ) ;  <end> <beg> public V remove ( Object key ) { V rv = null ; ry { rv = get ( key ) ; client . delete ( getKey ( ( String ) key ) ) ; } catch ( ClassCastException e ) { Not a string key. Ignore. } return rv; }  <end> <beg> public Collection < V > values ( ) { return Collections . emptySet ( ) ; }  <end> <beg> public V put ( String key , V value ) { V rv = get ( key ) ; client . set ( getKey ( key ) , exp , value ) ; return rv ; }  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { boolean doAuth = false ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , createWriteOperationQueue ( ) ,  <end> <beg> Operation newOp ( MemcachedNode , CountDownLatch latch ) ; }  <end> <beg> public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; If there were a CAS value, check to see if it's compatible. if (casval != null) { T tmp = casval.getValue(); current = tmp; } If we have anything mutate and CAS, else add. if (current != null) { Declaring this impossible since the only way current can be non-null is if casval was set. assert casval != null : "casval was null with a current value"; rv = m.getNewValue(current); There are three possibilities here: 1) It worked and we're done. 2) It collided and we need to reload and try again. 3) It disappeared between our fetch and our cas. We're ignoring #3 because it's *extremely* unlikely and the behavior will be fine in this code -- we'll do another gets and follow it up with either an add or another cas depending on whether it exists the next time. if (client.cas(key, casval.getCas(), rv, transcoder) == CASResponse.OK) { done = true; } } else { No value found, try an add. if (initial == null) { done = true; rv = null; } else if (client.add(key, initialExp, initial, transcoder).get()) { done = true; rv = initial; } } } if (!done) { throw new RuntimeException("Couldn't get a CAS in " + max + " attempts"); } return rv; }  <end> <beg> public String oString ( ) { return " {CasValue " + cas + " / " + value + " } " ; }  <end> <beg> public String oString ( ) { return " {CachedData flags= " + flags + " data= " + Arrays . oString ( data ) + " } " ;  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean isDaemon ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> int getReadBufSize ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> HashAlgorithm getHashAlg ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> long getMaxReconnectDelay ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; }  <end> <beg> public ConnectionFactoryBuilder setInitialObservers ( Collection < ConnectionObserver > obs ) { initialObservers = obs ; return his ; }  <end> <beg> public ConnectionFactory build ( ) { return new DefaultConnectionFactory ( ) {  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return opQueueFactory = = null ? super . createOperationQueue ( ) : opQueueFactory . create ( ) ;  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return readQueueFactory = = null ? super . createReadOperationQueue ( ) : readQueueFactory . create ( ) ;  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return writeQueueFactory = = null ? super . createReadOperationQueue ( ) : writeQueueFactory . create ( ) ;  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case ARRAY_MOD :  <end> <beg> public boolean isDaemon ( ) { return isDaemon ; }  <end> <beg> public boolean shouldOptimize ( ) { return shouldOptimize ; }  <end> <beg> public boolean useNagleAlgorithm ( ) { return useNagle ; }  <end> <beg> public MembaseConnectionFactory buildMembaseConnection ( final List < URI > baseList , final String bucketName , final String usr , final String pwd ) hrows IOException { return new MembaseConnectionFactory ( baseList , bucketName , usr , pwd ) {  <end> <beg> void connectionEstablished ( SocketAddress sa , int reconnectCount ) ; void connectionLost ( SocketAddress sa ) ; }  <end> <beg> public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { private View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; }  <end> <beg> public void complete ( ) { couchLatch . countDown ( ) ; }  <end> <beg> public void gotData ( View v ) { view = v ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsOperationImpl ( request , bucketName , designDocumentName , new ViewsCallback ( ) { private List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; }  <end> <beg> public void complete ( ) { couchLatch . countDown ( ) ; }  <end> <beg> public void gotData ( List < View > v ) { views = v ; }  <end> <beg> public ViewFuture asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ;  <end> <beg> public void complete ( ) { couchLatch . countDown ( ) ; }  <end> <beg> public void gotData ( ViewResponseWithDocs response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseNoDocs > crv = new HttpFuture < ViewResponseNoDocs > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsOperation . NoDocsCallback ( ) { private ViewResponseNoDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseNoDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; }  <end> <beg> public void gotData ( ViewResponseNoDocs response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { hrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { private ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void gotData ( ViewResponseReduced response ) { vr = response ; }  <end> <beg> public ViewResponseWithDocs query ( View view , Query query ) { ry { return asyncQuery ( view , query ) . get ( ) ;  <end> <beg> public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) { ry { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ;  <end> <beg> public ViewResponseReduced queryAndReduce ( View view , Query query ) { ry { return asyncQueryAndReduce ( view , query ) . get ( ) ;  <end> <beg> public void addOp ( final HttpOperation op ) { cconn . checkState ( ) ; cconn . addOp ( op ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { reconfiguring = rue ; ry { mconn . reconfigure ( bucket ) ;  <end> <beg> public void shutdown ( ) { shutdown ( - 1 , TimeUnit . MILLISECONDS ) ; }  <end> <beg> public boolean shutdown ( long duration , TimeUnit units ) { ry { return super . shutdown ( duration , units ) & & cconn . shutdown ( ) ;  <end> <beg> HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> List < View > getViews ( final String designDocumentName ) ; Query ViewFuture asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> ViewFuture asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> private List < CouchbaseNode > createConnections ( List < InetSocketAddress > addrs ) hrows IOException { List < CouchbaseNode > nodeList = new LinkedList < CouchbaseNode > ( ) ; for ( InetSocketAddress a : addrs ) { HttpParams params = new SyncBasicHttpParams ( ) ; params . setIntParameter ( CoreConnectionPNames . SO_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . CONNECTION_TIMEOUT , 5000 ) . setIntParameter ( CoreConnectionPNames . SOCKET_BUFFER_SIZE , 8 * 1024 ) . setBooleanParameter ( CoreConnectionPNames . STALE_CONNECTION_CHECK , false ) . setBooleanParameter ( CoreConnectionPNames . TCP_NODELAY , rue ) . setParameter ( CoreProtocolPNames . USER_AGENT , " Spymemcached Client/1.1 " ) ; HttpProcessor httpproc = new ImmutableHttpProcessor ( new HttpRequestInterceptor [ ] { new RequestContent ( ) , new RequestTargetHost ( ) , new RequestConnControl ( ) , new RequestUserAgent ( ) , new RequestExpectContinue ( ) , } ) ; AsyncNHttpClientHandler protocolHandler = new AsyncNHttpClientHandler ( httpproc , new MyHttpRequestExecutionHandler ( ) , new DefaultConnectionReuseStrategy ( ) , new DirectByteBufferAllocator ( ) , params ) ; protocolHandler . setEventListener ( new EventLogger ( ) ) ; AsyncConnectionManager connMgr = new AsyncConnectionManager ( new HttpHost ( a . getHostName ( ) , a . getPort ( ) ) , NUM_CONNS , protocolHandler , params ) ; getLogger ( ) . info ( " Added %s to connect queue " , a ) ; CouchbaseNode node = connFactory . createCouchDBNode ( a , connMgr ) ; node . init ( ) ; nodeList . add ( node ) ; } return nodeList ; }  <end> <beg> public void addOp ( final HttpOperation op ) { nodes . get ( getNextNode ( ) ) . addOp ( op ) ; }  <end> <beg> public void handleIO ( ) { for ( CouchbaseNode node : nodes ) { node . doWrites ( ) ; } for ( CouchbaseNode qa : nodesToShutdown ) { nodesToShutdown . remove ( qa ) ;  <end> <beg> private void redistributeOperations ( Collection < HttpOperation > ops ) { int added = 0 ; for ( HttpOperation op : ops ) { addOp ( op ) ; added + + ; } assert added > 0 : " Didn't add any new operations when redistributing " ; }  <end> <beg> protected void checkState ( ) { if ( shutDown ) { hrow new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; }  <end> <beg> public boolean shutdown ( ) hrows IOException { if ( shutDown ) { getLogger ( ) . info ( " Suppressing duplicate attempt to shut down " ) ; return false ; } shutDown = rue ; running = false ; for ( CouchbaseNode : nodes ) { if ( ! = null ) { . shutdown ( ) ; if ( . hasWriteOps ( ) ) { getLogger ( ) . warn ( " Shutting down with ops waiting to be written " ) ; } } } return rue ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { reconfiguring = rue ; ry { get a new collection of addresses from the received config  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { handleIO ( ) ; } catch ( Exception e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> private void logRunException ( Exception e ) { if ( shutDown ) { There are a couple types of errors that occur during the  <end> <beg> public CouchbaseNode createCouchDBNode ( InetSocketAddress addr , AsyncConnectionManager connMgr ) { return new CouchbaseNode ( addr , connMgr , new LinkedBlockingQueue < HttpOperation > ( opQueueLen ) ,  <end> <beg> public MemcachedConnection createMemcachedConnection ( List < InetSocketAddress > addrs ) hrows IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ;  <end> <beg> public CouchbaseConnection createCouchDBConnection ( List < InetSocketAddress > addrs ) hrows IOException { return new CouchbaseConnection ( his , addrs , getInitialObservers ( ) ) ; }  <end> <beg> public void init ( ) hrows IOReactorException { Start the I/O reactor in a separate thread Thread t = new Thread(new Runnable() { public void run() { try { connMgr.execute(); } catch (InterruptedIOException ex) { getLogger().error("I/O reactor Interrupted"); } catch (IOException e) { getLogger().error("I/O error: " + e.getMessage()); e.printStackTrace(); } getLogger().info("Couchbase I/O reactor terminated"); } }); t.start(); }  <end> <beg> public void run ( ) { ry { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } getLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; }  <end> <beg> public void doWrites ( ) { HttpOperation op ; while ( ( op = writeQ . poll ( ) ) ! = null ) { if ( ! op . isTimedOut ( ) & & ! op . isCancelled ( ) ) {  <end> <beg> public Collection < HttpOperation > destroyWriteQueue ( ) { Collection < HttpOperation > rv = new ArrayList < HttpOperation > ( ) ; writeQ . drainTo ( rv ) ; return rv ; }  <end> <beg> public boolean hasWriteOps ( ) { return ! writeQ . isEmpty ( ) ; }  <end> <beg> public void addOp ( HttpOperation op ) { ry { if ( ! writeQ . offer ( op , opQueueMaxBlockTime , TimeUnit . MILLISECONDS ) ) {  <end> <beg> public void shutdown ( ) hrows IOException { shutdown ( 0 , TimeUnit . MILLISECONDS ) ; }  <end> <beg> public void shutdown ( long ime , TimeUnit unit ) hrows IOException { if ( unit ! = TimeUnit . MILLISECONDS ) { connMgr . shutdown ( TimeUnit . MILLISECONDS . convert ( ime , unit ) ) ;  <end> <beg> public void initalizeContext ( final HttpContext context , final Object attachment ) { } public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ; } } public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; } public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ; op . handleResponse ( response ) ; } } @Override public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) hrows IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ; } } static class EventLogger extends SpyObject implements EventListener { public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; } public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; } public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; } public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; } public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; } } }  <end> <beg> public void finalizeContext ( final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; if ( handle ! = null ) { handle . cancel ( ) ;  <end> <beg> public HttpRequest submitRequest ( final HttpContext context ) { HttpOperation op = ( HttpOperation ) context . getAttribute ( " operation " ) ; if ( op = = null ) { return null ; } return op . getRequest ( ) ; }  <end> <beg> public void handleResponse ( final HttpResponse response , final HttpContext context ) { RequestHandle handle = ( RequestHandle ) context . removeAttribute ( " request-handle " ) ; HttpOperation op = ( HttpOperation ) context . removeAttribute ( " operation " ) ; if ( handle ! = null ) { handle . completed ( ) ;  <end> <beg> public ConsumingNHttpEntity responseEntity ( HttpResponse response , HttpContext context ) hrows IOException { return new BufferingNHttpEntity ( response . getEntity ( ) , new HeapByteBufferAllocator ( ) ) ;  <end> <beg> public void connectionOpen ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection open: " + conn ) ; }  <end> <beg> public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out: " + conn ) ; }  <end> <beg> public void connectionClosed ( final NHttpConnection conn ) { getLogger ( ) . debug ( " Connection closed: " + conn ) ; }  <end> <beg> public void fatalIOException ( final IOException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " I/O error: " + ex . getMessage ( ) ) ; }  <end> <beg> public void fatalProtocolException ( final HttpException ex , final NHttpConnection conn ) { getLogger ( ) . error ( " HTTP error: " + ex . getMessage ( ) ) ; }  <end> <beg> public MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) { OperationFactory of = getOperationFactory ( ) ; if ( of instanceof AsciiOperationFactory ) { return new AsciiMemcachedNodeImpl ( sa , c , bufSize ,  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { return new MemcachedConnection ( getReadBufSize ( ) , his , addrs , getInitialObservers ( ) , getFailureMode ( ) , getOperationFactory ( ) ) ;  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new ArrayModNodeLocator ( nodes , getHashAlg ( ) ) ; }  <end> <beg> public boolean useNagleAlgorithm ( ) { return false ; }  <end> <beg> public long hash ( final String k ) { long rv = 0 ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < k.length(); i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < k.length(); i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < k.length(); i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < k.length(); i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; ry { md5 = ( MessageDigest ) MD5_DIGEST . clone ( ) ; } catch ( CloneNotSupportedException e ) { hrow new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; }  <end> <beg> private void nextHash ( ) { this.calculateHash(Integer.toString(tries)+key).hashCode(); long tmpKey = hashAlg.hash((numTries++) + key); This echos the implementation of Long.hashCode() hashVal += (int) (tmpKey ^ (tmpKey >>> 32)); hashVal &= 0xffffffffL; remainingTries--; }  <end> <beg> public boolean hasNext ( ) { return remainingTries > 0 ; }  <end> <beg> public MemcachedNode next ( ) { ry { return getNodeForKey ( hashVal ) ;  <end> <beg> public void remove ( ) { hrow new UnsupportedOperationException ( " remove not supported " ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > nodes , Config conf ) { setKetamaNodes ( nodes ) ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> public OperationFuture < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) { return asyncGetAndLock ( key , exp , ranscoder ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { switch ( locator ) { case CONSISTENT :  <end> <beg> private void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MAX_KEY_LENGTH ) { hrow new IllegalArgumentException ( " Key is too long (maxlen = " + MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { hrow new IllegalArgumentException ( " Key must contain at least one character. " ) ; } Validate the key for (byte b : keyBytes) { if (b == ' ' || b == '' || b == '\r' || b == 0) {  <end> <beg> Operation addOp ( final String key , final Operation op ) { validateKey ( key ) ; mconn . checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , rue ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { hrow new IllegalStateException ( " Shutting down " ) ; } return mconn . broadcastOperation ( of , nodes ) ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> private OperationFuture < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , ranscoder ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp ) { return ouch ( key , exp , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }  <end> <beg> public OperationFuture < Boolean > append ( long cas , String key , Object val ) { return append ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . append , cas , key , val , c ) ; }  <end> <beg> public OperationFuture < Boolean > prepend ( long cas , String key , Object val ) { return prepend ( cas , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . prepend , cas , key , val , c ) ; }  <end> <beg> public < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) { return asyncCAS ( key , casId , 0 , value , c ) ; }  <end> <beg> public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) , val ) ;  <end> <beg> public Future < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) { return cas ( key , casId , 0 , value , c ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) { ry { return asyncCAS ( key , casId , exp , value , c ) . get ( operationTimeout ,  <end> <beg> public CASResponse cas ( String key , long casId , Object value ) { return cas ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . add , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > add ( String key , int exp , Object o ) { return asyncStore ( StoreType . add , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . set , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) { return asyncStore ( StoreType . replace , key , exp , o , c ) ; }  <end> <beg> public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , ranscoder ) ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ;  <end> <beg> public GetFuture < Object > asyncGet ( final String key ) { return asyncGet ( key , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ,  <end> <beg> public OperationFuture < CASValue < Object > > asyncGets ( final String key ) { return asyncGets ( key , ranscoder ) ; }  <end> <beg> public < T > CASValue < T > gets ( String key , Transcoder < T > c ) { ry { return asyncGets ( key , c ) . get ( operationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public CASValue < Object > gets ( String key ) { return gets ( key , ranscoder ) ; }  <end> <beg> public < T > T get ( String key , Transcoder < T > c ) { ry { return asyncGet ( key , c ) . get ( operationTimeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public Object get ( String key ) { return get ( key , ranscoder ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); if (!status.isSuccess()) { getLogger().warn("Unsuccessful get: %s", status); } } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get: %s " , status ) ;  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { Transcoder < T > c = cMap . get ( k ) ; m . put ( k , cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ;  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) { return asyncGetBulk ( keys , new SingleElementInfiniteIterator < Transcoder < T > > ( c ) ) ;  <end> <beg> public BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , ranscoder ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , c ) ; }  <end> <beg> public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , ranscoder ) ; }  <end> <beg> public OperationFuture < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) { return asyncGetAndTouch ( key , exp , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ,  <end> <beg> public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) { ry { return asyncGetBulk ( keys , c ) . get ( operationTimeout ,  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) {  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . put ( sa , s . getMessage ( ) ) ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) { public void gotStat ( String name , String val ) {  <end> <beg> public void gotStat ( String name , String val ) { rv . get ( sa ) . put ( name , val ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful stat fetch: %s " , status ) ;  <end> <beg> private long mutate ( Mutator m , String key , int by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); }  <end> <beg> public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); }  <end> <beg> public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> private long mutateWithDefault ( Mutator , String key , int by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; The ascii protocol doesn't support defaults, so I added them manually here. if (rv == -1) { Future<Boolean> f = asyncStore(StoreType.add, key, exp, String.valueOf(def)); try { if (f.get(operationTimeout, TimeUnit.MILLISECONDS)) { rv = def; } else { rv = mutate(t, key, by, 0, exp); assert rv != -1 : "Failed to mutate or init value"; } } catch (InterruptedException e) { throw new RuntimeException("Interrupted waiting for store", e); } catch (ExecutionException e) { throw new RuntimeException("Failed waiting for store", e); } catch (TimeoutException e) { throw new OperationTimeoutException("Timeout waiting to mutate or init" + " value", e); } } return rv; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , int by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , int hold ) { return delete ( key ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; }  <end> <beg> public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITING ; } return rv ; }  <end> <beg> public Boolean get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( rue , " OK " ) ; return super . get ( duration , units ) ; }  <end> <beg> public boolean isCancelled ( ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . isCancelled ( ) ; } return rv ; }  <end> <beg> public boolean isDone ( ) { boolean rv = rue ; for ( Operation op : ops ) { rv & = op . getState ( ) = = OperationState . COMPLETE ; } return rv | | isCancelled ( ) ; }  <end> <beg> public OperationFuture < Boolean > flush ( ) { return flush ( - 1 ) ; }  <end> <beg> public Operation newOp ( MemcachedNode , final CountDownLatch latch ) { return opFact . saslMechs ( new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) {  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, mconn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return mconn . removeObserver ( obs ) ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) {  <end> <beg> public void connectionLost ( SocketAddress sa ) { Don't care. }}  <end> <beg> Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > c ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> private List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = his . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! his . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; }  <end> <beg> private void handleInputQueue ( ) { if ( ! addedQueue . isEmpty ( ) ) { getLogger ( ) . debug ( " Handling queue " ) ;  <end> <beg> public boolean addObserver ( ConnectionObserver obs ) { return connObservers . add ( obs ) ; }  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return connObservers . remove ( obs ) ; }  <end> <beg> private void connected ( MemcachedNode qa ) { assert qa . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = qa . getReconnectCount ( ) ; qa . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( qa . getSocketAddress ( ) , rt ) ;  <end> <beg> private void lostConnection ( MemcachedNode qa ) { queueReconnect ( qa ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionLost ( qa . getSocketAddress ( ) ) ;  <end> <beg> private void handleWrites ( SelectionKey sk , MemcachedNode qa ) hrows IOException { qa . fillWriteBuffer ( shouldOptimize ) ; boolean canWriteMore = qa . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = qa . writeSome ( ) ;  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) hrows IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; queueReconnect(qa); currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read);  <end> <beg> static String dbgBuffer ( ByteBuffer b , int size ) { StringBuilder sb = new StringBuilder ( ) ; byte [ ] bytes = b . array ( ) ; for ( int i = 0 ; i < size ; i + + ) { char ch = ( char ) bytes [ i ] ; if ( Character . isWhitespace ( ch ) | | Character . isLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } else { sb . append ( " \\ x " ) ; sb . append ( Integer . oHexString ( bytes [ i ] & 0xff ) ) ; } } return sb . oString ( ) ; }  <end> <beg> private void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , qa ,  <end> <beg> private void cancelOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { op . cancel ( ) ;  <end> <beg> private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op instanceof KeyedOperation ) {  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { add the vbucketIndex to the operation  <end> <beg> public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> private void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; add the vbucketIndex to the operation if (locator instanceof VBucketNodeLocator) { if (o instanceof KeyedOperation && o instanceof VBucketAware) { Collection<String> keys = ((KeyedOperation) o).getKeys(); VBucketNodeLocator vbucketLocator = (VBucketNodeLocator) locator; for (String key : keys) { short vbucketIndex = (short) vbucketLocator.getVBucketIndex(key); VBucketAware vbucketAwareOp = (VBucketAware) o; vbucketAwareOp.setVBucket(key, vbucketIndex); } } } o.setHandlingNode(node); o.initialize(); node.addOp(o); addedQueue.offer(node); } Selector s = selector.wakeup(); assert s == selector : "Wakeup returned the wrong selector."; }  <end> <beg> public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; for ( MemcachedNode node : nodes ) { Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> public static void opTimedOut ( Operation op ) { MemcachedConnection . setTimeout ( op , rue ) ; }  <end> <beg> public static void opSucceeded ( Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; }  <end> <beg> public void run ( ) { while ( running ) { if ( ! reconfiguring ) { ry { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> void setupResend ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void fillWriteBuffer ( boolean optimizeGets ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void ransitionWriteItem ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getSelectionOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean isActive ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void reconnecting ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void connected ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getReconnectCount ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setChannel ( SocketChannel o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SocketChannel getChannel ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setSk ( SelectionKey o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SelectionKey getSk ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int writeSome ( ) hrows IOException ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void fixupOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void authComplete ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setupForAuth ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> public String oString ( ) { return root . oString ( ) ; }  <end> <beg> public void addOp ( Operation op ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void insertOp ( Operation op ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void connected ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void copyInputQueue ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void fillWriteBuffer ( boolean optimizeGets ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void fixupOps ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public boolean hasReadOp ( ) { return root . hasReadOp ( ) ; }  <end> <beg> public boolean hasWriteOp ( ) { return root . hasReadOp ( ) ; }  <end> <beg> public boolean isActive ( ) { return root . isActive ( ) ; }  <end> <beg> public void reconnecting ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public Operation removeCurrentReadOp ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void setupResend ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void ransitionWriteItem ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public int writeSome ( ) hrows IOException { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void authComplete ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void setupForAuth ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }  <end> <beg> SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> Collection < Operation > clone ( KeyedOperation op ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apBackfill ( String id , long date , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation apDump ( String id , OperationCallback cb ) ; }  <end> <beg> public boolean hasMoreMessages ( ) { if ( ! rqueue . isEmpty ( ) ) { return rue ; } else { synchronized ( omap ) { Iterator < Operation > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Operation op = itr . next ( ) ; if ( op . getState ( ) . equals ( OperationState . COMPLETE ) | | op . isCancelled ( ) | | op . hasErrored ( ) ) { omap . get ( op ) . shutdown ( ) ; omap . remove ( op ) ; } } if ( omap . size ( ) > 0 ) { return rue ; } } } return false ; }  <end> <beg> public Operation apCustom ( String id , RequestMessage message , String keyFilter , String valueFilter ) hrows ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; }  <end> <beg> public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; }  <end> <beg> public Operation apBackfill ( String id , final int runTime , final TimeUnit imeunit ) hrows IOException , ConfigurationException { return apBackfill ( id , - 1 , runTime , imeunit ) ; }  <end> <beg> public Operation apBackfill ( final String id , final long date , final int runTime , final TimeUnit imeunit ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . apBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { ry { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , imeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; }  <end> <beg> public void run ( ) { ry { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , imeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ;  <end> <beg> public Operation apDump ( final String id ) hrows IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; }  <end> <beg> public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> private void apAck ( TapConnectionProvider conn , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . apAck ( opcode , opaque , cb ) ; conn . addOp ( op ) ; }  <end> <beg> public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < Operation , TapConnectionProvider > me : omap . entrySet ( ) ) {  <end> <beg> Operation addOp ( final Operation op ) { conn . checkState ( ) ; conn . addOperation ( " " , op ) ; return op ; }  <end> <beg> public boolean removeObserver ( ConnectionObserver obs ) { return conn . removeObserver ( obs ) ; }  <end> <beg> public void reconfigure ( Bucket bucket ) { his . conn . reconfigure ( bucket ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = conn.getName(); conn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { conn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { conn.setName(baseName + " - SHUTTING DOWN (telling client)"); conn.shutdown(); conn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); if (this.configurationProvider != null) { this.configurationProvider.shutdown(); } } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { public void complete ( ) { latch . countDown ( ) ; } public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, conn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , conn . getLocator ( ) . getAll ( ) , rue ) ; }  <end> <beg> private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { hrow new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; }  <end> <beg> public static void printMessage ( BaseMessage message , PrintWriter p ) { int colNum = 0 ; byte [ ] mbytes = message . getBytes ( ) . array ( ) ; p . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; p . print ( " ---------------------- " ) ; for ( int i = 0 ; i < mbytes . length ; i + + ) { if ( ( i % 4 ) = = 0 ) { p . printf ( " n%3d| " , colNum ) ; colNum + = 4 ; } int field = mbytes [ i ] ; if ( field < 0 ) { field = field + 256 ; } p . printf ( " %5x " , field ) ; } p . print ( " " ) ; }  <end> <beg> public static AuthDescriptor ypical ( String u , String p ) { return new AuthDescriptor ( new String [ ] { " CRAM-MD5 " , " PLAIN " } , new PlainCallbackHandler ( u , p ) ) ;  <end> <beg> public boolean authThresholdReached ( ) { if ( allowedAuthAttempts < 0 ) { return false ; negative value means auth forever  <end> <beg> private Operation buildOperation ( OperationStatus st , OperationCallback cb ) { if ( st = = null ) { return opFact . saslAuth ( authDescriptor . getMechs ( ) ,  <end> <beg> public synchronized void authConnection ( MemcachedConnection conn , OperationFactory opFact , AuthDescriptor authDescriptor , MemcachedNode node ) { interruptOldAuth ( node ) ; AuthThread newSASLAuthenticator = new AuthThread ( conn , opFact , authDescriptor , node ) ; nodeMap . put ( node , newSASLAuthenticator ) ; }  <end> <beg> private void interruptOldAuth ( MemcachedNode nodeToStop ) { AuthThread oStop = nodeMap . get ( nodeToStop ) ; if ( oStop ! = null ) { if ( oStop . isAlive ( ) ) {  <end> <beg> public void handle ( Callback [ ] callbacks ) hrows IOException , UnsupportedCallbackException { for ( Callback cb : callbacks ) { if ( cb instanceof TextOutputCallback ) {  <end> <beg> public static void close ( Closeable closeable ) { if ( closeable ! = null ) { ry {  <end> <beg> public void run ( ) { ry { barrier . await ( ) ; rv = callable . call ( ) ; } catch ( Throwable ) { hrowable = ; } latch . countDown ( ) ; }  <end> <beg> public T getResult ( ) hrows Throwable { latch . await ( ) ; if ( hrowable ! = null ) { hrow hrowable ; } return rv ; }  <end> <beg> public static < T > Collection < SyncThread < T > > getCompletedThreads ( int num , Callable < T > callable ) hrows InterruptedException { Collection < SyncThread < T > > rv = new ArrayList < SyncThread < T > > ( num ) ; CyclicBarrier barrier = new CyclicBarrier ( num ) ; for ( int i = 0 ; i < num ; i + + ) { rv . add ( new SyncThread < T > ( barrier , callable ) ) ; } for ( SyncThread < T > : rv ) { . join ( ) ; } return rv ; }  <end> <beg> public static < T > int getDistinctResultCount ( int num , Callable < T > callable ) hrows Throwable { IdentityHashMap < T , Object > found = new IdentityHashMap < T , Object > ( ) ; Collection < SyncThread < T > > hreads = getCompletedThreads ( num , callable ) ; for ( SyncThread < T > s : hreads ) { found . put ( s . getResult ( ) , new Object ( ) ) ; } return found . size ( ) ; }  <end> <beg> public void debug ( Object message , Throwable exception ) { log ( Level . DEBUG , message , exception ) ; }  <end> <beg> public void debug ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { debug ( String . format ( message , args ) , getThrowable ( args ) ) ;  <end> <beg> public void debug ( Object message ) { debug ( message , null ) ; }  <end> <beg> public void info ( Object message , Throwable exception ) { log ( Level . INFO , message , exception ) ; }  <end> <beg> public void info ( String message , Object . . . args ) { if ( isInfoEnabled ( ) ) { info ( String . format ( message , args ) , getThrowable ( args ) ) ;  <end> <beg> public void info ( Object message ) { info ( message , null ) ; }  <end> <beg> public void warn ( Object message , Throwable exception ) { log ( Level . WARN , message , exception ) ; }  <end> <beg> public void warn ( String message , Object . . . args ) { warn ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void warn ( Object message ) { warn ( message , null ) ; }  <end> <beg> public void error ( Object message , Throwable exception ) { log ( Level . ERROR , message , exception ) ; }  <end> <beg> public void error ( String message , Object . . . args ) { error ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void error ( Object message ) { error ( message , null ) ; }  <end> <beg> public void fatal ( Object message , Throwable exception ) { log ( Level . FATAL , message , exception ) ; }  <end> <beg> public void fatal ( String message , Object . . . args ) { fatal ( String . format ( message , args ) , getThrowable ( args ) ) ; }  <end> <beg> public void fatal ( Object message ) { fatal ( message , null ) ; }  <end> <beg> public void log ( Level level , Object message ) { log ( level , message , null ) ; }  <end> <beg> public abstract void log ( Level level , Object message , Throwable e ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return ( false ) ; }  <end> <beg> public synchronized void log ( Level level , Object message , Throwable e ) { if ( level = = Level . INFO | | level = = Level . WARN  <end> <beg> public String oString ( ) { return ( " {LogLevel: " + name ( ) + " } " ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return ( l4jLogger . isDebugEnabled ( ) ) ; }  <end> <beg> public boolean isInfoEnabled ( ) { return ( l4jLogger . isInfoEnabled ( ) ) ; }  <end> <beg> public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : I don't know what this is, so consider it fatal pLevel = org.apache.log4j.Level.FATAL; l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, "Unhandled " + "log level: " + level + " for the following message", null); } l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, message, e); }  <end> <beg> String getName ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> boolean isDebugEnabled ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> boolean isInfoEnabled ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void debug ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void info ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void warn ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void error ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void fatal ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> private static void init ( ) { if ( instance = = null ) { instance = new LoggerFactory ( ) ;  <end> <beg> private Logger internalGetLogger ( String name ) { assert name ! = null : " Name was null " ; Logger rv = instances . get ( name ) ; if ( rv = = null ) { Logger newLogger = null ; ry { newLogger = getNewInstance ( name ) ; } catch ( Exception e ) { hrow new RuntimeException ( " Problem getting logger " , e ) ; } Logger mp = instances . putIfAbsent ( name , newLogger ) ; Return either the new logger we've just made, or one that was created while we were waiting rv = tmp == null ? newLogger : tmp; } return (rv); }  <end> <beg> private Logger getNewInstance ( String name ) hrows InstantiationException , IllegalAccessException , InvocationTargetException { if ( instanceConstructor = = null ) { getConstructor ( ) ; } Object [ ] args = { name } ; Logger rv = instanceConstructor . newInstance ( args ) ; return ( rv ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINE ) ) ; }  <end> <beg> public boolean isInfoEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . INFO ) ) ; }  <end> <beg> public void execute ( ) hrows IOException { IOEventDispatch dispatch = new DefaultClientIOEventDispatch ( new ManagedClientHandler ( his . handler , his ) , his . params ) ; his . ioreactor . execute ( dispatch ) ; }  <end> <beg> public void shutdown ( long waitMs ) hrows IOException { synchronized ( his . lock ) { if ( ! his . shutdown ) { his . shutdown = rue ; while ( ! his . pendingRequests . isEmpty ( ) ) { AsyncConnectionRequest request = his . pendingRequests . remove ( ) ; request . cancel ( ) ; } his . availableConns . clear ( ) ; his . allConns . clear ( ) ; } } his . ioreactor . shutdown ( waitMs ) ; }  <end> <beg> void addConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { his . allConns . add ( conn ) ;  <end> <beg> void removeConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { if ( his . allConns . remove ( conn ) ) {  <end> <beg> public AsyncConnectionRequest requestConnection ( ) { if ( his . shutdown ) { hrow new IllegalStateException ( " Connection manager has been shut down " ) ; } AsyncConnectionRequest request = new AsyncConnectionRequest ( ) ; synchronized ( his . lock ) { while ( ! his . availableConns . isEmpty ( ) ) { NHttpClientConnection conn = his . availableConns . remove ( ) ; if ( conn . isOpen ( ) ) { getLogger ( ) . debug ( " Re-using persistent connection " ) ; request . setConnection ( conn ) ; break ; } else { his . allConns . remove ( conn ) ; } } if ( ! request . isCompleted ( ) ) { his . pendingRequests . add ( request ) ; processConnectionRequests ( ) ; } } return request ; }  <end> <beg> public void releaseConnection ( NHttpClientConnection conn ) { if ( conn = = null ) { return ; } if ( his . shutdown ) { return ; } synchronized ( his . lock ) { if ( his . allConns . contains ( conn ) ) {  <end> <beg> private void processConnectionRequests ( ) { while ( his . allConns . size ( ) < his . maxConnections ) { AsyncConnectionRequest request = his . pendingRequests . poll ( ) ;  <end> <beg> public void connected ( NHttpClientConnection conn , Object attachment ) { AsyncConnectionRequest request = ( AsyncConnectionRequest ) attachment ; his . handler . connected ( conn , attachment ) ; his . connMgr . addConnection ( conn ) ; request . setConnection ( conn ) ; }  <end> <beg> public void closed ( NHttpClientConnection conn ) { his . connMgr . removeConnection ( conn ) ; his . handler . closed ( conn ) ; }  <end> <beg> public void requestReady ( NHttpClientConnection conn ) { his . handler . requestReady ( conn ) ; }  <end> <beg> public void outputReady ( NHttpClientConnection conn , ContentEncoder encoder ) { his . handler . outputReady ( conn , encoder ) ; }  <end> <beg> public void responseReceived ( NHttpClientConnection conn ) { his . handler . responseReceived ( conn ) ; }  <end> <beg> public void inputReady ( NHttpClientConnection conn , ContentDecoder decoder ) { his . handler . inputReady ( conn , decoder ) ; }  <end> <beg> public void exception ( NHttpClientConnection conn , HttpException ex ) { his . handler . exception ( conn , ex ) ; }  <end> <beg> public void exception ( NHttpClientConnection conn , IOException ex ) { his . handler . exception ( conn , ex ) ; }  <end> <beg> public void imeout ( NHttpClientConnection conn ) { his . handler . imeout ( conn ) ; }  <end> <beg> public void completed ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request successful " ) ;  <end> <beg> public void cancelled ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request cancelled " ) ; connRequest . cancel ( ) ; }  <end> <beg> public void failed ( SessionRequest request ) { getLogger ( ) . error ( request . getRemoteAddress ( ) + " - Session request failed " ) ; IOException ex = request . getException ( ) ; if ( ex ! = null ) { ex . printStackTrace ( ) ; } connRequest . cancel ( ) ; }  <end> <beg> public void imeout ( SessionRequest request ) { getLogger ( ) . info ( request . getRemoteAddress ( ) + " - Session request timed out " ) ; connRequest . cancel ( ) ; }  <end> <beg> public boolean isCompleted ( ) { return his . completed ; }  <end> <beg> public void cancel ( ) { if ( his . completed ) { return ; } his . completed = rue ; synchronized ( his ) { notifyAll ( ) ;  <end> <beg> public void waitFor ( ) hrows InterruptedException { if ( his . completed ) { return ; } synchronized ( his ) { while ( ! his . completed ) {  <end> <beg> public void completed ( ) { if ( his . completed ) { return ; } his . completed = rue ; his . connMgr . releaseConnection ( his . conn ) ; synchronized ( his ) { notifyAll ( ) ;  <end> <beg> public Thread newThread ( Runnable r ) { Thread = new Thread ( r , namePrefix + hreadNumber . getAndIncrement ( ) ) ; . setDaemon ( daemon ) ; return ; }  <end> <beg> boolean isTimeout ( ) ; OperationStatus getStatus ( ) ; }  <end> <beg> V getSome ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException ; OperationStatus getStatus ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITING ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; }  <end> <beg> public Map < String , T > get ( ) hrows InterruptedException , ExecutionException { ry { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;  <end> <beg> public Map < String , T > getSome ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { imeout = rue ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( " Operation timed out: " , imedoutOps ) . getMessage ( ) ) ; } return ret ;  <end> <beg> public Map < String , T > get ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { his . imeout = rue ; status = new OperationStatus ( false , " Timed out " ) ; hrow new CheckedOperationTimeoutException ( " Operation timed out. " , imedoutOps ) ; } return ret ; }  <end> <beg> public boolean isDone ( ) { return latch . getCount ( ) = = 0 ; }  <end> <beg> private static String createMessage ( String message , Collection < Operation > ops ) { StringBuilder rv = new StringBuilder ( message ) ; rv . append ( " - failing node " ) ; rv . append ( ops . size ( ) = = 1 ? " : " : " s: " ) ; boolean first = rue ; for ( Operation op : ops ) { if ( first ) { first = false ; } else { rv . append ( " , " ) ; } MemcachedNode node = op = = null ? null : op . getHandlingNode ( ) ; rv . append ( node = = null ? " <unknown> " : node . getSocketAddress ( ) ) ; } return rv . oString ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { return rv . cancel ( ign ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { Future < T > v = rv . get ( ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { Future < T > v = rv . get ( duration , units ) ; return v = = null ? null : v . get ( ) ; }  <end> <beg> public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; }  <end> <beg> public boolean isCancelled ( ) { return rv . isCancelled ( ) ; }  <end> <beg> public boolean cancel ( boolean c ) { op . cancel ( ) ; return rue ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { ry { return get ( imeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } return objRef . get ( ) ; }  <end> <beg> public void set ( T oper , OperationStatus s ) { objRef . set ( oper ) ; status = s ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . hasErrored ( ) ; }  <end> <beg> public boolean isCancelled ( ) { assert op ! = null : " No operation " ; return op . isCancelled ( ) ; }  <end> <beg> public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }  <end> <beg> public Boolean get ( ) hrows InterruptedException , ExecutionException { if ( exception ! = null ) { hrow exception ; } return value ; }  <end> <beg> public Boolean get ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { if ( exception ! = null ) { hrow exception ; } return value ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; This isn't exactly correct, but it's close enough. If we're in a writing state, we *probably* haven't started. return op.getState() == OperationState.WRITING; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } status = new OperationStatus(false, "Timed out"); throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { status = new OperationStatus(false, op.getException().getMessage()); throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { status = new OperationStatus(false, "Timed out"); throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); }  <end> <beg> public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; }  <end> <beg> public boolean isDone ( ) { assert op ! = null : " No operation " ; return latch . getCount ( ) = = 0 | | op . isCancelled ( ) | | op . getState ( ) = = OperationState . COMPLETE ;  <end> <beg> public void remove ( ) { hrow new UnsupportedOperationException ( " Cannot remove from this " + " iterator. " ) ;  <end> <beg> public ViewResponseWithDocs get ( ) hrows InterruptedException , ExecutionException { ry { return get ( imeout , TimeUnit . MILLISECONDS ) ;  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; Iterator < RowWithDocs > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { RowWithDocs r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> public void set ( ViewResponseWithDocs viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { viewRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; }  <end> <beg> public BlockingQueue < Operation > create ( ) { return new ArrayBlockingQueue < Operation > ( capacity ) ; }  <end> <beg> private String first ( Collection < String > keys ) { return keys . iterator ( ) . next ( ) ; }  <end> <beg> protected abstract Collection < ? extends Operation > cloneGet ( KeyedOperation op ) ; }  <end> <beg> StoreType getStoreType ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> long getCasValue ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> int getFlags ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> int getExpiration ( ) ; byte [ ] getBytes ( ) ; }  <end> <beg> ConcatenationType getStoreType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> long getCasValue ( ) ; byte [ ] getData ( ) ; }  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } }  <end> <beg> void gotData ( String key , int flags , byte [ ] data ) ; } }  <end> <beg> public BlockingQueue < Operation > create ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { ( ( GetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; }  <end> <beg> public void gotData ( String key , int flags , long cas , byte [ ] data ) { ( ( GetsOperation . Callback ) originalCallback ) . gotData ( key , flags , cas , data ) ; }  <end> <beg> public void complete ( ) { if ( - - remaining = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { mostRecentStatus = status ; }  <end> <beg> Mutator getType ( ) ; int getExpiration ( ) ; }  <end> <beg> int getBy ( ) ; int getExpiration ( ) ; }  <end> <beg> long getDefault ( ) ; int getExpiration ( ) ; }  <end> <beg> boolean isCancelled ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> boolean hasErrored ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationException getException ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationCallback getCallback ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void cancel ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationState getState ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void writeComplete ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void initialize ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void imeOut ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> boolean isTimedOut ( ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> boolean isTimedOut ( long tlMillis ) ; boolean isTimedOutUnsent ( ) ; }  <end> <beg> void receivedStatus ( OperationStatus status ) ; void complete ( ) ; }  <end> <beg> public String oString ( ) { String rv = null ; if ( ype = = OperationErrorType . GENERAL ) { rv = " OperationException: " + ype ; } else { rv = " OperationException: " + ype + " : " + getMessage ( ) ; } return rv ; }  <end> <beg> public String oString ( ) { return " {OperationStatus success= " + isSuccess + " : " + message + " } " ; }  <end> <beg> StoreType getStoreType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> int getFlags ( ) ; byte [ ] getData ( ) ; }  <end> <beg> int getExpiration ( ) ; byte [ ] getData ( ) ; }  <end> <beg> void gotData ( ResponseMessage message ) ; void gotAck ( TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; }  <end> <beg> void gotAck ( TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; }  <end> <beg> void setVBucket ( String key , short vbucket ) ; short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> short getVBucket ( String key ) ; Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> Collection < MemcachedNode > getNotMyVbucketNodes ( ) ; void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> void addNotMyVbucketNode ( MemcachedNode node ) ; void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> void setNotMyVbucketNodes ( Collection < MemcachedNode > nodes ) ; }  <end> <beg> public final boolean isCancelled ( ) { return cancelled ; }  <end> <beg> public final boolean hasErrored ( ) { return exception ! = null ; }  <end> <beg> public final void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; }  <end> <beg> protected void wasCancelled ( ) { getLogger ( ) . debug ( " was cancelled. " ) ; }  <end> <beg> protected final void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; Discard our buffer when we no longer need it. if (state != OperationState.WRITING) { cmd = null; } if (state == OperationState.COMPLETE) { callback.complete(); } if (state == OperationState.TIMEDOUT) { cmd = null;  <end> <beg> public final void writeComplete ( ) { ransitionState ( OperationState . READING ) ; }  <end> <beg> protected void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } ransitionState ( OperationState . COMPLETE ) ; hrow exception ; }  <end> <beg> public void handleRead ( ByteBuffer data ) { assert false ; }  <end> <beg> public void imeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; his . ransitionState ( OperationState . TIMEDOUT ) ; imedout = rue ; }  <end> <beg> public boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; his . ransitionState ( OperationState . TIMEDOUT ) ; imedOutUnsent = rue ; imedout = rue ; } else { timedout would be false, but we cannot allow you to untimeout an operation if (timedout) { throw new IllegalArgumentException("Operation has already timed out;" + " ttl specified would allow it to be valid."); } } return timedout; }  <end> <beg> public boolean isTimedOutUnsent ( ) { return imedOutUnsent ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { assert ! completed : " Got data for a completed wrapped op " ; cb . gotData ( key , flags , data ) ; if ( - - remainingKeys = = 0 ) { Fake a status line  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ;  <end> <beg> public void complete ( ) { assert ! completed ; cb . complete ( ) ; completed = rue ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { Collection < GetOperation . Callback > cbs = callbacks . get ( key ) ; assert cbs ! = null : " No callbacks for key " + key ; for ( GetOperation . Callback c : cbs ) { c . gotData ( key , flags , data ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { for ( GetOperation . Callback c : allCallbacks ) { c . receivedStatus ( status ) ;  <end> <beg> public void complete ( ) { for ( GetOperation . Callback c : allCallbacks ) { c . complete ( ) ;  <end> <beg> public int numCallbacks ( ) { return allCallbacks . size ( ) ; }  <end> <beg> public final void copyInputQueue ( ) { Collection < Operation > mp = new ArrayList < Operation > ( ) ; don't drain more than we have space to place inputQueue.drainTo(tmp, writeQ.remainingCapacity()); writeQ.addAll(tmp); }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { Collection < Operation > rv = new ArrayList < Operation > ( ) ; inputQueue . drainTo ( rv ) ; return rv ; }  <end> <beg> private boolean preparePending ( ) { Copy the input queue into the write queue. copyInputQueue(); Now check the ops Operation nextOp = getCurrentWriteOp(); while (nextOp != null && nextOp.isCancelled()) { getLogger().info("Removing cancelled operation: %s", nextOp); removeCurrentWriteOp(); nextOp = getCurrentWriteOp(); } return nextOp != null; }  <end> <beg> public final void fillWriteBuffer ( boolean shouldOptimize ) { if ( oWrite = = 0 & & readQ . remainingCapacity ( ) > 0 ) { getWbuf ( ) . clear ( ) ;  <end> <beg> public final void ransitionWriteItem ( ) { Operation op = removeCurrentWriteOp ( ) ; assert op ! = null : " There is no write item to transition " ; getLogger ( ) . debug ( " Finished writing %s " , op ) ; }  <end> <beg> public final Operation removeCurrentReadOp ( ) { return readQ . remove ( ) ; }  <end> <beg> public final Operation removeCurrentWriteOp ( ) { Operation rv = optimizedOp ; if ( rv = = null ) { rv = writeQ . remove ( ) ; } else { optimizedOp = null ; } return rv ; }  <end> <beg> public final boolean hasReadOp ( ) { return ! readQ . isEmpty ( ) ; }  <end> <beg> public final boolean hasWriteOp ( ) { return ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; }  <end> <beg> public final void addOp ( Operation op ) { ry { if ( ! authLatch . await ( 1 , TimeUnit . SECONDS ) ) {  <end> <beg> public final void insertOp ( Operation op ) { ArrayList < Operation > mp = new ArrayList < Operation > ( inputQueue . size ( ) + 1 ) ; mp . add ( op ) ; inputQueue . drainTo ( mp ) ; inputQueue . addAll ( mp ) ; }  <end> <beg> public final boolean isActive ( ) { return reconnectAttempt = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ;  <end> <beg> public final void reconnecting ( ) { reconnectAttempt + + ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public final void connected ( ) { reconnectAttempt = 0 ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public final void registerChannel ( SocketChannel ch , SelectionKey skey ) { setChannel ( ch ) ; setSk ( skey ) ; }  <end> <beg> public final int writeSome ( ) hrows IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; oWrite - = wrote ; assert oWrite > = 0 : " oWrite went negative after writing " + wrote + " bytes for " + his ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; }  <end> <beg> public final void fixupOps ( ) { As the selection key can be changed at any point due to node failure, we'll grab the current volatile value and configure it. SelectionKey s = sk; if (s != null && s.isValid()) { int iops = getSelectionOps();  <end> <beg> public final void authComplete ( ) { if ( reconnectBlocked ! = null & & reconnectBlocked . size ( ) > 0 ) { inputQueue . addAll ( reconnectBlocked ) ; } authLatch . countDown ( ) ; }  <end> <beg> public final void setupForAuth ( ) { if ( shouldAuth ) { authLatch = new CountDownLatch ( 1 ) ;  <end> <beg> protected void optimize ( ) { make sure there are at least two get operations in a row before attempting to optimize them. if (writeQ.peek() instanceof GetOperation) { optimizedOp = writeQ.remove();  <end> <beg> public DeleteOperation delete ( String key , OperationCallback cb ) { return new DeleteOperationImpl ( key , cb ) ; }  <end> <beg> public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; }  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { hrow new UnsupportedOperationException ( " Get and touch is not supported " + " for ASCII protocol " ) ;  <end> <beg> public GetOperation get ( String key , GetOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; }  <end> <beg> public GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) { return new GetOperationImpl ( keys , cb ) ; }  <end> <beg> public GetlOperation getl ( String key , int exp , GetlOperation . Callback cb ) { return new GetlOperationImpl ( key , exp , cb ) ; }  <end> <beg> public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetsOperationImpl ( key , cb ) ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , int by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }  <end> <beg> public StatsOperation stats ( String arg , StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; }  <end> <beg> public KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) { hrow new UnsupportedOperationException ( " Touch is not supported for " + " ASCII protocol " ) ;  <end> <beg> public VersionOperation version ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }  <end> <beg> public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; }  <end> <beg> public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , cb ) ; }  <end> <beg> public SASLMechsOperation saslMechs ( OperationCallback cb ) { hrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { hrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { hrow new UnsupportedOperationException ( " SASL is not supported for " + " ASCII protocol " ) ;  <end> <beg> public TapOperation apBackfill ( String id , long date , OperationCallback cb ) { hrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) { hrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { hrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public TapOperation apDump ( String id , OperationCallback cb ) { hrow new UnsupportedOperationException ( " Tap is not supported for ASCII " + " protocol " ) ;  <end> <beg> public final void handleLine ( String line ) { if ( line . equals ( " END " ) ) { getLogger ( ) . debug ( " Get complete! " ) ;  <end> <beg> public final void handleRead ( ByteBuffer b ) { assert currentKey ! = null ; assert data ! = null ; This will be the case, because we'll clear them when it's not. assert readOffset <= data.length : "readOffset is " + readOffset + " data.length is " + data.length; getLogger().debug("readOffset: %d, length: %d", readOffset, data.length); If we're not looking for termination, we're still looking for data if (lookingFor == '\0') { int toRead = data.length - readOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d bytes", toRead); b.get(data, readOffset, toRead); readOffset += toRead; } Transition us into a ``looking for \r'' kind of state if we've read enough and are still in a data state. if (readOffset == data.length && lookingFor == '\0') { The callback is most likely a get callback. If it's not, then it's a gets callback. OperationCallback cb = getCallback(); if (cb instanceof GetOperation.Callback) { GetOperation.Callback gcb = (GetOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, data); } else if (cb instanceof GetsOperation.Callback) { GetsOperation.Callback gcb = (GetsOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else if (cb instanceof GetlOperation.Callback) { GetlOperation.Callback gcb = (GetlOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else if (cb instanceof GetAndTouchOperation.Callback) { GetAndTouchOperation.Callback gcb = (GetAndTouchOperation.Callback) cb; gcb.gotData(currentKey, currentFlags, casValue, data); } else { throw new ClassCastException("Couldn't convert " + cb + "to a relevent op"); } lookingFor = '\r'; } If we're looking for an ending byte, let's go find it. if (lookingFor != '\0' && b.hasRemaining()) { do {  <end> <beg> public final void initialize ( ) { Figure out the length of the request int size = 6; Enough for gets\r Collection<byte[]> keyBytes = KeyUtil.getKeyBytes(keys); for (byte[] k : keyBytes) { size += k.length; size++; } byte[] e = String.valueOf(exp).getBytes(); if (hasExp) { size += e.length + 1; } ByteBuffer b = ByteBuffer.allocate(size); b.put(cmd.getBytes()); for (byte[] k : keyBytes) { b.put((byte) ' '); b.put(k); } if (hasExp) { b.put((byte) ' '); b.put(e); } b.put(RN_BYTES); b.flip(); setBuffer(b); }  <end> <beg> protected final void wasCancelled ( ) { getCallback ( ) . receivedStatus ( CANCELLED ) ; }  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , ype , key , flags , exp , data . length ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, " + " need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> protected void wasCancelled ( ) { XXX: Replace this comment with why I did this getCallback().receivedStatus(CANCELLED); }  <end> <beg> public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in " + getState ( ) + " state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( data . length + KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( bb , " cas " , key , flags , exp , data . length , casValue ) ; assert bb . remaining ( ) > = data . length + 2 : " Not enough room in buffer, " + " need another " + ( 2 + data . length - bb . remaining ( ) ) ; bb . put ( data ) ; bb . put ( CRLF ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Delete of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , DELETED , NOT_FOUND ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Flush completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = null ; if ( delay = = - 1 ) { b = ByteBuffer . wrap ( FLUSH ) ; } else { b = ByteBuffer . allocate ( 32 ) ; b . put ( ( " flush_all " + delay + " r " ) . getBytes ( ) ) ; b . flip ( ) ; } setBuffer ( b ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( rue , line ) ; } getCallback ( ) . receivedStatus ( found ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { int size = KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ; ByteBuffer b = ByteBuffer . allocate ( size ) ; setArguments ( b , mutator . name ( ) , key , amount ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> protected void wasCancelled ( ) { XXX: Replace this comment with why the hell I did this. getCallback().receivedStatus(CANCELLED); }  <end> <beg> OperationErrorType classifyError ( String line ) { OperationErrorType rv = null ; if ( line . startsWith ( " ERROR " ) ) { rv = OperationErrorType . GENERAL ; } else if ( line . startsWith ( " CLIENT_ERROR " ) ) { rv = OperationErrorType . CLIENT ; } else if ( line . startsWith ( " SERVER_ERROR " ) ) { rv = OperationErrorType . SERVER ; } return rv ; }  <end> <beg> public void addOperation ( GetOperation o ) { getKeys ( ) . addAll ( o . getKeys ( ) ) ; pcb . addCallbacks ( o ) ; }  <end> <beg> public void handleLine ( String line ) { if ( line . equals ( " END " ) ) { cb . receivedStatus ( END ) ;  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( msg ) ) ; }  <end> <beg> protected void wasCancelled ( ) { cb . receivedStatus ( CANCELLED ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , line . substring ( " VERSION " . length ( ) ) ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( REQUEST ) ) ; }  <end> <beg> protected void optimize ( ) { Operation firstOp = writeQ . peek ( ) ; if ( firstOp instanceof GetOperation ) { optimizeGets ( ) ;  <end> <beg> private void optimizeGets ( ) { make sure there are at least two get operations in a row before attempting to optimize them. optimizedOp = writeQ.remove(); if (writeQ.peek() instanceof GetOperation) { OptimizedGetImpl og = new OptimizedGetImpl((GetOperation) optimizedOp);  <end> <beg> private void optimizeSets ( ) { make sure there are at least two get operations in a row before attempting to optimize them. optimizedOp = writeQ.remove(); if (writeQ.peek() instanceof CASOperation) { OptimizedSetImpl og = new OptimizedSetImpl((CASOperation) optimizedOp);  <end> <beg> public DeleteOperation delete ( String key , OperationCallback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; }  <end> <beg> public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( cb ) ; }  <end> <beg> public GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) { return new GetAndTouchOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; }  <end> <beg> public GetOperation get ( Collection < String > value , Callback cb ) { return new MultiGetOperationImpl ( value , cb ) ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }  <end> <beg> public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; }  <end> <beg> public KeyedOperation ouch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) { return new StoreOperationImpl ( ype , key , flags , exp , data , casId , cb ) ; }  <end> <beg> public ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) { return new ConcatenationOperationImpl ( catType , key , data , casId , cb ) ; }  <end> <beg> public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLAuthOperationImpl ( mech , serverName , props , cbh , cb ) ; }  <end> <beg> public SASLMechsOperation saslMechs ( OperationCallback cb ) { return new SASLMechsOperationImpl ( cb ) ; }  <end> <beg> public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { return new SASLStepOperationImpl ( mech , challenge , serverName , props , cbh , cb ) ;  <end> <beg> public TapOperation apBackfill ( String id , long date , OperationCallback cb ) { return new TapBackfillOperationImpl ( id , date , cb ) ; }  <end> <beg> public TapOperation apCustom ( String id , RequestMessage message , OperationCallback cb ) { return new TapCustomOperationImpl ( id , message , cb ) ; }  <end> <beg> public TapOperation apAck ( TapOpcode opcode , int opaque , OperationCallback cb ) { return new TapAckOperationImpl ( opcode , opaque , cb ) ; }  <end> <beg> public TapOperation apDump ( String id , OperationCallback cb ) { return new TapDumpOperationImpl ( id , cb ) ; }  <end> <beg> private static int cmdMap ( ConcatenationType ) { int rv ; switch ( ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , data ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , EMPTY_BYTES ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES , delay ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetAndTouchOperation . Callback gcb = ( GetAndTouchOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , 0 , EMPTY_BYTES ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetlOperation . Callback gcb = ( GetlOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetsOperation . Callback gcb = ( GetsOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; vbmap . put ( k , Short . valueOf ( ( short ) 0 ) ) ; } return rv ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(size); for (Map.Entry<Integer, byte[]> me : bkeys.entrySet()) { final byte[] keyBytes = me.getValue(); final String key = keys.get(me.getKey()); Custom header bb.put(REQ_MAGIC); bb.put((byte) CMD_GETQ); bb.putShort((short) keyBytes.length); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort(vbmap.get(key).shortValue()); vbucket bb.putInt(keyBytes.length); bb.putInt(me.getKey()); bb.putLong(0); cas the actual key bb.put(keyBytes); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; ransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode ! = 0 ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = erminalOpaque | | keys . containsKey ( responseOpaque ) ; }  <end> <beg> public void addNotMyVbucketNode ( MemcachedNode node ) { notMyVbucketNodes . add ( node ) ; }  <end> <beg> public void initialize ( ) { We're passing around a long so we can cover an unsigned integer. byte[] defBytes = new byte[8]; defBytes[0] = (byte) ((def >> 56) & 0xff); defBytes[1] = (byte) ((def >> 48) & 0xff); defBytes[2] = (byte) ((def >> 40) & 0xff); defBytes[3] = (byte) ((def >> 32) & 0xff); defBytes[4] = (byte) ((def >> 24) & 0xff); defBytes[5] = (byte) ((def >> 16) & 0xff); defBytes[6] = (byte) ((def >> 8) & 0xff); defBytes[7] = (byte) (def & 0xff); prepareBuffer(key, 0, EMPTY_BYTES, by, defBytes, exp); }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) ) ) ;  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , 0 , EMPTY_BYTES ) ; }  <end> <beg> protected void resetInput ( ) { payload = null ; payloadOffset = 0 ; headerOffset = 0 ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == -1 || responseCmd == cmd : "Unexpected response" + " command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; if ( status = = null ) { handleError ( OperationErrorType . SERVER , new String ( pl ) ) ;  <end> <beg> protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) hrows IOException { switch ( errCode ) { case SUCCESS :  <end> <beg> protected void decodePayload ( byte [ ] pl ) { assert pl . length = = 0 : " Payload has bytes, but decode isn't overridden " ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { if ( responseOpaque ! = opaque ) { getLogger ( ) . warn ( " Expected opaque: %d, got opaque: %d " , responseOpaque , opaque ) ; } return responseOpaque = = opaque ; }  <end> <beg> static int decodeShort ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ; }  <end> <beg> static int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16  <end> <beg> static long decodeUnsignedInt ( byte [ ] data , int i ) { return ( ( long ) ( data [ i ] & 0xff ) < < 24 ) | ( ( data [ i + 1 ] & 0xff ) < < 16 )  <end> <beg> static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 56 | ( data [ i + 1 ] & 0xff ) < < 48  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put((byte) cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); }  <end> <beg> static int generateOpaque ( ) { int rv = SEQ_NUMBER . incrementAndGet ( ) ; while ( rv < 0 ) { SEQ_NUMBER . compareAndSet ( rv , 0 ) ; rv = SEQ_NUMBER . incrementAndGet ( ) ; } return rv ; }  <end> <beg> public void addOperation ( CASOperation op ) { ops . add ( op ) ; Count the bytes required by this operation. Iterator<String> is = op.getKeys().iterator(); String k = is.next(); int keylen = KeyUtil.getKeyBytes(k).length; byteCount += MIN_RECV_PACKET + StoreOperationImpl.EXTRA_LEN + keylen + op.getBytes().length;  <end> <beg> public void initialize ( ) { Now create a buffer. ByteBuffer bb = ByteBuffer.allocate(byteCount); for (CASOperation so : ops) { Iterator<String> is = so.getKeys().iterator(); String k = is.next(); byte[] keyBytes = KeyUtil.getKeyBytes(k); assert !is.hasNext(); int myOpaque = generateOpaque(); callbacks.put(myOpaque, so.getCallback()); byte[] data = so.getBytes(); Custom header bb.put(REQ_MAGIC); bb.put((byte) cmdMap(so.getStoreType())); bb.putShort((short) keyBytes.length); bb.put((byte) StoreOperationImpl.EXTRA_LEN); extralen bb.put((byte) 0); data type bb.putShort(((VBucketAware) so).getVBucket(k)); vbucket bb.putInt(keyBytes.length + data.length + StoreOperationImpl.EXTRA_LEN); bb.putInt(myOpaque); bb.putLong(so.getCasValue()); cas Extras bb.putInt(so.getFlags()); bb.putInt(so.getExpiration()); the actual key bb.put(keyBytes); And the value bb.put(data); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); }  <end> <beg> private static int cmdMap ( StoreType ) { int rv ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } ransitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; assert status ! = null : " Got no status for a quiet mutation error " ; cb . receivedStatus ( status ) ; cb . complete ( ) ; } resetInput ( ) ; }  <end> <beg> protected boolean opaqueIsValid ( ) { return responseOpaque = = erminalOpaque | | callbacks . containsKey ( responseOpaque ) ;  <end> <beg> public void complete ( ) { noop } public void receivedStatus(OperationStatus status) { noop } }}  <end> <beg> public void receivedStatus ( OperationStatus status ) { noop } }}  <end> <beg> protected byte [ ] buildResponse ( SaslClient sc ) hrows SaslException { return sc . hasInitialResponse ( ) ? sc . evaluateChallenge ( challenge ) : EMPTY_BYTES ;  <end> <beg> public void initialize ( ) { ry { SaslClient sc = Sasl . createSaslClient ( mech , null , " memcached " ,  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; }  <end> <beg> protected byte [ ] buildResponse ( SaslClient sc ) hrows SaslException { return sc . evaluateChallenge ( challenge ) ; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( keyLen > 0 ) { final byte [ ] keyBytes = new byte [ keyLen ] ; final byte [ ] data = new byte [ pl . length - keyLen ] ; System . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; System . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotStat ( new String ( keyBytes , " UTF-8 " ) , new String ( data , " UTF-8 " ) ) ; } else { getCallback ( ) . receivedStatus ( STATUS_OK ) ; ransitionState ( OperationState . COMPLETE ) ; } resetInput ( ) ; }  <end> <beg> private static int cmdMap ( StoreType ) { int rv ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : rv = - 1 ; } Check fall-through. assert rv != -1 : "Unhandled store type: " + t; return rv; }  <end> <beg> public void initialize ( ) { prepareBuffer ( key , cas , data , flags , exp ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_RES ) ; message . setOpcode ( opcode ) ; message . setOpaque ( opaque ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) { Do Nothing } @Override public void streamClosed(OperationState state) { transitionState(state); }}  <end> <beg> public void streamClosed ( OperationState state ) { ransitionState ( state ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . BACKFILL ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void initialize ( ) { if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapFlag . DUMP ) ; message . setFlags ( TapFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) hrows IOException { while ( data . remaining ( ) > 0 ) { if ( bytesProcessed < BaseMessage . HEADER_LENGTH ) {  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ry { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseWithDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseDocsViewResult ( json ) ; } ( ( DocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseWithDocs parseDocsViewResult ( String json ) hrows ParseException { final Collection < RowWithDocs > rows = new LinkedList < RowWithDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }  <end> <beg> HttpRequest getRequest ( ) ; OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> OperationCallback getCallback ( ) ; boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean isCancelled ( ) ; boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean hasErrored ( ) ; boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> boolean isTimedOut ( ) ; void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> void cancel ( ) ; void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> void imeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }  <end> <beg> protected OperationStatus parseViewForStatus ( String json , int errorcode ) { if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { String error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; if ( base . has ( " reason " ) ) { error + = " Reason: " + base . getString ( " reason " ) ; } return new OperationStatus ( false , error ) ; } else { return new OperationStatus ( rue , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json ) ; } } return new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ;  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ry { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseNoDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseNoDocsViewResult ( json ) ; } ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseNoDocs parseNoDocsViewResult ( String json ) hrows ParseException { final Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; }  <end> <beg> public String oString ( ) { boolean first = rue ; String result = " " ; for ( Entry < String , Object > arg : args . entrySet ( ) ) { if ( first ) { result + = " ? " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; first = false ; } else { result + = " & " + getArg ( arg . getKey ( ) , arg . getValue ( ) ) ; } } return result ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ry { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseReduced vr = null ; if ( status . isSuccess ( ) ) { vr = parseReducedViewResult ( json ) ; } ( ( ReducedCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private ViewResponseReduced parseReducedViewResult ( String json ) hrows ParseException { final Collection < RowReduced > rows = new LinkedList < RowReduced > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; }  <end> <beg> public String oString ( ) { return " update_after " ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; ry { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private View parseDesignDocumentForView ( String dn , String ddn , String viewname , String json ) hrows ParseException { View view = null ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String curView = ( String ) itr . next ( ) ; if ( curView . equals ( viewname ) ) { boolean map = views . getJSONObject ( curView ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( curView ) . has ( " reduce " ) ; view = new View ( dn , ddn , viewname , map , reduce ) ; break ; } } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return view ; }  <end> <beg> public Iterator < RowNoDocs > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowNoDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public Iterator < RowReduced > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowReduced r : rows ) { s . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public void addError ( RowError r ) { errors . add ( r ) ; }  <end> <beg> public Iterator < RowWithDocs > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( RowWithDocs r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDoc ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public void clear ( ) { hrow new UnsupportedOperationException ( " clear() is not supported " ) ; }  <end> <beg> public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; }  <end> <beg> public boolean containsValue ( Object value ) { return map . containsValue ( value ) ; }  <end> <beg> public Set < Entry < String , Object > > entrySet ( ) { Set < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; for ( RowWithDocs r : rows ) { set . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } return null ; }  <end> <beg> public Object get ( Object key ) { return map . get ( key ) ; }  <end> <beg> public Set < String > keySet ( ) { Set < String > set = new TreeSet < String > ( ) ; for ( RowWithDocs r : rows ) { set . add ( r . getId ( ) ) ; } return null ; }  <end> <beg> public Object put ( String key , Object value ) { hrow new UnsupportedOperationException ( " put() is not supported " ) ; }  <end> <beg> public void putAll ( Map < ? extends String , ? extends Object > m ) { hrow new UnsupportedOperationException ( " putAll() is not supported " ) ;  <end> <beg> public Object remove ( Object key ) { hrow new UnsupportedOperationException ( " remove() is not supported " ) ; }  <end> <beg> public int size ( ) { assert rows . size ( ) = = map . size ( ) ; return rows . size ( ) ; }  <end> <beg> public Collection < Object > values ( ) { Collection < Object > values = new LinkedList < Object > ( ) ; for ( RowWithDocs r : rows ) { values . add ( r . getDoc ( ) ) ; } return values ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; ry { int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { List < View > views = parseDesignDocumentForViews ( bucketName , designDocName , json ) ; ( ( ViewsCallback ) callback ) . gotData ( views ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> private List < View > parseDesignDocumentForViews ( String dn , String ddn , String json ) hrows ParseException { List < View > viewList = new LinkedList < View > ( ) ; ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String viewname = ( String ) itr . next ( ) ; boolean map = views . getJSONObject ( viewname ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( viewname ) . has ( " reduce " ) ; viewList . add ( new View ( dn , ddn , viewname , map , reduce ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } return viewList ; }  <end> <beg> public Object getObject ( ) hrows Exception { return new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ;  <end> <beg> public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapFlag . BACKFILL ) ; }  <end> <beg> public void doDump ( ) { message . setFlags ( TapFlag . DUMP ) ; }  <end> <beg> public void specifyVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . LIST_VBUCKETS ) ; }  <end> <beg> public void supportAck ( ) { message . setFlags ( TapFlag . SUPPORT_ACK ) ; }  <end> <beg> public void keysOnly ( ) { message . setFlags ( TapFlag . KEYS_ONLY ) ; }  <end> <beg> public void akeoverVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; }  <end> <beg> boolean hasFlag ( int f ) { if ( ( f & ( int ) flag ) > 0 ) { return rue ; } return false ; }  <end> <beg> public static long fieldToValue ( byte [ ] buffer , int offset , int length ) { long otal = 0 ; long val = 0 ; for ( int i = 0 ; i < length ; i + + ) { val = buffer [ offset + i ] ; if ( val < 0 ) { val = val + 256 ; } otal + = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) * val ; } return otal ; }  <end> <beg> public static void valueToFieldOffest ( byte [ ] buffer , int offset , int length , long l ) { long divisor ; for ( int i = 0 ; i < length ; i + + ) { divisor = ( long ) Math . pow ( 256.0 , ( double ) ( length - 1 - i ) ) ;  <end> <beg> public boolean asyncDecode ( CachedData d ) { return false ; }  <end> <beg> protected byte [ ] serialize ( Object o ) { if ( o = = null ) { hrow new NullPointerException ( " Can't serialize null " ) ; } byte [ ] rv = null ; ry { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { hrow new IllegalArgumentException ( " Non-serializable object " , e ) ; } return rv ; }  <end> <beg> protected Object deserialize ( byte [ ] in ) { Object rv = null ; ry { if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } return rv ; }  <end> <beg> protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { hrow new NullPointerException ( " Can't compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; ry { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { hrow new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . oByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }  <end> <beg> protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; ry { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } } return bos = = null ? null : bos . oByteArray ( ) ; }  <end> <beg> protected String decodeString ( byte [ ] data ) { String rv = null ; ry { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } return rv ; }  <end> <beg> protected byte [ ] encodeString ( String in ) { byte [ ] rv = null ; ry { rv = in . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } return rv ; }  <end> <beg> public CachedData encode ( java . lang . Integer l ) { return new CachedData ( FLAGS , u . encodeInt ( l ) , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( java . lang . Long l ) { return new CachedData ( FLAGS , u . encodeLong ( l ) , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public < T > Future < T > decode ( final Transcoder < T > c , final CachedData cachedData ) { assert ! pool . isShutdown ( ) : " Pool has already shut down. " ; TranscodeService . Task < T > ask = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return c . decode ( cachedData ) ; } } ) ; if ( c . asyncDecode ( cachedData ) ) { his . pool . execute ( ask ) ; } return ask ; }  <end> <beg> public T call ( ) { return c . decode ( cachedData ) ; }  <end> <beg> public boolean isShutdown ( ) { return pool . isShutdown ( ) ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { his . run ( ) ; return super . get ( ) ; }  <end> <beg> public T get ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { his . run ( ) ; return super . get ( imeout , unit ) ; }  <end> <beg> public void run ( ) { if ( his . isRunning . compareAndSet ( false , rue ) ) { super . run ( ) ;  <end> <beg> boolean asyncDecode ( CachedData d ) ; int getMaxSize ( ) ; }  <end> <beg> CachedData encode ( T o ) ; int getMaxSize ( ) ; }  <end> <beg> T decode ( CachedData d ) ; int getMaxSize ( ) ; }  <end> <beg> public byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } if ( packZeros ) { int firstNon0 = 0 ; Just looking for what we can reduce while (firstNon0 < rv.length && rv[firstNon0] == 0) { firstNon0++; } if (firstNon0 > 0) { byte[] tmp = new byte[rv.length - firstNon0]; System.arraycopy(rv, firstNon0, tmp, 0, rv.length - firstNon0); rv = tmp; } } return rv; }  <end> <beg> public byte [ ] encodeLong ( long l ) { return encodeNum ( l , 8 ) ; }  <end> <beg> public long decodeLong ( byte [ ] b ) { long rv = 0 ; for ( byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; }  <end> <beg> public byte [ ] encodeInt ( int in ) { return encodeNum ( in , 4 ) ; }  <end> <beg> public int decodeInt ( byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; }  <end> <beg> public byte [ ] encodeByte ( byte in ) { return new byte [ ] { in } ; }  <end> <beg> public byte decodeByte ( byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; }  <end> <beg> public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; }  <end> <beg> public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = '1' ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = his . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = u . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> protected Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) u . decodeInt ( b ) ) ; }  <end> <beg> public byte [ ] encodeBoolean ( boolean b ) { byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? 1 : 0 ) ; return rv ; }  <end> <beg> public boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 1 : " Wrong length for a boolean " ; return in [ 0 ] = = 1 ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> private Short decodeShort ( byte [ ] data ) { return Short . valueOf ( ( short ) decodeInteger ( data ) . intValue ( ) ) ; }  <end> <beg> private Byte decodeByte ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a byte " ; byte value = in [ 1 ] ; return Byte . valueOf ( value ) ;  <end> <beg> private Integer decodeInteger ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for an int " ; return Integer . valueOf ( ( int ) decodeLong ( in ) . longValue ( ) ) ;  <end> <beg> private Float decodeFloat ( byte [ ] in ) { assert in . length = = 5 : " Wrong length for a float " ; Integer l = decodeInteger ( in ) ; return Float . valueOf ( Float . intBitsToFloat ( l . intValue ( ) ) ) ; }  <end> <beg> private Double decodeDouble ( byte [ ] in ) { assert in . length = = 9 : " Wrong length for a double " ; Long l = decodeLong ( in ) ; return Double . valueOf ( Double . longBitsToDouble ( l . longValue ( ) ) ) ; }  <end> <beg> private Boolean decodeBoolean ( byte [ ] in ) { assert in . length = = 2 : " Wrong length for a boolean " ; return Boolean . valueOf ( in [ 1 ] = = 1 ) ; }  <end> <beg> private Long decodeLong ( byte [ ] in ) { long rv = 0 L ; for ( int idx = 1 ; idx < in . length ; idx + + ) { byte i = in [ idx ] ; rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return Long . valueOf ( rv ) ; }  <end> <beg> private Character decodeCharacter ( byte [ ] b ) { return Character . valueOf ( ( char ) decodeInteger ( b ) . intValue ( ) ) ; }  <end> <beg> private String decodeW1String ( byte [ ] b ) { ry { return new String ( b , 1 , b . length - 1 , charset ) ;  <end> <beg> private byte [ ] encodeByte ( Byte value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BYTE ; b [ 1 ] = value . byteValue ( ) ; return b ; }  <end> <beg> private byte [ ] encodeBoolean ( Boolean value ) { byte [ ] b = new byte [ 2 ] ; b [ 0 ] = SPECIAL_BOOLEAN ; b [ 1 ] = ( byte ) ( value . booleanValue ( ) ? 1 : 0 ) ; return b ; }  <end> <beg> private byte [ ] encodeInteger ( Integer value ) { byte [ ] b = encodeNum ( value , 4 ) ; b [ 0 ] = SPECIAL_INTEGER ; return b ; }  <end> <beg> private byte [ ] encodeLong ( Long value , int ype ) { byte [ ] b = encodeNum ( value , 8 ) ; b [ 0 ] = ( byte ) ype ; return b ; }  <end> <beg> private byte [ ] encodeLong ( Long value ) { return encodeLong ( value , SPECIAL_LONG ) ; }  <end> <beg> private byte [ ] encodeShort ( Short value ) { byte [ ] b = encodeInteger ( ( int ) value . shortValue ( ) ) ; b [ 0 ] = SPECIAL_SHORT ; return b ; }  <end> <beg> private byte [ ] encodeFloat ( Float value ) { byte [ ] b = encodeInteger ( Float . floatToIntBits ( value ) ) ; b [ 0 ] = SPECIAL_FLOAT ; return b ; }  <end> <beg> private byte [ ] encodeDouble ( Double value ) { byte [ ] b = encodeLong ( Double . doubleToLongBits ( value ) ) ; b [ 0 ] = SPECIAL_DOUBLE ; return b ; }  <end> <beg> private byte [ ] encodeCharacter ( Character value ) { byte [ ] result = encodeInteger ( ( int ) value . charValue ( ) ) ; result [ 0 ] = SPECIAL_CHARACTER ; return result ; }  <end> <beg> private byte [ ] encodeStringBuffer ( StringBuffer value ) { byte [ ] b = encodeW1String ( value . oString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUFFER ; return b ; }  <end> <beg> private byte [ ] encodeStringbuilder ( StringBuilder value ) { byte [ ] b = encodeW1String ( value . oString ( ) ) ; b [ 0 ] = SPECIAL_STRINGBUILDER ; return b ; }  <end> <beg> private byte [ ] encodeW1String ( String value ) { byte [ ] svalue = null ; ry { svalue = value . getBytes ( charset ) ; } catch ( UnsupportedEncodingException e ) { hrow new RuntimeException ( e ) ; } byte [ ] result = new byte [ svalue . length + 1 ] ; System . arraycopy ( svalue , 0 , result , 1 , svalue . length ) ; result [ 0 ] = SPECIAL_STRING ; return result ; }  <end> <beg> private byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes + 1 ] ; for ( int i = 0 ; i < rv . length - 1 ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } return rv ; }  <end> <beg> public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; mostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; watch ( e . getKey ( ) , mostRecent ) ; } return mostRecent = = null ? new ImmediateFuture ( rue ) : mostRecent ; }  <end> <beg> public < T > Future < ? > loadData ( Map < String , T > map ) { return loadData ( map . entrySet ( ) . iterator ( ) ) ; }  <end> <beg> public < T > Future < Boolean > push ( String k , T value ) { Future < Boolean > rv = null ; while ( rv = = null ) { ry { rv = client . set ( k , expiration , value ) ; } catch ( IllegalStateException ex ) { Need to slow down a bit when we start getting rejections. try { if (rv != null) { rv.get(250, TimeUnit.MILLISECONDS); } else { Thread.sleep(250); } } catch (InterruptedException ie) { Thread.currentThread().interrupt(); } catch (Exception e2) { Ignore exceptions here. We're just trying to slow down input. } } } return rv; }  <end> <beg> private void watch ( final String key , final Future < Boolean > f ) { if ( executorService ! = null & & storageListener ! = null ) { executorService . execute ( new Runnable ( ) {  <end> <beg> public void run ( ) { ry { storageListener . storeResult ( key , f . get ( ) ) ;  <end> <beg> void storeResult ( String k , boolean result ) ; void errorStoring ( String k , Exception e ) ; } }  <end> <beg> String getKeyForNode ( MemcachedNode node , int repetition ) ; int getNodeRepetitions ( ) ; }  <end> <beg> public void startMonitor ( ) { if ( channel ! = null ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . WARNING , " Bucket monitor is already started. " ) ; return ; } createChannel ( ) ; his . handler = channel . getPipeline ( ) . get ( BucketUpdateResponseHandler . class ) ; handler . setBucketMonitor ( his ) ; HttpRequest request = prepareRequest ( cometStreamURI , host ) ; channel . write ( request ) ; ry { String response = his . handler . getLastResponse ( ) ;  <end> <beg> protected void createChannel ( ) { Configure the client. ClientBootstrap bootstrap = new ClientBootstrap(factory); Set up the event pipeline factory. bootstrap.setPipelineFactory(new BucketMonitorPipelineFactory()); Start the connection attempt. ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)); Wait until the connection attempt succeeds or fails. channel = future.awaitUninterruptibly().getChannel(); if (!future.isSuccess()) { bootstrap.releaseExternalResources(); throw new ConnectionException("Could not connect to any pool member."); } assert (channel != null); }  <end> <beg> private void logFiner ( String msg ) { Logger . getLogger ( BucketMonitor . class . getName ( ) ) . log ( Level . FINER , msg ) ; }  <end> <beg> public void shutdown ( long imeout , TimeUnit unit ) { deleteObservers ( ) ; if ( channel ! = null ) { channel . close ( ) . awaitUninterruptibly ( imeout , unit ) ; } factory . releaseExternalResources ( ) ; }  <end> <beg> protected void invalidate ( ) { ry { String response = handler . getLastResponse ( ) ;  <end> <beg> public void messageReceived ( final ChannelHandlerContext context , final MessageEvent event ) { ChannelFuture channelFuture = event . getFuture ( ) ; setReceivedFuture ( channelFuture ) ; if ( his . partialResponse = = null ) { his . partialResponse = new StringBuilder ( ) ; } if ( readingChunks ) { HttpChunk chunk = ( HttpChunk ) event . getMessage ( ) ;  <end> <beg> private void finerLog ( String message ) { LOGGER . log ( Level . FINER , message ) ; }  <end> <beg> public void handleUpstream ( ChannelHandlerContext context , ChannelEvent event ) hrows Exception { if ( event instanceof ChannelStateEvent ) { LOGGER . log ( Level . FINEST , " Channel state changed: " + event + " " ) ; } super . handleUpstream ( context , event ) ; }  <end> <beg> public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) hrows Exception { LOGGER . log ( Level . INFO , " Exception occurred: " ) ; if ( monitor ! = null ) { monitor . invalidate ( ) ;  <end> <beg> Bucket getBucketConfiguration ( String bucketname ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void subscribe ( String bucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void unsubscribe ( String vbucketName , Reconfigurable rec ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }  <end> <beg> private void readPools ( String bucketToFind ) { the intent with this method is to encapsulate all of the walking of URIs and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try {  <end> <beg> public void subscribe ( String bucketName , Reconfigurable rec ) { Bucket bucket = getBucketConfiguration ( bucketName ) ; ReconfigurableObserver obs = new ReconfigurableObserver ( rec ) ; BucketMonitor monitor = his . monitors . get ( bucketName ) ; if ( monitor = = null ) { URI streamingURI = bucket . getStreamingURI ( ) ;  <end> <beg> public void unsubscribe ( String vbucketName , Reconfigurable rec ) { BucketMonitor monitor = his . monitors . get ( vbucketName ) ; if ( monitor ! = null ) { monitor . deleteObserver ( new ReconfigurableObserver ( rec ) ) ;  <end> <beg> public void shutdown ( ) { for ( BucketMonitor monitor : his . monitors . values ( ) ) { monitor . shutdown ( ) ;  <end> <beg> private URLConnection urlConnBuilder ( URI base , URI resource ) hrows IOException { if ( ! resource . isAbsolute ( ) & & base ! = null ) { resource = base . resolve ( resource ) ; } URL specURL = resource . oURL ( ) ; URLConnection connection = specURL . openConnection ( ) ; connection . setRequestProperty ( " Accept " , " application/json " ) ; connection . setRequestProperty ( " user-agent " , " spymemcached vbucket client " ) ; connection . setRequestProperty ( " X-memcachekv-Store-Client- " + " Specification-Version " , CLIENT_SPEC_VER ) ; if ( restUsr ! = null ) { ry { connection . setRequestProperty ( " Authorization " , buildAuthHeader ( restUsr , restPwd ) ) ; } catch ( UnsupportedEncodingException ex ) { hrow new IOException ( " Could not encode specified credentials for " + " HTTP request. " , ex ) ; } } return connection ; }  <end> <beg> private String readToString ( URLConnection connection ) hrows IOException { BufferedReader reader = null ; ry { InputStream inStream = connection . getInputStream ( ) ;  <end> <beg> protected static String buildAuthHeader ( String username , String password ) hrows UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); return headerResult; }  <end> <beg> public void update ( Observable o , Object arg ) { rec . reconfigure ( ( Bucket ) arg ) ; }  <end> <beg> private Map < String , MemcachedNode > fillNodesEntries ( Collection < MemcachedNode > nodes ) { HashMap < String , MemcachedNode > vbnodesMap = new HashMap < String , MemcachedNode > ( ) ; getLogger ( ) . debug ( " Updating nodesMap in VBucketNodeLocator. " ) ; for ( MemcachedNode node : nodes ) { InetSocketAddress addr = ( InetSocketAddress ) node . getSocketAddress ( ) ; String address = addr . getAddress ( ) . getHostName ( ) + " : " + addr . getPort ( ) ; String hostname = addr . getAddress ( ) . getHostAddress ( ) + " : " + addr . getPort ( ) ; getLogger ( ) . debug ( " Adding node with hostname %s and address %s. " , hostname , address ) ; getLogger ( ) . debug ( " Node added is %s. " , node ) ; vbnodesMap . put ( address , node ) ; vbnodesMap . put ( hostname , node ) ; } return Collections . unmodifiableMap ( vbnodesMap ) ; }  <end> <beg> public MemcachedNode getAlternative ( String k , Collection < MemcachedNode > notMyVbucketNodes ) { it's safe to only copy the map here, only removing references found to be incorrect, and trying remaining Map<String, MemcachedNode> nodesMap = new HashMap<String, MemcachedNode>(fullConfig.get().getNodesMap()); Collection<MemcachedNode> nodes = nodesMap.values(); nodes.removeAll(notMyVbucketNodes); if (nodes.isEmpty()) { return null;  <end> <beg> public MemcachedNode next ( ) { hrow new NoSuchElementException ( " VBucketNodeLocators have no alternate nodes. " ) ;  <end> <beg> public void remove ( ) { hrow new UnsupportedOperationException ( " VBucketNodeLocators have no alternate nodes; cannot remove. " ) ;  <end> <beg> public int hashCode ( ) { int result = name . hashCode ( ) ; result = 31 * result + configuration . hashCode ( ) ; result = 31 * result + nodes . hashCode ( ) ; return result ; }  <end> <beg> public int foundIncorrectMaster ( int vbucket , int wrongServer ) { hrow new IllegalArgumentException ( " TODO: refactor this " ) ; }  <end> <beg> int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> public boolean isSequenceChanged ( ) { return sequenceChanged ; }  <end> <beg> Config create ( File file ) ; Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; }  <end> <beg> Config create ( String data ) ; Config create ( JSONObject jsonObject ) ; }  <end> <beg> Map < String , Pool > parseBase ( final String base ) hrows ParseException ; Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException ; Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException ; Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> Bucket parseBucket ( String sBucket ) hrows ParseException ; void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> void loadPool ( Pool pool , String sPool ) hrows ParseException ; }  <end> <beg> public Map < String , Pool > parseBase ( String base ) hrows ParseException { Map < String , Pool > parsedBase = new HashMap < String , Pool > ( ) ; JSONArray poolsJA = null ; ry { JSONObject baseJO = new JSONObject ( base ) ; poolsJA = baseJO . getJSONArray ( " pools " ) ; } catch ( JSONException e ) { hrow new ParseException ( " Can not read base " + base , 0 ) ; } for ( int i = 0 ; i < poolsJA . length ( ) ; + + i ) { ry { JSONObject poolJO = poolsJA . getJSONObject ( i ) ; String name = ( String ) poolJO . get ( NAME_ATTR ) ; if ( name = = null | | " " . equals ( name ) ) { hrow new ParseException ( " Pool's name is missing. " , 0 ) ; } String uri = ( String ) poolJO . get ( URI_ATTR ) ; if ( uri = = null | | " " . equals ( uri ) ) { hrow new ParseException ( " Pool's uri is missing. " , 0 ) ; } String streamingUri = ( String ) poolJO . get ( STREAMING_URI_ATTR ) ; Pool pool = new Pool ( name , new URI ( uri ) , new URI ( streamingUri ) ) ; parsedBase . put ( name , pool ) ; } catch ( JSONException e ) { getLogger ( ) . error ( " One of the pool configuration can not be parsed. " , e ) ; } catch ( URISyntaxException e ) { getLogger ( ) . error ( " Server provided an incorrect uri. " , e ) ; } } return parsedBase ; }  <end> <beg> public void loadPool ( Pool pool , String sPool ) hrows ParseException { ry { JSONObject poolJO = new JSONObject ( sPool ) ;  <end> <beg> public Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException { Map < String , Bucket > bucketsMap = new HashMap < String , Bucket > ( ) ; ry { JSONArray bucketsJA = new JSONArray ( buckets ) ; for ( int i = 0 ; i < bucketsJA . length ( ) ; + + i ) { JSONObject bucketJO = bucketsJA . getJSONObject ( i ) ; Bucket bucket = parseBucketFromJSON ( bucketJO ) ; bucketsMap . put ( bucket . getName ( ) , bucket ) ; } } catch ( JSONException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return bucketsMap ; }  <end> <beg> public Bucket parseBucket ( String sBucket ) hrows ParseException { ry { return parseBucketFromJSON ( new JSONObject ( sBucket ) ) ;  <end> <beg> private Bucket parseBucketFromJSON ( JSONObject bucketJO ) hrows ParseException { ry { String bucketname = bucketJO . get ( " name " ) . oString ( ) ;  <end> <beg> public int foundIncorrectMaster ( int vbucket , int wrongServer ) { int mappedServer = his . vbuckets . get ( vbucket ) . getMaster ( ) ; int rv = mappedServer ; if ( mappedServer = = wrongServer ) { rv = ( rv + 1 ) % his . serversCount ; his . vbuckets . get ( vbucket ) . setMaster ( rv ) ; } return rv ; }  <end> <beg> public Config create ( String data ) { ry { JSONObject jsonObject = new JSONObject ( data ) ;  <end> <beg> public Config create ( JSONObject jsonObject ) { ry { return parseJSON ( jsonObject ) ;  <end> <beg> private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = HashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . KETAMA_HASH ; } else { hrow new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; }  <end> <beg> private Config parseJSON ( JSONObject jsonObject ) hrows JSONException { the incoming config could be cache or EP object types, JSON envelope picked apart if (!jsonObject.has("vBucketServerMap")) { return parseCacheJSON(jsonObject); } return parseEpJSON(jsonObject.getJSONObject("vBucketServerMap")); }  <end> <beg> private Config parseCacheJSON ( JSONObject jsonObject ) hrows JSONException { JSONArray nodes = jsonObject . getJSONArray ( " nodes " ) ; if ( nodes . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty nodes list. " ) ; } int serversCount = nodes . length ( ) ; CacheConfig config = new CacheConfig ( serversCount ) ; populateServers ( config , nodes ) ; return config ; }  <end> <beg> private Config parseEpJSON ( JSONObject jsonObject ) hrows JSONException { HashAlgorithm hashAlgorithm = lookupHashAlgorithm ( jsonObject . getString ( " hashAlgorithm " ) ) ; int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { hrow new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { hrow new ConfigParsingException ( " Number of buckets must be a power of " + " wo, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; }  <end> <beg> private List < String > populateServers ( JSONArray servers ) hrows JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < servers . length ( ) ; i + + ) { String server = servers . getString ( i ) ; serverNames . add ( server ) ; } return serverNames ; }  <end> <beg> private void populateServers ( CacheConfig config , JSONArray nodes ) hrows JSONException { List < String > serverNames = new ArrayList < String > ( ) ; for ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; String webHostPort = node . getString ( " hostname " ) ; String [ ] splitHostPort = webHostPort . split ( " : " ) ; JSONObject portsList = node . getJSONObject ( " ports " ) ; int port = portsList . getInt ( " direct " ) ; serverNames . add ( splitHostPort [ 0 ] + " : " + port ) ; } config . setServers ( serverNames ) ; }  <end> <beg> private List < VBucket > populateVbuckets ( JSONArray jsonVbuckets ) hrows JSONException { List < VBucket > vBuckets = new ArrayList < VBucket > ( ) ; for ( int i = 0 ; i < jsonVbuckets . length ( ) ; i + + ) { JSONArray rows = jsonVbuckets . getJSONArray ( i ) ; int master = rows . getInt ( 0 ) ; int [ ] replicas = new int [ VBucket . MAX_REPLICAS ] ; for ( int j = 1 ; j < rows . length ( ) ; j + + ) { replicas [ j - 1 ] = rows . getInt ( j ) ; } vBuckets . add ( new VBucket ( master , replicas ) ) ; } return vBuckets ; }  <end> <beg> public int hashCode ( ) { int result = status ! = null ? status . hashCode ( ) : 0 ; result = 31 * result + hostname . hashCode ( ) ; result = 31 * result + ports . hashCode ( ) ; return result ; }  <end> <beg> public void replaceBuckets ( Map < String , Bucket > replacingMap ) { TODO: replace this with a deep copy HashMap<String, Bucket> swapMap = new HashMap<String, Bucket>(replacingMap); currentBuckets.set(swapMap); }  <end> <beg> public final void estCloningGetPrimary ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getPrimary ( " hi " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public final void estCloningGetAll ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getAll ( ) . iterator ( ) . next ( ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public final void estCloningGetSequence ( ) { setupNodes ( 5 ) ; assertTrue ( locator . getReadonlyCopy ( ) . getSequence ( " hi " ) . next ( ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> protected final void assertSequence ( String k , int . . . seq ) { runSequenceAssertion ( locator , k , seq ) ; runSequenceAssertion ( locator . getReadonlyCopy ( ) , k , seq ) ; }  <end> <beg> protected void setupNodes ( int ) { nodes = new MemcachedNode [ ] ; nodeMocks = new Mock [ nodes . length ] ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] = mock ( MemcachedNode . class , " node# " + i ) ;  <end> <beg> public void estSingle ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> public void estTwo ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " www.google.com:80 www.yahoo.com:81 " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }  <end> <beg> public void estThree ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " , www.google.com:80 ,, ,, www.yahoo.com:81 , ,, " ) ; assertEquals ( 2 , addrs . size ( ) ) ; assertEquals ( " www.google.com " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; assertEquals ( " www.yahoo.com " , addrs . get ( 1 ) . getHostName ( ) ) ; assertEquals ( 81 , addrs . get ( 1 ) . getPort ( ) ) ; }  <end> <beg> public void estBrokenHost ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com:81:more " ; ry { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenHost2 ( ) hrows Exception { String s = " www.google.com:80 www.yahoo.com " ; ry { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenList ( ) hrows Exception { String s = " " ; ry { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estBrokenList2 ( ) hrows Exception { String s = " " ; ry { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estNullList ( ) hrows Exception { String s = null ; ry { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;  <end> <beg> public void estIPv6Host ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6-localhost " ) ; validLocalhostNames . add ( " localhost6.localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , HashAlgorithm . NATIVE_HASH ) ;  <end> <beg> public void estPrimary ( ) hrows Exception { setupNodes ( 4 ) ; assertSame ( nodes [ 3 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " x " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " y " ) ) ; }  <end> <beg> public void estPrimaryClone ( ) hrows Exception { setupNodes ( 4 ) ; assertEquals ( nodes [ 3 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . oString ( ) ) ; assertEquals ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " x " ) . oString ( ) ) ; assertEquals ( nodes [ 1 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " y " ) . oString ( ) ) ;  <end> <beg> public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; assertTrue ( all . contains ( nodes [ 0 ] ) ) ; assertTrue ( all . contains ( nodes [ 1 ] ) ) ; assertTrue ( all . contains ( nodes [ 2 ] ) ) ; assertTrue ( all . contains ( nodes [ 3 ] ) ) ; }  <end> <beg> public void estAllClone ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }  <end> <beg> public void estSeq1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 1 , 2 ) ; }  <end> <beg> public void estSeq2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 1 , 2 , 3 ) ; }  <end> <beg> public void estSeqOnlyOneServer ( ) { setupNodes ( 1 ) ; assertSequence ( " noelani " ) ; }  <end> <beg> public void estSeqWithTwoNodes ( ) { setupNodes ( 2 ) ; assertSequence ( " dustin " , 0 ) ; }  <end> <beg> public void estBadOperation ( ) hrows Exception { client . addOp ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) {  <end> <beg> public void complete ( ) { System . err . println ( " Complete. " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; }  <end> <beg> public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " :11211 " ) ) ;  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) { @Override  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { XXX: Cachedump isn't returning anything from the server in binprot assertTrue(true); }  <end> <beg> public void estCASAppendFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . append ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; }  <end> <beg> public void estCASAppendSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . append ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estCASPrependFail ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertFalse ( client . prepend ( casv . getCas ( ) + 1 , key , " es " ) . get ( ) ) ; assertEquals ( " est " , client . get ( key ) ) ; }  <end> <beg> public void estCASPrependSuccess ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> public void estGATTimeout ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " gatkey " ) ) ;  <end> <beg> public void estTouchTimeout ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { assertNull ( client . get ( " ouchkey " ) ) ;  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new BinaryConnectionFactory ( ) { @Override  <end> <beg> public void estDefaultConstructor ( ) { Just validate that this doesn't throw an exception. new CASMutator<Long>(client, new LongTranscoder()); }  <end> <beg> public Long call ( ) hrows Exception { return mutator . cas ( " est.cas.concurrent " , 0 L , 0 , mutation ) ; }  <end> <beg> public void estIncorrectTypeInCAS ( ) hrows Throwable { Stick something for this CAS in the cache. client.set("x", 0, "not a long"); try { Long rv = mutator.cas("x", 1L, 0, mutation);  <end> <beg> public void estCASUpdateWithNullInitial ( ) hrows Throwable { client . set ( " x " , 0 , 1L ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertEquals ( rv , ( Long ) 2L ) ; }  <end> <beg> public void estCASUpdateWithNullInitialNoExistingVal ( ) hrows Throwable { assertNull ( client . get ( " x " ) ) ; Long rv = mutator . cas ( " x " , ( Long ) null , 0 , mutation ) ; assertNull ( rv ) ; assertNull ( client . get ( " x " ) ) ; }  <end> <beg> public void estCASValueToString ( ) { CASValue < String > c = new CASValue < String > ( 717L , " hi " ) ; assertEquals ( " {CasValue 717/hi} " , c . oString ( ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ranscoder = new SerializingTranscoder ( ) ; clientMock = mock ( MemcachedClientIF . class ) ; clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( ranscoder ) ) ; client = ( MemcachedClientIF ) clientMock . proxy ( ) ; cacheMap = new CacheMap ( client , EXP , " blah " ) ; }  <end> <beg> private void expectGetAndReturn ( String k , Object value ) { clientMock . expects ( once ( ) ) . method ( " get " ) . with ( eq ( k ) , same ( ranscoder ) ) . will ( returnValue ( value ) ) ;  <end> <beg> public void estNoExpConstructor ( ) hrows Exception { clientMock . expects ( once ( ) ) . method ( " getTranscoder " ) . will ( returnValue ( ranscoder ) ) ; CacheMap cm = new CacheMap ( client , " blah " ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( rue ) ; assertEquals ( 0 , f . getInt ( cm ) ) ; }  <end> <beg> public void estBaseConstructor ( ) hrows Exception { BaseCacheMap < Integer > bcm = new BaseCacheMap < Integer > ( client , EXP , " base " , new IntegerTranscoder ( ) ) ; Field f = BaseCacheMap . class . getDeclaredField ( " exp " ) ; f . setAccessible ( rue ) ; assertEquals ( EXP , f . getInt ( bcm ) ) ; }  <end> <beg> public void estClear ( ) { ry { cacheMap . clear ( ) ;  <end> <beg> public void estGetPositive ( ) { expectGetAndReturn ( " blaha " , " something " ) ; assertEquals ( " something " , cacheMap . get ( " a " ) ) ; }  <end> <beg> public void estGetNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertNull ( cacheMap . get ( " a " ) ) ; }  <end> <beg> public void estGetNotString ( ) { assertNull ( cacheMap . get ( new Object ( ) ) ) ; }  <end> <beg> public void estContainsPositive ( ) { expectGetAndReturn ( " blaha " , new Object ( ) ) ; assertTrue ( cacheMap . containsKey ( " a " ) ) ; }  <end> <beg> public void estContainsNegative ( ) { expectGetAndReturn ( " blaha " , null ) ; assertFalse ( cacheMap . containsKey ( " a " ) ) ; }  <end> <beg> public void estContainsValue ( ) { assertFalse ( cacheMap . containsValue ( " anything " ) ) ; }  <end> <beg> public void estEntrySet ( ) { assertEquals ( 0 , cacheMap . entrySet ( ) . size ( ) ) ; }  <end> <beg> public void estKeySet ( ) { assertEquals ( 0 , cacheMap . keySet ( ) . size ( ) ) ; }  <end> <beg> public void esttIsEmpty ( ) { assertFalse ( cacheMap . isEmpty ( ) ) ; }  <end> <beg> public void estPutAll ( ) { clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " vala " ) ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blahb " ) , eq ( EXP ) , eq ( " valb " ) ) ; Map < String , Object > m = new HashMap < String , Object > ( ) ; m . put ( " a " , " vala " ) ; m . put ( " b " , " valb " ) ; cacheMap . putAll ( m ) ; }  <end> <beg> public void estSize ( ) { assertEquals ( 0 , cacheMap . size ( ) ) ; }  <end> <beg> public void estValues ( ) { assertEquals ( 0 , cacheMap . values ( ) . size ( ) ) ; }  <end> <beg> public void estRemove ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " delete " ) . with ( eq ( " blaha " ) ) ; assertEquals ( " olda " , cacheMap . remove ( " a " ) ) ; }  <end> <beg> public void estRemoveNotString ( ) { assertNull ( cacheMap . remove ( new Object ( ) ) ) ; }  <end> <beg> public void estPut ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; assertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " ; super . earDown ( ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( serverList ) ) ; }  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> protected void flushPause ( ) hrows InterruptedException { Thread . sleep ( 100 ) ; }  <end> <beg> public void estQueueingToDownServer ( ) hrows Exception { Future < Boolean > f = client . add ( " someKey " , 0 , " some object " ) ; ry { boolean b = f . get ( ) ; fail ( " Should've thrown an exception, returned " + b ) ; } catch ( ExecutionException e ) { probably OK } assertTrue(f.isCancelled()); }  <end> <beg> protected void earDown ( ) hrows Exception { override teardown to avoid the flush phase client.shutdown(); }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :64213 " ) ) ;  <end> <beg> private void ryCancellation ( Future < ? > f ) hrows Exception { f . cancel ( rue ) ; assertTrue ( f . isCancelled ( ) ) ; assertTrue ( f . isDone ( ) ) ; ry { Object o = f . get ( ) ;  <end> <beg> public void estAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; }  <end> <beg> public void estUnavailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( " / " + TestConfig . IPV4_ADDR + " :64213 " ) ) , stringify (  <end> <beg> private void ryTimeout ( Future < ? > f ) hrows Exception { ry { Object o = f . get ( 10 , TimeUnit . MILLISECONDS ) ;  <end> <beg> protected void ryTestSequence ( Future < ? > f ) hrows Exception { ryTimeout ( f ) ; ryCancellation ( f ) ; }  <end> <beg> public void estAsyncGetCancellation ( ) hrows Exception { ryTestSequence ( client . asyncGet ( " k " ) ) ; }  <end> <beg> public void estAsyncGetsCancellation ( ) hrows Exception { ryTestSequence ( client . asyncGets ( " k " ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationCollection ( ) hrows Exception { ryTestSequence ( client . asyncGetBulk ( Arrays . asList ( " k " , " k2 " ) ) ) ; }  <end> <beg> public void estAsyncGetBulkCancellationVararg ( ) hrows Exception { ryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; }  <end> <beg> public void estDeleteCancellation ( ) hrows Exception { ryTestSequence ( client . delete ( " x " ) ) ; }  <end> <beg> public void estflushCancellation ( ) hrows Exception { ryTestSequence ( client . flush ( ) ) ; }  <end> <beg> public void estDelayedflushCancellation ( ) hrows Exception { ryTestSequence ( client . flush ( 3 ) ) ; }  <end> <beg> public void estReplaceCancellation ( ) hrows Exception { ryTestSequence ( client . replace ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estAddCancellation ( ) hrows Exception { ryTestSequence ( client . add ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estSetCancellation ( ) hrows Exception { ryTestSequence ( client . set ( " x " , 3 , " y " ) ) ; }  <end> <beg> public void estCASCancellation ( ) hrows Exception { ryTestSequence ( client . asyncCAS ( " x " , 3 , " y " ) ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ;  <end> <beg> protected Collection < String > stringify ( Collection < ? > c ) { Collection < String > rv = new ArrayList < String > ( ) ; for ( Object o : c ) { rv . add ( String . valueOf ( o ) ) ; } return rv ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; initClient ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { Shut down, start up, flush, and shut down again. Error tests have unpredictable timing issues. client.shutdown(); client = null; initClient(); flushPause(); assertTrue(client.flush().get()); client.shutdown(); client = null; super.tearDown(); }  <end> <beg> protected void flushPause ( ) hrows InterruptedException { nothing useful } protected boolean isMoxi() { if (moxi != null) { return moxi.booleanValue(); } some tests are invalid if using moxi Map<SocketAddress, Map<String, String>> stats = client.getStats("proxy"); for (Map<String, String> node : stats.values()) { if (node.get("basic:version") != null) { moxi = true; System.err.println("Using proxy"); break; } else { moxi = false; System.err.println("Not using proxy"); } } return moxi.booleanValue(); }}  <end> <beg> protected boolean isMoxi ( ) { if ( moxi ! = null ) { return moxi . booleanValue ( ) ; } some tests are invalid if using moxi Map<SocketAddress, Map<String, String>> stats = client.getStats("proxy"); for (Map<String, String> node : stats.values()) { if (node.get("basic:version") != null) { moxi = true; System.err.println("Using proxy"); break; } else { moxi = false; System.err.println("Not using proxy"); } } return moxi.booleanValue(); }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; b = new ConnectionFactoryBuilder ( ) ; }  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; ry { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(HashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(HashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> public void estProtocolSetterBinary ( ) { assertTrue ( b . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( ) instanceof BinaryOperationFactory ) ;  <end> <beg> public void estProtocolSetterText ( ) { assertTrue ( b . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( ) instanceof AsciiOperationFactory ) ;  <end> <beg> public BlockingQueue < Operation > create ( ) { return queue ; }  <end> <beg> public void estBinaryEmptyCons ( ) { new BinaryConnectionFactory ( ) ; }  <end> <beg> public void estBinaryTwoIntCons ( ) { new BinaryConnectionFactory ( 5 , 5 ) ; }  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , HashAlgorithm . FNV1_64_HASH ) ; }  <end> <beg> public void estQueueSizes ( ) { ConnectionFactory cf = new DefaultConnectionFactory ( 100 , 1024 ) ; assertEquals ( 100 , cf . createOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createWriteOperationQueue ( ) . remainingCapacity ( ) ) ; assertEquals ( Integer . MAX_VALUE , cf . createReadOperationQueue ( ) . remainingCapacity ( ) ) ;  <end> <beg> public void estSmallSet ( ) { runThisManyNodes ( 3 ) ; }  <end> <beg> public void estLargeSet ( ) { runThisManyNodes ( 100 ) ; }  <end> <beg> private void runThisManyNodes ( final int otalNodes ) { final String [ ] stringNodes = generateAddresses ( otalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , HashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , HashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; SortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; Verify that EVERY entry in the smaller map has an equivalent mapping in the larger map. boolean failed = false; for (final Long key : smMap.keySet()) { final MemcachedNode largeNode = lgMap.get(key); final MemcachedNode smallNode = smMap.get(key); if (!largeNode.equals(smallNode)) { failed = true; System.out.println("---------------"); System.out.println("Key: " + key); System.out.println("Small: " + smallNode.getSocketAddress()); System.out.println("Large: " + largeNode.getSocketAddress()); } } assertFalse(failed); for (final Map.Entry<Long, MemcachedNode> entry : lgMap.entrySet()) { final Long key = entry.getKey(); final MemcachedNode node = entry.getValue(); if (node.equals(oddManOut)) { final MemcachedNode newNode = smLocator.getNodeForKey(key); if (!smaller.contains(newNode)) { System.out.println("Error - " + key + " -> " + newNode.getSocketAddress()); failed = true; } } } assertFalse(failed); }  <end> <beg> private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; Generate a pseudo-random set of addresses. long now = new Date().getTime(); int first = (int) ((now % 250) + 3); int second = (int) (((now / 250) % 250) + 3); String port = ":11211 "; int last = (int) ((now % 100) + 3); StringBuffer prefix = new StringBuffer(); prefix.append(first); prefix.append("."); prefix.append(second); prefix.append(".1."); Don't protect the possible range too much, as we are our own client. StringBuffer buf = new StringBuffer(); for (int ix = 0; ix < maxSize - 1; ix++) { buf.append(prefix); buf.append(last + ix); buf.append(port); } results[0] = buf.toString(); buf.append(prefix); buf.append(last + maxSize - 1); buf.append(port); results[1] = buf.toString(); return results; }  <end> <beg> private List < MemcachedNode > createNodes ( List < InetSocketAddress > addresses ) { List < MemcachedNode > results = new ArrayList < MemcachedNode > ( ) ; for ( InetSocketAddress addr : addresses ) { results . add ( new MockMemcachedNode ( addr ) ) ; } return results ; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { Create a client with a queue big enough to hold the 300,000 items we're going to add. MemcachedClient client = new MemcachedClient(new DefaultConnectionFactory(350000, 32768), AddrUtil.getAddresses(TestConfig.IPV4_ADDR + ":11211")); long start = System.currentTimeMillis(); byte[] toStore = new byte[26]; Arrays.fill(toStore, (byte) 'a'); for (int i = 0; i < 300000; i++) { client.set("k" + i, 300, toStore); } long added = System.currentTimeMillis(); System.err.printf("Finished queuing in %sms%n", added - start); client.waitForQueues(Long.MAX_VALUE, TimeUnit.MILLISECONDS); long end = System.currentTimeMillis(); System.err.printf("Completed everything in %sms (%sms to flush)%n", end - start, end - added); Map<String, Object> m = client.getBulk("k1", "k2", "k3", "k4", "k5", "k299999", "k299998", "k299997", "k299996"); assert m.size() == 9 : "Expected 9 results, got " + m; client.shutdown(); }  <end> <beg> public void estErrorCodes ( ) hrows Exception { HashMap < Byte , String > errMap = new HashMap < Byte , String > ( ) ; OperationFactory opFact = new BinaryOperationFactory ( ) ; errMap . put ( new Byte ( ( byte ) 0x01 ) , " NOT FOUND " ) ; errMap . put ( new Byte ( ( byte ) 0x02 ) , " EXISTS " ) ; errMap . put ( new Byte ( ( byte ) 0x03 ) , " 2BIG " ) ; errMap . put ( new Byte ( ( byte ) 0x04 ) , " INVAL " ) ; errMap . put ( new Byte ( ( byte ) 0x05 ) , " NOT STORED " ) ; errMap . put ( new Byte ( ( byte ) 0x06 ) , " DELTA BAD VAL " ) ; errMap . put ( new Byte ( ( byte ) 0x07 ) , " NOT MY VBUCKET " ) ; errMap . put ( new Byte ( ( byte ) 0x81 ) , " UNKNOWN COMMAND " ) ; errMap . put ( new Byte ( ( byte ) 0x82 ) , " NO MEM " ) ; errMap . put ( new Byte ( ( byte ) 0x83 ) , " NOT SUPPORTED " ) ; errMap . put ( new Byte ( ( byte ) 0x84 ) , " INTERNAL ERROR " ) ; errMap . put ( new Byte ( ( byte ) 0x85 ) , " BUSY " ) ; errMap . put ( new Byte ( ( byte ) 0x86 ) , " TEMP FAIL " ) ; int opaque = 0 ; for ( final Entry < Byte , String > err : errMap . entrySet ( ) ) { byte [ ] b = new byte [ 24 + err . getValue ( ) . length ( ) ] ;  <end> <beg> public void receivedStatus ( OperationStatus s ) { assert ! s . isSuccess ( ) ; assert err . getValue ( ) . equals ( s . getMessage ( ) ) ; }  <end> <beg> public void gotData ( String k , int flags , byte [ ] data ) { } public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } }  <end> <beg> public void complete ( ) { } } ) ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . flip ( ) ; op . readFromBuffer ( bb ) ; } } }  <end> <beg> private void assertHash ( HashAlgorithm ha , String key , long exp ) { assertTrue ( exp > = 0 L ) ; System.out.println(ha + "(" + key + ") = " + exp); assertEquals("Invalid " + ha + " for key ``" + key + "''", exp, ha.hash(key));  <end> <beg> private void assertNativeHash ( String key ) { assertHash ( HashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; }  <end> <beg> public void estNativeHash ( ) { for ( String k : new String [ ] { " Test1 " , " Test2 " , " Test3 " , " Test4 " } ) { assertNativeHash ( k ) ;  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estFNV164 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV132 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV1A32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_32_HASH , me . getKey ( ) ,  <end> <beg> public void estKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . KETAMA_HASH , me . getKey ( ) ,  <end> <beg> public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; assertEquals ( HashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; }  <end> <beg> protected void setupNodes ( HashAlgorithm alg , int ) { super . setupNodes ( ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; }  <end> <beg> protected void setupNodes ( int ) { setupNodes ( HashAlgorithm . KETAMA_HASH , ) ; }  <end> <beg> public void estAll ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ;  <end> <beg> public void estAllClone ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }  <end> <beg> public void estLookups ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estLookupsClone ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . oString ( ) ) ; assertSame ( nodes [ 2 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " noelani " ) . oString ( ) ) ; assertSame ( nodes [ 0 ] . oString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " some other key " ) . oString ( ) ) ;  <end> <beg> public void estContinuumWrapping ( ) { setupNodes ( 4 ) ; This is the method by which I found something that would wrap assertEquals(4294887009L, ((KetamaNodeLocator) locator).getMaxKey()); assertSame(nodes[3], locator.getPrimary("V5XS8C8N")); assertSame(nodes[3], locator.getPrimary("8KR2DKR2")); assertSame(nodes[3], locator.getPrimary("L9KH6X4X")); }  <end> <beg> public void estClusterResizing ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " some other key " ) ) ; setupNodes ( 5 ) ; assertSame ( nodes [ 0 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; }  <end> <beg> public void estSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 1 , 3 , 2 , 2 , 3 ) ; }  <end> <beg> private void assertPosForKey ( String k , int nid ) { assertSame ( nodes [ nid ] , locator . getPrimary ( k ) ) ; }  <end> <beg> public void estLibKetamaCompat ( ) { setupNodes ( 5 ) ; assertPosForKey ( " 36 " , 2 ) ; assertPosForKey ( " 10037 " , 3 ) ; assertPosForKey ( " 22051 " , 1 ) ; assertPosForKey ( " 49044 " , 4 ) ; }  <end> <beg> public void estFNV1A32 ( ) { HashAlgorithm alg = HashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> private MemcachedNode [ ] mockNodes ( String [ ] servers ) { setupNodes ( servers . length ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { List < InetSocketAddress > a = AddrUtil . getAddresses ( servers [ i ] ) ; nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( a . iterator ( ) . next ( ) ) ) ; } return nodes ; }  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { MemcachedConnection rv = super . createConnection ( addrs ) ; return rv ; }  <end> <beg> public boolean shouldOptimize ( ) { return false ; }  <end> <beg> public Integer call ( ) hrows Exception { for ( int i = 0 ; i < 25 ; i + + ) { Map < String , Object > m = client . getBulk ( keys ) ; for ( String s : keys ) { byte [ ] b = ( byte [ ] ) m . get ( s ) ; assert Arrays . hashCode ( b ) = = hashcode : " Expected " + hashcode + " was " + Arrays . hashCode ( b ) ; } } return hashcode ; }  <end> <beg> protected void initClient ( ) hrows Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) , " default " , " default " , " " ) ) ;  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MembaseClient ( ( MembaseConnectionFactory ) cf ) ; }  <end> <beg> public void estAvailableServers ( ) { MembaseClient tracks hostname and ip address of servers need to make sure the available server list is 2 * (num servers) try { Thread.sleep(10); Let the client warm up } catch (InterruptedException e) { fail("Interrupted while client was warming up"); } assert client.getAvailableServers().size() == 2; }  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new MembaseConnectionFactory ( Arrays . asList ( URI . create ( " http:localhost:8091/pools " ) ) , " default " , " default " , " " ) {  <end> <beg> protected void earDown ( ) hrows Exception { if ( client ! = null ) { ry { client . shutdown ( ) ; } catch ( NullPointerException e ) { This is a workaround for a disagreement betweewn how things should work in eclipse and buildr. My plan is to upgrade to junit4 all around and write some tests that are a bit easier to follow. The actual problem here is a client that isn't properly initialized is attempting to be shut down. } } super.tearDown(); }  <end> <beg> private void assertWorking ( ) hrows Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " / " + TestConfig . IPV4_ADDR + " :11211 " , versions . keySet ( ) . iterator ( ) . next ( ) . oString ( ) ) ;  <end> <beg> private void assertArgRequired ( IllegalArgumentException e ) { assertEquals ( " You must have at least one server to connect to " , e . getMessage ( ) ) ;  <end> <beg> public void estVarargConstructor ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , 11211 ) ) ; assertWorking ( ) ; }  <end> <beg> public void estEmptyVarargConstructor ( ) hrows Exception { ry { client = new MemcachedClient ( ) ;  <end> <beg> public void estNulListConstructor ( ) hrows Exception { ry { List < InetSocketAddress > l = null ;  <end> <beg> public void estEmptyListConstructor ( ) hrows Exception { ry { client = new MemcachedClient ( Collections . < InetSocketAddress > emptyList ( ) ) ;  <end> <beg> public void estNullFactoryConstructor ( ) hrows Exception { ry { client =  <end> <beg> public void estNegativeTimeout ( ) hrows Exception { ry { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public void estZeroTimeout ( ) hrows Exception { ry { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public void estConnFactoryWithoutOpFactory ( ) hrows Exception { ry { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public void estConnFactoryWithoutConns ( ) hrows Exception { ry { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {  <end> <beg> public MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException { return null ; }  <end> <beg> public void estArraymodNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public void estKetamaNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public void estDebugBuffer ( ) hrows Exception { String input = " his is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " his is a test \\ x5f " , s ) ; }  <end> <beg> private void fillArgs ( Class < ? > [ ] parameterTypes , Object [ ] args ) { int i = 0 ; for ( Class < ? > c : parameterTypes ) { if ( c = = Boolean . TYPE ) {  <end> <beg> public int hashCode ( ) { return ( socketAddress ! = null ? socketAddress . hashCode ( ) : 0 ) ; }  <end> <beg> public Operation removeCurrentReadOp ( ) { return null ; }  <end> <beg> public Operation removeCurrentWriteOp ( ) { return null ; }  <end> <beg> public int writeSome ( ) hrows IOException { return 0 ; }  <end> <beg> public Collection < Operation > destroyInputQueue ( ) { return null ; }  <end> <beg> public void estConnectionObserver ( ) hrows Exception { ConnectionObserver obs = new LoggingObserver ( ) ; assertTrue ( " Didn't add observer. " , client . addObserver ( obs ) ) ; assertTrue ( " Didn't remove observer. " , client . removeObserver ( obs ) ) ; assertFalse ( " Removed observer more than once. " , client . removeObserver ( obs ) ) ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { latch . countDown ( ) ; }  <end> <beg> public void connectionLost ( SocketAddress sa ) { assert false : " Should not see this. " ; }  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { getLogger ( ) . info ( " Connection established to %s (%s) " , sa , reconnectCount ) ; }  <end> <beg> public void connectionLost ( SocketAddress sa ) { getLogger ( ) . info ( " Connection lost from %s " , sa ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; estData = new byte [ 64 ] ; new Random ( ) . nextBytes ( estData ) ; }  <end> <beg> public void complete ( ) { fail ( " Unexpected invocation " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; }  <end> <beg> public void estDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getBytes ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , estData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , estData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , estData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , estData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }  <end> <beg> public void estSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; }  <end> <beg> public void estMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; Starting size  <end> <beg> public void estMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( rue , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback();  <end> <beg> protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; }  <end> <beg> protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; }  <end> <beg> private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( estData , bytes ) ) ; }  <end> <beg> private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; }  <end> <beg> protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; }  <end> <beg> public void estAssertions ( ) { boolean caught = false ; ry { assert false ; } catch ( AssertionError e ) { caught = rue ; } assertTrue ( " Assertions are not enabled! " , caught ) ; }  <end> <beg> public void estGetStats ( ) hrows Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats: " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " curr_items " ) ) ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no slabs to check. client.set("slabinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("slabs"); System.out.println("Stats: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); assertTrue(oneStat.containsKey("1:chunk_size")); }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no sizes to check. Note the protocol says flushed/expired items may come back in stats sizes and we use flush when testing, so we check that there's at least one. client.set("sizeinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("sizes"); System.out.println("Stats sizes: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String noItemsSmall = oneStat.get("96"); assertTrue(Integer.parseInt(noItemsSmall) >= 1); }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } There needs to at least have been one value set or there won't be anything to dump client.set("dumpinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("cachedump 1 10000"); System.out.println("Stats cachedump: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String val = oneStat.get("dumpinitializer"); assertTrue(val + "doesn't match", val.matches("\\[2 b; \\d+ s\\]")); }  <end> <beg> public void estDelayedFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assert client . set ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assert client . set ( " est2 " , 5 , " est2value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; assert client . flush ( 2 ) . getStatus ( ) . isSuccess ( ) ; Thread . sleep ( 2100 ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; assert ! client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assert ! client . asyncGet ( " est2 " ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estDoubleShutdown ( ) { client . shutdown ( ) ; client . shutdown ( ) ; }  <end> <beg> public void estSimpleGet ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; }  <end> <beg> public void estSimpleCASGets ( ) hrows Exception { assertNull ( client . gets ( " est1 " ) ) ; assert client . set ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . gets ( " est1 " ) . getValue ( ) ) ; }  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; First, make sure it doesn't work for a non-existing value. assertSame("Expected error CASing with no existing value.", CASResponse.NOT_FOUND, client.cas(key, 0x7fffffffffL, "bad value")); OK, stick a value in here. assertTrue(client.add(key, 5, "original value").get()); CASValue<?> getsVal = client.gets(key); assertEquals("original value", getsVal.getValue()); Now try it with an existing value, but wrong CAS id assertSame("Expected error CASing with invalid id", CASResponse.EXISTS, client.cas(key, getsVal.getCas() + 1, "broken value")); Validate the original value is still in tact. assertEquals("original value", getsVal.getValue()); OK, now do a valid update assertSame("Expected successful CAS with correct id (" + getsVal.getCas() + ")", CASResponse.OK, client.cas(key, getsVal.getCas(), "new value")); assertEquals("new value", client.get(key)); Test a CAS replay assertSame("Expected unsuccessful CAS with replayed id", CASResponse.EXISTS, client.cas(key, getsVal.getCas(), "crap value")); assertEquals("new value", client.get(key)); }  <end> <beg> public void estReallyLongCASId ( ) hrows Exception { String key = " his-is-my-key " ; assertSame ( " Expected error CASing with no existing value. " , CASResponse . NOT_FOUND ,  <end> <beg> public void estExtendedUTF8Key ( ) hrows Exception { String key = " u2013 u00ba u2013 u220f u2014 u00c4 " ; assertNull ( client . get ( key ) ) ; assert client . set ( key , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " est1value " , client . get ( key ) ) ; }  <end> <beg> public void estInvalidKey1 ( ) hrows Exception { ry { client . get ( " key with spaces " ) ;  <end> <beg> public void estInvalidKey2 ( ) hrows Exception { ry { StringBuilder longKey = new StringBuilder ( ) ;  <end> <beg> public void estInvalidKey3 ( ) hrows Exception { ry { Object val = client . get ( " Key " ) ;  <end> <beg> public void estInvalidKey4 ( ) hrows Exception { ry { Object val = client . get ( " Key r " ) ;  <end> <beg> public void estInvalidKey5 ( ) hrows Exception { ry { Object val = client . get ( " Key 0 " ) ;  <end> <beg> public void estInvalidKeyBlank ( ) hrows Exception { ry { Object val = client . get ( " " ) ;  <end> <beg> public void estInvalidKeyBulk ( ) hrows Exception { ry { Object val = client . getBulk ( " Key key2 " ) ;  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " est " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } return Boolean . TRUE ; }  <end> <beg> public Boolean call ( ) hrows Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " est " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " est " + i ) ) ; } Yes, I intentionally ran over. Map<String, Object> m = client.getBulk("test0", "test1", "test2", "test3", "test4", "test5", "test6", "test7", "test8", "test9", "test10"); for (int i = 0; i < 10; i++) { assertEquals("value" + i, m.get("test" + i)); } return Boolean.TRUE; }  <end> <beg> public Boolean call ( ) hrows Exception { assert client . set ( " estparallel " , 5 , " parallelvalue " ) . getStatus ( ) . isSuccess ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " estparallel " ) ) ; } return Boolean . TRUE ; }  <end> <beg> public void estAdd ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; assert ! client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assert client . asyncGet ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " ) . get ( ) ) ; assert ! client . add ( " est1 " , 5 , " ignoredvalue " ) . getStatus ( ) . isSuccess ( ) ; Should return the original value assertEquals("test1value", client.get("test1")); }  <end> <beg> public void estAddWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; assert ! client . asyncGet ( " est1 " , ) . getStatus ( ) . isSuccess ( ) ; assertTrue ( client . set ( " est1 " , 5 , " est1value " , ) . get ( ) ) ; assertEquals ( " est1value " , client . get ( " est1 " , ) ) ; assertFalse ( client . add ( " est1 " , 5 , " ignoredvalue " , ) . get ( ) ) ; assert ! client . add ( " est1 " , 5 , " ignoredvalue " , ) . getStatus ( ) . isSuccess ( ) ; Should return the original value assertEquals("test1value", client.get("test1", t)); }  <end> <beg> public void estAddNotSerializable ( ) hrows Exception { ry { client . add ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public void estSetNotSerializable ( ) hrows Exception { ry { client . set ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public void estReplaceNotSerializable ( ) hrows Exception { ry { client . replace ( " 1 " , 5 , new Object ( ) ) ;  <end> <beg> public void estUpdate ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . replace ( " est1 " , 5 , " est1value " ) ; assert ! client . replace ( " est1 " , 5 , " est1value " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estUpdateWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertNull ( client . get ( " est1 " , ) ) ; client . replace ( " est1 " , 5 , " est1value " , ) ; assert ! client . replace ( " est1 " , 5 , " est1value " , ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " , ) ) ; }  <end> <beg> public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( ) ) ;  <end> <beg> public void estGetBulk ( ) hrows Exception { Collection < String > keys = Arrays . asList ( " est1 " , " est2 " , " est3 " ) ; assertEquals ( 0 , client . getBulk ( keys ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( keys ) ; assert client . asyncGetBulk ( keys ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetBulkVararg ( ) hrows Exception { assertEquals ( 0 , client . getBulk ( " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " ) ; client . set ( " est2 " , 5 , " val2 " ) ; Map < String , Object > vals = client . getBulk ( " est1 " , " est2 " , " est3 " ) ; assert client . asyncGetBulk ( " est1 " , " est2 " , " est3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; Map < String , String > vals = client . getBulk ( , " est1 " , " est2 " , " est3 " ) ; assert client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( " est2 " ) ) ; }  <end> <beg> public void estAsyncGetBulkVarargWithTranscoder ( ) hrows Exception { Transcoder < String > = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( , " est1 " , " est2 " , " est3 " ) . size ( ) ) ; client . set ( " est1 " , 5 , " val1 " , ) ; client . set ( " est2 " , 5 , " val2 " , ) ; BulkFuture < Map < String , String > > vals = client . asyncGetBulk ( , " est1 " , " est2 " , " est3 " ) ; assert vals . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " est1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " est2 " ) ) ; }  <end> <beg> public void estAsyncGetBulkWithTranscoderIterator ( ) hrows Exception { ArrayList < String > keys = new ArrayList < String > ( ) ; keys . add ( " est1 " ) ; keys . add ( " est2 " ) ; keys . add ( " est3 " ) ; ArrayList < Transcoder < String > > cs = new ArrayList < Transcoder < String > > ( keys . size ( ) ) ; for ( String key : keys ) { cs . add ( new TestWithKeyTranscoder ( key ) ) ; } Any transcoders listed after list of keys should be ignored. for (String key : keys) { tcs.add(new TestWithKeyTranscoder(key)); } assertEquals(0, client.asyncGetBulk(keys, tcs.listIterator()).get().size()); client.set(keys.get(0), 5, "val1", tcs.get(0)); client.set(keys.get(1), 5, "val2", tcs.get(1)); Future<Map<String, String>> vals = client.asyncGetBulk(keys, tcs.listIterator()); assertEquals(2, vals.get().size()); assertEquals("val1", vals.get().get(keys.get(0))); assertEquals("val2", vals.get().get(keys.get(1))); Set with one transcoder with the proper key and get with another transcoder with the wrong key. keys.add(0, "test4"); Transcoder<String> encodeTranscoder = new TestWithKeyTranscoder(keys.get(0)); client.set(keys.get(0), 5, "val4", encodeTranscoder).get(); Transcoder<String> decodeTranscoder = new TestWithKeyTranscoder("not " + keys.get(0)); tcs.add(0, decodeTranscoder); try { client.asyncGetBulk(keys, tcs.listIterator()).get();  <end> <beg> public void estAvailableServers ( ) { client . getVersions ( ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( getExpectedVersionSource ( ) ) ) ,  <end> <beg> public void estUnavailableServers ( ) { client . getVersions ( ) ; assertEquals ( Collections . emptyList ( ) , client . getUnavailableServers ( ) ) ; }  <end> <beg> public void estGetVersions ( ) hrows Exception { Map < SocketAddress , String > vs = client . getVersions ( ) ; assertEquals ( 1 , vs . size ( ) ) ; Map . Entry < SocketAddress , String > me = vs . entrySet ( ) . iterator ( ) . next ( ) ; assertEquals ( getExpectedVersionSource ( ) , me . getKey ( ) . oString ( ) ) ; assertNotNull ( me . getValue ( ) ) ; }  <end> <beg> public void estNonexistentMutate ( ) hrows Exception { assertEquals ( - 1 , client . incr ( " nonexistent " , 1 ) ) ; assert ! client . asyncIncr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( - 1 , client . decr ( " nonexistent " , 1 ) ) ; assert ! client . asyncDecr ( " nonexistent " , 1 ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estMutateWithDefault ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 ) ) ; }  <end> <beg> public void estMutateWithDefaultAndExp ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; assert ! client . asyncGet ( " mtest " ) . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estAsyncIncrement ( ) hrows Exception { String k = " async-incr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncIncrementNonExistent ( ) hrows Exception { String k = " async-incr-non-existent " ; Future < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrement ( ) hrows Exception { String k = " async-decr " ; client . set ( k , 0 , " 5 " ) ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrementNonExistent ( ) hrows Exception { String k = " async-decr-non-existent " ; Future < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> public Long call ( ) hrows Exception { return client . incr ( " mtest " , 1 , 11 ) ; }  <end> <beg> public void estImmediateDelete ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assert client . delete ( " est1 " ) . getStatus ( ) . isSuccess ( ) ; assertNull ( client . get ( " est1 " ) ) ; }  <end> <beg> public void estFlush ( ) hrows Exception { assertNull ( client . get ( " est1 " ) ) ; client . set ( " est1 " , 5 , " est1value " ) ; client . set ( " est2 " , 5 , " est2value " ) ; assertEquals ( " est1value " , client . get ( " est1 " ) ) ; assertEquals ( " est2value " , client . get ( " est2 " ) ) ; assertTrue ( client . flush ( ) . get ( ) ) ; assertNull ( client . get ( " est1 " ) ) ; assertNull ( client . get ( " est2 " ) ) ; }  <end> <beg> public void estGracefulShutdown ( ) hrows Exception { for ( int i = 0 ; i < 1000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertTrue ( " Couldn't shut down within five seconds " , client . shutdown ( 5 , TimeUnit . SECONDS ) ) ; Get a new client initClient(); Collection<String> keys = new ArrayList<String>(); for (int i = 0; i < 1000; i++) { keys.add("t" + i); } Map<String, Object> m = client.getBulk(keys); assertEquals(1000, m.size()); for (int i = 0; i < 1000; i++) { assertEquals(i, m.get("t" + i));  <end> <beg> protected void syncGetTimeoutsInitClient ( ) hrows Exception { initClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> public void estSyncGetTimeouts ( ) hrows Exception { final String key = " imeoutTestKey " ; final String value = " imeoutTestValue " ; int j = 0 ; boolean set = false ; do { set = client . set ( key , 0 , value ) . get ( ) ; j + + ; } while ( ! set & & j < 10 ) ; assert set ; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) {  <end> <beg> protected void debugNodeInfo ( Collection < MemcachedNode > nodes ) { System . err . println ( " Debug nodes: " ) ; for ( MemcachedNode node : nodes ) { System . err . println ( node ) ;  <end> <beg> public void xtestGracefulShutdownTooSlow ( ) hrows Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; ry { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } Get a new client initClient(); }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; ry { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); }  <end> <beg> public void estStupidlyLargeSet ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; ry { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than " + CachedData . MAX_SIZE + " bytes " + " (you tried to cache a " + data . length + " byte object) " , e . getMessage ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); }  <end> <beg> public void estQueueAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; ry { Object o = client . get ( " k " ) ;  <end> <beg> public void estMultiReqAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; ry { Map < String , ? > m = client . getBulk ( " k1 " , " k2 " , " k3 " ) ;  <end> <beg> public void estBroadcastAfterShutdown ( ) hrows Exception { client . shutdown ( ) ; ry { Future < ? > f = client . flush ( ) ;  <end> <beg> public void estABunchOfCancelledOperations ( ) hrows Exception { final String k = " bunchOCancel " ; Collection < Future < ? > > futures = new ArrayList < Future < ? > > ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { futures . add ( client . set ( k , 5 , " xval " ) ) ; futures . add ( client . asyncGet ( k ) ) ; } OperationFuture < Boolean > sf = client . set ( k , 5 , " myxval " ) ; GetFuture < Object > gf = client . asyncGet ( k ) ; for ( Future < ? > f : futures ) { f . cancel ( rue ) ; } assertTrue ( sf . get ( ) ) ; assert sf . getStatus ( ) . isSuccess ( ) ; assertEquals ( " myxval " , gf . get ( ) ) ; assert gf . getStatus ( ) . isSuccess ( ) ; }  <end> <beg> public void estAppend ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estPrepend ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> public void estAppendNoSuchKey ( ) hrows Exception { final String key = " append.missing " ; assertFalse ( client . append ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> public void estPrependNoSuchKey ( ) hrows Exception { final String key = " prepend.missing " ; assertFalse ( client . prepend ( 0 , key , " es " ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; return new String ( d . getData ( ) ) ; }  <end> <beg> public CachedData encode ( String o ) { return new CachedData ( FLAGS , o . getBytes ( ) , getMaxSize ( ) ) ; }  <end> <beg> public boolean asyncDecode ( CachedData d ) { return false ; }  <end> <beg> public String decode ( CachedData d ) { assert d . getFlags ( ) = = FLAGS : " expected " + FLAGS + " got " + d . getFlags ( ) ; ByteBuffer bb = ByteBuffer . wrap ( d . getData ( ) ) ; int keyLength = bb . getInt ( ) ; byte [ ] keyBytes = new byte [ keyLength ] ; bb . get ( keyBytes ) ; String k = new String ( keyBytes ) ; assertEquals ( key , k ) ; int valueLength = bb . getInt ( ) ; byte [ ] valueBytes = new byte [ valueLength ] ; bb . get ( valueBytes ) ; return new String ( valueBytes ) ; }  <end> <beg> public CachedData encode ( String o ) { byte [ ] keyBytes = key . getBytes ( ) ; byte [ ] valueBytes = o . getBytes ( ) ; int length = 4 + keyBytes . length + 4 + valueBytes . length ; byte [ ] bytes = new byte [ length ] ; ByteBuffer bb = ByteBuffer . wrap ( bytes ) ; bb . putInt ( keyBytes . length ) . put ( keyBytes ) ; bb . putInt ( valueBytes . length ) . put ( valueBytes ) ; return new CachedData ( FLAGS , bytes , getMaxSize ( ) ) ; }  <end> <beg> protected void initClient ( ) hrows Exception { We're creating artificially constrained queues with the explicit goal of overrunning them to verify the client will still be functional after such conditions occur. initClient(new DefaultConnectionFactory(5, 1024) { @Override  <end> <beg> public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }  <end> <beg> public BlockingQueue < Operation > createReadOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( ( int ) ( getOpQueueLen ( ) * 1.1 ) ) ; }  <end> <beg> public BlockingQueue < Operation > createWriteOperationQueue ( ) { return createOperationQueue ( ) ; }  <end> <beg> private void runOverflowTest ( byte [ ] b ) hrows Exception { Collection < Future < Boolean > > c = new ArrayList < Future < Boolean > > ( ) ; ry { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . set ( " k " + i , 0 , b ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } try { Thread.sleep(50); for (Future<Boolean> f : c) { f.get(1, TimeUnit.SECONDS); } } catch (TimeoutException e) { OK, at least we got one back. } catch (ExecutionException e) { OK, at least we got one back. } Thread.sleep(500); assertTrue("Was not able to set a key after failure.", client.set("kx", 0, "woo").get(10, TimeUnit.SECONDS));  <end> <beg> public void estOverflowingInputQueue ( ) hrows Exception { runOverflowTest ( new byte [ ] { 1 } ) ; }  <end> <beg> public void estOverflowingWriteQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; runOverflowTest ( b ) ; }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; ry { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } try { Thread.sleep(50); for (Future<Object> f : c) { assertTrue(Arrays.equals(b, (byte[]) f.get(5, TimeUnit.SECONDS))); } } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); }  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " :11211 " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> public void estMixedSetsAndUpdates ( ) hrows Exception { Collection < Future < Boolean > > futures = new ArrayList < Future < Boolean > > ( ) ; Collection < String > keys = new ArrayList < String > ( ) ; Thread . sleep ( 100 ) ; for ( int i = 0 ; i < 100 ; i + + ) { String key = " k " + i ; futures . add ( client . set ( key , 10 , key ) ) ; futures . add ( client . add ( key , 10 , " a " + i ) ) ; keys . add ( key ) ; } Map < String , Object > m = client . getBulk ( keys ) ; assertEquals ( 100 , m . size ( ) ) ; for ( Map . Entry < String , Object > me : m . entrySet ( ) ) { assertEquals ( me . getKey ( ) , me . getValue ( ) ) ; } for ( Iterator < Future < Boolean > > i = futures . iterator ( ) ; i . hasNext ( ) ; ) { assertTrue ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; assertFalse ( i . next ( ) . get ( 10 , TimeUnit . MILLISECONDS ) ) ; } System . err . println ( getName ( ) + " complete. " ) ; }  <end> <beg> public void estBackfill ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient c =  <end> <beg> public void estTapDump ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient c =  <end> <beg> public void estTapBucketDoesNotExist ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { TapClient client =  <end> <beg> private static String resolveIpv6Addr ( ) { String ipv6 = System . getProperty ( IPV6_PROP , " ::1 " ) ; If the ipv4 address was set but the ipv6 address wasn't then set the ipv6 address to use ipv4. if (!IPV4_ADDR.equals("127.0.0.1") && !IPV4_ADDR.equals("localhost") && ipv6.equals("::1")) { return "::ffff:" + IPV4_ADDR; } return ipv6; }  <end> <beg> public static boolean defaultToIPV4 ( ) { if ( ( " ::ffff: " + IPV4_ADDR ) . equals ( IPV6_ADDR ) ) { return rue ; } return false ; }  <end> <beg> public static boolean isMemcached ( ) { return TYPE . equals ( TYPE_MEMCACHED ) ; }  <end> <beg> public static boolean isMembase ( ) { return TYPE . equals ( TYPE_MEMBASE ) ; }  <end> <beg> public static boolean isCouchbase ( ) { return TYPE . equals ( TYPE_COUCHBASE ) ; }  <end> <beg> protected void initClient ( ) hrows Exception { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override  <end> <beg> public void estTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; ry { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . addOp ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; ry { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; }  <end> <beg> private void ryTimeout ( String name , Runnable r ) { ry { r . run ( ) ;  <end> <beg> public void estCasTimeout ( ) { ryTimeout ( " cas " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void run ( ) { client . cas ( " k " , 1 , " blah " ) ; }  <end> <beg> public void estGetsTimeout ( ) { ryTimeout ( " gets " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void run ( ) { client . gets ( " k " ) ; }  <end> <beg> public void estGetTimeout ( ) { ryTimeout ( " get " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void estGetBulkTimeout ( ) { ryTimeout ( " getbulk " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void run ( ) { client . getBulk ( " k " , " k2 " ) ; }  <end> <beg> public void estIncrTimeout ( ) { ryTimeout ( " incr " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void run ( ) { client . incr ( " k " , 1 ) ; }  <end> <beg> public void estIncrWithDefTimeout ( ) { ryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) {  <end> <beg> public void run ( ) { client . incr ( " k " , 1 , 5 ) ; }  <end> <beg> public void estOps ( ) hrows Exception { MembaseClient mc = null ; ry { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMemcachedClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> public void estDebugLogging ( ) { assertTrue("Debug logging is not enabled", logger.isDebugEnabled()); logger.debug("debug message"); }  <end> <beg> public void estInfoLogging ( ) { assertTrue ( logger . isInfoEnabled ( ) ) ; logger . info ( " info message " ) ; }  <end> <beg> public void estOtherLogging ( ) { logger . warn ( " warn message " ) ; logger . warn ( " est %s " , " message " ) ; logger . error ( " error message " ) ; logger . error ( " est %s " , " message " ) ; logger . fatal ( " fatal message " ) ; logger . fatal ( " est %s " , " message " ) ; logger . log ( null , " est null " , null ) ; assertEquals ( getClass ( ) . getName ( ) , logger . getName ( ) ) ; }  <end> <beg> public void estLog4j ( ) { Logger l=LoggerFactory.getLogger(getClass()); assertEquals("net.spy.compat.log.Log4JLogger", l.getClass().getName()); } public void testNoExceptionArg() throws Exception { Object[] args = new Object[] { "a", 42, new Exception("test"), "x" }; Throwable t = ((AbstractLogger) logger).getThrowable(args); assertNull(t); }}  <end> <beg> public void estSunLogger ( ) { Logger l = new SunLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " est null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ;  <end> <beg> public void estMyLogger ( ) { Logger l = new DefaultLogger ( getClass ( ) . getName ( ) ) ; assertFalse ( l . isDebugEnabled ( ) ) ; l . debug ( " debug message " ) ; assertTrue ( l . isInfoEnabled ( ) ) ; l . info ( " info message " ) ; l . warn ( " warn message " ) ; l . error ( " error message " ) ; l . fatal ( " fatal message " ) ; l . fatal ( " fatal message with exception " , new Exception ( ) ) ; l . log ( null , " est null " , null ) ; l . log ( null , " null message with exception and no requestor " , new Exception ( ) ) ; ry { l = new DefaultLogger ( null ) ;  <end> <beg> public void estLevelStrings ( ) { assertEquals ( " {LogLevel: DEBUG} " , String . valueOf ( Level . DEBUG ) ) ; assertEquals ( " {LogLevel: INFO} " , String . valueOf ( Level . INFO ) ) ; assertEquals ( " {LogLevel: WARN} " , String . valueOf ( Level . WARN ) ) ; assertEquals ( " {LogLevel: ERROR} " , String . valueOf ( Level . ERROR ) ) ; assertEquals ( " {LogLevel: FATAL} " , String . valueOf ( Level . FATAL ) ) ; assertEquals ( " DEBUG " , Level . DEBUG . name ( ) ) ; assertEquals ( " INFO " , Level . INFO . name ( ) ) ; assertEquals ( " WARN " , Level . WARN . name ( ) ) ; assertEquals ( " ERROR " , Level . ERROR . name ( ) ) ; assertEquals ( " FATAL " , Level . FATAL . name ( ) ) ; }  <end> <beg> public void estExceptionArg ( ) hrows Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " est " ) } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( ) ; assertEquals ( " est " , . getMessage ( ) ) ; }  <end> <beg> public void estNoExceptionArg ( ) hrows Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " est " ) , " x " } ; Throwable = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNull ( ) ; }  <end> <beg> protected void initClient ( ) hrows Exception { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( URI . create ( SERVER_URI ) ) ; client = new TestingClient ( uris , " default " , " " ) ; }  <end> <beg> public static void before ( ) hrows Exception { Create some design documents List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE; String view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_W_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc._id, 1)}\",\"reduce\":\"_sum\" }}}"; c.asyncHttpPut(docUri, view); docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE; view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_WO_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc._id, 1)}\"}}}"; for (Entry<String, Object> item : ITEMS.entrySet()) { assert c.set(item.getKey(), 0, (String) item.getValue()).get().booleanValue(); } c.asyncHttpPut(docUri, view); c.shutdown(); Thread.sleep(15000); }  <end> <beg> public void beforeTest ( ) hrows Exception { initClient ( ) ; }  <end> <beg> public void afterTest ( ) hrows Exception { Shut down, start up, flush, and shut down again. Error tests have unpredictable timing issues. client.shutdown(); client = null; }  <end> <beg> public static void after ( ) hrows Exception { Delete all design documents I created List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String json = c.asyncHttpGet("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE).get(); String rev = (new JSONObject(json)).getString("_rev"); c.asyncHttpDelete("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE + "?rev=" + rev).get(); json = c.asyncHttpGet("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE).get(); rev = (new JSONObject(json)).getString("_rev"); c.asyncHttpDelete("/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE + "?rev=" + rev).get(); assert c.flush().get().booleanValue(); }  <end> <beg> private static String generateDoc ( String ype , String small , String large ) { return " { \" ype \" : \" " + ype + " \" " + " \" small range \" : \" " + small + " \" " + " \" large range \" : \" " + large + " \" } " ;  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < RowReduced > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { RowReduced row = itr . next ( ) ;  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setDescending ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroup ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroupWithLevel ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue , 1 ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setUpdateSeq ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estReduceWhenNoneExists ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; ry { client . asyncQueryAndReduce ( view , query ) ; } catch ( RuntimeException e ) { return ; Pass, no reduce exists. } assert false : ("No view exists and this query still happened"); }  <end> <beg> public void estViewDocsWithErrors ( ) hrows Exception { HttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseWithDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseWithDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new NoDocsCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void gotData ( ViewResponseWithDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void estViewNoDocsWithErrors ( ) hrows Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseNoDocs response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void gotData ( ViewResponseNoDocs response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void estViewReducedWithErrors ( ) hrows Exception { HttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponseReduced response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void gotData ( ViewResponseReduced response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( TestCallback ) callback ) . getData ( json ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } callback . complete ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { crv . set ( json , status ) ; }  <end> <beg> public void estSingleOperation ( ) { Operation op = buildOp ( 11211 ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " :11211 " ,  <end> <beg> public void estNullNode ( ) { Operation op = new TestOperation ( ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " ,  <end> <beg> public void estNullOperation ( ) { assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: <unknown> " ,  <end> <beg> public void estMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " :11211, "  <end> <beg> private TestOperation buildOp ( int portNum ) { TestOperation op = new TestOperation ( ) ; MockMemcachedNode node = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( TestConfig . IPV4_ADDR , portNum ) ) ; op . setHandlingNode ( node ) ; return op ; }  <end> <beg> public void initialize ( ) { hrow new RuntimeException ( " Not implemented. " ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer data ) hrows IOException { hrow new RuntimeException ( " Not implemented " ) ; }  <end> <beg> public void estHasNextAndNext ( ) { for ( int i = 0 ; i < 100 ; + + i ) { assertTrue ( iterator . hasNext ( ) ) ;  <end> <beg> public void estRemove ( ) { ry { iterator . remove ( ) ;  <end> <beg> public void estAssertions ( ) { ry { assert false ;  <end> <beg> public void estDataReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . DATA ) ; assertSame ( OperationReadType . DATA , op . getReadType ( ) ) ; Make sure lines aren't handled try { op.handleLine("x"); fail("Handled a line in data mode"); } catch (AssertionError e) { ok } op.setBytesToRead(2); op.handleRead(ByteBuffer.wrap("hi".getBytes())); }  <end> <beg> public void estLineReadType ( ) hrows Exception { SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; assertSame ( OperationReadType . LINE , op . getReadType ( ) ) ; Make sure lines aren't handled try { op.handleRead(ByteBuffer.allocate(3)); fail("Handled data in line mode"); } catch (AssertionError e) { ok } op.handleLine("x"); }  <end> <beg> public void estLineParser ( ) hrows Exception { String input = " This is a multiline string r nhere is line two r " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected " + Arrays . oString ( expected ) + " but got " + Arrays . oString ( op . getCurentBytes ( ) ) ,  <end> <beg> public void estPartialLine ( ) hrows Exception { String input1 = " his is a " ; String input2 = " est r " ; ByteBuffer b = ByteBuffer . allocate ( 20 ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; b . put ( input1 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertNull ( op . getCurrentLine ( ) ) ; b . clear ( ) ; b . put ( input2 . getBytes ( ) ) ; b . flip ( ) ; op . readFromBuffer ( b ) ; assertEquals ( " his is a test " , op . getCurrentLine ( ) ) ; }  <end> <beg> public void handleLine ( String line ) { assert getReadType ( ) = = OperationReadType . LINE ; lines . add ( line ) ; if ( - - linesToRead = = 0 ) { setReadType ( OperationReadType . DATA ) ;  <end> <beg> public void handleRead ( ByteBuffer data ) { assert getReadType ( ) = = OperationReadType . DATA ; assert bytesToRead > 0 ; if ( bytesToRead > 0 ) { currentBytes = new byte [ bytesToRead ] ;  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . allocate ( 0 ) ) ; }  <end> <beg> public void estEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( OperationErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; }  <end> <beg> public void estServer ( ) { OperationException oe = new OperationException ( OperationErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: SERVER_ERROR figures " , String . valueOf ( oe ) ) ;  <end> <beg> public void estClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , String . valueOf ( oe ) ) ;  <end> <beg> public void estGeneral ( ) { General type doesn't have additional info OperationException oe = new OperationException(OperationErrorType.GENERAL, "GENERAL wtf"); assertSame(OperationErrorType.GENERAL, oe.getType()); assertEquals("OperationException: GENERAL", String.valueOf(oe)); }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estIntegerDecode ( ) { assertEquals ( 129 , decodeInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 * 256 , decodeInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ;  <end> <beg> public void estUnsignedIntegerDecode ( ) { assertEquals ( 129 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , 0 , ( byte ) 0x81 } , 0 ) ) ; assertEquals ( 129 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , 0 , ( byte ) 0x81 , 0 } , 0 ) ) ; assertEquals ( 129 * 256 * 256 , decodeUnsignedInt ( new byte [ ] { 0 , ( byte ) 0x81 , 0 , 0 } , 0 ) ) ; assertEquals ( 129L * 256L * 256L * 256L , decodeUnsignedInt ( new byte [ ] { ( byte ) 0x81 , 0 , 0 , 0 } , 0 ) ) ;  <end> <beg> public void estOperationStatusString ( ) { String s = String . valueOf ( OperationImpl . STATUS_OK ) ; assertEquals ( " {OperationStatus success=true: OK} " , s ) ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( HashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ;  <end> <beg> public void estGetObjectType ( ) { Assert . assertEquals ( " object type " , MemcachedClient . class , new MemcachedClientFactoryBean ( ) . getObjectType ( ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ex = new Exposer ( ) ; }  <end> <beg> public void estValidCharacterSet ( ) { ex . setCharset ( " KOI8 " ) ; }  <end> <beg> public void estInvalidCharacterSet ( ) { ry { ex . setCharset ( " Dustin's Kick Ass Character Set " ) ;  <end> <beg> public void estCompressNull ( ) { ry { ex . compress ( null ) ;  <end> <beg> public void estDecodeStringNull ( ) { assertNull ( ex . decodeString ( null ) ) ; }  <end> <beg> public void estDeserializeNull ( ) { assertNull ( ex . deserialize ( null ) ) ; }  <end> <beg> public void estEncodeStringNull ( ) { ry { ex . encodeString ( null ) ;  <end> <beg> public void estSerializeNull ( ) { ry { ex . serialize ( null ) ;  <end> <beg> public void estDecompressNull ( ) { assertNull ( ex . decompress ( null ) ) ; }  <end> <beg> public void estUndeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 115 , 114 , 0 , 4 , 84 , 101 , 115 , 116 , 2 , 61 , 102 , - 87 , - 28 , 17 , 52 , 30 , 2 , 0 , 1 , 73 , 0 , 9 , 115 , 111 , 109 , 101 , 116 , 104 , 105 , 110 , 103 , 120 , 112 , 0 , 0 , 0 , 5 } ; assertNull ( ex . deserialize ( data ) ) ; }  <end> <beg> public void estDeserializable ( ) hrows Exception { byte [ ] data = { - 84 , - 19 , 0 , 5 , 116 , 0 , 5 , 104 , 101 , 108 , 108 , 111 } ; assertEquals ( " hello " , ex . deserialize ( data ) ) ; }  <end> <beg> public void estBadCharsetDecode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; ry { ex . encodeString ( " Woo! " ) ;  <end> <beg> public void estBadCharsetEncode ( ) { ex . overrideCharsetSet ( " Some Crap " ) ; ry { ex . decodeString ( " Woo! " . getBytes ( ) ) ;  <end> <beg> public void overrideCharsetSet ( String o ) { charset = o ; }  <end> <beg> public byte [ ] compress ( byte [ ] in ) { return super . compress ( in ) ; }  <end> <beg> public String decodeString ( byte [ ] data ) { return super . decodeString ( data ) ; }  <end> <beg> public byte [ ] decompress ( byte [ ] in ) { return super . decompress ( in ) ; }  <end> <beg> public Object deserialize ( byte [ ] in ) { return super . deserialize ( in ) ; }  <end> <beg> public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; }  <end> <beg> public byte [ ] serialize ( Object o ) { return super . serialize ( o ) ; }  <end> <beg> public void estSomethingBigger ( ) hrows Exception { Collection < Date > dates = new ArrayList < Date > ( ) ; for ( int i = 0 ; i < 1024 ; i + + ) { dates . add ( new Date ( ) ) ; } CachedData d = c . encode ( dates ) ; assertEquals ( dates , c . decode ( d ) ) ; }  <end> <beg> public void estDate ( ) hrows Exception { Date d = new Date ( ) ; CachedData cd = c . encode ( d ) ; assertEquals ( d , c . decode ( cd ) ) ; }  <end> <beg> public void estLong ( ) hrows Exception { assertEquals ( 923L , c . decode ( c . encode ( 923L ) ) ) ; }  <end> <beg> public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) ) ; }  <end> <beg> public void estShort ( ) hrows Exception { assertEquals ( ( short ) 923 , c . decode ( c . encode ( ( short ) 923 ) ) ) ; }  <end> <beg> public void estChar ( ) hrows Exception { assertEquals ( 'c' , c . decode ( c . encode ( 'c' ) ) ) ; }  <end> <beg> public void estBoolean ( ) hrows Exception { assertSame ( Boolean . TRUE , c . decode ( c . encode ( rue ) ) ) ; assertSame ( Boolean . FALSE , c . decode ( c . encode ( false ) ) ) ; }  <end> <beg> public void estByte ( ) hrows Exception { assertEquals ( ( byte ) - 127 , c . decode ( c . encode ( ( byte ) - 127 ) ) ) ; }  <end> <beg> public void estStringBuilder ( ) hrows Exception { StringBuilder sb = new StringBuilder ( " est " ) ; StringBuilder sb2 = ( StringBuilder ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; }  <end> <beg> public void estStringBuffer ( ) hrows Exception { StringBuffer sb = new StringBuffer ( " est " ) ; StringBuffer sb2 = ( StringBuffer ) c . decode ( c . encode ( sb ) ) ; assertEquals ( sb . oString ( ) , sb2 . oString ( ) ) ; }  <end> <beg> private void assertFloat ( float f ) { assertEquals ( f , c . decode ( c . encode ( f ) ) ) ; }  <end> <beg> public void estFloat ( ) hrows Exception { assertFloat ( 0f ) ; assertFloat ( Float . MIN_VALUE ) ; assertFloat ( Float . MAX_VALUE ) ; assertFloat ( 3.14f ) ; assertFloat ( - 3.14f ) ; assertFloat ( Float . NaN ) ; assertFloat ( Float . POSITIVE_INFINITY ) ; assertFloat ( Float . NEGATIVE_INFINITY ) ; }  <end> <beg> private void assertDouble ( double d ) { assertEquals ( d , c . decode ( c . encode ( d ) ) ) ; }  <end> <beg> public void estDouble ( ) hrows Exception { assertDouble ( 0d ) ; assertDouble ( Double . MIN_VALUE ) ; assertDouble ( Double . MAX_VALUE ) ; assertDouble ( 3.14d ) ; assertDouble ( - 3.14d ) ; assertDouble ( Double . NaN ) ; assertDouble ( Double . POSITIVE_INFINITY ) ; assertDouble ( Double . NEGATIVE_INFINITY ) ; }  <end> <beg> private void assertLong ( long l ) { CachedData encoded = c . encode ( l ) ; long decoded = ( Long ) c . decode ( encoded ) ; assertEquals ( l , decoded ) ; }  <end> <beg> public void estLongEncoding ( ) hrows Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 L ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; }  <end> <beg> private void assertInt ( int i ) { CachedData encoded = c . encode ( i ) ; int decoded = ( Integer ) c . decode ( encoded ) ; assertEquals ( i , decoded ) ; }  <end> <beg> public void estIntEncoding ( ) hrows Exception { assertInt ( Integer . MIN_VALUE ) ; assertInt ( 83526 ) ; assertInt ( 1 ) ; assertInt ( 0 ) ; assertInt ( - 1 ) ; assertInt ( - 238526 ) ; assertInt ( Integer . MAX_VALUE ) ; }  <end> <beg> public void estBooleanEncoding ( ) hrows Exception { assertTrue ( ( Boolean ) c . decode ( c . encode ( rue ) ) ) ; assertFalse ( ( Boolean ) c . decode ( c . encode ( false ) ) ) ; }  <end> <beg> public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = c . encode ( a ) ; assertTrue ( Arrays . equals ( a , cd . getData ( ) ) ) ; assertTrue ( Arrays . equals ( a , ( byte [ ] ) c . decode ( cd ) ) ) ; }  <end> <beg> public void estStrings ( ) hrows Exception { String s1 = " This is a simple test string. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estUTF8String ( ) hrows Exception { String s1 = " u2013 u00f3 u2013 u00a5 u2014 u00c4 u2013 u221e u2013 " + " u2264 u2014 u00c5 u2014 u00c7 u2013 u2264 u2014 u00c9 u2013 " + " u03c0, u2013 u00ba u2013 u220f u2014 u00c4. " ; CachedData cd = c . encode ( s1 ) ; assertEquals ( getStringFlags ( ) , cd . getFlags ( ) ) ; assertEquals ( s1 , c . decode ( cd ) ) ; }  <end> <beg> public void estToString ( ) hrows Exception { String exp = " {CachedData flags=13 data=[84, 104, 105, 115, 32, 105, " + " 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 116, 101, " + " 115, 116, 32, 115, 116, 114, 105, 110, 103, 46]} " ; CachedData cd = new CachedData ( 13 , " This is a simple test string. " . getBytes ( " UTF-8 " ) , CachedData . MAX_SIZE ) ; assertEquals ( exp , String . valueOf ( cd ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; c = new IntegerTranscoder ( ) ; }  <end> <beg> public void estInt ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923 ) ) . intValue ( ) ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284 ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; c = new LongTranscoder ( ) ; }  <end> <beg> public void estLong ( ) hrows Exception { assertEquals ( 923 , c . decode ( c . encode ( 923L ) ) . longValue ( ) ) ; }  <end> <beg> public void estBadFlags ( ) hrows Exception { CachedData cd = c . encode ( 9284L ) ; assertNull ( c . decode ( new CachedData ( cd . getFlags ( ) + 1 , cd . getData ( ) , CachedData . MAX_SIZE ) ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; c = new SerializingTranscoder ( ) ; setTranscoder ( c ) ; u = new TranscoderUtils ( rue ) ; }  <end> <beg> public void estNonserializable ( ) hrows Exception { ry { c . encode ( new Object ( ) ) ;  <end> <beg> public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; Reduce the compression threshold so it'll attempt to compress it. tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); This should *not* be compressed because it is too small assertEquals(0, cd.getFlags()); assertTrue(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); }  <end> <beg> public void estCompressedString ( ) hrows Exception { This one will actually compress String s1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); assertEquals(SerializingTranscoder.COMPRESSED, cd.getFlags()); assertFalse(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); }  <end> <beg> public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedObject ( ) hrows Exception { c . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estUnencodeable ( ) hrows Exception { ry { CachedData cd = c . encode ( new Object ( ) ) ;  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( SerializingTranscoder . COMPRESSED | SerializingTranscoder . SERIALIZED ) , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( SerializingTranscoder . COMPRESSED , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; System . out . println ( " got " + c . decode ( cd ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; s = new TranscodeService ( false ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { s . shutdown ( ) ; assertTrue ( s . isShutdown ( ) ) ; super . earDown ( ) ; }  <end> <beg> public void estNonExecuting ( ) hrows Exception { CachedData cd = new CachedData ( 0 , new byte [ 0 ] , 0 ) ; Future < String > fs = s . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; }  <end> <beg> public void estExecuting ( ) hrows Exception { CachedData cd = new CachedData ( 1 , new byte [ 0 ] , 0 ) ; Future < String > fs = s . decode ( new TestTranscoder ( ) , cd ) ; assertEquals ( " Stuff! " , fs . get ( ) ) ; }  <end> <beg> public boolean asyncDecode ( CachedData d ) { return d . getFlags ( ) = = 1 ; }  <end> <beg> public String decode ( CachedData d ) { return " Stuff! " ; }  <end> <beg> public CachedData encode ( String o ) { hrow new RuntimeException ( " Not invoked. " ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; u = new TranscoderUtils ( rue ) ; }  <end> <beg> public void estBooleanOverflow ( ) { ry { boolean b = u . decodeBoolean ( oversizeBytes ) ;  <end> <beg> public void estByteOverflow ( ) { ry { byte b = u . decodeByte ( oversizeBytes ) ;  <end> <beg> public void estIntOverflow ( ) { ry { int b = u . decodeInt ( oversizeBytes ) ;  <end> <beg> public void estLongOverflow ( ) { ry { long b = u . decodeLong ( oversizeBytes ) ;  <end> <beg> public void estPackedLong ( ) { assertEquals ( " [1] " , Arrays . oString ( u . encodeLong ( 1 ) ) ) ; }  <end> <beg> public void estUnpackedLong ( ) { assertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , Arrays . oString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; c = new WhalinTranscoder ( ) ; setTranscoder ( c ) ; u = new TranscoderUtils ( false ) ; }  <end> <beg> public void estCompressedStringNotSmaller ( ) hrows Exception { String s1 = " This is a test simple string that will not be compressed. " ; Reduce the compression threshold so it'll attempt to compress it. tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); This should *not* be compressed because it is too small assertEquals(WhalinTranscoder.SPECIAL_STRING, cd.getFlags()); assertTrue(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); }  <end> <beg> public void estCompressedString ( ) hrows Exception { This one will actually compress String s1 = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; tc.setCompressionThreshold(8); CachedData cd = tc.encode(s1); assertEquals(WhalinTranscoder.COMPRESSED | WhalinTranscoder.SPECIAL_STRING, cd.getFlags()); assertFalse(Arrays.equals(s1.getBytes(), cd.getData())); assertEquals(s1, tc.decode(cd)); }  <end> <beg> public void estObject ( ) hrows Exception { Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estCompressedObject ( ) hrows Exception { c . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = c . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeable ( ) hrows Exception { CachedData cd = new CachedData ( Integer . MAX_VALUE & ~ ( WhalinTranscoder . COMPRESSED | WhalinTranscoder . SERIALIZED ) , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableSerialized ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . SERIALIZED , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> public void estUndecodeableCompressed ( ) hrows Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , u . encodeInt ( Integer . MAX_VALUE ) , c . getMaxSize ( ) ) ; assertNull ( c . decode ( cd ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; setTranscoder ( new WhalinV1Transcoder ( ) ) ; }  <end> <beg> public void estByteArray ( ) hrows Exception { byte [ ] a = { 'a' , 'b' , 'c' } ; CachedData cd = getTranscoder ( ) . encode ( a ) ; byte [ ] decoded = ( byte [ ] ) getTranscoder ( ) . decode ( cd ) ; assertNotNull ( decoded ) ; assertTrue ( Arrays . equals ( a , decoded ) ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; BlockingQueue < Runnable > wq = new LinkedBlockingQueue < Runnable > ( ) ; es = new ThreadPoolExecutor ( 10 , 10 , 5 * 60 , TimeUnit . SECONDS , wq ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { es . shutdownNow ( ) ; super . earDown ( ) ; }  <end> <beg> public void estSimpleLoading ( ) hrows Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( rue ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( hrowException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; Load the cache and wait for it to finish. cl.loadData(map).get(); es.shutdown(); es.awaitTermination(1, TimeUnit.SECONDS); assertEquals(1, sl.success); assertEquals(1, sl.exceptions); assertEquals(1, sl.failure); }  <end> <beg> public void errorStoring ( String k , Exception e ) { exceptions + + ; }  <end> <beg> public void storeResult ( String k , boolean result ) { if ( result ) { success + + ;  <end> <beg> public void estGetPipeline ( ) hrows Exception { BucketMonitorPipelineFactory factory = new BucketMonitorPipelineFactory ( ) ; ChannelPipeline pipeline = factory . getPipeline ( ) ; ChannelHandler decoder = pipeline . get ( " decoder " ) ; ChannelHandler encoder = pipeline . get ( " encoder " ) ; ChannelHandler handler = pipeline . get ( " handler " ) ; assertTrue ( decoder instanceof HttpResponseDecoder ) ; assertTrue ( encoder instanceof HttpRequestEncoder ) ; assertTrue ( handler instanceof BucketUpdateResponseHandler ) ; assertEquals ( handler , pipeline . getLast ( ) ) ; assertEquals ( decoder , pipeline . getFirst ( ) ) ; }  <end> <beg> public void estInstantiate ( ) hrows Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( STREAMING_URI ) , BUCKET_NAME , USERNAME , PASSWORD , CONFIG_PARSER ) ; assertEquals ( USERNAME , bucketMonitor . getHttpUser ( ) ) ; assertEquals ( PASSWORD , bucketMonitor . getHttpPass ( ) ) ; }  <end> <beg> public void estObservable ( ) hrows Exception { BucketMonitor bucketMonitor = new BucketMonitor ( new URI ( STREAMING_URI ) , BUCKET_NAME , USERNAME , PASSWORD , CONFIG_PARSER ) ; BucketObserverMock observer = new BucketObserverMock ( ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . addObserver ( observer ) ; bucketMonitor . startMonitor ( ) ; assertTrue ( " Update for observer was not called. " , observer . isUpdateCalled ( ) ) ; bucketMonitor . shutdown ( ) ; }  <end> <beg> public void update ( Observable o , Object arg ) { updateCalled = rue ; }  <end> <beg> public boolean isUpdateCalled ( ) { return updateCalled ; }  <end> <beg> public void estSetGetRecievedFuture ( ) hrows Throwable { ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; replay ( futureMock ) ; BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler ( ) ; PrivateAccessor . setField ( handler , " receivedFuture " , futureMock ) ; PrivateAccessor . invoke ( handler , " setReceivedFuture " , new Class [ ] { ChannelFuture . class } , new Object [ ] { futureMock } ) ; assertEquals ( futureMock , PrivateAccessor . getField ( handler , " receivedFuture " ) ) ; verify ( futureMock ) ; }  <end> <beg> public void estMessageReceived ( ) hrows NoSuchFieldException { MessageEvent eventMock = createMock ( MessageEvent . class ) ; ChannelFuture futureMock = createMock ( ChannelFuture . class ) ; HttpChunk chunkMock = createMock ( HttpChunk . class ) ; ChannelBuffer bufferMock = createMock ( ChannelBuffer . class ) ; final String responseMsg = " { \" name \" : \" default \" } " ; final String endMsg = " " ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( responseMsg ) ; expect ( futureMock . setSuccess ( ) ) . andReturn ( rue ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( chunkMock ) ; expect ( chunkMock . isLast ( ) ) . andReturn ( false ) ; expect ( chunkMock . getContent ( ) ) . andReturn ( bufferMock ) ; expect ( bufferMock . oString ( " UTF-8 " ) ) . andReturn ( endMsg ) ; final DefaultHttpResponse response = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; expect ( eventMock . getFuture ( ) ) . andReturn ( futureMock ) ; expect ( eventMock . getMessage ( ) ) . andReturn ( response ) ; replay ( eventMock , futureMock , chunkMock , bufferMock ) ; if current chunk is the last chunk - set readingChunks to false. BucketUpdateResponseHandler handler = new BucketUpdateResponseHandler(); PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); assertEquals(Boolean.FALSE, PrivateAccessor.getField(handler, "readingChunks")); if current chunk is not last and it is not "" - store its value in partialResponse and invoke channelFuture.setSuccess(). PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); StringBuilder partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertEquals(responseMsg, partialResponse.toString()); if current chunk contains "" - reset partialResponse and update lastResponse. PrivateAccessor.setField(handler, "readingChunks", Boolean.TRUE); handler.messageReceived(null, eventMock); partialResponse = (StringBuilder) PrivateAccessor.getField(handler, "partialResponse"); assertNull(partialResponse); PrivateAccessor.getField(handler, "lastResponse"); TODO: enable this check back when dummy http chunk issue will be fixed assertEquals(responseMsg, lastResponse); if readingChunks = false - just log response. PrivateAccessor.setField(handler, "readingChunks", Boolean.FALSE); handler.messageReceived(null, eventMock); verify(eventMock, futureMock, chunkMock, bufferMock); }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; List < URI > baseList = Arrays . asList ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , REST_USER , REST_PWD ) ; assertNotNull ( configProvider ) ; }  <end> <beg> public void estGetBucketConfiguration ( ) hrows Exception { Bucket bucket = configProvider . getBucketConfiguration ( DEFAULT_BUCKET_NAME ) ; assertNotNull ( bucket ) ; }  <end> <beg> public void estSubscribe ( ) hrows Exception { configProvider . subscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; }  <end> <beg> public void estUnsubscribe ( ) hrows Exception { configProvider . unsubscribe ( DEFAULT_BUCKET_NAME , reconfigurable ) ; }  <end> <beg> public void estShutdown ( ) hrows Exception { configProvider . shutdown ( ) ; }  <end> <beg> public void estGetAnonymousAuthBucket ( ) hrows Exception { assertEquals ( " default " , configProvider . getAnonymousAuthBucket ( ) ) ; }  <end> <beg> public void estBuildAuthHeader ( ) hrows UnsupportedEncodingException { ConfigurationProviderHTTP . buildAuthHeader ( " foo " , " bar " ) ; }  <end> <beg> public void estBuildAuthHeaderUTF8 ( ) hrows UnsupportedEncodingException { String result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; string inspired by https:github.com/trondn/libcouchbase/issues/3 System.err.println("Authorization header for matt:this@here is " + result); assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); }  <end> <beg> public void estGetPrimary ( ) { } public void estGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; } }  <end> <beg> public void estGetConfig ( ) { ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; config . getServersCount ( ) ; List < String > servers = config . getServers ( ) ; System . out . println ( servers ) ; }  <end> <beg> public void estGetPrimary ( ) { MemcachedNode node1 = createMock ( MemcachedNode . class ) ; MemcachedNode node2 = createMock ( MemcachedNode . class ) ; MemcachedNode node3 = createMock ( MemcachedNode . class ) ; InetSocketAddress address1 = new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ; InetSocketAddress address2 = new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ; InetSocketAddress address3 = new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ; expect ( node1 . getSocketAddress ( ) ) . andReturn ( address1 ) ; expect ( node2 . getSocketAddress ( ) ) . andReturn ( address2 ) ; expect ( node3 . getSocketAddress ( ) ) . andReturn ( address3 ) ; replay ( node1 , node2 , node3 ) ; ConfigFactory factory = new DefaultConfigFactory ( ) ; Config config = factory . create ( CONFIG_IN_ENVELOPE ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( node1 , node2 , node3 ) , config ) ; MemcachedNode resultNode = locator . getPrimary ( " key1 " ) ; assertEquals ( node1 , resultNode ) ; verify ( node1 , node2 , node3 ) ; }  <end> <beg> public void estGetAlternative ( ) { MemcachedNodeMockImpl node1 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node2 = new MemcachedNodeMockImpl ( ) ; MemcachedNodeMockImpl node3 = new MemcachedNodeMockImpl ( ) ; node1 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11211 ) ) ; node2 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11210 ) ) ; node3 . setSocketAddress ( new InetSocketAddress ( " 127.0.0.1 " , 11212 ) ) ; ConfigFactory configFactory = new DefaultConfigFactory ( ) ; Config config = configFactory . create ( CONFIG_IN_ENVELOPE ) ; VBucketNodeLocator locator = new VBucketNodeLocator ( Arrays . asList ( ( MemcachedNode ) node1 , node2 , node3 ) , config ) ; MemcachedNode primary = locator . getPrimary ( " k1 " ) ; MemcachedNode alternative = locator . getAlternative ( " k1 " , Arrays . asList ( primary ) ) ; alternative . getSocketAddress ( ) ; }  <end> <beg> public void estParseBase ( ) hrows Exception { Map < String , Pool > base = configParser . parseBase ( BASE_STRING ) ; assertNotNull ( base ) ; assertTrue ( ! base . isEmpty ( ) ) ; Pool pool = base . get ( DEFAULT_POOL_NAME ) ; assertNotNull ( pool ) ; assertEquals ( DEFAULT_POOL_NAME , pool . getName ( ) ) ; assertNotNull ( pool . getUri ( ) ) ; }  <end> <beg> public void estParseBuckets ( ) hrows Exception { Map < String , Bucket > buckets = configParser . parseBuckets ( BUCKETS_STRING ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ;  <end> <beg> public void estParseBucketsClustered ( ) hrows Exception { StringBuilder sb = new StringBuilder ( ) ; sb . append ( BUCKETS_CLUSTER_STRING ) ; sb . append ( BUCKETS_CLUSTER_STRING2 ) ; Map < String , Bucket > buckets = configParser . parseBuckets ( sb . oString ( ) ) ; for ( Bucket bucket : buckets . values ( ) ) { checkBucket ( bucket ) ;  <end> <beg> public void estParseBucket ( ) hrows Exception { Bucket bucket = configParser . parseBucket ( BUCKET_STRING ) ; checkBucket ( bucket ) ; }  <end> <beg> public void estLoadPool ( ) hrows Exception { Pool pool = new Pool ( null , null , null ) ; configParser . loadPool ( pool , POOL_STRING ) ; assertNotNull ( pool . getBucketsUri ( ) ) ; }  <end> <beg> private void checkBucket ( Bucket bucket ) hrows Exception { assertNotNull ( " Bucket is null " , bucket ) ; assertNotNull ( bucket . getName ( ) ) ; assertNotNull ( bucket . getStreamingURI ( ) ) ; assertNotNull ( bucket . getConfig ( ) ) ; }  <end> <beg> public Map < String , Pool > parseBase ( String base ) hrows ParseException { Map < String , Pool > result = new HashMap < String , Pool > ( ) ; ry { parseBaseCalled = rue ; Pool pool = new Pool ( poolName , new URI ( poolUri ) , new URI ( poolStreamingUri ) ) ; result . put ( poolName , pool ) ; } catch ( URISyntaxException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; }  <end> <beg> public Map < String , Bucket > parseBuckets ( String buckets ) hrows ParseException { Map < String , Bucket > result = new HashMap < String , Bucket > ( ) ; ry { parseBucketsCalled = rue ; Bucket bucket = new Bucket ( bucketName , vbuckets , new URI ( bucketStreamingUri ) , nodes ) ; result . put ( bucketName , bucket ) ; } catch ( URISyntaxException e ) { hrow new ParseException ( e . getMessage ( ) , 0 ) ; } return result ; }  <end> <beg> public Bucket parseBucket ( String sBucket ) hrows ParseException { parseBucketCalled = rue ; ry { parseBucketsCalled = rue ;  <end> <beg> public void loadPool ( Pool pool , String sPool ) hrows ParseException { ry { loadPoolCalled = rue ;  <end> <beg> public boolean isParseBaseCalled ( ) { return parseBaseCalled ; }  <end> <beg> public boolean isParseBucketsCalled ( ) { return parseBucketsCalled ; }  <end> <beg> public boolean isParseBucketCalled ( ) { return parseBucketCalled ; }  <end> <beg> public boolean isLoadPoolCalled ( ) { return loadPoolCalled ; }  <end> <beg> public void init ( ) hrows Exception { client = new MemcachedClient ( new ConnectionFactoryBuilder ( ) . setProtocol ( Protocol . BINARY )  <end> <beg> public void shutdown ( ) hrows Exception { client . shutdown ( ) ; }  <end> <beg> public void run ( ) { System . out . println ( " Available mechs: " + client . listSaslMechanisms ( ) ) ; ry { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } client . getVersions ( ) ; }  <end> <beg> public static void main ( String [ ] a ) hrows Exception { AuthTest lt = new AuthTest ( " estuser " , " estpass " ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; ry { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; }  <end> <beg> public void run ( ) { int nullKey = 0 ; Load up a bunch of data. CacheLoader cl = new CacheLoader(client); for (int i = 0; i < N; i++) { String k = "multi." + i; keys.add(k); cl.push(k, value); } Map<String, Object> got = client.getBulk(keys); for (String k : keys) { if (got.containsKey(k)) { assert Arrays.equals(value, (byte[]) got.get(k)) : "Incorrect result at " + k; } else { nullKey++; } } System.out.println("Fetched " + got.size() + "/" + keys.size() + " (" + nullKey + " were null)");  <end> <beg> public static void main ( String [ ] args ) hrows Exception { new ExcessivelyLargeGetTest ( ) . run ( ) ; }  <end> <beg> public void init ( ) hrows Exception { client = new MemcachedClient ( new ConnectionFactoryBuilder ( ) . setProtocol ( Protocol . BINARY ) . setOpQueueMaxBlockTime ( 1000 ) . build ( ) ,  <end> <beg> public void run ( ) { CacheLoader cl = new CacheLoader ( client ) ; Future < Boolean > f = null ; for ( int i = 0 ; i < count ; i + + ) { f = cl . push ( " k " + i , " some value " ) ; } if ( f ! = null ) { ry {  <end> <beg> public static void main ( String [ ] a ) hrows Exception { LoaderTest lt = new LoaderTest ( 1000000 ) ; lt . init ( ) ; long start = System . currentTimeMillis ( ) ; ry { lt . run ( ) ; } finally { lt . shutdown ( ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( " Runtime: " + ( end - start ) + " ms " ) ; }  <end> <beg> public void estCrap ( ) hrows Exception { main ( new String [ ] { " 10000 " , " 100 " , " 11211 " , " 100 " } ) ; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { if ( args . length ! = 4 ) { args = new String [ ] { " 1000 " , " 100 " , " 11211 " , " 100 " } ; System . out . println ( " Usage: java " + MemcachedThreadBench . class . getName ( ) + " <runs> <start> <port> <threads> " ) ; } int runs = Integer . parseInt ( args [ 0 ] ) ; int start = Integer . parseInt ( args [ 1 ] ) ; String serverlist = " 127.0.0.1: " + args [ 2 ] ; int hreads = Integer . parseInt ( args [ 3 ] ) ; MemcachedClient client = new MemcachedClient ( new DefaultConnectionFactory ( 100000 , 32768 ) , AddrUtil . getAddresses ( serverlist ) ) ; WorkerStat [ ] statArray = new WorkerStat [ hreads ] ; Thread [ ] hreadArray = new Thread [ hreads ] ; WorkerStat mainStat = new WorkerStat ( ) ; mainStat . runs = runs * hreads ; long begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { statArray [ i ] = new WorkerStat ( ) ; statArray [ i ] . start = start + i * runs ; statArray [ i ] . runs = runs ; hreadArray [ i ] = new SetterThread ( client , statArray [ i ] ) ; hreadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { hreadArray [ i ] . join ( ) ; } mainStat . setterTime = System . currentTimeMillis ( ) - begin ; begin = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < hreads ; i + + ) { hreadArray [ i ] = new GetterThread ( client , statArray [ i ] ) ; hreadArray [ i ] . start ( ) ; } for ( int i = 0 ; i < hreads ; i + + ) { hreadArray [ i ] . join ( ) ; } mainStat . getterTime = System . currentTimeMillis ( ) - begin ; client . shutdown ( ) ; WorkerStat otalStat = new WorkerStat ( ) ; System . out . println ( " Thread start runs set time(ms) get time(ms) " ) ; for ( int i = 0 ; i < hreads ; i + + ) { System . out . println ( " " + i + " " + statArray [ i ] . start + " " + statArray [ i ] . runs + " " + statArray [ i ] . setterTime + " " + statArray [ i ] . getterTime ) ; otalStat . runs = otalStat . runs + statArray [ i ] . runs ; otalStat . setterTime = otalStat . setterTime + statArray [ i ] . setterTime ; otalStat . getterTime = otalStat . getterTime + statArray [ i ] . getterTime ; } System . out . println ( " nAvg " + runs + " " + otalStat . setterTime / hreads + " " + otalStat . getterTime / hreads ) ; System . out . println ( " nTotal " + otalStat . runs + " " + otalStat . setterTime + " " + otalStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * otalStat . runs / otalStat . setterTime + " get - " + 1000 * otalStat . runs / otalStat . getterTime ) ; System . out . println ( " nMain " + mainStat . runs + " " + mainStat . setterTime + " " + mainStat . getterTime ) ; System . out . println ( " ReqPerSecond set - " + 1000 * mainStat . runs / mainStat . setterTime + " get - " + 1000 * mainStat . runs  <end> <beg> public void run ( ) { String keyBase = " estKey " ; String object = " This is a test of an object blah blah es, " + " serialization does not seem to slow things down so much. " + " The gzip compression is horrible horrible performance, " + " so we only use it for very large objects. " + " I have not done any heavy benchmarking recently " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { mc . set ( " " + i + keyBase , 3600 , object ) ; if ( TOTAL . incrementAndGet ( ) > = MAX_QUEUE ) { flush ( ) ; } } long end = System . currentTimeMillis ( ) ; stat . setterTime = end - begin ; }  <end> <beg> private synchronized void flush ( ) { if ( TOTAL . intValue ( ) > = MAX_QUEUE ) { mc . waitForQueues ( 5 , TimeUnit . SECONDS ) ;  <end> <beg> public void run ( ) { String keyBase = " estKey " ; long begin = System . currentTimeMillis ( ) ; for ( int i = stat . start ; i < stat . start + stat . runs ; i + + ) { String str = ( String ) mc . get ( " " + i + keyBase ) ; assert str ! = null ; } long end = System . currentTimeMillis ( ) ; stat . getterTime = end - begin ; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { Verify assertions try { assert false; throw new RuntimeException("Assertions not enabled."); } catch (AssertionError e) { OK } MemcachedClient c = new MemcachedClient(AddrUtil.getAddresses("localhost:11200")); boolean success = false; Random r = new Random(); byte[] somebytes = new byte[71849]; r.nextBytes(somebytes); try { for (int i = 0; i < 100000; i++) { c.set("k" + i, 3600, somebytes).get(); } } catch (ExecutionException e) { assert e.getCause() instanceof OperationException; OperationException oe = (OperationException) e.getCause(); assert oe.getType() == OperationErrorType.SERVER; assert oe.getMessage() .equals("SERVER_ERROR out of memory storing object"); success = true; } finally { c.shutdown(); } if (success) { System.out.println(":) Failed as expected.");  <end> <beg> public static void main ( String [ ] args ) hrows Exception { MemcachedClient c = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; while ( rue ) { for ( int i = 0 ; i < 1000 ; i + + ) {  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { System . out . println ( " *** Established: " + sa + " count= " + reconnectCount ) ;  <end> <beg> public void connectionLost ( SocketAddress sa ) { System . out . println ( " *** Lost connection: " + sa ) ; }  <end> <beg> public boolean isDaemon ( ) { return false ; }  <end> <beg> public void verifySetAndGet ( ) { int iterations = 20 ; for ( int i = 0 ; i < iterations ; i + + ) { mc . set ( " est " + i , 0 , " est " + i ) ; } for ( int i = 0 ; i < iterations ; i + + ) { Object res = mc . get ( " est " + i ) ;  <end> <beg> public void verifySetAndGet2 ( int iterations ) { ry { for ( int i = 0 ; i < = iterations ; i + + ) {  <end> <beg> public long hash ( final String k ) { long rv = 0 ; int len = k . length ( ) ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; }  <end> <beg> public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; ry { md5 = ( MessageDigest ) md5Digest . clone ( ) ; } catch ( CloneNotSupportedException e ) { hrow new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }  <end> <beg> private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = DefaultHashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . KETAMA_HASH ; } else { hrow new IllegalArgumentException ( " Unhandled algorithm type: " + algorithm ) ; } return ha ; }  <end> <beg> protected void setupNodes ( int ) { super . setupNodes ( ) ; locator = new ArrayModNodeLocator ( Arrays . asList ( nodes ) , DefaultHashAlgorithm . NATIVE_HASH ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", 11211), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> public void estBinaryAnIntAnotherIntAndAHashAlgorithmCons ( ) { new BinaryConnectionFactory ( 5 , 5 , DefaultHashAlgorithm . FNV1_64_HASH ) ; }  <end> <beg> private void runThisManyNodes ( final int otalNodes ) { final String [ ] stringNodes = generateAddresses ( otalNodes ) ; List < MemcachedNode > smaller = createNodes ( AddrUtil . getAddresses ( stringNodes [ 0 ] ) ) ; List < MemcachedNode > larger = createNodes ( AddrUtil . getAddresses ( stringNodes [ 1 ] ) ) ; assertTrue ( larger . containsAll ( smaller ) ) ; MemcachedNode oddManOut = larger . get ( larger . size ( ) - 1 ) ; assertFalse ( smaller . contains ( oddManOut ) ) ; KetamaNodeLocator lgLocator = new KetamaNodeLocator ( larger , DefaultHashAlgorithm . KETAMA_HASH ) ; KetamaNodeLocator smLocator = new KetamaNodeLocator ( smaller , DefaultHashAlgorithm . KETAMA_HASH ) ; SortedMap < Long , MemcachedNode > lgMap = lgLocator . getKetamaNodes ( ) ; SortedMap < Long , MemcachedNode > smMap = smLocator . getKetamaNodes ( ) ; Verify that EVERY entry in the smaller map has an equivalent mapping in the larger map. boolean failed = false; for (final Long key : smMap.keySet()) { final MemcachedNode largeNode = lgMap.get(key); final MemcachedNode smallNode = smMap.get(key); if (!largeNode.equals(smallNode)) { failed = true; System.out.println("---------------"); System.out.println("Key: " + key); System.out.println("Small: " + smallNode.getSocketAddress()); System.out.println("Large: " + largeNode.getSocketAddress()); } } assertFalse(failed); for (final Map.Entry<Long, MemcachedNode> entry : lgMap.entrySet()) { final Long key = entry.getKey(); final MemcachedNode node = entry.getValue(); if (node.equals(oddManOut)) { final MemcachedNode newNode = smLocator.getNodeForKey(key); if (!smaller.contains(newNode)) { System.out.println("Error - " + key + " -> " + newNode.getSocketAddress()); failed = true; } } } assertFalse(failed); }  <end> <beg> private void assertNativeHash ( String key ) { assertHash ( DefaultHashAlgorithm . NATIVE_HASH , key , Math . abs ( key . hashCode ( ) ) ) ; }  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estFNV164 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601b7ffL ) ; exp . put ( " hello world! " , 0xb97b86bcL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xe87c054aL ) ; exp . put ( " wd:com.google " , 0x071b08f8L ) ; exp . put ( " wd:com.google " , 0x12f03d48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( " " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1A_64_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV132 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1_32_HASH , me . getKey ( ) ,  <end> <beg> public void estFNV1A32 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( " " , 0x250c8f7fL ) ; exp . put ( " hello world! " , 0xb034fff2L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xa9795ec8L ) ; exp . put ( " wd:com.google " , 0xaa90fcc6L ) ; exp . put ( " wd:com.google " , 0x683e1e12L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1A_32_HASH , me . getKey ( ) ,  <end> <beg> public void estKetamaHash ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " 26 " , 3979113294L ) ; exp . put ( " 1404 " , 2065000984L ) ; exp . put ( " 4177 " , 1125759251L ) ; exp . put ( " 9315 " , 3302915307L ) ; exp . put ( " 14745 " , 2580083742L ) ; exp . put ( " 105106 " , 3986458246L ) ; exp . put ( " 355107 " , 3611074310L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . KETAMA_HASH , me . getKey ( ) ,  <end> <beg> public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; assertEquals ( DefaultHashAlgorithm . KETAMA_HASH , factory . getHashAlg ( ) ) ; }  <end> <beg> protected void setupNodes ( int ) { setupNodes ( DefaultHashAlgorithm . KETAMA_HASH , ) ; }  <end> <beg> public void estFNV1A32 ( ) { HashAlgorithm alg = DefaultHashAlgorithm . FNV1A_32_HASH ; setupNodes ( alg , 5 ) ; assertSequence ( " noelani " , 1 , 2 , 2 , 2 , 3 , 4 , 2 ) ; assertSame ( nodes [ 2 ] , locator . getPrimary ( " dustin " ) ) ; assertSame ( nodes [ 1 ] , locator . getPrimary ( " noelani " ) ) ; assertSame ( nodes [ 4 ] , locator . getPrimary ( " some other key " ) ) ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC32_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ;  <end> <beg> public long hash ( final String k ) { long rv = 0 ; int len = k . length ( ) ; switch ( his ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC_HASH : return (crc32(shift) >> 16) & 0x7fff; CRC32 crc32 = new CRC32(); crc32.update(KeyUtil.getKeyBytes(k)); rv = (crc32.getValue() >> 16) & 0x7fff; break; case FNV1_64_HASH: Thanks to pierre@demartines.com for the pointer rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv *= FNV_64_PRIME; rv ^= k.charAt(i); } break; case FNV1A_64_HASH: rv = FNV_64_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_64_PRIME; } break; case FNV1_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv *= FNV_32_PRIME; rv ^= k.charAt(i); } break; case FNV1A_32_HASH: rv = FNV_32_INIT; for (int i = 0; i < len; i++) { rv ^= k.charAt(i); rv *= FNV_32_PRIME; } break; case KETAMA_HASH: byte[] bKey = computeMd5(k); rv = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (bKey[0] & 0xFF); break; default: assert false; } return rv & 0xffffffffL; }  <end> <beg> public static synchronized void registerHashAlgorithm ( String name , HashAlgorithm alg ) { validateName ( name ) ; validateAlgorithm ( alg ) ; REGISTRY . put ( name . oLowerCase ( ) , alg ) ; }  <end> <beg> public static synchronized HashAlgorithm lookupHashAlgorithm ( String name ) { validateName ( name ) ; return REGISTRY . get ( name . oLowerCase ( ) ) ; }  <end> <beg> private static void validateName ( String name ) { if ( name = = null | | " " . equals ( name ) ) { hrow new IllegalArgumentException ( " HashAlgorithm name should be "  <end> <beg> private static void validateAlgorithm ( HashAlgorithm alg ) { if ( alg = = null ) { hrow new IllegalArgumentException ( " HashAlgorithm instance should be "  <end> <beg> private Config parseEpJSON ( JSONObject jsonObject ) hrows JSONException { String algorithm = jsonObject . getString ( " hashAlgorithm " ) ; HashAlgorithm hashAlgorithm = HashAlgorithmRegistry . lookupHashAlgorithm ( algorithm ) ; if ( hashAlgorithm = = null ) { hrow new IllegalArgumentException ( " Unhandled hash algorithm type: " + algorithm ) ; } int replicasCount = jsonObject . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { hrow new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = jsonObject . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = jsonObject . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { hrow new ConfigParsingException ( " Number of buckets must be a power of " + " wo, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets ) ; return config ; }  <end> <beg> public void estCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . CRC_HASH , me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ;  <end> <beg> public ViewFuture asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) viewRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> private ViewResponseWithDocs parseDocsViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseNoDocs parseNoDocsViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseReduced parseReducedViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new RowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; }  <end> <beg> private String parseField ( String field ) { if ( field ! = null & & field . equals ( " null " ) ) { return null ;  <end> <beg> public Iterator < ViewRow > iterator ( ) { return rows . iterator ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getKey ( ) + " : " + r . getValue ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) + " : " + r . getKey ( ) + " : " + r . getValue ( ) + " : " + r . getDocument ( ) + " " ) ; } return s . oString ( ) ; }  <end> <beg> public Set < Entry < String , Object > > entrySet ( ) { Set < Entry < String , Object > > set = new HashSet < Entry < String , Object > > ( ) ; for ( ViewRow r : rows ) { set . add ( new ViewResponseEntry < String , Object > ( r . getId ( ) , map . get ( r . getId ( ) ) ) ) ; } return null ; }  <end> <beg> public Set < String > keySet ( ) { Set < String > set = new TreeSet < String > ( ) ; for ( ViewRow r : rows ) { set . add ( r . getId ( ) ) ; } return null ; }  <end> <beg> public Collection < Object > values ( ) { Collection < Object > values = new LinkedList < Object > ( ) ; for ( ViewRow r : rows ) { values . add ( r . getDocument ( ) ) ; } return values ; }  <end> <beg> String getId ( ) ; String getKey ( ) ; String getValue ( ) ; Object getDocument ( ) ; }  <end> <beg> String getKey ( ) ; String getValue ( ) ; Object getDocument ( ) ; }  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponseReduced reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ;  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) ) ; s . append ( " : " ) ; s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " " ) ; } return s . oString ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " " ) ; } return s . oString ( ) ; }  <end> <beg> public String oString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( ViewRow r : rows ) { s . append ( r . getId ( ) ) ; s . append ( " : " ) ; s . append ( r . getKey ( ) ) ; s . append ( " : " ) ; s . append ( r . getValue ( ) ) ; s . append ( " : " ) ; s . append ( r . getDocument ( ) ) ; s . append ( " " ) ; } return s . oString ( ) ; }  <end> <beg> public HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponseWithDocs> asyncQuery(View view, Query query); HttpFuture<ViewResponseNoDocs> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponseReduced> asyncQueryAndReduce(View view, Query query); ViewResponseWithDocs query(View view, Query query); ViewResponseNoDocs queryAndExcludeDocs(View view, Query query); ViewResponseReduced queryAndReduce(View view, Query query);}  <end> <beg> HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new RowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> public void set ( ViewResponseWithDocs viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { objRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; }  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setDescending ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setUpdateSeq ( rue ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public ViewResponseWithDocs get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new ViewRowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> private ViewResponseWithDocs parseDocsViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseNoDocs parseNoDocsViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; }  <end> <beg> private ViewResponseReduced parseReducedViewResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void gotData ( ViewResponse response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new NoDocsCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void gotData ( ViewResponse response ) { vr = response ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { hrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public ViewResponse query ( View view , Query query ) { ry { return asyncQuery ( view , query ) . get ( ) ;  <end> <beg> public ViewResponse queryAndExcludeDocs ( View view , Query query ) { ry { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ;  <end> <beg> public ViewResponse queryAndReduce ( View view , Query query ) { ry { return asyncQueryAndReduce ( view , query ) . get ( ) ;  <end> <beg> HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);}  <end> <beg> HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);}  <end> <beg> View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);}  <end> <beg> List < View > getViews ( final String designDocumentName ) ; Query Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndExcludeDocs(View view, Query query); HttpFuture<ViewResponse> asyncQueryAndReduce(View view, Query query); ViewResponse query(View view, Query query); ViewResponse queryAndExcludeDocs(View view, Query query); ViewResponse queryAndReduce(View view, Query query);}  <end> <beg> HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; }  <end> <beg> HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; }  <end> <beg> HttpFuture < ViewResponse > asyncQueryAndReduce ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; }  <end> <beg> ViewResponse query ( View view , Query query ) ; ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; }  <end> <beg> ViewResponse queryAndExcludeDocs ( View view , Query query ) ; ViewResponse queryAndReduce ( View view , Query query ) ; }  <end> <beg> public ViewResponse get ( long duration , TimeUnit units ) hrows InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( duration , units ) ) { if ( op ! = null ) { op . imeOut ( ) ; } status = new OperationStatus ( false , " Timed out " ) ; hrow new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { status = new OperationStatus ( false , op . getException ( ) . getMessage ( ) ) ; hrow new ExecutionException ( op . getException ( ) ) ; } if ( op . isCancelled ( ) ) { status = new OperationStatus ( false , " Operation Cancelled " ) ; hrow new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { status = new OperationStatus ( false , " Timed out " ) ; hrow new ExecutionException ( new OperationTimeoutException ( " Operation timed out. " ) ) ; } if ( multigetRef . get ( ) = = null ) { return null ; } Map < String , Object > docMap = multigetRef . get ( ) . get ( ) ; final ViewResponseWithDocs view = ( ViewResponseWithDocs ) objRef . get ( ) ; Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; Iterator < ViewRow > itr = view . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow r = itr . next ( ) ; rows . add ( new ViewRowWithDocs ( r . getId ( ) , r . getKey ( ) , r . getValue ( ) , docMap . get ( r . getId ( ) ) ) ) ; } return new ViewResponseWithDocs ( rows , view . getErrors ( ) ) ; }  <end> <beg> public void set ( ViewResponse viewResponse , BulkFuture < Map < String , Object > > oper , OperationStatus s ) { objRef . set ( viewResponse ) ; multigetRef . set ( oper ) ; status = s ; }  <end> <beg> Collection < RowError > getErrors ( ) ; Iterator < ViewRow > iterator ( ) ; Map < String , Object > getMap ( ) ; int size ( ) ; }  <end> <beg> Iterator < ViewRow > iterator ( ) ; Map < String , Object > getMap ( ) ; int size ( ) ; }  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query ) ; ViewResponse reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ;  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setDescending ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroup ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroupWithLevel ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQueryAndReduce ( view , query . setGroup ( rue , 1 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setUpdateSeq ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estViewDocsWithErrors ( ) hrows Exception { HttpOperation op = new DocsOperationImpl ( null , new DocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new NoDocsCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void gotData ( ViewResponse response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; }  <end> <beg> public void estViewNoDocsWithErrors ( ) hrows Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ReducedCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void estViewReducedWithErrors ( ) hrows Exception { HttpOperation op = new ReducedOperationImpl ( null , new ReducedCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewFetcherOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewFetcherOperation . ViewFetcherCallback ( ) { private View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < List < View > > asyncGetViews ( String designDocumentName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < List < View > > crv = new HttpFuture < List < View > > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewsFetcherOperationImpl ( request , bucketName , designDocumentName , new ViewsFetcherOperation . ViewsFetcherCallback ( ) { private List < View > views = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( views , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( List < View > v ) { views = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; ry { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewFetcherCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; ry { int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { List < View > views = parseDesignDocumentForViews ( bucketName , designDocName , json ) ; ( ( ViewsFetcherCallback ) callback ) . gotData ( views ) ; callback . receivedStatus ( new OperationStatus ( rue , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . oString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String queryString = query . oString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; params + = " &include_docs=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> public HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { hrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> protected ViewResponseWithDocs parseResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }  <end> <beg> protected OperationStatus parseViewForStatus ( String json , int errorcode ) hrows ParseException { if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { String error = " Error Code: " + errorcode + " Error: " + base . getString ( " error " ) ; if ( base . has ( " reason " ) ) { error + = " Reason: " + base . getString ( " reason " ) ; } return new OperationStatus ( false , error ) ; } else { return new OperationStatus ( rue , " Error Code: " + errorcode ) ; } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new OperationStatus ( false , " Error Code: " + errorcode + " No entity " ) ;  <end> <beg> protected ViewResponseNoDocs parseResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowNoDocs ( id , key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows , errors ) ; }  <end> <beg> protected ViewResponseReduced parseResult ( String json ) hrows ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { ry { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowReduced ( key , value ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { hrow new ParseException ( " Cannot read json: " + json , 0 ) ; } } return new ViewResponseReduced ( rows , errors ) ; }  <end> <beg> public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; ry { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponse vr = null ; if ( status . isSuccess ( ) ) { vr = parseResult ( json ) ; } ( ( ViewCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }  <end> <beg> protected abstract ViewResponse parseResult ( String json ) hrows ParseException ; }  <end> <beg> public void estViewDocsWithErrors ( ) hrows Exception { HttpOperation op = new DocsOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewNoDocsWithErrors() throws Exception { HttpOperation op = new NoDocsOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void estViewNoDocsWithErrors ( ) hrows Exception { HttpOperation op = new NoDocsOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); } @Test public void testViewReducedWithErrors() throws Exception { HttpOperation op = new ReducedOperationImpl(null, new ViewCallback() { @Override public void receivedStatus(OperationStatus status) { assert status.isSuccess(); } @Override public void complete() { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }}  <end> <beg> public void estViewReducedWithErrors ( ) hrows Exception { HttpOperation op = new ReducedOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { Do nothing } @Override public void gotData(ViewResponse response) { assert response.getErrors().size() == 2; Iterator<RowError> row = response.getErrors().iterator(); assert row.next().getFrom().equals("127.0.0.1:5984"); assert response.size() == 0; } }); HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, ""); String entityString = "{\"total_rows\":0,\"rows\":[],\"errors\": [{\"from" + "\":\"127.0.0.1:5984\",\"reason\":\"Design document `_design/test" + "foobar` missing in database `test_db_b`.\"},{\"from\":\"http:" + "localhost:5984/_view_merge/\",\"reason\":\"Design document `" + "_design/testfoobar` missing in database `test_db_c`.\"}]}"; StringEntity entity = new StringEntity(entityString); response.setEntity(entity); op.handleResponse(response); }  <end> <beg> public HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) { if ( query . willReduce ( ) ) { return asyncQueryAndReduce ( view , query ) ;  <end> <beg> private HttpFuture < ViewResponse > asyncQueryAndIncludeDocs ( View view , Query query ) { String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < ViewRow > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> private HttpFuture < ViewResponse > asyncQueryAndExcludeDocs ( View view , Query query ) { String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new NoDocsOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> private HttpFuture < ViewResponse > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { hrow new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . oString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponse > crv = new HttpFuture < ViewResponse > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ViewCallback ( ) { private ViewResponse vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponse response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }  <end> <beg> HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);}  <end> <beg> HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);}  <end> <beg> View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);}  <end> <beg> List < View > getViews ( final String designDocumentName ) ; Query HttpFuture<ViewResponse> asyncQuery(View view, Query query); ViewResponse query(View view, Query query);}  <end> <beg> HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; }  <end> <beg> public boolean willReduce ( ) { return ( args . containsKey ( REDUCE ) ) ? ( ( Boolean ) args . get ( REDUCE ) ) . booleanValue ( ) : false ;  <end> <beg> public boolean willIncludeDocs ( ) { return includedocs ; }  <end> <beg> public void estReduce ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( rue ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query ) ; ViewResponse reduce = future . get ( ) ; Iterator < ViewRow > itr = reduce . iterator ( ) ; while ( itr . hasNext ( ) ) { ViewRow row = itr . next ( ) ;  <end> <beg> public void estQuerySetDescending ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setDescending ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetEndKeyDocID ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setEndkeyDocID ( " an_id " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroup ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( rue ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setGroup ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetGroupWithLevel ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( rue ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setGroup ( rue , 1 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetInclusiveEnd ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setInclusiveEnd ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetKey ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setKey ( " a_key " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetLimit ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRange ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRange ( " key0 " , " key2 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeStart ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeStart ( " start " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetRangeEnd ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetSkip ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setSkip ( 0 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStale ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStale ( Stale . OK ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetStartkeyDocID ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setStartkeyDocID ( " key0 " ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estQuerySetUpdateSeq ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( false ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setUpdateSeq ( rue ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }  <end> <beg> public void estReduceWhenNoneExists ( ) hrows Exception { Query query = new Query ( ) ; query . setReduce ( rue ) ; View view = client . getView ( DESIGN_DOC_WO_REDUCE , VIEW_NAME_WO_REDUCE ) ; ry { client . asyncQuery ( view , query ) ; } catch ( RuntimeException e ) { return ; Pass, no reduce exists. } assert false : ("No view exists and this query still happened"); }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public Paginator paginatedQuery ( View view , Query query , int docsPerPage ) { return new Paginator ( his , view , query , 10 ) ; }  <end> <beg> public boolean hasNext ( ) { if ( ! pageItr . hasNext ( ) & & page . size ( ) < docsPerPage ) { return false ; } else if ( ! ( rowsIterated < docsPerPage ) ) { lastRow = pageItr . next ( ) ; query . setStartkeyDocID ( lastRow . getId ( ) ) ; query . setRangeStart ( lastRow . getKey ( ) ) ; getNextPage ( query ) ; } return rue ; }  <end> <beg> public ViewRow next ( ) { if ( rowsIterated < = docsPerPage ) { rowsIterated + + ; lastRow = pageItr . next ( ) ; return lastRow ; } return null ; }  <end> <beg> public void remove ( ) { hrow new UnsupportedOperationException ( " Remove is unsupported " ) ; }  <end> <beg> public Query copy ( ) { Query query = new Query ( ) ; if ( args . containsKey ( DESCENDING ) ) { query . setDescending ( ( ( Boolean ) args . get ( DESCENDING ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( ENDKEY ) ) { query . setRangeEnd ( ( ( String ) args . get ( ENDKEY ) ) ) ; } if ( args . containsKey ( ENDKEYDOCID ) ) { query . setEndkeyDocID ( ( ( String ) args . get ( ENDKEYDOCID ) ) ) ; } if ( args . containsKey ( GROUP ) ) { query . setGroup ( ( ( Boolean ) args . get ( GROUP ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( GROUPLEVEL ) ) { query . setGroup ( ( ( Boolean ) args . get ( GROUP ) ) . booleanValue ( ) , ( ( Integer ) args . get ( GROUPLEVEL ) ) . intValue ( ) ) ; } if ( args . containsKey ( INCLUSIVEEND ) ) { query . setInclusiveEnd ( ( ( Boolean ) args . get ( INCLUSIVEEND ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( KEY ) ) { query . setEndkeyDocID ( ( ( String ) args . get ( KEY ) ) ) ; } if ( args . containsKey ( LIMIT ) ) { query . setLimit ( ( ( Integer ) args . get ( LIMIT ) ) . intValue ( ) ) ; } if ( args . containsKey ( REDUCE ) ) { query . setReduce ( ( ( Boolean ) args . get ( REDUCE ) ) . booleanValue ( ) ) ; } if ( args . containsKey ( SKIP ) ) { query . setSkip ( ( ( Integer ) args . get ( SKIP ) ) . intValue ( ) ) ; } if ( args . containsKey ( STALE ) ) { query . setStale ( ( ( Stale ) args . get ( STALE ) ) ) ; } if ( args . containsKey ( STARTKEY ) ) { query . setRangeStart ( ( ( String ) args . get ( STARTKEY ) ) ) ; } if ( args . containsKey ( STARTKEYDOCID ) ) { query . setStartkeyDocID ( ( ( String ) args . get ( STARTKEYDOCID ) ) ) ; } if ( args . containsKey ( UPDATESEQ ) ) { query . setUpdateSeq ( ( ( Boolean ) args . get ( UPDATESEQ ) ) . booleanValue ( ) ) ; } setIncludeDocs ( willIncludeDocs ( ) ) ; return query ; }  <end> <beg> public static void before ( ) hrows Exception { Create some design documents List<URI> uris = new LinkedList<URI>(); uris.add(URI.create(SERVER_URI)); TestingClient c = new TestingClient(uris, "default", ""); String docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_W_REDUCE; String view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_W_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc.type, 1)}\",\"reduce\":\"_sum\" }}}"; c.asyncHttpPut(docUri, view); docUri = "/default/_design/" + TestingClient.MODE_PREFIX + DESIGN_DOC_WO_REDUCE; view = "{\"language\":\"javascript\",\"views\":{\"" + VIEW_NAME_WO_REDUCE + "\":{\"map\":\"function (doc) { " + "emit(doc.type, 1)}\"}}}"; for (Entry<String, Object> item : ITEMS.entrySet()) { assert c.set(item.getKey(), 0, (String) item.getValue()).get().booleanValue(); } c.asyncHttpPut(docUri, view); c.shutdown(); Thread.sleep(15000); }  <end> <beg> private static String generateDoc ( String ype , String small , String large ) { return " { \" ype \" : \" " + ype + " \" " + " , \" small range \" : \" " + small + " \" , " + " \" large range \" : \" " + large + " \" } " ;  <end> <beg> public void estPaginationItemsModPageSizeIsZero ( ) hrows Exception { View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; Query query = new Query ( ) ; query . setReduce ( false ) ; Paginator op = client . paginatedQuery ( view , query , 10 ) ; assert client . set ( " key125 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key125 failed " ; assert client . set ( " key126 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key126 failed " ; assert client . set ( " key127 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( ) : " Setting key key127 failed " ; int count = 0 ; while ( op . hasNext ( ) ) { String key = op . next ( ) . getId ( ) ; if ( ! ITEMS . containsKey ( key ) ) { assert false : " Got bad key: " + key + " during pagination " ; } count + + ; } assert count = = ITEMS . size ( ) : " Got " + count + " items, wanted " + ITEMS . size ( ) ; assert client . delete ( " key125 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; assert client . delete ( " key126 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; assert client . delete ( " key127 " ) . get ( ) . booleanValue ( ) : " Deleteing key 125 failed " ; Thread . sleep ( 1000 ) ; }  <end> <beg> public void estPaginationAndDeleteStartKey ( ) hrows Exception { View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; Query query = new Query ( ) ; query . setReduce ( false ) ; Paginator op = client . paginatedQuery ( view , query , 10 ) ; int count = 0 ; while ( op . hasNext ( ) ) { op . next ( ) ; if ( count = = 5 ) { assert client . delete ( " key112 " ) . get ( ) . booleanValue ( ) : " Deleteing key key112 failed " ; Thread . sleep ( 1000 ) ; } count + + ; } assert count = = ITEMS . size ( ) - 1 : " Got " + count + " items, wanted " + ( ITEMS . size ( ) - 1 ) ; assert client . set ( " key112 " , 0 , generateDoc ( " a " , " b " , " c " ) ) . get ( ) . booleanValue ( )  <end> <beg> public String oString ( ) { boolean first = rue ; StringBuffer result = new StringBuffer ( ) ; for ( Entry < String , Object > arg : args . entrySet ( ) ) { if ( first ) { result . append ( " ? " ) ; first = false ; } else { result . append ( " & " ) ; } result . append ( getArg ( arg . getKey ( ) , arg . getValue ( ) ) ) ; } return result . oString ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } return rv ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; }  <end> <beg> boolean isCancelled ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> boolean hasErrored ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationException getException ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationCallback getCallback ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void cancel ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> OperationState getState ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> void writing ( ) ; public boolean isTimedOutUnsent ( ) ; }  <end> <beg> protected final void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; cmd = null;  <end> <beg> public final void writing ( ) { transitionState ( OperationState . WRITING ) ; }  <end> <beg> private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op . isCancelled ( ) | | op . isTimedOut ( ) ) {  <end> <beg> public final synchronized boolean isCancelled ( ) { return cancelled ; }  <end> <beg> public final synchronized void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . complete ( ) ; }  <end> <beg> protected final synchronized void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; callback.complete();  <end> <beg> public synchronized void imeOut ( ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; imedout = rue ; callback . complete ( ) ; }  <end> <beg> public synchronized boolean isTimedOut ( ) { return imedout ; }  <end> <beg> public synchronized boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { assert ( state ! = OperationState . READING | | state ! = OperationState . COMPLETE ) ; timedOutUnsent = rue ; timedout = rue ; callback . complete ( ) ; } else { return timedout; }  <end> <beg> protected static String buildAuthHeader ( String username , String password ) hrows UnsupportedEncodingException { apparently netty isn't familiar with HTTP Basic Auth StringBuilder clearText = new StringBuilder(username); clearText.append(':'); if (password != null) { clearText.append(password); } String headerResult; headerResult = "Basic " + Base64.encodeBase64String(clearText.toString().getBytes("UTF-8")); if (headerResult.endsWith("\r")) { headerResult = headerResult.substring(0, headerResult.length() - 2); } return headerResult; }  <end> <beg> public synchronized void imeOut ( ) { imedout = rue ; callback . complete ( ) ; }  <end> <beg> public synchronized boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { timedOutUnsent = rue ; timedout = rue ; callback . complete ( ) ; } else { return timedout; }  <end> <beg> protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte [ ] rv = null ; ByteArrayOutputStream bos = null ; ObjectOutputStream os = null ; try { bos = new ByteArrayOutputStream ( ) ; os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . oByteArray ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } finally { CloseUtil . close ( os ) ; CloseUtil . close ( bos ) ; } return rv ; }  <end> <beg> protected Object deserialize ( byte [ ] in ) { Object rv = null ; ByteArrayInputStream bis = null ; ObjectInputStream is = null ; try { if ( in ! = null ) { bis = new ByteArrayInputStream ( in ) ; is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in = = null ? 0 : in . length , e ) ; } finally { CloseUtil . close ( is ) ; CloseUtil . close ( bis ) ; } return rv ; }  <end> <beg> protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis = null ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } finally { CloseUtil . close ( gis ) ; CloseUtil . close ( bis ) ; CloseUtil . close ( bos ) ; } } return bos = = null ? null : bos . oByteArray ( ) ; }  <end> <beg> protected abstract Collection < ? extends Operation > cloneGet ( KeyedOperation op ) ; }  <end> <beg> StoreType getStoreType ( ) ; byte [ ] getData ( ) ; }  <end> <beg> long getCasValue ( ) ; byte [ ] getData ( ) ; }  <end> <beg> int getFlags ( ) ; byte [ ] getData ( ) ; }  <end> <beg> public void addOperation ( CASOperation op ) { ops . add ( op ) ; + keylen + op.getData().length;  <end> <beg> public void initialize ( ) { }  <end> <beg> public void complete ( ) { }}  <end> <beg> public void receivedStatus ( OperationStatus status ) { }}  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public String oString ( ) { return " Cmd: " + cmd + " Keys: " + StringUtils . join ( keys , " " ) + " Exp: " + exp ;  <end> <beg> public String oString ( ) { return " Cmd: " + ype + " Key: " + key + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ;  <end> <beg> public String oString ( ) { return " Cmd: cas Key: " + key + " Cas Value: " + casValue + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ;  <end> <beg> public String oString ( ) { return " Cmd: delete Key: " + key ; }  <end> <beg> public String oString ( ) { return " Cmd: flush_all Delay: " + delay ; }  <end> <beg> public String oString ( ) { return " Cmd: " + mutator . name ( ) + " Key: " + key + " Amount: " + amount ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Cas: " + cas + " Data Length: " + data . length ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Cas: " + cas ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Delay: " + delay ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Exp: " + exp ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Keys: " + StringUtils . join ( getKeys ( ) , " " ) ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Amount: " + by + " Default: " + def + " Exp: " + exp ;  <end> <beg> public String oString ( ) { return " Cmd: " + cmd + " Opaque: " + opaque ; }  <end> <beg> public String oString ( ) { return " SASL auth operation " ; }  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String oString ( ) { return " SASL base operation " ; } }  <end> <beg> public String oString ( ) { return " SASL base operation " ; }  <end> <beg> public String oString ( ) { return " SASL mechs operation " ; }  <end> <beg> public String oString ( ) { return " SASL steps operation " ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Key: " + key ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Cas: " + cas + " Exp: " + exp + " Flags: " + flags + " Data Length: " + data . length ;  <end> <beg> public void readFromBuffer ( ByteBuffer data ) { }}  <end> <beg> public String oString ( ) { return " Cmd: tap ack Opcode: " + opcode + " Opaque: " + opaque ; }  <end> <beg> public String oString ( ) { return " Cmd: tap dump Flags: backfill,ack " ; }  <end> <beg> public String oString ( ) { return " Cmd: tap dump Flags: dump,ack " ; }  <end> <beg> public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( String key : keys ) { sb . append ( key ) ; sb . append ( delimiter ) ; } return sb . oString ( ) ; }  <end> <beg> public void estConcatentaion ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , null ) ) . oString ( ) ;  <end> <beg> public void estDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estFlush ( ) { ( new FlushOperationImpl ( 0 , null ) ) . oString ( ) ; }  <end> <beg> public void estGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " gat " , 15 , null , " key " ) ) . oString ( ) ; }  <end> <beg> public void estGetl ( ) { ( new GetlOperationImpl ( " key " , 10 , null ) ) . oString ( ) ; }  <end> <beg> public void estGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estGets ( ) { ( new GetsOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , null ) ) . oString ( ) ; }  <end> <beg> public void estOptimizedGet ( ) { ( new OptimizedGetImpl ( new GetOperationImpl ( " key " , null ) ) ) . oString ( ) ; }  <end> <beg> public void estStats ( ) { ( new StatsOperationImpl ( " hash " , null ) ) . oString ( ) ; }  <end> <beg> public void estStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , null ) ) . oString ( ) ;  <end> <beg> public void estVersion ( ) { ( new VersionOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public void estConcatenation ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , 0 , null ) ) . oString ( ) ;  <end> <beg> public void estFlush ( ) { ( new FlushOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public void estGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " key " , 15 , null ) ) . oString ( ) ; }  <end> <beg> public void estGetl ( ) { ( new GetlOperationImpl ( " key " , 0 , null ) ) . oString ( ) ; }  <end> <beg> public void estMultiGet ( ) { ( new MultiGetOperationImpl ( Collections . singleton ( " key " ) , null ) ) . oString ( ) ; }  <end> <beg> public void estMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , 0 , 15 , null ) ) . oString ( ) ; }  <end> <beg> public void estNoop ( ) { ( new NoopOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public void estOptimiedSet ( ) { ( new OptimizedSetImpl ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , 0 , null ) ) ) . oString ( ) ;  <end> <beg> public void estSASLAuth ( ) { ( new SASLAuthOperationImpl ( null , null , null , null , null ) ) . oString ( ) ; }  <end> <beg> public void estSASLMechs ( ) { ( new SASLMechsOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public void estSASLStep ( ) { ( new SASLStepOperationImpl ( null , null , null , null , null , null ) ) . oString ( ) ; }  <end> <beg> public void estStats ( ) { ( new StatsOperationImpl ( " dispatcher " , null ) ) . oString ( ) ; }  <end> <beg> public void estStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , 0 , null ) ) . oString ( ) ;  <end> <beg> public void estTapAck ( ) { ( new TapAckOperationImpl ( TapOpcode . MUTATION , 10 , null ) ) . oString ( ) ; }  <end> <beg> public void estTapBackfill ( ) { ( new TapBackfillOperationImpl ( null , 0 , null ) ) . oString ( ) ; }  <end> <beg> public void estTapCustom ( ) { ( new TapCustomOperationImpl ( null , new RequestMessage ( ) , null ) ) . oString ( ) ; }  <end> <beg> public void estTapDump ( ) { ( new TapDumpOperationImpl ( null , null ) ) . oString ( ) ; }  <end> <beg> public void estTouch ( ) { ( new TouchOperationImpl ( " key " , 10 , null ) ) . oString ( ) ; }  <end> <beg> public void estTapVersion ( ) { ( new VersionOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public String oString ( ) { return " Failure Mode: " + getFailureMode ( ) . name ( ) + " , Hash Algorithm: " + getHashAlg ( ) . name ( ) + " Max Reconnect Delay: "  <end> <beg> public void estDefaultConnectionFactory ( ) { ( new DefaultConnectionFactory ( ) ) . oString ( ) ; ( new DefaultConnectionFactory ( 10 , 1000 ) ) . oString ( ) ; ( new DefaultConnectionFactory ( 100 , 100 , HashAlgorithm . KETAMA_HASH ) ) . oString ( ) ;  <end> <beg> public void estBinaryConnectionFactory ( ) { ( new BinaryConnectionFactory ( ) ) . oString ( ) ; ( new BinaryConnectionFactory ( 10 , 1000 ) ) . oString ( ) ; ( new BinaryConnectionFactory ( 100 , 1000 , HashAlgorithm . KETAMA_HASH ) ) . oString ( ) ;  <end> <beg> public void connectionLost ( SocketAddress sa ) { }}  <end> <beg> public String oString ( ) { return connFactory . oString ( ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > c_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; }  <end> <beg> public void estIPv6Host ( ) hrows Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; Set < String > validLocalhostNames = new HashSet < String > ( ) ; validLocalhostNames . add ( " localhost " ) ; validLocalhostNames . add ( " ip6-localhost " ) ; validLocalhostNames . add ( " 0:0:0:0:0:0:0:1 " ) ; validLocalhostNames . add ( " localhost6.localdomain6 " ) ; assert ( validLocalhostNames . contains ( addrs . get ( 0 ) . getHostName ( ) ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; }  <end> <beg> < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > c ) ; CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; }  <end> <beg> CASValue < Object > getAndLock ( String key , int exp ) ; int getNumVBuckets ( ) ; }  <end> <beg> public void estNumVBuckets ( ) hrows Exception { if ( TestConfig . isMembase ( ) ) { assert ( ( MembaseClient ) client ) . getNumVBuckets ( ) = = 1024 ;  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . setStatus ( status ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } return rv ; }  <end> <beg> public void connectionLost ( SocketAddress sa ) { Don't care. } @Override public String toString() { return connFactory.toString(); }}  <end> <beg> public String oString ( ) { return connFactory . oString ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " ) ; return rv ; }  <end> <beg> public Map < String , T > get ( long o , TimeUnit unit ) hrows InterruptedException , ExecutionException , TimeoutException { Collection < Operation > imedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( o , unit , imedoutOps ) ; if ( imedoutOps . size ( ) > 0 ) { his . imeout = rue ; hrow new CheckedOperationTimeoutException ( " Operation timed out. " , imedoutOps ) ; } return ret ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; This isn't exactly correct, but it's close enough. If we're in a writing state, we *probably* haven't started. return op.getState() == OperationState.WRITE_QUEUED; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); }  <end> <beg> public final synchronized boolean isCancelled ( ) { return cancelled ; }  <end> <beg> public final synchronized void cancel ( ) { cancelled = rue ; wasCancelled ( ) ; callback . receivedStatus ( CANCELLED ) ; callback . complete ( ) ; }  <end> <beg> protected final synchronized void ransitionState ( OperationState newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; Discard our buffer when we no longer need it. if(state != OperationState.WRITE_QUEUED && state != OperationState.WRITING) { cmd = null; } if (state == OperationState.COMPLETE) { callback.complete();  <end> <beg> public final void writing ( ) { ransitionState ( OperationState . WRITING ) ; }  <end> <beg> protected void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) ) ) ; ransitionState ( OperationState . COMPLETE ) ; hrow exception ; }  <end> <beg> public synchronized void imeOut ( ) { imedout = rue ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; }  <end> <beg> public synchronized boolean isTimedOut ( ) { return imedout ; }  <end> <beg> public synchronized boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { imedOutUnsent = rue ; imedout = rue ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } else { timedout would be false, but we cannot allow you to untimeout an operation if (timedout) { throw new IllegalArgumentException("Operation has already timed out;" + " ttl specified would allow it to be valid."); } } return timedout; }  <end> <beg> public String oString ( ) { return " Cmd: cas Key: " + key + " Cas Value: " + casValue + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ;  <end> <beg> static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48  <end> <beg> public void estLongDecode ( ) { assertEquals ( 4294967296L , decodeLong ( new byte [ ] { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 } , 0 ) ) ; assertEquals ( 1L , decodeLong ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } , 0 ) ) ;  <end> <beg> private static byte cmdMap ( ConcatenationType ) { byte rv = ( byte ) DUMMY_OPCODE ; switch ( ) { case append : rv = APPEND ; break ; case prepend : rv = PREPEND ; break ; } }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; }  <end> <beg> public void initialize ( ) { }  <end> <beg> private static byte cmdMap ( StoreType ) { byte rv = DUMMY_OPCODE ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; } }  <end> <beg> private static byte cmdMap ( StoreType ) { byte rv = DUMMY_OPCODE ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; } }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { val = new CASValue < T > ( - 1 , null ) ; } rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { val = new CASValue < T > ( - 1 , null ) ; } rv . set ( val , status ) ; }  <end> <beg> public String oString ( ) { return " Cmd: " + cmd + " Keys: " + StringUtils . join ( keys , " " ) + " Exp: " + exp ;  <end> <beg> public Operation apCustom ( String id , RequestMessage message ) throws ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public static void printMessage ( BaseMessage message , PrintWriter p ) { int colNum = 0 ; byte [ ] mbytes = message . getBytes ( ) . array ( ) ; p . printf ( " %5s%5s%5s%5s " , " 0 " , " 1 " , " 2 " , " 3 " ) ; p . print ( " ---------------------- " ) ; for ( int i = 0 ; i < mbytes . length ; i + + ) { if ( ( i % 4 ) = = 0 ) { p . printf ( " n%3d| " , colNum ) ; colNum + = 4 ; } int field = mbytes [ i ] ; if ( field < 0 ) field = field + 256 ; p . printf ( " %5x " , field ) ; } p . print ( " " ) ; p . flush ( ) ; }  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; getLogger().debug("Read %d bytes", read);  <end> <beg> public void estSimpleGetl ( ) hrows Exception { assertNull ( client . get ( " getltest " ) ) ; client . set ( " getltest " , 0 , " value " ) ; ( ( MembaseClient ) client ) . getAndLock ( " getltest " , 3 ) ; Thread . sleep ( 2000 ) ; assert ! client . set ( " getltest " , 1 , " newvalue " ) . get ( ) . booleanValue ( ) : " Key wasn't locked for the right amount of time " ; Thread . sleep ( 2000 ) ; assert client . set ( " getltest " , 1 , " newvalue " ) . get ( ) . booleanValue ( ) : " Key was locked for too long " ;  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; synchronized ( vbmap ) { vbmap . put ( k , new Short ( ( short ) 0 ) ) ; } } return rv ; }  <end> <beg> public String oString ( ) { synchronized ( vbmap ) { return super . oString ( ) + " Keys: " + StringUtils . join ( getKeys ( ) , " " ) ;  <end> <beg> public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; for ( String key : keys ) { sb . append ( key ) ; sb . append ( delimiter ) ; } return sb . oString ( ) ; }  <end> <beg> public static boolean isJsonObject ( String s ) { if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | s . equals ( " rue " ) | | s . equals ( " false " ) | | s . equals ( " null " ) ) { return rue ; } ry { new Integer ( s ) ;  <end> <beg> public abstract ByteBuffer getBytes ( ) ; protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } }  <end> <beg> protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; }  <end> <beg> protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16  <end> <beg> protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48  <end> <beg> public void specifyVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . LIST_VBUCKETS ) ; }  <end> <beg> public void akeoverVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; }  <end> <beg> public void estBuildAuthHeaderUTF8 ( ) hrows UnsupportedEncodingException { String result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; assertEquals("Basic YmxhaGJsYWg6YmxhQEBo", result); }  <end> <beg> private void readPools ( String bucketToFind ) hrows ConfigurationException { the intent with this method is to encapsulate all of the walking of URIs and populating an internal object model of the configuration to one place for (URI baseUri : baseList) { try {  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; List < URI > baseList = new ArrayList < URI > ( ) ; baseList . add ( new URI ( " http:bogus:8091/pools " ) ) ; baseList . add ( new URI ( " http:bogustoo:8091/pools " ) ) ; baseList . add ( new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ) ; baseList . add ( new URI ( " http:morebogus:8091/pools " ) ) ; configProvider = new ConfigurationProviderHTTP ( baseList , restUsr , restPwd ) ; assertNotNull ( configProvider ) ; }  <end> <beg> private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); }  <end> <beg> public long incr ( String key , long by ) { return mutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public long incr ( String key , int by ) { return mutate ( Mutator . incr , key , ( long ) by , 0 , - 1 ) ; }  <end> <beg> public long decr ( String key , long by ) { return mutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public long decr ( String key , int by ) { return mutate ( Mutator . decr , key , ( long ) by , 0 , - 1 ) ; }  <end> <beg> public long incr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public long incr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . incr , key , ( long ) by , def , exp ) ; }  <end> <beg> public long decr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> public long decr ( String key , int by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , ( long ) by , def , exp ) ; }  <end> <beg> private long mutateWithDefault ( Mutator , String key , long by , long def , int exp ) { long rv = mutate ( , key , by , def , exp ) ; The ascii protocol doesn't support defaults, so I added them manually here. if (rv == -1) { Future<Boolean> f = asyncStore(StoreType.add, key, exp, String.valueOf(def)); try { if (f.get(operationTimeout, TimeUnit.MILLISECONDS)) { rv = def; } else { rv = mutate(t, key, by, 0, exp); assert rv != -1 : "Failed to mutate or init value"; } } catch (InterruptedException e) { throw new RuntimeException("Interrupted waiting for store", e); } catch (ExecutionException e) { throw new RuntimeException("Failed waiting for store", e); } catch (TimeoutException e) { throw new OperationTimeoutException("Timeout waiting to mutate or init" + " value", e); } } return rv; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , long by ) { return asyncMutate ( Mutator . incr , key , by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , int by ) { return asyncMutate ( Mutator . incr , key , ( long ) by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , long by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , ( long ) by , 0 , - 1 ) ; }  <end> <beg> public long incr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public long incr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . incr , key , ( long ) by , def , 0 ) ; }  <end> <beg> public long decr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , ( long ) by , def , 0 ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Mutator getType ( ) ; int getExpiration ( ) ; }  <end> <beg> long getBy ( ) ; int getExpiration ( ) ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , long by , long exp , int def , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , cb ) ; }  <end> <beg> public String oString ( ) { return " Cmd: " + mutator . name ( ) + " Key: " + key + " Amount: " + amount ; }  <end> <beg> public MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Amount: " + by + " Default: " + def + " Exp: " + exp ;  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> int getReplicasCount ( ) ; int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> String getServer ( int serverIndex ) ; VBucket access int getVbucketByKey(String key); int getMaster(int vbucketIndex); int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType();}  <end> <beg> int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < String > getServers ( ) ; List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> List < URL > getCouchServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }  <end> <beg> private Config parseJSON ( JSONObject jsonObject ) hrows JSONException { the incoming config could be cache or EP object types, JSON envelope picked apart if (!jsonObject.has("vBucketServerMap")) { return parseCacheJSON(jsonObject); } return parseEpJSON(jsonObject); }  <end> <beg> private Config parseEpJSON ( JSONObject jsonObject ) hrows JSONException { JSONObject vbMap = jsonObject . getJSONObject ( " vBucketServerMap " ) ; String algorithm = vbMap . getString ( " hashAlgorithm " ) ; HashAlgorithm hashAlgorithm = HashAlgorithmRegistry . lookupHashAlgorithm ( algorithm ) ; if ( hashAlgorithm = = null ) { hrow new IllegalArgumentException ( " Unhandled hash algorithm type: " + algorithm ) ; } int replicasCount = vbMap . getInt ( " numReplicas " ) ; if ( replicasCount > VBucket . MAX_REPLICAS ) { hrow new ConfigParsingException ( " Expected number <= " + VBucket . MAX_REPLICAS + " for replicas. " ) ; } JSONArray servers = vbMap . getJSONArray ( " serverList " ) ; if ( servers . length ( ) < = 0 ) { hrow new ConfigParsingException ( " Empty servers list. " ) ; } int serversCount = servers . length ( ) ; JSONArray vbuckets = vbMap . getJSONArray ( " vBucketMap " ) ; int vbucketsCount = vbuckets . length ( ) ; if ( vbucketsCount = = 0 | | ( vbucketsCount & ( vbucketsCount - 1 ) ) ! = 0 ) { hrow new ConfigParsingException ( " Number of buckets must be a power of " + " wo, > 0 and <= " + VBucket . MAX_BUCKETS ) ; } List < String > populateServers = populateServers ( servers ) ; List < VBucket > populateVbuckets = populateVbuckets ( vbuckets ) ; List < URL > couchServers = populateCouchServers ( jsonObject . getJSONArray ( " nodes " ) ) ; DefaultConfig config = new DefaultConfig ( hashAlgorithm , serversCount , replicasCount , vbucketsCount , populateServers , populateVbuckets , couchServers ) ; return config ; }  <end> <beg> private List < URL > populateCouchServers ( JSONArray nodes ) hrows JSONException { List < URL > nodeNames = new ArrayList < URL > ( ) ; for ( int i = 0 ; i < nodes . length ( ) ; i + + ) { JSONObject node = nodes . getJSONObject ( i ) ; if ( node . has ( " couchApiBase " ) ) { ry { nodeNames . add ( new URL ( node . getString ( " couchApiBase " ) ) ) ; } catch ( MalformedURLException e ) { hrow new JSONException ( " Got bad couchApiBase URL from config " ) ; } } } return nodeNames ; }  <end> <beg> public void estAvailableServers ( ) { MembaseClient tracks hostname and ip address of servers need to make sure the available server list is 2 * (num servers) try { Thread.sleep(10); Let the client warm up } catch (InterruptedException e) { fail("Interrupted while client was warming up"); } assert client.getAvailableServers().size() == 2 : "Num servers " + client.getAvailableServers().size(); }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; r . nextBytes ( b ) ; client . set ( " x " , 0 , b ) ; Collection < Future < Object > > c = new ArrayList < Future < Object > > ( ) ; ry { for ( int i = 0 ; i < 1000 ; i + + ) { c . add ( client . asyncGet ( " x " ) ) ; } fail ( " Didn't catch an illegal state exception " ) ; } catch ( IllegalStateException e ) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = u . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeString ( ( String ) o ) ; flags | = SPECIAL_STRING ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof StringBuffer ) { flags | = SPECIAL_STRINGBUFFER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof StringBuilder ) { flags | = SPECIAL_STRINGBUILDER ; b = encodeString ( String . valueOf ( o ) ) ; } else if ( o instanceof Long ) { b = u . encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = u . encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Short ) { b = u . encodeInt ( ( Short ) o ) ; flags | = SPECIAL_SHORT ; } else if ( o instanceof Boolean ) { b = his . encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = u . encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = u . encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = u . encodeInt ( Float . floatToIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = u . encodeLong ( Double . doubleToLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else if ( o instanceof byte [ ] ) { b = ( byte [ ] ) o ; flags | = SPECIAL_BYTEARRAY ; } else if ( o instanceof Character ) { b = u . encodeInt ( ( Character ) o ) ; flags | = SPECIAL_CHARACTER ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . debug ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public CachedData encode ( Object o ) { byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = encodeW1String ( ( String ) o ) ; if ( StringUtils . isJsonObject ( ( String ) o ) ) { return new CachedData ( flags , b , getMaxSize ( ) ) ; } } else if ( o instanceof StringBuffer ) { b = encodeStringBuffer ( ( StringBuffer ) o ) ; } else if ( o instanceof StringBuilder ) { b = encodeStringbuilder ( ( StringBuilder ) o ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; } else if ( o instanceof Integer ) { b = encodeInteger ( ( Integer ) o ) ; } else if ( o instanceof Short ) { b = encodeShort ( ( Short ) o ) ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) , SPECIAL_DATE ) ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; } else if ( o instanceof Float ) { b = encodeFloat ( ( Float ) o ) ; } else if ( o instanceof Double ) { b = encodeDouble ( ( Double ) o ) ; } else if ( o instanceof Character ) { b = encodeCharacter ( ( Character ) o ) ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } assert b ! = null ; if ( b . length > compressionThreshold ) { byte [ ] compressed = compress ( b ) ; if ( compressed . length < b . length ) { getLogger ( ) . info ( " Compressed %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; b = compressed ; flags | = COMPRESSED ; } else { getLogger ( ) . info ( " Compression increased the size of %s from %d to %d " , o . getClass ( ) . getName ( ) , b . length , compressed . length ) ; } } return new CachedData ( flags , b , getMaxSize ( ) ) ; }  <end> <beg> public void estJsonObject ( ) { String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; c . setCompressionThreshold ( 8 ) ; CachedData cd = c . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < SerializingTranscoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , c . decode ( cd ) ) ; }  <end> <beg> public void estJsonObject ( ) { String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; c . setCompressionThreshold ( 8 ) ; CachedData cd = c . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < WhalinTranscoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , c . decode ( cd ) ) ; }  <end> <beg> public void estJsonObject ( ) { WhalinV1Transcoder ranscoder = ( ( WhalinV1Transcoder ) getTranscoder ( ) ) ; String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; ranscoder . setCompressionThreshold ( 8 ) ; CachedData cd = ranscoder . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < WhalinV1Transcoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , Arrays . copyOfRange ( cd . getData ( ) , 1 , cd . getData ( ) . length ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , ranscoder . decode ( cd ) ) ;  <end> <beg> public void estOps ( ) hrows Exception { MembaseClient mc = null ; ry { URI base = new URI ( " http: " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " est " + i , 0 , i . oString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " est " + i ) ; assert ( res . equals ( i . oString ( ) ) ) ; } assert mc . flush ( ) . get ( ) . booleanValue ( ) ; mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > newNodes ) { his . nodes = newNodes . oArray ( new MemcachedNode [ newNodes . size ( ) ] ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > nodes ) { setKetamaNodes ( nodes ) ; }  <end> <beg> protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = his . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! his . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; }  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) hrows IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read);  <end> <beg> private void redistributeOperations ( Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op . isCancelled ( ) | | op . isTimedOut ( ) ) {  <end> <beg> public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { addOperation(placeIn, o);  <end> <beg> protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; }  <end> <beg> public void run ( ) { while ( running ) { ry { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> public void estGetStatsSlabs ( ) hrows Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no slabs to check. client.set("slabinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("slabs"); System.out.println("Stats: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); assertTrue(oneStat.containsKey("1:chunk_size")); }  <end> <beg> public void estGetStatsSizes ( ) hrows Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there may be no sizes to check. Note the protocol says flushed/expired items may come back in stats sizes and we use flush when testing, so we check that there's at least one. client.set("sizeinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("sizes"); System.out.println("Stats sizes: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String noItemsSmall = oneStat.get("96"); assertTrue(Integer.parseInt(noItemsSmall) >= 1); }  <end> <beg> public void estGetStatsCacheDump ( ) hrows Exception { if ( isMoxi ( ) ) { return ; } There needs to at least have been one value set or there won't be anything to dump client.set("dumpinitializer", 0, "hi"); Map<SocketAddress, Map<String, String>> stats = client.getStats("cachedump 1 10000"); System.out.println("Stats cachedump: " + stats); assertEquals(1, stats.size()); Map<String, String> oneStat = stats.values().iterator().next(); String val = oneStat.get("dumpinitializer"); assertTrue(val + "doesn't match", val.matches("\\[2 b; \\d+ s\\]")); }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; ry { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing. Ass size " + data . length + " bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } But I should still be able to do something. client.set("k", 5, "Blah"); assertEquals("Blah", client.get("k")); }  <end> <beg> public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) hrows Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , ranscoder ) ; T current = null ; If there were a CAS value, check to see if it's compatible. if (casval != null) { T tmp = casval.getValue(); current = tmp; } If we have anything mutate and CAS, else add. if (current != null) { Declaring this impossible since the only way current can be non-null is if casval was set. assert casval != null : "casval was null with a current value"; rv = m.getNewValue(current); There are three possibilities here: 1) It worked and we're done. 2) It collided and we need to reload and try again. 3) It disappeared between our fetch and our cas. We're ignoring #3 because it's *extremely* unlikely and the behavior will be fine in this code -- we'll do another gets and follow it up with either an add or another cas depending on whether it exists the next time. if (client.cas(key, casval.getCas(), initialExp, rv, transcoder) == CASResponse.OK) { done = true; } } else { No value found, try an add. if (initial == null) { done = true; rv = null; } else if (client.add(key, initialExp, initial, transcoder).get()) { done = true; rv = initial; } } } if (!done) { throw new RuntimeException("Couldn't get a CAS in " + max + " attempts"); } return rv; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void estSyncGetTimeouts ( ) hrows Exception { final String key = " imeoutTestKey " ; final String value = " imeoutTestValue " ; int j = 0 ; boolean set = false ; Do not execute this for CI if (TestConfig.isCITest()) return; do { set = client.set(key, 0, value).get(); j++; } while (!set && j < 10); assert set; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) {  <end> <beg> public void estOverflowingWriteQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) return; r.nextBytes(b); runOverflowTest(b); }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) return; r.nextBytes(b); client.set("x", 0, b); Collection<Future<Object>> c = new ArrayList<Future<Object>>(); try { for (int i = 0; i < 1000; i++) { c.add(client.asyncGet("x")); } fail("Didn't catch an illegal state exception"); } catch (IllegalStateException e) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); }  <end> <beg> public static boolean isCITest ( ) { return TEST_TYPE . equals ( TYPE_TEST_CI ) ; }  <end> <beg> Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > c ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void estSyncGetTimeouts ( ) hrows Exception { final String key = " imeoutTestKey " ; final String value = " imeoutTestValue " ; int j = 0 ; boolean set = false ; Do not execute this for CI if (TestConfig.isCITest()) { return; } do { set = client.set(key, 0, value).get(); j++; } while (!set && j < 10); assert set; Shutting down the default client to get one with a short timeout. assertTrue("Couldn't shut down within five seconds", client.shutdown(5, TimeUnit.SECONDS)); syncGetTimeoutsInitClient(); Thread.sleep(100); allow connections to be established int i = 0; GetFuture<Object> g = null; try { for (i = 0; i < 1000000; i++) { g = client.asyncGet(key); g.get(); } throw new Exception("Didn't get a timeout."); } catch (Exception e) { assert !g.getStatus().isSuccess(); System.err.println("Got a timeout at iteration " + i + "."); } Thread.sleep(100); let whatever caused the timeout to pass try { if (value.equals(client.asyncGet(key).get(30, TimeUnit.SECONDS))) {  <end> <beg> public void estOverflowingWriteQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) { return; } r.nextBytes(b); runOverflowTest(b); }  <end> <beg> public void estOverflowingReadQueue ( ) hrows Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; Do not execute this for CI if (TestConfig.isCITest()) { return; } r.nextBytes(b); client.set("x", 0, b); Collection<Future<Object>> c = new ArrayList<Future<Object>>(); try { for (int i = 0; i < 1000; i++) { c.add(client.asyncGet("x")); } fail("Didn't catch an illegal state exception"); } catch (IllegalStateException e) { expected } Thread.sleep(50); for (Future<Object> f : c) { try { f.get(1, TimeUnit.SECONDS); } catch (TimeoutException e) { OK, just want to make sure the client doesn't crash } catch (ExecutionException e) { OK, at least we got one back. } } Thread.sleep(500); assertTrue(client.set("kx", 0, "woo").get(5, TimeUnit.SECONDS)); }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV6_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ;  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> protected void earDown ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ; super . earDown ( ) ; }  <end> <beg> protected void initClient ( ConnectionFactory cf ) hrows Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ;  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; ry { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertTrue ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode(  <end> <beg> public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor).build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER), sc, 1) instanceof BinaryMemcachedNodeImpl); } finally { sc.close(); } } public void testProtocolSetterBinary() { assertTrue(b.setProtocol(Protocol.BINARY).build().getOperationFactory() instanceof BinaryOperationFactory); } public void testProtocolSetterText() { assertTrue(b.setProtocol(Protocol.TEXT).build().getOperationFactory() instanceof AsciiOperationFactory); } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue<Operation> queue; public DirectFactory(BlockingQueue<Operation> q) { super(); queue = q; } public BlockingQueue<Operation> create() { return queue; } }}  <end> <beg> private String [ ] generateAddresses ( final int maxSize ) { final String [ ] results = new String [ 2 ] ; Generate a pseudo-random set of addresses. long now = new Date().getTime(); int first = (int) ((now % 250) + 3); int second = (int) (((now / 250) % 250) + 3); String port = ":" + TestConfig.PORT_NUMBER + " "; int last = (int) ((now % 100) + 3); StringBuffer prefix = new StringBuffer(); prefix.append(first); prefix.append("."); prefix.append(second); prefix.append(".1."); Don't protect the possible range too much, as we are our own client. StringBuffer buf = new StringBuffer(); for (int ix = 0; ix < maxSize - 1; ix++) { buf.append(prefix); buf.append(last + ix); buf.append(port); } results[0] = buf.toString(); buf.append(prefix); buf.append(last + maxSize - 1); buf.append(port); results[1] = buf.toString(); return results; }  <end> <beg> public static void main ( String [ ] args ) hrows Exception { Create a client with a queue big enough to hold the 300,000 items we're going to add. MemcachedClient client = new MemcachedClient(new DefaultConnectionFactory(350000, 32768), AddrUtil.getAddresses(TestConfig.IPV4_ADDR + ":" + TestConfig.PORT_NUMBER)); long start = System.currentTimeMillis(); byte[] toStore = new byte[26]; Arrays.fill(toStore, (byte) 'a'); for (int i = 0; i < 300000; i++) { client.set("k" + i, 300, toStore); } long added = System.currentTimeMillis(); System.err.printf("Finished queuing in %sms%n", added - start); client.waitForQueues(Long.MAX_VALUE, TimeUnit.MILLISECONDS); long end = System.currentTimeMillis(); System.err.printf("Completed everything in %sms (%sms to flush)%n", end - start, end - added); Map<String, Object> m = client.getBulk("k1", "k2", "k3", "k4", "k5", "k299999", "k299998", "k299997", "k299996"); assert m.size() == 9 : "Expected 9 results, got " + m; client.shutdown(); }  <end> <beg> private void assertWorking ( ) hrows Exception { Map < SocketAddress , String > versions = client . getVersions ( ) ; assertEquals ( " / " + TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER , versions . keySet ( ) . iterator ( ) . next ( ) . oString ( ) ) ;  <end> <beg> public void estVarargConstructor ( ) hrows Exception { client = new MemcachedClient ( new InetSocketAddress ( InetAddress . getByName ( TestConfig . IPV4_ADDR ) , TestConfig . PORT_NUMBER ) ) ; assertWorking ( ) ; }  <end> <beg> public void estArraymodNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof ArrayModNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> public void estKetamaNodeLocatorAccessor ( ) hrows Exception { client = new MemcachedClient ( new KetamaConnectionFactory ( ) , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . getNodeLocator ( ) instanceof KetamaNodeLocator ) ; assertTrue ( client . getNodeLocator ( ) . getPrimary ( " x " ) instanceof MemcachedNodeROImpl ) ;  <end> <beg> protected void setUp ( ) hrows Exception { serverList = TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER + " " + TestConfig . IPV4_ADDR + " :11311 " ; super . setUp ( ) ; }  <end> <beg> public void estSingleOperation ( ) { Operation op = buildOp ( TestConfig . PORT_NUMBER ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing node: " + TestConfig . IPV4_ADDR + " : "  <end> <beg> public void estMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( TestConfig . PORT_NUMBER ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: " + TestConfig . IPV4_ADDR + " : "  <end> <beg> Operation addOp ( final String key , final Operation op ) { StringUtils . validateKey ( key ) ; mconn . checkState ( ) ; mconn . addOperation ( key , op ) ; return op ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); Iterator<String> keyIter = keys.iterator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public static void validateKey ( String key ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MemcachedClientIF . MAX_KEY_LENGTH ) { hrow new IllegalArgumentException ( " Key is too long (maxlen = " + MemcachedClientIF . MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { hrow new IllegalArgumentException ( " Key must contain at least one character. " ) ; } Validate the key for (byte b : keyBytes) { if (b == ' ' || b == '' || b == '\r' || b == 0) {  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + "]"); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); }  <end> <beg> public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void enqueueOperation ( String key , Operation o ) { StringUtils . validateKey ( key ) ; checkState ( ) ; addOperation ( key , o ) ; }  <end> <beg> protected void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Look for another node in sequence that is ready. for (Iterator<MemcachedNode> i = locator.getSequence(key); placeIn == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { placeIn = n; } } If we didn't find an active node, queue it in the primary node and wait for it to come back online. if (placeIn == null) { placeIn = primary; this.getLogger().warn( "Could not redistribute " + "to another node, retrying primary node for %s.", key); } } assert o.isCancelled() || placeIn != null : "No node found for key " + key; if (placeIn != null) { addOperation(placeIn, o);  <end> <beg> public void estBadOperation ( ) hrows Exception { client . mconn . enqueueOperation ( " x " , new ExtensibleOperationImpl ( new OperationCallback ( ) {  <end> <beg> public void complete ( ) { System . err . println ( " Complete. " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; }  <end> <beg> public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; }  <end> <beg> public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; }  <end> <beg> public void estTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage r " . getBytes ( ) ) ) ; } } ; ry { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . mconn . enqueueOperation ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; ry { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully: " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; }  <end> <beg> MemcachedNode getPrimary ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> Iterator < MemcachedNode > getSequence ( String k ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> Collection < MemcachedNode > getAll ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }  <end> <beg> public abstract ByteBuffer getBytes ( ) ; protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } }  <end> <beg> protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; }  <end> <beg> protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16  <end> <beg> protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48  <end> <beg> public Operation apCustom ( String id , RequestMessage message ) hrows ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> public Operation apDump ( final String id ) hrows IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }  <end> <beg> protected void addOp ( final Operation op ) { conn . enqueueOperation ( " TStream " , op ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = conn.getName(); conn.setName(baseName + " - SHUTTING DOWN"); boolean rv = false; try { Conditionally wait if (timeout > 0) { conn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { conn.setName(baseName + " - SHUTTING DOWN (telling client)"); conn.shutdown(); conn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public String oString ( ) { return " Cmd: tap dump Flags: backfill,ack " ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . DUMP ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public String oString ( ) { return " Cmd: tap dump Flags: dump,ack " ; }  <end> <beg> public void doBackfill ( long date ) { message . setBackfill ( date ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; }  <end> <beg> public void doDump ( ) { message . setFlags ( TapRequestFlag . DUMP ) ; }  <end> <beg> public void specifyVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . LIST_VBUCKETS ) ; }  <end> <beg> public void supportAck ( ) { message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; }  <end> <beg> public void keysOnly ( ) { message . setFlags ( TapRequestFlag . KEYS_ONLY ) ; }  <end> <beg> public void akeoverVbuckets ( short [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapRequestFlag . TAKEOVER_VBUCKETS ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cIter ) { return asyncGetBulk ( keys . iterator ( ) , cIter ) ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Transcoder < T > c ) { return asyncGetBulk ( keyIter , new SingleElementInfiniteIterator < Transcoder < T > > ( c ) ) ;  <end> <beg> public BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keyIter ) { return asyncGetBulk ( keyIter , ranscoder ) ; }  <end> <beg> public < T > Map < String , T > getBulk ( Iterator < String > keyIter , Transcoder < T > c ) { ry { return asyncGetBulk ( keyIter , c ) . get ( operationTimeout ,  <end> <beg> public < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) { return getBulk ( keys . iterator ( ) , c ) ; }  <end> <beg> CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public UnlockOperation unlock ( String key , long casId , OperationCallback cb ) { return new UnlockOperationImpl ( key , casId , cb ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Unlock of %s returned %s " , key , line ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , UNLOCKED , NOT_FOUND ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , CMD , key , cas ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public String oString ( ) { return " Cmd: " + CMD + " Key: " + key + " Cas Value: " + cas ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Cas: " + cas ; }  <end> <beg> public boolean hasMoreMessages ( ) { if ( ! rqueue . isEmpty ( ) ) { return rue ; } else { synchronized ( omap ) { Iterator < TapStream > itr = omap . keySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { TapStream s = itr . next ( ) ; if ( s . isCompleted ( ) | | s . isCancelled ( ) | | s . hasErrored ( ) ) { omap . get ( s ) . shutdown ( ) ; omap . remove ( s ) ; } } if ( omap . size ( ) > 0 ) { return rue ; } } } return false ; }  <end> <beg> public TapStream apCustom ( final String id , final RequestMessage message ) hrows ConfigurationException , IOException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream s = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; s . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( s , conn ) ; } return s ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . apCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; s . addOp ( ( TapOperation ) op ) ; return op ; }  <end> <beg> public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; }  <end> <beg> public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , his ) ) ; }  <end> <beg> public TapStream apDump ( final String id ) hrows IOException , ConfigurationException { final TapConnectionProvider conn = new TapConnectionProvider ( addrs ) ; final TapStream s = new TapStream ( ) ; conn . broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; s . addOp ( ( TapOperation ) op ) ; return op ; } } ) ; synchronized ( omap ) { omap . put ( s , conn ) ; } return s ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = conn . getOpFactory ( ) . apDump ( id , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage apMessage ) { rqueue . add ( apMessage ) ; messagesRead + + ; } public void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , node , opcode , opaque , his ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; s . addOp ( ( TapOperation ) op ) ; return op ; }  <end> <beg> private void apAck ( TapConnectionProvider conn , MemcachedNode node , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . apAck ( opcode , opaque , cb ) ; conn . addTapAckOp ( node , op ) ; }  <end> <beg> public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < TapStream , TapConnectionProvider > me : omap . entrySet ( ) ) {  <end> <beg> public void addTapAckOp ( MemcachedNode node , final Operation op ) { conn . addOperation ( node , op ) ; }  <end> <beg> public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { if ( shuttingDown ) { hrow new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , conn . getLocator ( ) . getAll ( ) ) ; }  <end> <beg> void gotData ( ResponseMessage message ) ; void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; }  <end> <beg> void gotAck ( MemcachedNode node , TapOpcode opcode , int opaque ) ; } void streamClosed ( OperationState state ) ; }  <end> <beg> public void cancel ( ) { for ( TapOperation op : ops ) { op . cancel ( ) ;  <end> <beg> public boolean isCancelled ( ) { for ( TapOperation op : ops ) { if ( ! op . isCancelled ( ) ) { return false ; } } return rue ; }  <end> <beg> public boolean hasErrored ( ) { for ( TapOperation op : ops ) { if ( ! op . hasErrored ( ) ) { return false ; } } return rue ; }  <end> <beg> public void addOp ( TapOperation op ) { ops . add ( op ) ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . BACKFILL ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } message . setBackfill ( date ) ; setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public void initialize ( ) { message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public String oString ( ) { return " Cmd: tap custom " ; }  <end> <beg> public void initialize ( ) { RequestMessage message = new RequestMessage ( ) ; message . setMagic ( TapMagic . PROTOCOL_BINARY_REQ ) ; message . setOpcode ( TapOpcode . REQUEST ) ; message . setFlags ( TapRequestFlag . DUMP ) ; message . setFlags ( TapRequestFlag . SUPPORT_ACK ) ; message . setFlags ( TapRequestFlag . FIX_BYTEORDER ) ; if ( id ! = null ) { message . setName ( id ) ; } else { message . setName ( UUID . randomUUID ( ) . oString ( ) ) ; } setBuffer ( message . getBytes ( ) ) ; }  <end> <beg> public abstract ByteBuffer getBytes ( ) ; protected short decodeShort ( byte [ ] data , int i ) { return ( short ) ( ( data [ i ] & 0xff ) < < 8 | ( data [ i + 1 ] & 0xff ) ) ; } protected int decodeInt ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) < < 24 | ( data [ i + 1 ] & 0xff ) < < 16 | ( data [ i + 2 ] & 0xff ) < < 8 | ( data [ i + 3 ] & 0xff ) ; } protected int decodeIntHostOrder ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) | ( data [ i + 1 ] & 0xff ) < < 8 | ( data [ i + 2 ] & 0xff ) < < 16 | ( data [ i + 3 ] & 0xff ) < < 24 ; } protected long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48 | ( data [ i + 2 ] & 0xffL ) < < 40 | ( data [ i + 3 ] & 0xffL ) < < 32 | ( data [ i + 4 ] & 0xffL ) < < 24 | ( data [ i + 5 ] & 0xffL ) < < 16 | ( data [ i + 6 ] & 0xffL ) < < 8 | ( data [ i + 7 ] & 0xffL ) ; } }  <end> <beg> protected int decodeIntHostOrder ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) | ( data [ i + 1 ] & 0xff ) < < 8  <end> <beg> public void earDown ( ) { } @Test public void estGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; } }  <end> <beg> public void estGetEnginePrivate ( ) { long expResult = 0 L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetFlags ( ) { List < TapResponseFlag > result = instance . getFlags ( ) ; short expResultVal = 0 ; for ( TapResponseFlag flag : expectedFlags ) { expResultVal = ( short ) ( expResultVal + flag . getFlags ( ) ) ; } short resultVal = 0 ; for ( TapResponseFlag flag : result ) { resultVal = ( short ) ( resultVal + ( int ) flag . getFlags ( ) ) ; } assertEquals ( expResultVal , resultVal ) ; }  <end> <beg> public void estGetTTL ( ) { int expResult = 0 ; int result = instance . getTTL ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetReserved1 ( ) { int expResult = 0 ; int result = instance . getReserved1 ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetReserved2 ( ) { int expResult = 0 ; int result = instance . getReserved2 ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetReserved3 ( ) { int expResult = 0 ; int result = instance . getReserved3 ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetVBucketState ( ) { int expResult = 0 ; int result = instance . getVBucketState ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetItemFlags ( ) { int expResult = ( int ) 0x0200 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetItemExpiry ( ) { long expResult = 0 L ; long result = instance . getItemExpiry ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetKey ( ) { String expResult = " a " ; String result = instance . getKey ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetValue ( ) { ByteBuffer bb = ByteBuffer . allocate ( 8 ) ; bb . put ( 7 , ( byte ) 42 ) ; byte [ ] expResult = bb . array ( ) ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; }  <end> <beg> public void estGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; }  <end> <beg> public String oString ( ) { return String . format ( " Key: %s, Flags: %d, TTL: %d, Size: %d nValue: %s " , getKey ( ) , getItemFlags ( ) , getTTL ( ) , getValue ( ) . length , deserialize ( ) ) ;  <end> <beg> private Object deserialize ( ) { SerializingTranscoder c = new SerializingTranscoder ( ) ; CachedData d = new CachedData ( his . getItemFlags ( ) , his . getValue ( ) , CachedData . MAX_SIZE ) ; Object rv = null ; rv = c . decode ( d ) ; return rv ; }  <end> <beg> public void earDown ( ) { } @Test public void estToString ( ) { assertNotNull ( instance . oString ( ) ) ; } }  <end> <beg> public void estToString ( ) { assertNotNull ( instance . oString ( ) ) ; }  <end> <beg> public void addOperation ( CASOperation op ) { ops . add ( op ) ; Count the bytes required by this operation. Iterator<String> is = op.getKeys().iterator(); String k = is.next(); int keylen = KeyUtil.getKeyBytes(k).length; byteCount += MIN_RECV_PACKET + StoreOperationImpl.EXTRA_LEN + keylen + op.getData().length;  <end> <beg> public void initialize ( ) { Now create a buffer. ByteBuffer bb = ByteBuffer.allocate(byteCount); for (CASOperation so : ops) { Iterator<String> is = so.getKeys().iterator(); String k = is.next(); byte[] keyBytes = KeyUtil.getKeyBytes(k); assert !is.hasNext(); int myOpaque = generateOpaque(); callbacks.put(myOpaque, so.getCallback()); byte[] data = so.getData(); Custom header bb.put(REQ_MAGIC); bb.put(cmdMap(so.getStoreType())); bb.putShort((short) keyBytes.length); bb.put((byte) StoreOperationImpl.EXTRA_LEN); extralen bb.put((byte) 0); data type bb.putShort(((VBucketAware) so).getVBucket(k)); vbucket bb.putInt(keyBytes.length + data.length + StoreOperationImpl.EXTRA_LEN); bb.putInt(myOpaque); bb.putLong(so.getCasValue()); cas Extras bb.putInt(so.getFlags()); bb.putInt(so.getExpiration()); the actual key bb.put(keyBytes); And the value bb.put(data); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); }  <end> <beg> private static byte cmdMap ( StoreType ) { byte rv ; switch ( ) { case set : rv = StoreOperationImpl . SETQ ; break ; case add : rv = StoreOperationImpl . ADDQ ; break ; case replace : rv = StoreOperationImpl . REPLACEQ ; break ; default : rv = DUMMY_OPCODE ; } Check fall-through. assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; return rv; }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( responseOpaque = = erminalOpaque ) { for ( OperationCallback cb : callbacks . values ( ) ) { cb . receivedStatus ( STATUS_OK ) ; cb . complete ( ) ; } ransitionState ( OperationState . COMPLETE ) ; } else { OperationCallback cb = callbacks . remove ( responseOpaque ) ; assert cb ! = null : " No callback for " + responseOpaque ; assert errorCode ! = 0 : " Got no error on a quiet mutation. " ; super . finishedPayload ( pl ) ; } resetInput ( ) ; }  <end> <beg> protected void queueReconnect ( MemcachedNode qa ) { if ( ! shutDown ) { getLogger ( ) . warn ( " Closing, and reopening %s, attempt %d. " , qa ,  <end> <beg> public void earDown ( ) { } @Test public void estToString ( ) { assertNotNull ( instance . oString ( ) ) ; } }  <end> <beg> public void estGetItemFlags ( ) { int expResult = ( int ) 0x0300 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == DUMMY_OPCODE || responseCmd == cmd : "Unexpected response command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = (short) decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES);  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; ErrorCode ec = ErrorCode . getErrorCode ( errorCode ) ; if ( status = = null ) { handleError ( OperationErrorType . SERVER , new String ( pl ) ) ;  <end> <beg> static long decodeLong ( byte [ ] data , int i ) { return ( data [ i ] & 0xffL ) < < 56 | ( data [ i + 1 ] & 0xffL ) < < 48  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put(cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); }  <end> <beg> public String oString ( ) { return " Cmd: " + cmd + " Opaque: " + opaque ; }  <end> <beg> public Boolean get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( rue , " OK " , ErrorCode . SUCCESS ) ; return super . get ( duration , units ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " , ErrorCode . CANCELLED ) ; return rv ; }  <end> <beg> protected void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) , ErrorCode . EXCEPTION , exception ) ) ; ransitionState ( OperationState . COMPLETE ) ; hrow exception ; }  <end> <beg> public String oString ( ) { return " Cmd: " + ype + " Key: " + key + " Flags: " + flags + " Exp: " + exp + " Data Length: " + data . length ;  <end> <beg> public String oString ( ) { return " Cmd: delete Key: " + key ; }  <end> <beg> public String oString ( ) { return " Cmd: flush_all Delay: " + delay ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( rue , line , ErrorCode . SUCCESS ) ; } getCallback ( ) . receivedStatus ( found ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , line , ErrorCode . SUCCESS ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public String oString ( ) { return " Cmd: version " ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) , ec ) ) ;  <end> <beg> protected OperationStatus getStatusForErrorCode ( short errCode , byte [ ] errPl ) hrows IOException { ErrorCode ec = ErrorCode . getErrorCode ( errCode ) ; switch ( ec ) { case SUCCESS :  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; if ( ec = = ErrorCode . ERR_AUTH_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) , ec ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else if ( ec = = ErrorCode . SUCCESS ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " , ec ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String oString ( ) { return " SASL base operation " ; } }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; if ( ec = = ErrorCode . ERR_AUTH_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ,  <end> <beg> public String oString ( ) { return " SASL base operation " ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) , ec ) ) ; }  <end> <beg> public String oString ( ) { return " SASL mechs operation " ; }  <end> <beg> public void estMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( rue , " blah " , ErrorCode . SUCCESS ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback();  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }  <end> <beg> public boolean cancel ( ) { assert op ! = null : " No operation " ; op . cancel ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } assert op.getState() == OperationState.COMPLETE; return objRef.get(); }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } if (op != null) { assert op.getState() == OperationState.COMPLETE; } return objRef.get(); }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( keyLen > 0 ) { final byte [ ] keyBytes = new byte [ keyLen ] ; final byte [ ] data = new byte [ pl . length - keyLen ] ; System . arraycopy ( pl , 0 , keyBytes , 0 , keyLen ) ; System . arraycopy ( pl , keyLen , data , 0 , pl . length - keyLen ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotStat ( new String ( keyBytes , " UTF-8 " ) , new String ( data , " UTF-8 " ) ) ; } else { OperationStatus status = getStatusForErrorCode ( errorCode , pl ) ; getCallback ( ) . receivedStatus ( status ) ; ransitionState ( OperationState . COMPLETE ) ; } resetInput ( ) ; }  <end> <beg> public void estGetEnginePrivate ( ) { long expResult = 4L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetItemFlags ( ) { int expResult = ( int ) 0x0000 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; }  <end> <beg> public void estGetValue ( ) { byte [ ] expResult = new byte [ 0 ] ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; }  <end> <beg> public void estRevID ( ) { byte [ ] result = instance . getRevID ( ) ; assertEquals ( 'a' , result [ 0 ] ) ; assertEquals ( 'b' , result [ 1 ] ) ; assertEquals ( 'c' , result [ 2 ] ) ; assertEquals ( 'd' , result [ 3 ] ) ; }  <end> <beg> public void estGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( 'a' , result [ result . length - 1 ] ) ; }  <end> <beg> public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! keys . isEmpty ( ) ) { Iterator < String > itr = keys . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . oString ( ) ; }  <end> <beg> public void setup ( ) { Empty } public void teardown() { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key1"); keys.add("key1"); assert StringUtils.join(keys, ",").compareTo("key1,key2,key3") == 0; }}  <end> <beg> public void eardown ( ) { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key1"); keys.add("key1"); assert StringUtils.join(keys, ",").compareTo("key1,key2,key3") == 0; }}  <end> <beg> public void estJoin ( ) { Collection < String > keys = new LinkedList < String > ( ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; assert StringUtils . join ( keys , " , " ) . compareTo ( " key1,key2,key3 " ) = = 0 ; }  <end> <beg> public void setup ( ) { Empty } public void teardown() { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key2"); keys.add("key3"); assertEquals("key1,key2,key3", StringUtils.join(keys, ",")); }}  <end> <beg> public void eardown ( ) { Empty } @Test public void testJoin() { Collection<String> keys = new LinkedList<String>(); keys.add("key1"); keys.add("key2"); keys.add("key3"); assertEquals("key1,key2,key3", StringUtils.join(keys, ",")); }}  <end> <beg> public void estJoin ( ) { Collection < String > keys = new LinkedList < String > ( ) ; keys . add ( " key1 " ) ; keys . add ( " key2 " ) ; keys . add ( " key3 " ) ; assertEquals ( " key1,key2,key3 " , StringUtils . join ( keys , " , " ) ) ; }  <end> <beg> public void setvBucketCheckpoints ( Map < Short , Long > vbchkpnts ) { int oldSize = ( vBucketCheckpoints . size ( ) ) * 10 ; int newSize = ( vbchkpnts . size ( ) ) * 10 ; otalbody + = newSize - oldSize ; vBucketCheckpoints = vbchkpnts ; }  <end> <beg> public String oString ( ) { return " Failure Mode: " + getFailureMode ( ) . name ( ) + " , Hash Algorithm: " + ( ( DefaultHashAlgorithm ) getHashAlg ( ) ) . name ( ) + " Max Reconnect Delay: "  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new RuntimeException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); }  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; ry { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ;  <end> <beg> public void readFromBuffer ( ByteBuffer b ) hrows IOException { First process headers if we haven't completed them yet if (headerOffset < MIN_RECV_PACKET) { int toRead = MIN_RECV_PACKET - headerOffset; int available = b.remaining(); toRead = Math.min(toRead, available); getLogger().debug("Reading %d header bytes", toRead); b.get(header, headerOffset, toRead); headerOffset += toRead; We've completed reading the header. Prepare body read. if (headerOffset == MIN_RECV_PACKET) { int magic = header[0]; assert magic == RES_MAGIC : "Invalid magic: " + magic; responseCmd = header[1]; assert cmd == DUMMY_OPCODE || responseCmd == cmd : "Unexpected response command value"; keyLen = decodeShort(header, 2); TODO: Examine extralen and datatype errorCode = decodeShort(header, 6); int bytesToRead = decodeInt(header, 8); payload = new byte[bytesToRead]; responseOpaque = decodeInt(header, 12); responseCas = decodeLong(header, 16); assert opaqueIsValid() : "Opaque is not valid"; } } Now process the payload if we can. if (headerOffset >= MIN_RECV_PACKET && payload == null) { finishedPayload(EMPTY_BYTES);  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String oString ( ) { return " SASL base operation " ; } }  <end> <beg> public void gotData ( String key , long cas ) { rv . setCas ( cas ) ; }  <end> <beg> StoreType getStoreType ( ) ; void gotData ( String key , long cas ) ; } }  <end> <beg> int getFlags ( ) ; void gotData ( String key , long cas ) ; } }  <end> <beg> int getExpiration ( ) ; void gotData ( String key , long cas ) ; } }  <end> <beg> byte [ ] getData ( ) ; void gotData ( String key , long cas ) ; } }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , cb ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new CASOperationImpl ( key , casId , flags , exp , data , cb ) ; }  <end> <beg> public StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( storeType , key , flags , exp , data , 0 , cb ) ; }  <end> <beg> public CASOperation cas ( StoreType ype , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) { return new StoreOperationImpl ( ype , key , flags , exp , data , casId , cb ) ; }  <end> <beg> private static byte cmdMap ( StoreType ) { byte rv ; switch ( ) { case set : rv = SET ; break ; case add : rv = ADD ; break ; case replace : rv = REPLACE ; break ; default : rv = DUMMY_OPCODE ; } Check fall-through. assert rv != DUMMY_OPCODE : "Unhandled store type: " + t; return rv; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( StoreOperation . Callback ) getCallback ( ) ) . gotData ( key , responseCas ) ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Cas: " + cas + " Exp: " + exp + " Flags: " + flags + " Data Length: " + data . length ;  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; storeCallback = new StoreOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; estData = new byte [ 64 ] ; new Random ( ) . nextBytes ( estData ) ; }  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , estData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; }  <end> <beg> public void estStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , estData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; }  <end> <beg> protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; }  <end> <beg> public void estSetReturnsCAS ( ) hrows Exception { OperationFuture < Boolean > setOp = client . set ( " estSetReturnsCAS " , 0 , " estSetReturnsCAS " ) ; setOp . get ( ) ; assertTrue ( setOp . getCas ( ) > 0 ) ; }  <end> <beg> public CountDownLatch broadcastOp ( final BroadcastOpFactory of ) { return broadcastOp ( of , mconn . getLocator ( ) . getAll ( ) , rue ) ; }  <end> <beg> public CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { return broadcastOp ( of , nodes , rue ) ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( locator . getAll ( ) . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> void gotData ( String key , long cas , ObserveResponse or ) ; } }  <end> <beg> public ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback cb ) { hrow new UnsupportedOperationException ( " Observe is not supported " + " for ASCII protocol " ) ;  <end> <beg> public ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback cb ) { return new ObserveOperationImpl ( key , casId , index , cb ) ; }  <end> <beg> public void initialize ( ) { prepareBuffer ( " " , 0x0 , EMPTY_BYTES , ( short ) index , ( short ) key . length ( ) , key . getBytes ( ) ) ;  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . values ( ) [ keystate ] ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> static int decodeByte ( byte [ ] data , int i ) { return ( data [ i ] & 0xff ) ; }  <end> <beg> protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; # magic, opcode, keylen, extralen, datatype, [reserved], bodylen, opaque, cas REQ_PKT_FMT=">BBHBBxxIIQ" set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(bufSize + extraLen); assert bb.order() == ByteOrder.BIG_ENDIAN; bb.put(REQ_MAGIC); bb.put(cmd); bb.putShort((short) keyBytes.length); bb.put((byte) extraLen); bb.put((byte) 0); data type bb.putShort(vbucket); vbucket bb.putInt(keyBytes.length + val.length + extraLen); bb.putInt(opaque); bb.putLong(cas); Add the extra headers. for (Object o : extraHeaders) { if (o instanceof Integer) { bb.putInt((Integer) o); } else if (o instanceof byte[]) { bb.put((byte[]) o); } else if (o instanceof Long) { bb.putLong((Long) o); } else if (o instanceof Short) { bb.putShort((Short) o); } else { assert false : "Unhandled extra header type: " + o.getClass(); } } Add the normal stuff bb.put(keyBytes); bb.put(val); bb.flip(); setBuffer(bb); }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public static ObserveResponse valueOf ( byte b ) { switch ( b ) { case ( byte ) 0x00 :  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . valueOf ( keystate ) ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > c ) { return asyncCAS ( key , casId , 0 , value , c ) ; }  <end> <beg> public OperationFuture < CASResponse > asyncCAS ( String key , long casId , Object value ) { return asyncCAS ( key , casId , value , ranscoder ) ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) { CASResponse casr = null ; ry { OperationFuture < CASResponse > casOp = asyncCAS ( key ,  <end> <beg> public void estAsyncCASResponse ( ) hrows InterruptedException , ExecutionException { String key = " estAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; CASResponse innerCasRes = casRes . get ( ) ; ry { casRes . getCas ( ) ;  <end> <beg> public void estAsyncCASResponse ( ) { String key = " estAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; ry { CASResponse innerCasRes = casRes . get ( ) ; assertNotNull ( " OperationFuture is missing cas value. " , casRes . getCas ( ) ) ; } catch ( InterruptedException ex ) { fail ( " Interrupted while getting CASResponse " ) ; } catch ( ExecutionException ex ) { fail ( " Execution problem while getting CASResponse " ) ; } assertNotNull ( casRes . getCas ( ) ) ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> public void estAsyncCASResponse ( ) hrows InterruptedException , ExecutionException { String key = " estAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; ry { casRes . getCas ( ) ;  <end> <beg> public void estAsyncCASResponse ( ) { String key = " estAsyncCASResponse " ; client . set ( key , 300 , key + " 0 " ) ; CASValue < Object > getsRes = client . gets ( key ) ; OperationFuture < CASResponse > casRes = client . asyncCAS ( key , getsRes . getCas ( ) , key + " 1 " ) ; ry { casRes . get ( ) ; assertNotNull ( " OperationFuture is missing cas value. " , casRes . getCas ( ) ) ; } catch ( InterruptedException ex ) { fail ( " Interrupted while getting CASResponse " ) ; } catch ( ExecutionException ex ) { fail ( " Execution problem while getting CASResponse " ) ; } assertNotNull ( casRes . getCas ( ) ) ; }  <end> <beg> void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final short keylen = ( short ) decodeShort ( pl , 2 ) ; keystate = ( byte ) decodeByte ( pl , keylen + 4 ) ; retCas = ( long ) decodeLong ( pl , keylen + 5 ) ; ObserveResponse r = ObserveResponse . valueOf ( keystate ) ; ( ( ObserveOperation . Callback ) getCallback ( ) ) . gotData ( key , retCas , getHandlingNode ( ) , r ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( long cas ) { rv . setCas ( cas ) ; }  <end> <beg> public DeleteOperation delete ( String key , DeleteOperation . Callback cb ) { return new DeleteOperationImpl ( key , cb ) ; }  <end> <beg> public DeleteOperation delete ( String key , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , operationCallback ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { super . decodePayload ( pl ) ; ( ( DeleteOperation . Callback ) getCallback ( ) ) . gotData ( responseCas ) ; }  <end> <beg> protected void setUp ( ) hrows Exception { super . setUp ( ) ; ofact = getOperationFactory ( ) ; genericCallback = new OperationCallback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; storeCallback = new StoreOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; deleteCallback = new DeleteOperation . Callback ( ) { public void complete ( ) { fail ( " Unexpected invocation " ) ; } public void gotData ( long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status: " + status ) ; } } ; estData = new byte [ 64 ] ; new Random ( ) . nextBytes ( estData ) ; }  <end> <beg> public void estDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , deleteCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertDeleteCallback ( op2 ) ; }  <end> <beg> protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; }  <end> <beg> public String oString ( ) { return " Cmd: " + Arrays . oString ( msg ) ; }  <end> <beg> public StatsOperation keyStats ( String key , Callback cb ) { hrow new UnsupportedOperationException ( " Key stats are not supported " + " for ASCII protocol " ) ;  <end> <beg> public StatsOperation keyStats ( String key , StatsOperation . Callback cb ) { return new KeyStatsOperationImpl ( key , cb ) ; }  <end> <beg> public void initialize ( ) { String keyval = " key " + key + " " + getVBucket ( key ) ; prepareBuffer ( keyval , 0 , EMPTY_BYTES ) ; }  <end> <beg> public final boolean isActive ( ) { return reconnectAttempt . get ( ) = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ;  <end> <beg> public final void reconnecting ( ) { reconnectAttempt . incrementAndGet ( ) ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public final void connected ( ) { reconnectAttempt . set ( 0 ) ; continuousTimeout . set ( 0 ) ; }  <end> <beg> public void estSimpleLoading ( ) hrows Exception { Mock m = mock ( MemcachedClientIF . class ) ; LoadCounter sl = new LoadCounter ( ) ; CacheLoader cl = new CacheLoader ( ( MemcachedClientIF ) m . proxy ( ) , es , sl , 0 ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( returnValue ( new ImmediateFuture ( rue ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " a " ) , eq ( 0 ) , eq ( 1 ) ) . will ( hrowException ( new IllegalStateException ( " Full up " ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " b " ) , eq ( 0 ) , eq ( 2 ) ) . will ( returnValue ( new ImmediateFuture ( new RuntimeException ( " blah " ) ) ) ) ; m . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " c " ) , eq ( 0 ) , eq ( 3 ) ) . will ( returnValue ( new ImmediateFuture ( false ) ) ) ; Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; Load the cache and wait for it to finish. cl.loadData(map).get(); es.shutdown(); es.awaitTermination(1, TimeUnit.SECONDS); assertEquals(1, sl.success.get()); assertEquals(1, sl.exceptions.get()); assertEquals(1, sl.failure.get()); }  <end> <beg> public void errorStoring ( String k , Exception e ) { exceptions . incrementAndGet ( ) ; }  <end> <beg> public void storeResult ( String k , boolean result ) { if ( result ) { success . incrementAndGet ( ) ;  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public void enqueueOperation ( String key , Operation o ) { StringUtils . validateKey ( key , opFact instanceof BinaryOperationFactory ) ; checkState ( ) ; addOperation ( key , o ) ; }  <end> <beg> public static void validateKey ( String key , boolean binary ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; if ( keyBytes . length > MemcachedClientIF . MAX_KEY_LENGTH ) { hrow new IllegalArgumentException ( " Key is too long (maxlen = " + MemcachedClientIF . MAX_KEY_LENGTH + " ) " ) ; } if ( keyBytes . length = = 0 ) { hrow new IllegalArgumentException ( " Key must contain at least one character. " ) ; } if ( ! binary ) { Validate the key  <end> <beg> public void estKeyWithSpaces ( ) hrows Exception { String key = " key with spaces " ; client . set ( key , 0 , " " ) ; assertNotNull ( " Couldn't get the key with spaces in it. " , client . get ( key ) ) ; }  <end> <beg> public void estKeyWithNewline ( ) hrows Exception { String key = " Key " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }  <end> <beg> public void estKeyWithReturn ( ) hrows Exception { String key = " Key r " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }  <end> <beg> public void estKeyWithASCIINull ( ) hrows Exception { String key = " Key 0 " ; client . set ( key , 0 , " " ) ; assertNotNull ( client . get ( key ) ) ; }  <end> <beg> public void estGetBulkKeyWSpaces ( ) hrows Exception { String key = " Key key2 " ; client . set ( key , 0 , " " ) ; Map < String , Object > bulkReturn = client . getBulk ( key ) ; assertTrue ( bulkReturn . size ( ) > = 1 ) ; }  <end> <beg> public void estKeyWithSpaces ( ) hrows Exception { ry { client . get ( " key with spaces " ) ;  <end> <beg> public void estKeyLongerThan250 ( ) hrows Exception { ry { StringBuilder longKey = new StringBuilder ( ) ;  <end> <beg> public void estKeyWithNewline ( ) hrows Exception { ry { Object val = client . get ( " Key " ) ;  <end> <beg> public void estKeyWithReturn ( ) hrows Exception { ry { Object val = client . get ( " Key r " ) ;  <end> <beg> public void estKeyWithASCIINull ( ) hrows Exception { ry { Object val = client . get ( " Key 0 " ) ;  <end> <beg> public void estGetBulkKeyWSpaces ( ) hrows Exception { ry { Object val = client . getBulk ( " Key key2 " ) ;  <end> <beg> public synchronized boolean isTimedOut ( long tlMillis ) { long elapsed = System . nanoTime ( ) ; long tlNanos = tlMillis * 1000 * 1000 ; if ( elapsed - creationTime > tlNanos ) { imedOutUnsent = rue ; imedout = rue ; callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; } else timedout would be false, but we cannot allow you to untimeout an operation. This can happen when the latch timeout is shorter than the default operation timeout. return timedout; }  <end> <beg> private void connected ( MemcachedNode node ) { assert node . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = node . getReconnectCount ( ) ; node . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( node . getSocketAddress ( ) , rt ) ;  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }  <end> <beg> public void updateLocator ( List < MemcachedNode > nodes ) { allNodes = nodes ; setKetamaNodes ( nodes ) ; }  <end> <beg> public void estAllAfterUpdate ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; } ArrayList < MemcachedNode > oUpdate = new ArrayList < MemcachedNode > ( ) ; Mock mock = mock ( MemcachedNode . class ) ; mock . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 ) ) ) ; oUpdate . add ( ( MemcachedNode ) mock . proxy ( ) ) ; locator . updateLocator ( oUpdate ) ; Collection < MemcachedNode > afterUpdate = locator . getAll ( ) ; assertEquals ( 1 , afterUpdate . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertFalse ( afterUpdate . contains ( nodes [ i ] ) ) ; } assertTrue ( afterUpdate . contains ( ( MemcachedNode ) mock . proxy ( ) ) ) ; }  <end> <beg> public void estBelongsToCluster ( ) hrows Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; OperationFactory opfactory = new BinaryOperationFactory ( ) ; MemcachedNode node = new MockMemcachedNode ( new InetSocketAddress ( TestConfig . IPV4_ADDR , TestConfig . PORT_NUMBER ) ) ; MemcachedNode node2 = new MockMemcachedNode ( new InetSocketAddress ( " invalidIpAddr " , TestConfig . PORT_NUMBER ) ) ; List < InetSocketAddress > nodes = new ArrayList < InetSocketAddress > ( ) ; nodes . add ( ( InetSocketAddress ) node . getSocketAddress ( ) ) ; MemcachedConnection conn = new MemcachedConnection ( 100 , factory , nodes , observers , FailureMode . Retry , opfactory ) ; assertTrue ( conn . belongsToCluster ( node ) ) ; assertFalse ( conn . belongsToCluster ( node2 ) ) ; }  <end> <beg> public void estAllAfterUpdate ( ) hrows Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertTrue ( all . contains ( nodes [ i ] ) ) ; } ArrayList < MemcachedNode > oUpdate = new ArrayList < MemcachedNode > ( ) ; Mock mock = mock ( MemcachedNode . class ) ; mock . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 ) ) ) ; oUpdate . add ( ( MemcachedNode ) mock . proxy ( ) ) ; locator . updateLocator ( oUpdate ) ; Collection < MemcachedNode > afterUpdate = locator . getAll ( ) ; assertEquals ( 1 , afterUpdate . size ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { assertFalse ( afterUpdate . contains ( nodes [ i ] ) ) ; } assertTrue ( afterUpdate . contains ( ( MemcachedNode ) mock . proxy ( ) ) ) ; }  <end> <beg> public T get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { whenever timeout occurs, continuous timeout counter will increase by 1. MemcachedConnection.opTimedOut(op); if (op != null) { op can be null on a flush op.timeOut(); } throw new CheckedOperationTimeoutException( "Timed out waiting for operation", op); } else { continuous timeout counter will be reset MemcachedConnection.opSucceeded(op); } if (op != null && op.hasErrored()) { throw new ExecutionException(op.getException()); } if (isCancelled()) { throw new ExecutionException(new CancellationException("Cancelled")); } if (op != null && op.isTimedOut()) { throw new ExecutionException(new CheckedOperationTimeoutException( "Operation timed out.", op)); } return objRef.get(); }  <end> <beg> protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > a ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( a . size ( ) ) ; for ( SocketAddress sa : a ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = his . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! his . connectionFactory . useNagleAlgorithm ( ) ) ; Initially I had attempted to skirt this by queueing every connect, but it considerably slowed down start time. try { if (ch.connect(sa)) { getLogger().info("Connected to %s immediately", qa); connected(qa); } else { getLogger().info("Added %s to connect queue", qa); ops = SelectionKey.OP_CONNECT; } selector.wakeup(); qa.setSk(ch.register(selector, ops, qa)); assert ch.isConnected() || qa.getSk().interestOps() == SelectionKey.OP_CONNECT : "Not connected, and not wanting to connect"; } catch (SocketException e) { getLogger().warn("Socket error on initial connect", e); queueReconnect(qa); } connections.add(qa); } return connections; }  <end> <beg> public void run ( ) { while ( running ) { ry { handleIO ( ) ; } catch ( IOException e ) { logRunException ( e ) ; } catch ( CancelledKeyException e ) { logRunException ( e ) ; } catch ( ClosedSelectorException e ) { logRunException ( e ) ; } catch ( IllegalStateException e ) { logRunException ( e ) ; } catch ( ConcurrentModificationException e ) { logRunException ( e ) ; } } getLogger ( ) . info ( " Shut down memcached client " ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; }  <end> <beg> public void race ( Object message , Throwable exception ) { log ( Level . TRACE , message , exception ) ; }  <end> <beg> public void race ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { race ( String . format ( message , args ) , getThrowable ( args ) ) ;  <end> <beg> public void race ( Object message ) { race ( message , null ) ; }  <end> <beg> public boolean isTraceEnabled ( ) { return ( false ) ; }  <end> <beg> public boolean isTraceEnabled ( ) { return ( l4jLogger . isTraceEnabled ( ) ) ; }  <end> <beg> public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case TRACE : pLevel = org . apache . log4j . Level . TRACE ; break ; case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : I don't know what this is, so consider it fatal pLevel = org.apache.log4j.Level.FATAL; l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, "Unhandled " + "log level: " + level + " for the following message", null); } l4jLogger.log("net.spy.compat.log.AbstractLogger", pLevel, message, e); }  <end> <beg> boolean isTraceEnabled ( ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void log ( Level level , Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void race ( Object message , Throwable exception ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void race ( Object message ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> void race ( String message , Object . . . args ) ; void fatal ( String message , Object . . . args ) ; }  <end> <beg> public boolean isTraceEnabled ( ) { return logger . isTraceEnabled ( ) ; }  <end> <beg> public boolean isDebugEnabled ( ) { return logger . isDebugEnabled ( ) ; }  <end> <beg> public boolean isInfoEnabled ( ) { return logger . isInfoEnabled ( ) ; }  <end> <beg> public void log ( Level level , Object message , Throwable e ) { if ( level = = null ) { level = Level . FATAL ; } switch ( level ) { case TRACE :  <end> <beg> public boolean isTraceEnabled ( ) { return ( sunLogger . isLoggable ( java . util . logging . Level . FINEST ) ) ; }  <end> <beg> public OperationFuture < Boolean > append ( String key , Object val ) { return append ( 0 , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > append ( String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . append , 0 , key , val , c ) ; }  <end> <beg> public OperationFuture < Boolean > prepend ( String key , Object val ) { return prepend ( 0 , key , val , ranscoder ) ; }  <end> <beg> public < T > OperationFuture < Boolean > prepend ( String key , T val , Transcoder < T > c ) { return asyncCat ( ConcatenationType . prepend , 0 , key , val , c ) ; }  <end> <beg> public void estAppendWithoutCAS ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estPrependWithoutCAS ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Touch completed successfully " ) ; getCallback ( ) . receivedStatus ( matchStatus ( line , OK ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void initialize ( ) { ByteBuffer b = null ; b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + String . valueOf ( exp ) . length ( ) + OVERHEAD ) ; b . put ( ( " ouch " + key + " " + exp + " r " ) . getBytes ( ) ) ; b . flip ( ) ; setBuffer ( b ) ; }  <end> <beg> public String oString ( ) { return " Cmd: touch key: " + key + " exp: " + exp ; }  <end> <beg> public String oString ( ) { return super . oString ( ) + " Exp: " + exp ; }  <end> <beg> public void estTouch ( ) hrows Exception { assertNull ( client . get ( " ouchtest " ) ) ; assertNull ( client . get ( " nonexistent " ) ) ; assertTrue ( client . set ( " ouchtest " , 5 , " ouchtest " ) . get ( ) ) ; assertTrue ( client . ouch ( " ouchtest " , 2 ) . get ( ) ) ; assertFalse ( client . ouch ( " nonexistent " , 2 ) . get ( ) ) ; }  <end> <beg> public void estConcatentaion ( ) { ( new ConcatenationOperationImpl ( ConcatenationType . append , " key " , " value " . getBytes ( ) , null ) ) . oString ( ) ;  <end> <beg> public void estDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estFlush ( ) { ( new FlushOperationImpl ( 0 , null ) ) . oString ( ) ; }  <end> <beg> public void estGetAndTouch ( ) { ( new GetAndTouchOperationImpl ( " gat " , 15 , null , " key " ) ) . oString ( ) ; }  <end> <beg> public void estTouch ( ) { ( new TouchOperationImpl ( " key " , 2 , null ) ) . oString ( ) ; }  <end> <beg> public void estGetl ( ) { ( new GetlOperationImpl ( " key " , 10 , null ) ) . oString ( ) ; }  <end> <beg> public void estGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estGets ( ) { ( new GetsOperationImpl ( " key " , null ) ) . oString ( ) ; }  <end> <beg> public void estMutator ( ) { ( new MutatorOperationImpl ( Mutator . decr , " key " , 1 , null ) ) . oString ( ) ; }  <end> <beg> public void estOptimizedGet ( ) { ( new OptimizedGetImpl ( new GetOperationImpl ( " key " , null ) ) ) . oString ( ) ; }  <end> <beg> public void estStats ( ) { ( new StatsOperationImpl ( " hash " , null ) ) . oString ( ) ; }  <end> <beg> public void estStore ( ) { ( new StoreOperationImpl ( StoreType . set , " key " , 0 , 10 , " value " . getBytes ( ) , null ) ) . oString ( ) ;  <end> <beg> public void estVersion ( ) { ( new VersionOperationImpl ( null ) ) . oString ( ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { return delete ( key , ( long ) 0 ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op = null ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback cb ) { hrow new UnsupportedOperationException ( " Delete with CAS is not supported " + " for ASCII protocol " ) ;  <end> <beg> public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , cas , operationCallback ) ; }  <end> <beg> public void estDeleteWithCAS ( ) hrows Exception { final String key = " delete.with.cas " ; final long wrongCAS = 1234 ; OperationFuture < Boolean > setFuture = client . set ( key , 0 , " est " ) ; assertTrue ( setFuture . get ( ) ) ; assertFalse ( client . delete ( key , wrongCAS ) . get ( ) ) ; assertTrue ( client . delete ( key , setFuture . getCas ( ) ) . get ( ) ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { ( ( ReplicaGetOperation . Callback ) originalCallback ) . gotData ( key , flags , data ) ; }  <end> <beg> void gotData ( String key , int flags , byte [ ] data ) ; } int getReplicaIndex ( ) ; }  <end> <beg> public ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) { hrow new UnsupportedOperationException ( " Replica get is not supported " + " for ASCII protocol " ) ;  <end> <beg> public ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) { return new ReplicaGetOperationImpl ( key , index , callback ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; ReplicaGetOperation . Callback gcb = ( ReplicaGetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> private String buildTimeoutMessage ( long imeWaited , TimeUnit unit ) { StringBuilder message = new StringBuilder ( ) ; message . append ( MessageFormat . format ( " waited {0} ms. " , unit . convert ( imeWaited , TimeUnit . MILLISECONDS ) ) ) ; message . append ( " Node status: " ) . append ( mconn . connectionsStatus ( ) ) ; return message . oString ( ) ; }  <end> <beg> Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void addOp ( Operation op ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> int getSelectionOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean isActive ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> boolean isAuthenticated ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> long lastReadDelta ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> void completedRead ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; }  <end> <beg> public boolean isAuthenticated ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public long lastReadDelta ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public void completedRead ( ) { hrow new UnsupportedOperationException ( ) ; }  <end> <beg> public boolean isAuthenticated ( ) { return ( 0 = = authLatch . getCount ( ) ) ; }  <end> <beg> public long lastReadDelta ( ) { return System . currentTimeMillis ( ) - lastReadTimestamp ; }  <end> <beg> public void completedRead ( ) { lastReadTimestamp = System . currentTimeMillis ( ) ; }  <end> <beg> public void estConnectionsStatus ( ) hrows Exception { ConnectionFactory factory = new DefaultConnectionFactory ( ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11211 " ) ; Collection < ConnectionObserver > observers = new ArrayList < ConnectionObserver > ( ) ; MemcachedConnection mcc = new MemcachedConnection ( 10240 , factory , addresses , observers , FailureMode . Retry , new BinaryOperationFactory ( ) ) ; assertNotNull ( mcc . connectionsStatus ( ) ) ; }  <end> <beg> private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; ry { listMechsLatch . await ( 10 , TimeUnit . SECONDS ) ; } catch ( InterruptedException ex ) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); }  <end> <beg> public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ;  <end> <beg> public void complete ( ) { listMechsLatch . countDown ( ) ; }  <end> <beg> private Operation buildOperation ( OperationStatus st , OperationCallback cb , final String [ ] supportedMechs ) { if ( st = = null ) { return opFact . saslAuth ( supportedMechs ,  <end> <beg> public CASResponse cas ( String key , long casId , int exp , Object value ) { return cas ( key , casId , exp , value , ranscoder ) ; }  <end> <beg> public void estCAS ( ) hrows Exception { final String key = " castestkey " ; First, make sure it doesn't work for a non-existing value. assertSame("Expected error CASing with no existing value.", CASResponse.NOT_FOUND, client.cas(key, 0x7fffffffffL, "bad value")); OK, stick a value in here. assertTrue(client.add(key, 5, "original value").get()); CASValue<?> getsVal = client.gets(key); assertEquals("original value", getsVal.getValue()); Now try it with an existing value, but wrong CAS id assertSame("Expected error CASing with invalid id", CASResponse.EXISTS, client.cas(key, getsVal.getCas() + 1, "broken value")); Validate the original value is still in tact. assertEquals("original value", getsVal.getValue()); OK, now do a valid update assertSame("Expected successful CAS with correct id (" + getsVal.getCas() + ")", CASResponse.OK, client.cas(key, getsVal.getCas(), "new value")); assertEquals("new value", client.get(key)); Test a CAS replay assertSame("Expected unsuccessful CAS with replayed id", CASResponse.EXISTS, client.cas(key, getsVal.getCas(), "crap value")); assertEquals("new value", client.get(key)); final String key2 = "castestkey2"; assertTrue(client.add(key2, 0, "value").get()); CASValue<Object> casValue = client.gets(key2); assertEquals(CASResponse.OK, client.cas(key2, casValue.getCas(), 3, "new val")); Verify the doc is not there anymore Thread.sleep(5000); assertNull(client.get(key2)); }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> boolean isDaemon ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> int getReadBufSize ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> HashAlgorithm getHashAlg ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> long getMaxReconnectDelay ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> AuthDescriptor getAuthDescriptor ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> int getTimeoutExceptionThreshold ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> public MetricType enableMetrics ( ) { return metricType = = null ? super . enableMetrics ( ) : metricType ; }  <end> <beg> public MetricType enableMetrics ( ) { String metricType = System . getProperty ( " net.spy.metrics.type " ) ; return metricType = = null ? DEFAULT_METRIC_TYPE : MetricType . valueOf ( metricType . oUpperCase ( ) ) ;  <end> <beg> protected void registerMetrics ( ) { if ( metricType . equals ( MetricType . DEBUG ) | | metricType . equals ( MetricType . PERFORMANCE ) ) { metrics . addHistogram ( OVERALL_AVG_BYTES_READ_METRIC ) ;  <end> <beg> private void handleReads ( SelectionKey sk , MemcachedNode qa ) hrows IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; If it's a tap ack there is no response if (currentOp instanceof TapAckOperationImpl) { qa.removeCurrentReadOp(); return; } ByteBuffer rbuf = qa.getRbuf(); final SocketChannel channel = qa.getChannel(); int read = channel.read(rbuf); metrics.updateHistogram(OVERALL_AVG_BYTES_READ_METRIC, read); if (read < 0) { if (currentOp instanceof TapOperation) { If were doing tap then we won't throw an exception currentOp.getCallback().complete(); ((TapOperation) currentOp).streamClosed(OperationState.COMPLETE); getLogger().debug("Completed read op: %s and giving the next %d bytes", currentOp, rbuf.remaining()); Operation op = qa.removeCurrentReadOp(); assert op == currentOp : "Expected to pop " + currentOp + " got " + op; currentOp = qa.getCurrentReadOp(); } else { our model is to keep the connection alive for future ops so we'll queue a reconnect if disconnected via an IOException throw new IOException("Disconnected unexpected, will reconnect."); } } while (read > 0) { getLogger().debug("Read %d bytes", read);  <end> <beg> public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> public void decrementCounter ( String name ) { decrementCounter ( name , 1 ) ; }  <end> <beg> public void incrementCounter ( String name ) { incrementCounter ( name , 1 ) ; }  <end> <beg> private void initReporter ( ) { String reporterType = System . getProperty ( " net.spy.metrics.reporter.type " , DEFAULT_REPORTER_TYPE ) ; String reporterInterval = System . getProperty ( " net.spy.metrics.reporter.interval " , DEFAULT_REPORTER_INTERVAL ) ; String reporterDir = System . getProperty ( " net.spy.metrics.reporter.outdir " , DEFAULT_REPORTER_OUTDIR ) ; if ( reporterType . equals ( " console " ) ) { final ConsoleReporter reporter = ConsoleReporter . forRegistry ( registry )  <end> <beg> public void addCounter ( String name ) { if ( ! counters . containsKey ( name ) ) { counters . put ( name , registry . counter ( name ) ) ;  <end> <beg> public void removeCounter ( String name ) { if ( ! counters . containsKey ( name ) ) { registry . remove ( name ) ;  <end> <beg> public void incrementCounter ( String name , int amount ) { if ( counters . containsKey ( name ) ) { counters . get ( name ) . inc ( amount ) ;  <end> <beg> public void decrementCounter ( String name , int amount ) { if ( counters . containsKey ( name ) ) { counters . get ( name ) . dec ( amount ) ;  <end> <beg> public void addMeter ( String name ) { if ( ! meters . containsKey ( name ) ) { meters . put ( name , registry . meter ( name ) ) ;  <end> <beg> public void removeMeter ( String name ) { if ( meters . containsKey ( name ) ) { meters . remove ( name ) ;  <end> <beg> public void markMeter ( String name ) { if ( meters . containsKey ( name ) ) { meters . get ( name ) . mark ( ) ;  <end> <beg> public void addHistogram ( String name ) { if ( ! histograms . containsKey ( name ) ) { histograms . put ( name , registry . histogram ( name ) ) ;  <end> <beg> public void removeHistogram ( String name ) { if ( histograms . containsKey ( name ) ) { histograms . remove ( name ) ;  <end> <beg> public void updateHistogram ( String name , int amount ) { if ( histograms . containsKey ( name ) ) { histograms . get ( name ) . update ( amount ) ;  <end> <beg> void addCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void removeCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void incrementCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void incrementCounter ( String name , int amount ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void decrementCounter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void decrementCounter ( String name , int amount ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void addMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void removeMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void markMeter ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void addHistogram ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> void removeHistogram ( String name ) ; void updateHistogram ( String name , int amount ) ; }  <end> <beg> public void incrementCounter ( String name , int amount ) { return ; }  <end> <beg> public void decrementCounter ( String name , int amount ) { return ; }  <end> <beg> public void removeHistogram ( String name ) { return ; }  <end> <beg> public void updateHistogram ( String name , int amount ) { return ; }  <end> <beg> boolean isCancelled ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> boolean hasErrored ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> OperationException getException ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> OperationCallback getCallback ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void cancel ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> OperationState getState ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void writing ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void writeComplete ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void initialize ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> void imeOut ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> boolean isTimedOut ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> boolean isTimedOut ( long tlMillis ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; }  <end> <beg> public final void writeComplete ( ) { writeCompleteTimestamp = System . nanoTime ( ) ; ransitionState ( OperationState . READING ) ; }  <end> <beg> public void isDisabledByDefault ( ) hrows Exception { System . clearProperty ( " net.spy.metrics.enable " ) ; System . clearProperty ( " net.spy.metrics.type " ) ; ConnectionFactory cf = new DefaultConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; cf = new BinaryConnectionFactory ( ) ; assertEquals ( MetricType . OFF , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof NoopMetricCollector ) ; }  <end> <beg> public void canBeEnabledManually ( ) hrows Exception { ConnectionFactory cf = new ConnectionFactoryBuilder ( ) . setEnableMetrics ( MetricType . PERFORMANCE ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; System . setProperty ( " net.spy.metrics.enable " , " rue " ) ; System . setProperty ( " net.spy.metrics.type " , " performance " ) ; cf = new ConnectionFactoryBuilder ( ) . build ( ) ; assertEquals ( MetricType . PERFORMANCE , cf . enableMetrics ( ) ) ; assertTrue ( cf . getMetricCollector ( ) instanceof DefaultMetricCollector ) ; }  <end> <beg> public void doStuff ( ) hrows Exception { DummyMetricCollector collector = new DummyMetricCollector ( ) ; ConnectionFactory cf = new ConnectionFactoryBuilder ( ) . setEnableMetrics ( MetricType . DEBUG ) . setMetricCollector ( collector ) . build ( ) ; MemcachedClient client = new MemcachedClient ( cf , AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " : " + TestConfig . PORT_NUMBER ) ) ; assertTrue ( client . set ( " metrics:test " , 0 , " value " ) . get ( ) ) ; assertNotNull ( client . get ( " metrics:test " ) ) ; HashMap < String , Integer > metrics = collector . getMetrics ( ) ; assertTrue ( metrics . get ( " [MEM] Average Bytes written to OS per write " ) > 0 ) ; assertEquals ( 2 , ( long ) metrics . get ( " [MEM] Response Rate: Success " ) ) ; client . shutdown ( ) ; }  <end> <beg> public void addCounter ( String name ) { metrics . put ( name , 0 ) ; }  <end> <beg> public void removeCounter ( String name ) { metrics . remove ( name ) ; }  <end> <beg> public void incrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; }  <end> <beg> public void incrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; }  <end> <beg> public void decrementCounter ( String name ) { metrics . put ( name , metrics . get ( name ) - 1 ) ; }  <end> <beg> public void decrementCounter ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) - amount ) ; }  <end> <beg> public void addMeter ( String name ) { metrics . put ( name , 0 ) ; }  <end> <beg> public void removeMeter ( String name ) { metrics . remove ( name ) ; }  <end> <beg> public void markMeter ( String name ) { metrics . put ( name , metrics . get ( name ) + 1 ) ; }  <end> <beg> public void addHistogram ( String name ) { metrics . put ( name , 0 ) ; }  <end> <beg> public void removeHistogram ( String name ) { metrics . remove ( name ) ; }  <end> <beg> public void updateHistogram ( String name , int amount ) { metrics . put ( name , metrics . get ( name ) + amount ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> ExecutorService getListenerExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch, executorService); GetOperation.Callback cb = new GetOperation.Callback() { @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero: " + cas ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void gotData ( long cas ) { rv . setCas ( cas ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op = null ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout , executorService ) {  <end> <beg> protected ExecutorService executor ( ) { return service ; }  <end> <beg> protected Future < T > addToListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { hrow new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( isDone ( ) ) { notifyListener ( executor ( ) , his , listener ) ; return his ; } synchronized ( his ) { if ( ! isDone ( ) ) { listeners . add ( listener ) ; return his ; } } notifyListener ( executor ( ) , his , listener ) ; return his ; }  <end> <beg> protected void notifyListener ( final ExecutorService executor , final Future < ? > future , final GenericCompletionListener listener ) { executor . submit ( new Runnable ( ) { @Override  <end> <beg> public void run ( ) { Thread . currentThread ( ) . setName ( " FutureNotifyListener " ) ; ry { listener . onComplete ( future ) ;  <end> <beg> protected void notifyListeners ( ) { notifyListeners ( his ) ; }  <end> <beg> protected void notifyListeners ( final Future < ? > future ) { for ( GenericCompletionListener < ? extends Future < ? super T > > listener : listeners ) {  <end> <beg> protected Future < T > removeFromListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { hrow new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( isDone ( ) ) { return his ; } synchronized ( his ) { if ( ! isDone ( ) ) { listeners . remove ( listener ) ; } } return his ; }  <end> <beg> boolean isTimeout ( ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; }  <end> <beg> V getSome ( long imeout , TimeUnit unit ) hrows InterruptedException , ExecutionException ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; }  <end> <beg> OperationStatus getStatus ( ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; }  <end> <beg> Future < V > addListener ( BulkGetCompletionListener listener ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; }  <end> <beg> Future < V > removeListener ( BulkGetCompletionListener listener ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " ) ; notifyListeners ( ) ; return rv ; }  <end> <beg> public Future < Map < String , T > > addListener ( BulkGetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> public Future < Map < String , T > > removeListener ( BulkGetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean result = rv . cancel ( ign ) ; notifyListeners ( ) ; return result ; }  <end> <beg> public void set ( Future < T > d , OperationStatus s ) { rv . set ( d , s ) ; notifyListeners ( ) ; }  <end> <beg> public GetFuture < T > addListener ( GetCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> public GetFuture < T > removeListener ( GetCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> Future < T > addListener ( L listener ) ; Future < T > removeListener ( L listener ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }  <end> <beg> public boolean cancel ( ) { assert op ! = null : " No operation " ; op . cancel ( ) ; notifyListeners ( ) ; return op . getState ( ) = = OperationState . WRITE_QUEUED ; }  <end> <beg> public void set ( T o , OperationStatus s ) { objRef . set ( o ) ; status = s ; notifyListeners ( ) ; }  <end> <beg> public OperationFuture < T > addListener ( OperationCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> public OperationFuture < T > removeListener ( OperationCompletionListener listener ) { super . removeFromListeners ( ( GenericCompletionListener ) listener ) ; return his ; }  <end> <beg> public void estSetWithCallback ( ) hrows Exception { OperationFuture < Boolean > setOp = client . set ( " setWithCallback " , 0 , " content " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; setOp . addListener ( new OperationCompletionListener ( ) { @Override public void onComplete ( OperationFuture < ? > f ) hrows Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( OperationFuture < ? > f ) hrows Exception { latch . countDown ( ) ; }  <end> <beg> public void estGetWithCallback ( ) hrows Exception { client . set ( " getWithCallback " , 0 , " content " ) . get ( ) ; GetFuture < Object > getOp = client . asyncGet ( " getWithCallback " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; getOp . addListener ( new GetCompletionListener ( ) { @Override public void onComplete ( GetFuture < ? > f ) hrows Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( GetFuture < ? > f ) hrows Exception { latch . countDown ( ) ; }  <end> <beg> public void estGetBulkWithCallback ( ) hrows Exception { client . set ( " getBulkWithCallback1 " , 0 , " content " ) . get ( ) ; BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( " getBulkWithCallback1 " ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { latch . countDown ( ) ; }  <end> <beg> public boolean cancel ( boolean bln ) { cancelled = rue ; notifyListeners ( ) ; return rue ; }  <end> <beg> public T get ( ) hrows InterruptedException , ExecutionException { ry { return get ( 1 , TimeUnit . SECONDS ) ;  <end> <beg> public T get ( long l , TimeUnit u ) hrows InterruptedException , ExecutionException , TimeoutException { return content ; }  <end> <beg> public void set ( T c ) { notifyListeners ( ) ; content = c ; }  <end> <beg> public DummyListenableFuture < T > addListener ( GenericCompletionListener listener ) { super . addToListeners ( listener ) ; return his ; }  <end> <beg> public DummyListenableFuture < T > removeListener ( GenericCompletionListener listener ) { super . removeFromListeners ( listener ) ; return his ; }  <end> <beg> public void verifyOnComplete ( ) hrows Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; } } ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( Future future ) hrows Exception { assertEquals ( " Hello World " , ( String ) future . get ( ) ) ; latch . countDown ( ) ; }  <end> <beg> public void verifyOnCompleteWhenAlreadyDone ( ) hrows Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( rue , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; }  <end> <beg> public void verifyOnCompleteWhenCancelled ( ) hrows Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; future . addListener ( new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; } } ) ; future . cancel ( rue ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( Future future ) hrows Exception { assertTrue ( future . isCancelled ( ) ) ; latch . countDown ( ) ; }  <end> <beg> public void verifyRemoval ( ) hrows Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GenericCompletionListener listener = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; } } ; future . addListener ( listener ) ; future . removeListener ( listener ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , latch . getCount ( ) ) ; }  <end> <beg> public void verifyMultipleListeners ( ) hrows Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 2 ) ; final GenericCompletionListener listener1 = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; } } ; final GenericCompletionListener listener2 = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; } } ; future . addListener ( listener1 ) ; future . addListener ( listener2 ) ; future . set ( " Hello World " ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( Future future ) hrows Exception { latch . countDown ( ) ; }  <end> <beg> public OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , Object value ) { return asyncCAS ( key , casId , exp , value , ranscoder ) ; }  <end> <beg> public void estAsyncCASWithExpiration ( ) hrows Exception { final String key = " casWithExpiration " ; final String value = " value " ; OperationFuture < Boolean > future = client . set ( key , 0 , value ) ; assertTrue ( future . get ( ) ) ; OperationFuture < CASResponse > casFuture = client . asyncCAS ( key , future . getCas ( ) , 2 , value ) ; assertEquals ( CASResponse . OK , casFuture . get ( ) ) ; Thread . sleep ( 2500 ) ; assertNull ( client . get ( key ) ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> ExecutorService getListenerExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> boolean isDefaultExecutorService ( ) ; MetricCollector getMetricCollector ( ) ; }  <end> <beg> public boolean isDefaultExecutorService ( ) { return executorService = = null ; }  <end> <beg> public boolean isDefaultExecutorService ( ) { return rue ; }  <end> <beg> public void estOverridingExecutorService ( ) { ConnectionFactory factory = b . build ( ) ; assertTrue ( factory . isDefaultExecutorService ( ) ) ; ExecutorService service = Executors . newFixedThreadPool ( 1 ) ; b . setListenerExecutorService ( service ) ; factory = b . build ( ) ; assertFalse ( factory . isDefaultExecutorService ( ) ) ; assertEquals ( service . hashCode ( ) , factory . getListenerExecutorService ( ) . hashCode ( ) ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; if (connFactory.isDefaultExecutorService()) { try { executorService.shutdown(); } catch (Exception ex) { getLogger().warn("Failed shutting down the ExecutorService: ", ex); } } try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ,  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } public void complete ( ) { latch . countDown ( ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data ,  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getExpiration ( ) ; }  <end> <beg> public void estGetAndTouchOperationCloning ( ) { GetAndTouchOperation . Callback callback = ( GetAndTouchOperation . Callback ) mock ( GetAndTouchOperation . Callback . class ) . proxy ( ) ; GetAndTouchOperation op = ofact . getAndTouch ( TEST_KEY , 0 , callback ) ; GetAndTouchOperation op2 = cloneOne ( GetAndTouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; }  <end> <beg> private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; ry { listMechsLatch . await ( ) ; } catch ( InterruptedException ex ) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); }  <end> <beg> public void estCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , estData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; }  <end> <beg> public void estMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }  <end> <beg> public void estNotGrowingCallstack ( ) hrows Exception { final CountDownLatch latch = new CountDownLatch ( 1 ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus status ) { } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( estData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; } }  <end> <beg> public void gotData ( String key , int flags , byte [ ] data ) { } } ; GetOperation operation = ofact . get ( " key " , cb ) ; int nestingDepth = 10000000 ; for ( int i = 0 ; i < nestingDepth ; i + + ) { List < Operation > clonedOps = ( List < Operation > ) ofact . clone ( operation ) ; operation = ( GetOperation ) clonedOps . get ( 0 ) ; } operation . getCallback ( ) . complete ( ) ; assertTrue ( latch . await ( 1 , TimeUnit . SECONDS ) ) ; } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( estData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation ) { return assertOne ( c , ofact . clone ( ) ) ; } }  <end> <beg> protected void registerMetrics ( ) { if ( metricType . equals ( MetricType . DEBUG ) | | metricType . equals ( MetricType . PERFORMANCE ) ) {  <end> <beg> protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = his . connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! his . connectionFactory . useNagleAlgorithm ( ) ) ; ry { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { hrow new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { getLogger ( ) . debug ( " No selectors ready, interrupted: " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . debug ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; if ( sk . readyOps ( ) ! = 0 ) { getLogger ( ) . debug ( " %s has a ready op, handling IO " , sk ) ; handleIO ( sk ) ; } else { lostConnection ( ( MemcachedNode ) sk . attachment ( ) ) ; } } assert emptySelects < EXCESSIVE_EMPTY : " Too many empty selects " ; } } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } redistributeOperations ( retryOps ) ; retryOps . clear ( ) ; handleShutdownQueue ( ) ; }  <end> <beg> private void handleShutdownQueue ( ) hrows IOException { for ( MemcachedNode qa : nodesToShutdown ) { if ( ! addedQueue . contains ( qa ) ) {  <end> <beg> private void checkPotentiallyTimedOutConnection ( ) { boolean stillCheckingTimeouts = rue ; while ( stillCheckingTimeouts ) { ry {  <end> <beg> public boolean addObserver ( final ConnectionObserver obs ) { return connObservers . add ( obs ) ; }  <end> <beg> public boolean removeObserver ( final ConnectionObserver obs ) { return connObservers . remove ( obs ) ; }  <end> <beg> private void connected ( final MemcachedNode node ) { assert node . getChannel ( ) . isConnected ( ) : " Not connected. " ; int rt = node . getReconnectCount ( ) ; node . connected ( ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionEstablished ( node . getSocketAddress ( ) , rt ) ;  <end> <beg> private void lostConnection ( final MemcachedNode node ) { queueReconnect ( node ) ; for ( ConnectionObserver observer : connObservers ) { observer . connectionLost ( node . getSocketAddress ( ) ) ;  <end> <beg> private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; ry { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { if ( sk . isValid ( ) & & sk . isReadable ( ) ) { handleReads ( node ) ; } if ( sk . isValid ( ) & & sk . isWritable ( ) ) { handleWrites ( node ) ; } } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; }  <end> <beg> public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }  <end> <beg> private void handleWrites ( final MemcachedNode node ) hrows IOException { node . fillWriteBuffer ( shouldOptimize ) ; boolean canWriteMore = node . getBytesRemainingToWrite ( ) > 0 ; while ( canWriteMore ) { int wrote = node . writeSome ( ) ;  <end> <beg> private void handleReads ( final MemcachedNode node ) hrows IOException { Operation currentOp = node . getCurrentReadOp ( ) ; if ( currentOp instanceof TapAckOperationImpl ) { node . removeCurrentReadOp ( ) ; return ; } ByteBuffer rbuf = node . getRbuf ( ) ; final SocketChannel channel = node . getChannel ( ) ; int read = channel . read ( rbuf ) ; metrics . updateHistogram ( OVERALL_AVG_BYTES_READ_METRIC , read ) ; if ( read < 0 ) { currentOp = handleReadsWhenChannelEndOfStream ( currentOp , node , rbuf ) ; } while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;  <end> <beg> private Operation handleReadsWhenChannelEndOfStream ( final Operation currentOp , final MemcachedNode node , final ByteBuffer rbuf ) hrows IOException { if ( currentOp instanceof TapOperation ) { currentOp . getCallback ( ) . complete ( ) ;  <end> <beg> private void cancelOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { op . cancel ( ) ;  <end> <beg> private void redistributeOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { if ( op . isCancelled ( ) | | op . isTimedOut ( ) ) {  <end> <beg> private void potentiallyCloseLeakingChannel ( final SocketChannel ch , final MemcachedNode node ) { if ( ch ! = null & & ! ch . isConnected ( ) & & ! ch . isConnectionPending ( ) ) { ry {  <end> <beg> public void enqueueOperation ( final String key , final Operation o ) { checkState ( ) ; StringUtils . validateKey ( key , opFact instanceof BinaryOperationFactory ) ; addOperation ( key , o ) ; }  <end> <beg> protected void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { Iterator < MemcachedNode > i = locator . getSequence ( key ) ; while ( placeIn = = null & & i . hasNext ( ) ) { MemcachedNode = i . next ( ) ; if ( . isActive ( ) ) { placeIn = ; } } if ( placeIn = = null ) { placeIn = primary ; his . getLogger ( ) . warn ( " Could not redistribute to another node, " + " retrying primary node for %s. " , key ) ; } } assert o . isCancelled ( ) | | placeIn ! = null : " No node found for key " + key ; if ( placeIn ! = null ) { addOperation ( placeIn , o ) ;  <end> <beg> public void insertOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . insertOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> protected void addOperation ( final MemcachedNode node , final Operation o ) { o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { addOperation ( me . getKey ( ) , me . getValue ( ) ) ;  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }  <end> <beg> public CountDownLatch broadcastOperation ( final BroadcastOpFactory of , final Collection < MemcachedNode > nodes ) { final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) ) ; for ( MemcachedNode node : nodes ) { getLogger ( ) . debug ( " broadcast Operation: node = " + node ) ; Operation op = of . newOp ( node , latch ) ; op . initialize ( ) ; node . addOp ( op ) ; op . setHandlingNode ( node ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; return latch ; }  <end> <beg> public static void opTimedOut ( final Operation op ) { MemcachedConnection . setTimeout ( op , rue ) ; }  <end> <beg> public static void opSucceeded ( final Operation op ) { MemcachedConnection . setTimeout ( op , false ) ; }  <end> <beg> private void logRunException ( final Exception e ) { if ( shutDown ) { getLogger ( ) . debug ( " Exception occurred during shutdown " , e ) ;  <end> <beg> public void readFromBuffer ( final ByteBuffer buffer ) hrows IOException { if ( headerOffset < MIN_RECV_PACKET ) { readHeaderFromBuffer ( buffer ) ; if ( headerOffset = = MIN_RECV_PACKET ) { parseHeaderFromBuffer ( ) ; } } if ( headerOffset > = MIN_RECV_PACKET & & payload = = null ) { finishedPayload ( EMPTY_BYTES ) ;  <end> <beg> private void readHeaderFromBuffer ( final ByteBuffer buffer ) { int oRead = MIN_RECV_PACKET - headerOffset ; int available = buffer . remaining ( ) ; oRead = Math . min ( oRead , available ) ; getLogger ( ) . debug ( " Reading %d header bytes " , oRead ) ; buffer . get ( header , headerOffset , oRead ) ; headerOffset + = oRead ; }  <end> <beg> private void parseHeaderFromBuffer ( ) { int magic = header [ 0 ] ; assert magic = = RES_MAGIC : " Invalid magic: " + magic ; responseCmd = header [ 1 ] ; assert cmd = = DUMMY_OPCODE | | responseCmd = = cmd : " Unexpected response command value " ; keyLen = decodeShort ( header , 2 ) ; errorCode = decodeShort ( header , 6 ) ; int bytesToRead = decodeInt ( header , 8 ) ; payload = new byte [ bytesToRead ] ; responseOpaque = decodeInt ( header , 12 ) ; responseCas = decodeLong ( header , 16 ) ; assert opaqueIsValid ( ) : " Opaque is not valid " ; }  <end> <beg> private void readPayloadFromBuffer ( final ByteBuffer buffer ) hrows IOException { int oRead = payload . length - payloadOffset ; int available = buffer . remaining ( ) ; oRead = Math . min ( oRead , available ) ; getLogger ( ) . debug ( " Reading %d payload bytes " , oRead ) ; buffer . get ( payload , payloadOffset , oRead ) ; payloadOffset + = oRead ; if ( payloadOffset = = payload . length ) { finishedPayload ( payload ) ;  <end> <beg> protected void prepareBuffer ( final String key , final long cas , final byte [ ] val , final Object . . . extraHeaders ) { int extraLen = 0 ; int extraHeadersLength = extraHeaders . length ; if ( extraHeadersLength > 0 ) { extraLen = calculateExtraLength ( extraHeaders ) ; } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; ByteBuffer bb = ByteBuffer . allocate ( bufSize + extraLen ) ; assert bb . order ( ) = = ByteOrder . BIG_ENDIAN ; bb . put ( REQ_MAGIC ) ; bb . put ( cmd ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) extraLen ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbucket ) ; bb . putInt ( keyBytes . length + val . length + extraLen ) ; bb . putInt ( opaque ) ; bb . putLong ( cas ) ; if ( extraHeadersLength > 0 ) { addExtraHeaders ( bb , extraHeaders ) ; } bb . put ( keyBytes ) ; bb . put ( val ) ; bb . flip ( ) ; setBuffer ( bb ) ; }  <end> <beg> private void addExtraHeaders ( final ByteBuffer bb , final Object . . . extraHeaders ) { for ( Object o : extraHeaders ) { if ( o instanceof Integer ) {  <end> <beg> private int calculateExtraLength ( final Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type: " + o . getClass ( ) ; } } return extraLen ; }  <end> <beg> public void initialize ( ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; prepareBuffer ( " " , 0x0 , EMPTY_BYTES , ( short ) index , ( short ) keyBytes . length , keyBytes ) ;  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { hrow new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } handleOperationalTasks ( ) ; }  <end> <beg> private void handleOperationalTasks ( ) hrows IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } redistributeOperations ( retryOps ) ; retryOps . clear ( ) ; handleShutdownQueue ( ) ; }  <end> <beg> private void handleEmptySelects ( ) { getLogger ( ) . debug ( " No selectors ready, interrupted: " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) {  <end> <beg> private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; ry { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . info ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { handleReadsAndWrites ( sk , node ) ; } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; }  <end> <beg> private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) hrows IOException { if ( sk . isValid ( ) ) { if ( sk . isReadable ( ) ) {  <end> <beg> Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > c ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < T > asyncGet ( String key , Transcoder < T > c ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > c ) { CASResponse casr ; ry { OperationFuture < CASResponse > casOp = asyncCAS ( key ,  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keyIter , Iterator < Transcoder < T > > cIter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; This map does not need to be a ConcurrentHashMap because it is fully populated when it is used and used only to read the transcoder for a key. final Map<String, Transcoder<T>> tcMap = new HashMap<String, Transcoder<T>>(); Break the gets down into groups by key final Map<MemcachedNode, Collection<String>> chunks = new HashMap<MemcachedNode, Collection<String>>(); final NodeLocator locator = mconn.getLocator(); while (keyIter.hasNext() && tcIter.hasNext()) { String key = keyIter.next(); tcMap.put(key, tcIter.next()); StringUtils.validateKey(key, opFact instanceof BinaryOperationFactory); final MemcachedNode primaryNode = locator.getPrimary(key); MemcachedNode node = null; if (primaryNode.isActive()) { node = primaryNode; } else { for (Iterator<MemcachedNode> i = locator.getSequence(key); node == null && i.hasNext();) { MemcachedNode n = i.next(); if (n.isActive()) { node = n; } } if (node == null) { node = primaryNode; } } assert node != null : "Didn't find a node for " + key; Collection<String> ks = chunks.get(node); if (ks == null) { ks = new ArrayList<String>(); chunks.put(node, ks); } ks.add(key); } final CountDownLatch latch = new CountDownLatch(chunks.size()); final Collection<Operation> ops = new ArrayList<Operation>(chunks.size()); final BulkGetFuture<T> rv = new BulkGetFuture<T>(m, ops, latch, executorService); GetOperation.Callback cb = new GetOperation.Callback() { @Override @SuppressWarnings("synthetic-access") public void receivedStatus(OperationStatus status) { rv.setStatus(status); } @Override public void gotData(String k, int flags, byte[] data) { Transcoder<T> tc = tcMap.get(k); m.put(k, tcService.decode(tc, new CachedData(flags, data, tc.getMaxSize()))); } @Override public void complete() { latch.countDown(); } }; Now that we know how many servers it breaks down into, and the latch is all set up, convert all of these strings collections to operations final Map<MemcachedNode, Operation> mops = new HashMap<MemcachedNode, Operation>(); for (Map.Entry<MemcachedNode, Collection<String>> me : chunks.entrySet()) { Operation op = opFact.get(me.getValue(), cb); mops.put(me.getKey(), op); ops.add(op); } assert mops.size() == chunks.size(); mconn.checkState(); mconn.addOperations(mops); return rv; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; return opFact . version ( new OperationCallback ( ) { @Override  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { final SocketAddress sa = . getSocketAddress ( ) ; rv . put ( sa , new HashMap < String , String > ( ) ) ; return opFact . stats ( arg , new StatsOperation . Callback ( ) { @Override  <end> <beg> private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { XXX: Potential abstraction leak. The handling of incr/decr in the binary protocol Allows us to avoid string processing. rv.set(new Long(s.isSuccess() ? s.getMessage() : "-1")); } @Override public void complete() { latch.countDown(); } })); try { if (!latch.await(operationTimeout, TimeUnit.MILLISECONDS)) { throw new OperationTimeoutException("Mutate operation timed out," + "unable to modify counter [" + key + ']'); } } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key ) { return delete ( key , 0 L ) ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { @Override public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout , executorService ) {  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; }  <end> <beg> public Operation newOp ( MemcachedNode , final CountDownLatch latch ) { return opFact . saslMechs ( new OperationCallback ( ) { @Override  <end> <beg> public boolean waitForQueues ( long imeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { @Override public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void receivedStatus ( OperationStatus s ) { Nothing special when receiving status, only necessary to complete the interface } }); } }, mconn.getLocator().getAll(), false); try { XXX: Perhaps IllegalStateException should be caught here  <end> <beg> public Operation newOp ( final MemcachedNode , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { @Override  <end> <beg> public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }  <end> <beg> private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > c ) { CachedData co = c . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }  <end> <beg> public < T > OperationFuture < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . ouch ( key , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; }  <end> <beg> public < T > GetFuture < T > asyncGet ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GetFuture < T > rv = new GetFuture < T > ( latch , operationTimeout , key , executorService ) ; Operation op = opFact . get ( key , new GetOperation . Callback ( ) { private Future < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = cService . decode ( c , new CachedData ( flags , data , c . getMaxSize ( ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGets ( final String key , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . gets ( key , new GetsOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > c ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , c . decode ( new CachedData ( flags , data , c . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }  <end> <beg> public void set ( Boolean o , OperationStatus s ) { super . set ( o , s ) ; notifyListeners ( ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { op . cancel ( ) ; rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; } notifyListeners ( ) ; return rv ; }  <end> <beg> public void signalComplete ( ) { notifyListeners ( ) ; }  <end> <beg> public void estGetBulkWithCallback ( ) hrows Exception { final int items = 1000 ; List < String > keysList = new ArrayList < String > ( items ) ; for ( int i = 0 ; i < items ; i + + ) { assertTrue ( client . set ( " getBulkWithCallback " + i , 0 , " content " ) . get ( ) ) ; keysList . add ( " getBulkWithCallback " + i ) ; } BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( keysList ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; latch . countDown ( ) ; }  <end> <beg> public boolean shutdown ( long imeout , TimeUnit unit ) { Guard against double shutdowns (bug 8). if (shuttingDown) { getLogger().info("Suppressing duplicate attempt to shut down"); return false; } shuttingDown = true; String baseName = mconn.getName(); mconn.setName(baseName + " - SHUTTING DOWN"); boolean rv = true; if (connFactory.isDefaultExecutorService()) { try { executorService.shutdown(); } catch (Exception ex) { getLogger().warn("Failed shutting down the ExecutorService: ", ex); } } try { Conditionally wait if (timeout > 0) { mconn.setName(baseName + " - SHUTTING DOWN (waiting)"); rv = waitForQueues(timeout, unit); } } finally { But always begin the shutdown sequence try { mconn.setName(baseName + " - SHUTTING DOWN (telling client)"); mconn.shutdown(); mconn.setName(baseName + " - SHUTTING DOWN (informed client)"); tcService.shutdown(); terminate all pending Auth Threads authMonitor.interruptAllPendingAuth(); } catch (IOException e) { getLogger().warn("exception while shutting down", e); } } return rv; }  <end> <beg> public synchronized void interruptAllPendingAuth ( ) { for ( AuthThread oStop : nodeMap . values ( ) ) { if ( oStop . isAlive ( ) ) {  <end> <beg> private String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; ry { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( rue ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); }  <end> <beg> protected void handleRetryInformation ( final byte [ ] retryMessage ) { getLogger ( ) . debug ( " Got RETRY message: " + new String ( retryMessage ) + " , but not handled. " ) ;  <end> <beg> boolean isCancelled ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> boolean hasErrored ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> OperationException getException ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> OperationCallback getCallback ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void cancel ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> OperationState getState ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void writing ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void writeComplete ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void initialize ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> void imeOut ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> boolean isTimedOut ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> boolean isTimedOut ( long tlMillis ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> boolean isTimedOutUnsent ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; }  <end> <beg> protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) hrows IOException { errorMsg = new byte [ errPl . length ] ; errorMsg = errPl . clone ( ) ; switch ( errCode ) { case SUCCESS :  <end> <beg> public Thread newThread ( Runnable r ) { return new Thread ( r , " FutureNotifyListener " ) ; }  <end> <beg> public void run ( ) { ry { listener . onComplete ( future ) ;  <end> <beg> protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; ry { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( rue ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { throw new IllegalStateException("Got empty SASL auth mech list."); } return supported.split(MECH_SEPARATOR); }  <end> <beg> protected synchronized void notifyListeners ( final Future < ? > future ) { for ( GenericCompletionListener < ? extends Future < ? super T > > listener : listeners ) {  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getReplicaIndex ( ) ; }  <end> <beg> public ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) { hrow new UnsupportedOperationException ( " Replica gets is not supported " + " for ASCII protocol " ) ;  <end> <beg> public ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) { return new ReplicaGetsOperationImpl ( key , index , callback ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN - keyLen ] ; System . arraycopy ( pl , ( EXTRA_HDR_LEN + keyLen ) , data , 0 , pl . length - EXTRA_HDR_LEN - keyLen ) ; Callback gcb = ( Callback ) getCallback ( ) ; gcb . gotData ( key , flags , responseCas , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }  <end> <beg> public Boolean get ( long duration , TimeUnit units ) hrows InterruptedException , TimeoutException , ExecutionException { status = new OperationStatus ( rue , " OK " , StatusCode . SUCCESS ) ; return super . get ( duration , units ) ; }  <end> <beg> public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = rue ; status = new OperationStatus ( false , " Cancelled " , StatusCode . CANCELLED ) ; notifyListeners ( ) ; return rv ; }  <end> <beg> public static StatusCode fromBinaryCode ( int code ) { switch ( code ) { case 0x00 :  <end> <beg> public static StatusCode fromAsciiLine ( String line ) { if ( line . equals ( " STORED " ) | | line . equals ( " DELETED " ) ) { return SUCCESS ;  <end> <beg> protected void handleError ( OperationErrorType eType , String line ) hrows IOException { getLogger ( ) . error ( " Error: %s " , line ) ; switch ( eType ) { case GENERAL : exception = new OperationException ( ) ; break ; case SERVER : exception = new OperationException ( eType , line ) ; break ; case CLIENT : exception = new OperationException ( eType , line ) ; break ; default : assert false ; } callback . receivedStatus ( new OperationStatus ( false , exception . getMessage ( ) , StatusCode . ERR_INTERNAL ) ) ; ransitionState ( OperationState . COMPLETE ) ; hrow exception ; }  <end> <beg> public void handleLine ( String line ) { getLogger ( ) . debug ( " Result: %s " , line ) ; OperationStatus found = null ; if ( line . equals ( " NOT_FOUND " ) ) { found = NOT_FOUND ; } else { found = new OperationStatus ( rue , line , StatusCode . SUCCESS ) ; } getCallback ( ) . receivedStatus ( found ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> public void handleLine ( String line ) { assert line . startsWith ( " VERSION " ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( rue , line . substring ( " VERSION " . length ( ) ) , StatusCode . SUCCESS ) ) ; ransitionState ( OperationState . COMPLETE ) ; }  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , String . valueOf ( decodeLong ( pl , 0 ) ) , StatusCode . SUCCESS ) ) ;  <end> <beg> protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) hrows IOException { errorMsg = new byte [ errPl . length ] ; errorMsg = errPl . clone ( ) ; StatusCode statusCode = StatusCode . fromBinaryCode ( errCode ) ; switch ( errCode ) { case SUCCESS :  <end> <beg> protected abstract byte [ ] buildResponse ( SaslClient sc ) hrows SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response: %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) , StatusCode . SUCCESS ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , " " , StatusCode . SUCCESS ) ) ; ransitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String oString ( ) { return " SASL base operation " ; } }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) ,  <end> <beg> protected void decodePayload ( byte [ ] pl ) { getCallback ( ) . receivedStatus ( new OperationStatus ( rue , new String ( pl ) , StatusCode . SUCCESS ) ) ;  <end> <beg> public void estAddGetSetStatusCodes ( ) hrows Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_NOT_STORED , add . getStatus ( ) . getStatusCode ( ) ) ; }  <end> <beg> public void estAddGetSetStatusCodes ( ) hrows Exception { OperationFuture < Boolean > set = client . set ( " statusCode1 " , 0 , " value " ) ; set . get ( ) ; assertEquals ( StatusCode . SUCCESS , set . getStatus ( ) . getStatusCode ( ) ) ; GetFuture < Object > get = client . asyncGet ( " statusCode1 " ) ; get . get ( ) ; assertEquals ( StatusCode . SUCCESS , get . getStatus ( ) . getStatusCode ( ) ) ; OperationFuture < Boolean > add = client . add ( " statusCode1 " , 0 , " value2 " ) ; add . get ( ) ; assertEquals ( StatusCode . ERR_EXISTS , add . getStatus ( ) . getStatusCode ( ) ) ; }  <end> <beg> public void estMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( rue , " blah " , StatusCode . SUCCESS ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Transition each operation callback into the complete state. Iterator<String> ki = keys.iterator(); int i = 0; for (Operation o : ofact.clone(op)) { GetOperation.Callback cb = (GetOperation.Callback) o.getCallback();  <end> <beg> public void estMutateWithDefaultAndExp ( ) hrows Exception { assertEquals ( 3 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 4 , client . incr ( " mtest " , 1 , 3 , 1 ) ) ; assertEquals ( 3 , client . decr ( " mtest " , 1 , 9 , 1 ) ) ; assertEquals ( 9 , client . decr ( " mtest2 " , 1 , 9 , 1 ) ) ; Thread . sleep ( 2000 ) ; assertNull ( client . get ( " mtest " ) ) ; OperationStatus status = client . asyncGet ( " mtest " ) . getStatus ( ) ; assertFalse ( status . isSuccess ( ) ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , status . getStatusCode ( ) ) ; }  <end> <beg> public void estAsyncIncrement ( ) hrows Exception { String k = " async-incr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncIncrementNonExistent ( ) hrows Exception { String k = " async-incr-non-existent " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrement ( ) hrows Exception { String k = " async-decr " ; client . set ( k , 0 , " 5 " ) ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 4 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrementNonExistent ( ) hrows Exception { String k = " async-decr-non-existent " ; OperationFuture < Long > f = client . asyncDecr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAppend ( ) hrows Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estes " , client . get ( key ) ) ; }  <end> <beg> public void estPrepend ( ) hrows Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " est " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assertEquals ( StatusCode . SUCCESS , op . getStatus ( ) . getStatusCode ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }  <end> <beg> public void estGetBulkWithCallback ( ) hrows Exception { final int items = 1000 ; List < String > keysList = new ArrayList < String > ( items ) ; for ( int i = 0 ; i < items ; i + + ) { assertTrue ( client . set ( " getBulkWithCallback " + i , 0 , " content " ) . get ( ) ) ; keysList . add ( " getBulkWithCallback " + i ) ; } BulkFuture < Map < String , Object > > asyncGetBulk = client . asyncGetBulk ( keysList ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; asyncGetBulk . addListener ( new BulkGetCompletionListener ( ) { @Override public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void onComplete ( BulkGetFuture < ? > f ) hrows Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; latch . countDown ( ) ; }  <end> <beg> public static String join ( final Collection < String > chunks , final String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! chunks . isEmpty ( ) ) { Iterator < String > itr = chunks . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . oString ( ) ; }  <end> <beg> public static boolean isJsonObject ( final String s ) { if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " rue " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalMatcher . reset ( s ) . matches ( ) ) { return rue ; } return false ; }  <end> <beg> public static void validateKey ( final String key , final boolean binary ) { byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int keyLength = keyBytes . length ; if ( keyLength > MAX_KEY_LENGTH ) { hrow KEY_TOO_LONG_EXCEPTION ; } if ( keyLength = = 0 ) { hrow KEY_EMPTY_EXCEPTION ; } if ( ! binary ) { for ( byte b : keyBytes ) {  <end> <beg> public void setup ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < MemcachedClientIF . MAX_KEY_LENGTH + 1 ; i + + ) { builder . append ( " k " ) ; } ooLongKey = builder . oString ( ) ; }  <end> <beg> public void shouldJoinChunk ( ) { List < String > chunks = Arrays . asList ( " chunk1 " ) ; String delimiter = " , " ; String expected = " chunk1 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; }  <end> <beg> public void shouldJoinChunks ( ) { List < String > chunks = Arrays . asList ( " chunk1 " , " chunk2 " , " chunk3 " ) ; String delimiter = " , " ; String expected = " chunk1,chunk2,chunk3 " ; String result = StringUtils . join ( chunks , delimiter ) ; assertEquals ( expected , result ) ; }  <end> <beg> public void shouldReturnEmptyStringWithNoChunks ( ) { String result = StringUtils . join ( Collections . < String > emptyList ( ) , " , " ) ; assertEquals ( " " , result ) ; }  <end> <beg> public void shouldValidateJSONObject ( ) { assertTrue ( StringUtils . isJsonObject ( " { \" a \" :true} " ) ) ; assertTrue ( StringUtils . isJsonObject ( " [0, 1, 2] " ) ) ; assertTrue ( StringUtils . isJsonObject ( " rue " ) ) ; assertTrue ( StringUtils . isJsonObject ( " false " ) ) ; assertTrue ( StringUtils . isJsonObject ( " null " ) ) ; assertTrue ( StringUtils . isJsonObject ( " 1 " ) ) ; assertTrue ( StringUtils . isJsonObject ( " -1 " ) ) ; }  <end> <beg> public void shouldValidateNonJSONObject ( ) { assertFalse ( StringUtils . isJsonObject ( " foobar " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 0.5 " ) ) ; assertFalse ( StringUtils . isJsonObject ( " 1,244.0 " ) ) ; }  <end> <beg> public void shouldValidateAsciiKey ( ) { StringUtils . validateKey ( " mykey1234 " , false ) ; assertTrue ( rue ) ; }  <end> <beg> public void shouldFailValidationWithAsciiSpace ( ) { StringUtils . validateKey ( " key baz " , false ) ; }  <end> <beg> public void shouldFailValidationWithAsciiNewline ( ) { StringUtils . validateKey ( " keybaz " , false ) ; }  <end> <beg> public void shouldFailValidationWithAsciiReturn ( ) { StringUtils . validateKey ( " keybaz r " , false ) ; }  <end> <beg> public void shouldFailValidationWithAsciiNull ( ) { StringUtils . validateKey ( " keybaz 0 " , false ) ; }  <end> <beg> public void shouldFailValidationWithAsciiTooLong ( ) { StringUtils . validateKey ( ooLongKey , false ) ; }  <end> <beg> public void shouldFailValidationWithBinaryTooLong ( ) { StringUtils . validateKey ( ooLongKey , rue ) ; }  <end> <beg> public void shouldFailValidationWithAsciiEmpty ( ) { StringUtils . validateKey ( " " , false ) ; }  <end> <beg> public void shouldFailValidationWithBinaryEmpty ( ) { StringUtils . validateKey ( " " , rue ) ; }  <end> <beg> public void shouldValidateBinaryKey ( ) { StringUtils . validateKey ( " mykey1234 " , rue ) ; StringUtils . validateKey ( " key baz " , rue ) ; StringUtils . validateKey ( " keybaz " , rue ) ; StringUtils . validateKey ( " keybaz r " , rue ) ; StringUtils . validateKey ( " keybaz 0 " , rue ) ; }  <end> <beg> public void complete ( ) { if ( pendingChunks . decrementAndGet ( ) < = 0 ) { latch . countDown ( ) ;  <end> <beg> protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; synchronized ( vbmap ) { vbmap . put ( k , new Short ( ( short ) 0 ) ) ; } } return rv ; }  <end> <beg> public void initialize ( ) { int size = ( 1 + keys . size ( ) ) * MIN_RECV_PACKET ; for ( byte [ ] b : bkeys . values ( ) ) { size + = b . length ; } set up the initial header stuff ByteBuffer bb = ByteBuffer.allocate(size); for (Map.Entry<Integer, byte[]> me : bkeys.entrySet()) { final byte[] keyBytes = me.getValue(); final String key = keys.get(me.getKey()); Custom header bb.put(REQ_MAGIC); bb.put(CMD_GETQ); bb.putShort((short) keyBytes.length); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort(vbmap.get(key).shortValue()); vbucket bb.putInt(keyBytes.length); bb.putInt(me.getKey()); bb.putLong(0); cas the actual key bb.put(keyBytes); } Add the noop bb.put(REQ_MAGIC); bb.put((byte) NoopOperationImpl.CMD); bb.putShort((short) 0); bb.put((byte) 0); extralen bb.put((byte) 0); data type bb.putShort((short) 0); reserved bb.putInt(0); bb.putInt(terminalOpaque); bb.putLong(0); cas bb.flip(); setBuffer(bb); }  <end> <beg> protected void finishedPayload ( byte [ ] pl ) hrows IOException { getStatusForErrorCode ( errorCode , pl ) ; if ( responseOpaque = = erminalOpaque ) { if ( retryKeys . size ( ) > 0 ) { ransitionState ( OperationState . RETRY ) ; OperationStatus retryStatus = new OperationStatus ( rue , Integer . oString ( retryKeys . size ( ) ) , StatusCode . ERR_NOT_MY_VBUCKET ) ; getCallback ( ) . receivedStatus ( retryStatus ) ; getCallback ( ) . complete ( ) ; } else { getCallback ( ) . receivedStatus ( STATUS_OK ) ; ransitionState ( OperationState . COMPLETE ) ; } } else if ( errorCode = = ERR_NOT_MY_VBUCKET ) { retryKeys . add ( keys . get ( responseOpaque ) ) ; } else if ( errorCode ! = SUCCESS ) { getLogger ( ) . warn ( " Error on key %s: %s (%d) " , keys . get ( responseOpaque ) , new String ( pl ) , errorCode ) ; } else { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( keys . get ( responseOpaque ) , flags , data ) ; } resetInput ( ) ; }  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; long getAuthWaitTime ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> ExecutorService getListenerExecutorService ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean isDefaultExecutorService ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getAuthWaitTime ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean isDaemon ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> Collection < ConnectionObserver > getInitialObservers ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> FailureMode getFailureMode ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> Transcoder < Object > getDefaultTranscoder ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean shouldOptimize ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> int getReadBufSize ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> HashAlgorithm getHashAlg ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> long getMaxReconnectDelay ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> AuthDescriptor getAuthDescriptor ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> int getTimeoutExceptionThreshold ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> MetricType enableMetrics ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> public final void addOp ( Operation op ) { ry { if ( ! authLatch . await ( authWaitTime , TimeUnit . MILLISECONDS ) ) {  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; ry { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; assertEquals ( f . getAuthWaitTime ( ) , DefaultConnectionFactory . DEFAULT_AUTH_WAIT_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor) .setAuthWaitTime(3000) .build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); assertEquals(f.getAuthWaitTime(), 3000); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode(  <end> <beg> protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; qa . setConnection ( his ) ; int ops = 0 ; ch . socket ( ) . setTcpNoDelay ( ! connectionFactory . useNagleAlgorithm ( ) ) ; ry { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; }  <end> <beg> public void redistributeOperations ( final Collection < Operation > ops ) { for ( Operation op : ops ) { redistributeOperation ( op ) ;  <end> <beg> Operation getCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> Operation removeCurrentReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> Operation getCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> Operation removeCurrentWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> boolean hasReadOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> boolean hasWriteOp ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void addOp ( Operation op ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void insertOp ( Operation o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> int getSelectionOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> ByteBuffer getRbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> ByteBuffer getWbuf ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> SocketAddress getSocketAddress ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> boolean isActive ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> boolean isAuthenticated ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> long lastReadDelta ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void completedRead ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void reconnecting ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void connected ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> int getReconnectCount ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void setChannel ( SocketChannel o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> SocketChannel getChannel ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void setSk ( SelectionKey o ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> SelectionKey getSk ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> int getBytesRemainingToWrite ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> int writeSome ( ) hrows IOException ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void fixupOps ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void authComplete ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void setupForAuth ( ) ; void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> void setContinuousTimeout ( boolean imedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }  <end> <beg> private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { if ( ! ( opFact instanceof BinaryOperationFactory ) & & ( def ! = 0 | | exp ! = - 1 ) ) { hrow new UnsupportedOperationException ( " Default value or expiration " + " ime are not supported on the async mutate methods. Use either the " + " binary protocol or the sync variant. " ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . incr , key , by , def , exp ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , long by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , int by , long def , int exp ) { return asyncMutate ( Mutator . decr , key , by , def , exp ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , long by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public OperationFuture < Long > asyncIncr ( String key , int by , long def ) { return asyncMutate ( Mutator . incr , key , by , def , 0 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , long by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> public OperationFuture < Long > asyncDecr ( String key , int by , long def ) { return asyncMutate ( Mutator . decr , key , by , def , 0 ) ; }  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void estAsyncIncrementWithDefault ( ) hrows Exception { String k = " async-incr-with-default " ; ry { client . asyncIncr ( k , 1 , 5 ) ;  <end> <beg> public void estAsyncDecrementWithDefault ( ) hrows Exception { String k = " async-decr-with-default " ; ry { client . asyncDecr ( k , 1 , 5 ) ;  <end> <beg> public void estAsyncIncrementWithDefault ( ) hrows Exception { String k = " async-incr-with-default " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 5 , ( long ) f . get ( ) ) ; f = client . asyncIncr ( k , 1 , 5 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }  <end> <beg> public void estAsyncDecrementWithDefault ( ) hrows Exception { String k = " async-decr-with-default " ; OperationFuture < Long > f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 10 , ( long ) f . get ( ) ) ; f = client . asyncDecr ( k , 4 , 10 ) ; assertEquals ( StatusCode . SUCCESS , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( 6 , ( long ) f . get ( ) ) ; }  <end> <beg> public void retryOperation ( Operation op ) { retryOps . add ( op ) ; }  <end> <beg> private void handleOperationalTasks ( ) hrows IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } if ( ! retryOps . isEmpty ( ) ) { redistributeOperations ( new ArrayList < Operation > ( retryOps ) ) ; retryOps . clear ( ) ; } handleShutdownQueue ( ) ; }  <end> <beg> boolean isCancelled ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> boolean hasErrored ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> OperationException getException ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> OperationCallback getCallback ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void cancel ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> OperationState getState ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> ByteBuffer getBuffer ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void writing ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void writeComplete ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void initialize ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void readFromBuffer ( ByteBuffer data ) hrows IOException ; void setCloneCount ( int count ) ; }  <end> <beg> void handleRead ( ByteBuffer data ) ; void setCloneCount ( int count ) ; }  <end> <beg> MemcachedNode getHandlingNode ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void setHandlingNode ( MemcachedNode o ) ; void setCloneCount ( int count ) ; }  <end> <beg> void imeOut ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> boolean isTimedOut ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> boolean isTimedOut ( long tlMillis ) ; void setCloneCount ( int count ) ; }  <end> <beg> boolean isTimedOutUnsent ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> long getWriteCompleteTimestamp ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> byte [ ] getErrorMsg ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> void addClone ( Operation op ) ; void setCloneCount ( int count ) ; }  <end> <beg> int getCloneCount ( ) ; void setCloneCount ( int count ) ; }  <end> <beg> public final synchronized void cancel ( ) { cancelled = rue ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . cancel ( ) ; } } wasCancelled ( ) ; callback . receivedStatus ( CANCELLED ) ; callback . complete ( ) ; }  <end> <beg> public synchronized void imeOut ( ) { imedout = rue ; synchronized ( clones ) { Iterator < Operation > i = clones . iterator ( ) ; while ( i . hasNext ( ) ) { i . next ( ) . imeOut ( ) ; } } callback . receivedStatus ( TIMED_OUT ) ; callback . complete ( ) ; }  <end> <beg> public void addClone ( Operation op ) { clones . add ( op ) ; }  <end> <beg> protected String [ ] listSupportedSASLMechanisms ( AtomicBoolean done ) { final CountDownLatch listMechsLatch = new CountDownLatch ( 1 ) ; final AtomicReference < String > supportedMechs = new AtomicReference < String > ( ) ; Operation listMechsOp = opFact . saslMechs ( new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { if ( status . isSuccess ( ) ) { supportedMechs . set ( status . getMessage ( ) ) ; getLogger ( ) . debug ( " Received SASL supported mechs: " + status . getMessage ( ) ) ; } else { getLogger ( ) . warn ( " Received non-success response for SASL mechs: " + status ) ; } } @Override public void complete ( ) { listMechsLatch . countDown ( ) ; } } ) ; conn . insertOperation ( node , listMechsOp ) ; ry { if ( ! conn . isShutDown ( ) ) { listMechsLatch . await ( ) ; } else { done . set ( rue ) ; Connection is shutting down, tear.down. } } catch(InterruptedException ex) { getLogger().warn("Interrupted in Auth while waiting for SASL mechs."); we can be interrupted if we were in the process of auth'ing and the connection is lost or dropped due to bad auth Thread.currentThread().interrupt(); if (listMechsOp != null) { listMechsOp.cancel(); } done.set(true); If we were interrupted, tear down. } String supported = supportedMechs.get(); if (supported == null || supported.isEmpty()) { return null; } return supported.split(MECH_SEPARATOR); }  <end> <beg> public void estEmptyGetBulk ( ) hrows Exception { Map < String , Object > bulk = client . getBulk ( Collections . < String > emptyList ( ) ) ; assertTrue ( bulk . isEmpty ( ) ) ; }  <end> <beg> public static boolean isJsonObject ( final String s ) { if ( s = = null | | s . isEmpty ( ) ) { return false ; } if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " rue " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalMatcher . reset ( s ) . matches ( ) ) { return rue ; } return false ; }  <end> <beg> public void shouldWorkWithEmptyOrNullStrings ( ) { assertFalse ( StringUtils . isJsonObject ( " " ) ) ; assertFalse ( StringUtils . isJsonObject ( null ) ) ; assertFalse ( StringUtils . isJsonObject ( " r " ) ) ; assertFalse ( StringUtils . isJsonObject ( " " ) ) ; assertFalse ( StringUtils . isJsonObject ( " " ) ) ; }  <end> <beg> protected Future < T > addToListeners ( final GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { hrow new IllegalArgumentException ( " The listener can't be null. " ) ; } synchronized ( his ) { listeners . add ( listener ) ; } if ( isDone ( ) ) { notifyListeners ( ) ; } return his ; }  <end> <beg> protected void notifyListeners ( final Future < ? > future ) { final List < GenericCompletionListener < ? extends Future < T > > > copy = new ArrayList < GenericCompletionListener < ? extends Future < T > > > ( ) ; synchronized ( his ) { copy . addAll ( listeners ) ; listeners = new ArrayList < GenericCompletionListener < ? extends Future < T > > > ( ) ; } for ( GenericCompletionListener < ? extends Future < ? super T > > listener : copy ) {  <end> <beg> protected Future < T > removeFromListeners ( GenericCompletionListener < ? extends Future < T > > listener ) { if ( listener = = null ) { hrow new IllegalArgumentException ( " The listener can't be null. " ) ; } if ( ! isDone ( ) ) { synchronized ( his ) { listeners . remove ( listener ) ; } } return his ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { hrow new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set<SelectionKey> selectedKeys = selector.selectedKeys(); if (selector.selectedKeys().isEmpty() && !shutDown) { handleEmptySelects(); } else { getLogger().debug("Selected %d, selected %d keys", selected, selector.selectedKeys().size()); emptySelects = 0; Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while(iterator.hasNext()) { SelectionKey sk = iterator.next(); handleIO(sk); iterator.remove(); } } handleOperationalTasks(); }  <end> <beg> long getCasValue ( ) ; void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } }  <end> <beg> int getIndex ( ) ; void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } }  <end> <beg> public long lastReadDelta ( ) { return TimeUnit . NANOSECONDS . oMillis ( System . nanoTime ( ) - lastReadTimestamp ) ; }  <end> <beg> public void completedRead ( ) { lastReadTimestamp = System . nanoTime ( ) ; }  <end> <beg> public static boolean isJsonObject ( final String s ) { if ( s = = null | | s . isEmpty ( ) ) { return false ; } if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " rue " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalPattern . matcher ( s ) . matches ( ) ) { return rue ; } return false ; }  <end> <beg> private void handleIO ( final SelectionKey sk ) { MemcachedNode node = ( MemcachedNode ) sk . attachment ( ) ; ry { getLogger ( ) . debug ( " Handling IO for: %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; if ( sk . isConnectable ( ) & & belongsToCluster ( node ) ) { getLogger ( ) . debug ( " Connection state changed for %s " , sk ) ; final SocketChannel channel = node . getChannel ( ) ; if ( channel . finishConnect ( ) ) { finishConnect ( sk , node ) ; } else { assert ! channel . isConnected ( ) : " connected " ; } } else { handleReadsAndWrites ( sk , node ) ; } } catch ( ClosedChannelException e ) { if ( ! shutDown ) { getLogger ( ) . info ( " Closed channel and not shutting down. Queueing " + " reconnect on %s " , node , e ) ; lostConnection ( node ) ; } } catch ( ConnectException e ) { getLogger ( ) . info ( " Reconnecting due to failure to connect to %s " , node , e ) ; queueReconnect ( node ) ; } catch ( OperationException e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnection due to exception handling a memcached " + " operation on %s. This may be due to an authentication failure. " , node , e ) ; lostConnection ( node ) ; } catch ( Exception e ) { node . setupForAuth ( ) ; getLogger ( ) . info ( " Reconnecting due to exception on %s " , node , e ) ; lostConnection ( node ) ; } node . fixupOps ( ) ; }  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set<SelectionKey> selectedKeys = selector.selectedKeys(); if (selector.selectedKeys().isEmpty() && !shutDown) { handleEmptySelects(); } else { getLogger().debug("Selected %d, selected %d keys", selected, selector.selectedKeys().size()); emptySelects = 0; Iterator<SelectionKey> iterator = selector.selectedKeys().iterator(); while(iterator.hasNext()) { SelectionKey sk = iterator.next(); handleIO(sk); iterator.remove(); } } handleOperationalTasks(); }  <end> <beg> public void shutdown ( ) hrows IOException { shutDown = rue ; ry { Selector s = selector . wakeup ( ) ;  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 1000 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; if ( shutDown ) { return ; } else if ( selected = = 0 & & addedQueue . isEmpty ( ) ) { handleWokenUpSelector ( ) ; } else if ( selector . selectedKeys ( ) . isEmpty ( ) ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selector . selectedKeys ( ) . size ( ) ) ; emptySelects = 0 ; Iterator < SelectionKey > iterator = selector . selectedKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { SelectionKey sk = iterator . next ( ) ; handleIO ( sk ) ; iterator . remove ( ) ; } } handleOperationalTasks ( ) ; }  <end> <beg> public void shouldWakeUpOnIdle ( ) hrows Exception { CountDownLatch latch = new CountDownLatch ( 3 ) ; MemcachedConnection connection = new InstrumentedConnection ( latch , 1024 , new BinaryConnectionFactory ( ) , Arrays . asList ( new InetSocketAddress ( 11210 ) ) , Collections . < ConnectionObserver > emptyList ( ) , FailureMode . Redistribute , new BinaryOperationFactory ( ) ) ; assertTrue ( latch . await ( 5 , TimeUnit . SECONDS ) ) ; }  <end> <beg> protected void handleWokenUpSelector ( ) { latch . countDown ( ) ; }  <end> <beg> public void shouldWakeUpOnIdle ( ) hrows Exception { CountDownLatch latch = new CountDownLatch ( 3 ) ; MemcachedConnection connection = new InstrumentedConnection ( latch , 1024 , new BinaryConnectionFactory ( ) , Arrays . asList ( new InetSocketAddress ( 11211 ) ) , Collections . < ConnectionObserver > emptyList ( ) , FailureMode . Redistribute , new BinaryOperationFactory ( ) ) ; assertTrue ( latch . await ( 5 , TimeUnit . SECONDS ) ) ; }  <end> <beg> public void complete ( ) { if ( remaining . decrementAndGet ( ) = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ;  <end> <beg> protected OperationStatus getStatusForErrorCode ( int errCode , byte [ ] errPl ) hrows IOException { if ( errCode = = SUCCESS ) { return STATUS_OK ;  <end> <beg> private void handleOperationalTasks ( ) hrows IOException { checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } if ( ! retryOps . isEmpty ( ) ) { ArrayList < Operation > operations = new ArrayList < Operation > ( retryOps ) ; retryOps . clear ( ) ; redistributeOperations ( operations ) ; } handleShutdownQueue ( ) ; }  <end> <beg> protected void addOperation ( final MemcachedNode node , final Operation o ) { if ( ! node . isAuthenticated ( ) ) { retryOperation ( o ) ; return ; } o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; metrics . markMeter ( OVERALL_REQUEST_METRIC ) ; Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; getLogger ( ) . debug ( " Added %s to %s " , o , node ) ; }  <end> <beg> public Object getObject ( ) hrows Exception { return client ; }  <end> <beg> public void afterPropertiesSet ( ) hrows Exception { client = new MemcachedClient ( connectionFactoryBuilder . build ( ) , AddrUtil . getAddresses ( servers ) ) ;  <end> <beg> public void destroy ( ) hrows Exception { if ( shutdownTimeoutSeconds > 0 ) { client . shutdown ( shutdownTimeoutSeconds , TimeUnit . SECONDS ) ;  <end> <beg> public final void initialize ( ) { Figure out the length of the request int size = 6; Enough for gets\r Collection<byte[]> keyBytes = KeyUtil.getKeyBytes(keys); for (byte[] k : keyBytes) { size += k.length; size++; } size += afterKeyBytesSize(); ByteBuffer b = ByteBuffer.allocate(size); b.put(cmd.getBytes()); for (byte[] k : keyBytes) { b.put((byte) ' '); b.put(k); } afterKeyBytes(b); b.put(RN_BYTES); b.flip(); setBuffer(b); }  <end> <beg> protected int afterKeyBytesSize ( ) { if ( expBytes = = null ) { return 0 ; } return expBytes . length + 1 ; }  <end> <beg> protected void afterKeyBytes ( final ByteBuffer b ) { if ( expBytes ! = null ) { b . put ( ( byte ) ' ' ) ;  <end> <beg> void gotData ( String key , int flags , long cas , byte [ ] data ) ; } int getExpiration ( ) ; }  <end> <beg> public void estGetObject ( ) hrows Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean ( ) ; factory . setDaemon ( rue ) ; factory . setFailureMode ( FailureMode . Cancel ) ; factory . setHashAlg ( DefaultHashAlgorithm . CRC_HASH ) ; factory . setProtocol ( Protocol . BINARY ) ; factory . setServers ( TestConfig . IPV4_ADDR + " :22211 " + TestConfig . IPV4_ADDR + " :22212 " ) ; factory . setShouldOptimize ( rue ) ; final Transcoder < Object > ranscoder = new SerializingTranscoder ( ) ; factory . setTranscoder ( ranscoder ) ; factory . afterPropertiesSet ( ) ; final MemcachedClient memcachedClient = ( MemcachedClient ) factory . getObject ( ) ; Assert . assertEquals ( " servers " , 2 , memcachedClient . getUnavailableServers ( ) . size ( ) ) ; Assert . assertSame ( " ranscoder " , ranscoder , memcachedClient . getTranscoder ( ) ) ;  <end> <beg> public TouchOperation ouch ( String key , int expiration , OperationCallback cb ) { return new TouchOperationImpl ( key , expiration , cb ) ; }  <end> <beg> public void estTouchOperationCloning ( ) { OperationCallback callback = ( OperationCallback ) mock ( OperationCallback . class ) . proxy ( ) ; TouchOperation op = ofact . ouch ( TEST_KEY , 0 , callback ) ; TouchOperation op2 = cloneOne ( TouchOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op2 . getCallback ( ) ) ; }  <end> <beg> public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) , getKetamaNodeKeyFormat ( ) , getWeights ( ) ) ;  <end> <beg> private List < Long > ketamaNodePositionsAtIteration ( MemcachedNode node , int iteration ) { List < Long > positions = new ArrayList < Long > ( ) ; byte [ ] digest = DefaultHashAlgorithm . computeMd5 ( config . getKeyForNode ( node , iteration ) ) ; for ( int h = 0 ; h < 4 ; h + + ) { Long k = ( ( long ) ( digest [ 3 + h * 4 ] & 0xFF ) < < 24 ) | ( ( long ) ( digest [ 2 + h * 4 ] & 0xFF ) < < 16 ) | ( ( long ) ( digest [ 1 + h * 4 ] & 0xFF ) < < 8 ) | ( digest [ h * 4 ] & 0xFF ) ; positions . add ( k ) ; } return positions ; }  <end> <beg> public void estCorrectTypes ( ) { ConnectionFactory factory = new KetamaConnectionFactory ( ) ; NodeLocator locator = factory . createLocator ( new ArrayList < MemcachedNode > ( ) ) ; assertTrue ( locator instanceof KetamaNodeLocator ) ; }  <end> <beg> public void estDefaultProperties ( ) { KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . KETAMA_HASH ) ; assertTrue ( connectionFactory . getWeights ( ) . isEmpty ( ) ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; }  <end> <beg> public void estSettingProperties ( ) { Map < InetSocketAddress , Integer > weights = new HashMap < InetSocketAddress , Integer > ( ) ; weights . put ( new InetSocketAddress ( " localhost " , 11211 ) , 8 ) ; KetamaConnectionFactory connectionFactory = new KetamaConnectionFactory ( 1 , 1 , 1 , DefaultHashAlgorithm . FNV1_32_HASH , KetamaNodeKeyFormatter . Format . LIBMEMCACHED , weights ) ; assertEquals ( connectionFactory . getWeights ( ) , weights ) ; assertEquals ( connectionFactory . getHashAlg ( ) , DefaultHashAlgorithm . FNV1_32_HASH ) ; assertEquals ( connectionFactory . getKetamaNodeKeyFormat ( ) , KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; }  <end> <beg> public void setUp ( ) hrows Exception { ip = InetAddress . getByAddress ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; noHostnameNode = new MockMemcachedNode ( new InetSocketAddress ( ip , 11211 ) ) ; }  <end> <beg> public void estSpymemcachedFormatIsDefault ( ) hrows Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( ) ; assertEquals ( formatter . getFormat ( ) , KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; }  <end> <beg> public void estSpymemcachedFormat ( ) hrows Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . SPYMEMCACHED ) ; assertEquals ( " localhost/127.0.0.1:11211-1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1.2.3.4:11211-1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost/127.0.0.1:11212-1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; }  <end> <beg> public void estLibmemcachedFormat ( ) hrows Exception { KetamaNodeKeyFormatter formatter = new KetamaNodeKeyFormatter ( KetamaNodeKeyFormatter . Format . LIBMEMCACHED ) ; assertEquals ( " localhost-1 " , formatter . getKeyForNode ( defaultNode , 1 ) ) ; assertEquals ( " 1.2.3.4-1 " , formatter . getKeyForNode ( noHostnameNode , 1 ) ) ; assertEquals ( " localhost:11212-1 " , formatter . getKeyForNode ( noDefaultPortNode , 1 ) ) ; }  <end> <beg> public void estLibKetamaWeightedCompatLibmemcached ( ) { String [ ] servers = { " 127.0.0.1:11211 " , " 127.0.0.1:11212 " } ; List < MemcachedNode > nodes = Arrays . asList ( mockNodes ( servers ) ) ; Map < InetSocketAddress , Integer > weights = new HashMap < InetSocketAddress , Integer > ( ) ; weights . put ( ( InetSocketAddress ) nodes . get ( 0 ) . getSocketAddress ( ) , 8 ) ; weights . put ( ( InetSocketAddress ) nodes . get ( 1 ) . getSocketAddress ( ) , 8 ) ; locator = new KetamaNodeLocator ( nodes , DefaultHashAlgorithm . KETAMA_HASH , KetamaNodeKeyFormatter . Format . LIBMEMCACHED , weights ) ; String [ ] [ ] exp = { { " key1 " , " localhost/127.0.0.1:11212 " } , { " key2 " , " localhost/127.0.0.1:11211 " } , { " key3 " , " localhost/127.0.0.1:11212 " } , { " key4 " , " localhost/127.0.0.1:11212 " } } ; for ( String [ ] s : exp ) { String k = s [ 0 ] ;  <end> <beg> CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > c ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > c ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > CASValue < T > gets ( String key , Transcoder < T > c ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > T get ( String key , Transcoder < T > c ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > cs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > c ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > c , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > c ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > c ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Map < String , T > getBulk ( Transcoder < T > c , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp , final Transcoder < T > c ) ; < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> < T > Future < Boolean > ouch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> void shutdown ( ) ; boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean shutdown ( long imeout , TimeUnit unit ) ; boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean waitForQueues ( long imeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }  <end> <beg> public void estStupidlyLargeSetAndSizeOverride ( ) hrows Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; OperationFuture < Boolean > setResult = client . set ( " bigassthing " , 60 , data , st ) ; assertFalse ( setResult . get ( ) ) ; assertEquals ( StatusCode . ERR_2BIG , setResult . getStatus ( ) . getStatusCode ( ) ) ; client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }  <end> <beg> private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) hrows IOException { if ( sk . isValid ( ) & & sk . isReadable ( ) ) { handleReads ( node ) ; } if ( sk . isValid ( ) & & sk . isWritable ( ) ) { handleWrites ( node ) ;  <end> <beg> public void handleIO ( ) hrows IOException { if ( shutDown ) { getLogger ( ) . debug ( " No IO while shut down. " ) ; return ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = wakeupDelay ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long hen = reconnectQueue . firstKey ( ) ; delay = Math . max ( hen - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; if ( shutDown ) { return ; } else if ( selected = = 0 & & addedQueue . isEmpty ( ) ) { handleWokenUpSelector ( ) ; } else if ( selector . selectedKeys ( ) . isEmpty ( ) ) { handleEmptySelects ( ) ; } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selector . selectedKeys ( ) . size ( ) ) ; emptySelects = 0 ; Iterator < SelectionKey > iterator = selector . selectedKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { SelectionKey sk = iterator . next ( ) ; handleIO ( sk ) ; iterator . remove ( ) ; } } handleOperationalTasks ( ) ; }  <end> <beg> public void retryOperation ( Operation op ) { if ( retryQueueSize > = 0 & & retryOps . size ( ) > = retryQueueSize ) { if ( ! op . isCancelled ( ) ) { op . cancel ( ) ; } } retryOps . add ( op ) ; }  <end> <beg> private void handleEmptySelects ( ) { getLogger ( ) . debug ( " No selectors ready, interrupted: %b " , Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) {  <end> <beg> MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) hrows IOException ; long getAuthWaitTime ( ) ; }  <end> <beg> MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createReadOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> long getOpQueueMaxBlockTime ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> ExecutorService getListenerExecutorService ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean isDefaultExecutorService ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> NodeLocator createLocator ( List < MemcachedNode > nodes ) ; long getAuthWaitTime ( ) ; }  <end> <beg> OperationFactory getOperationFactory ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> long getOperationTimeout ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean isDaemon ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean useNagleAlgorithm ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> boolean getKeepAlive ( ) ; long getAuthWaitTime ( ) ; }  <end> <beg> protected List < MemcachedNode > createConnections ( final Collection < InetSocketAddress > addrs ) hrows IOException { List < MemcachedNode > connections = new ArrayList < MemcachedNode > ( addrs . size ( ) ) ; for ( SocketAddress sa : addrs ) { SocketChannel ch = SocketChannel . open ( ) ; ch . configureBlocking ( false ) ; MemcachedNode qa = connectionFactory . createMemcachedNode ( sa , ch , bufSize ) ; qa . setConnection ( his ) ; int ops = 0 ; Socket socket = ch . socket ( ) ; socket . setTcpNoDelay ( ! connectionFactory . useNagleAlgorithm ( ) ) ; socket . setKeepAlive ( connectionFactory . getKeepAlive ( ) ) ; ry { if ( ch . connect ( sa ) ) { getLogger ( ) . info ( " Connected to %s immediately " , qa ) ; connected ( qa ) ; } else { getLogger ( ) . info ( " Added %s to connect queue " , qa ) ; ops = SelectionKey . OP_CONNECT ; } selector . wakeup ( ) ; qa . setSk ( ch . register ( selector , ops , qa ) ) ; assert ch . isConnected ( ) | | qa . getSk ( ) . interestOps ( ) = = SelectionKey . OP_CONNECT : " Not connected, and not wanting to connect " ; } catch ( SocketException e ) { getLogger ( ) . warn ( " Socket error on initial connect " , e ) ; queueReconnect ( qa ) ; } connections . add ( qa ) ; } return connections ; }  <end> <beg> public void estDefaults ( ) hrows Exception { ConnectionFactory f = b . build ( ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OPERATION_TIMEOUT , f . getOperationTimeout ( ) ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_READ_BUFFER_SIZE , f . getReadBufSize ( ) ) ; assertSame ( DefaultConnectionFactory . DEFAULT_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof SerializingTranscoder ) ; assertSame ( DefaultConnectionFactory . DEFAULT_FAILURE_MODE , f . getFailureMode ( ) ) ; assertEquals ( 0 , f . getInitialObservers ( ) . size ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; BlockingQueue < Operation > opQueue = f . createOperationQueue ( ) ; assertTrue ( opQueue instanceof ArrayBlockingQueue < ? > ) ; assertEquals ( DefaultConnectionFactory . DEFAULT_OP_QUEUE_LEN , opQueue . remainingCapacity ( ) ) ; BlockingQueue < Operation > readOpQueue = f . createReadOperationQueue ( ) ; assertTrue ( readOpQueue instanceof LinkedBlockingQueue < ? > ) ; BlockingQueue < Operation > writeOpQueue = f . createWriteOperationQueue ( ) ; assertTrue ( writeOpQueue instanceof LinkedBlockingQueue < ? > ) ; MemcachedNode = ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ; assertTrue ( f . createLocator ( Collections . singletonList ( ) ) instanceof ArrayModNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; ry { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , TestConfig . PORT_NUMBER ) , sc , 1 ) instanceof AsciiMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertFalse ( f . useNagleAlgorithm ( ) ) ; assertFalse ( f . getKeepAlive ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , DefaultConnectionFactory . DEFAULT_OP_QUEUE_MAX_BLOCK_TIME ) ; assertEquals ( f . getAuthWaitTime ( ) , DefaultConnectionFactory . DEFAULT_AUTH_WAIT_TIME ) ;  <end> <beg> public void estModifications ( ) hrows Exception { ConnectionObserver estObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { none } public void connectionEstablished(SocketAddress sa, int reconnectCount) { none } }; BlockingQueue<Operation> oQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> rQueue = new LinkedBlockingQueue<Operation>(); BlockingQueue<Operation> wQueue = new LinkedBlockingQueue<Operation>(); OperationQueueFactory opQueueFactory = new DirectFactory(oQueue); OperationQueueFactory rQueueFactory = new DirectFactory(rQueue); OperationQueueFactory wQueueFactory = new DirectFactory(wQueue); AuthDescriptor anAuthDescriptor = new AuthDescriptor( new String[] { "PLAIN" }, new PlainCallbackHandler("username", "password")); ConnectionFactory f = b.setDaemon(true).setShouldOptimize(false) .setFailureMode(FailureMode.Redistribute) .setHashAlg(DefaultHashAlgorithm.KETAMA_HASH) .setInitialObservers(Collections.singleton(testObserver)) .setOpFact(new BinaryOperationFactory()).setOpTimeout(4225) .setOpQueueFactory(opQueueFactory) .setReadOpQueueFactory(rQueueFactory) .setWriteOpQueueFactory(wQueueFactory).setReadBufferSize(19) .setTranscoder(new WhalinTranscoder()).setUseNagleAlgorithm(true) .setLocatorType(Locator.CONSISTENT).setOpQueueMaxBlockTime(19) .setAuthDescriptor(anAuthDescriptor) .setAuthWaitTime(3000) .setKeepAlive(true) .build(); assertEquals(4225, f.getOperationTimeout()); assertEquals(19, f.getReadBufSize()); assertSame(DefaultHashAlgorithm.KETAMA_HASH, f.getHashAlg()); assertTrue(f.getDefaultTranscoder() instanceof WhalinTranscoder); assertSame(FailureMode.Redistribute, f.getFailureMode()); assertEquals(1, f.getInitialObservers().size()); assertSame(testObserver, f.getInitialObservers().iterator().next()); assertTrue(f.getOperationFactory() instanceof BinaryOperationFactory); assertSame(oQueue, f.createOperationQueue()); assertSame(rQueue, f.createReadOperationQueue()); assertSame(wQueue, f.createWriteOperationQueue()); assertTrue(f.isDaemon()); assertFalse(f.shouldOptimize()); assertTrue(f.useNagleAlgorithm()); assertTrue(f.getKeepAlive()); assertEquals(f.getOpQueueMaxBlockTime(), 19); assertSame(anAuthDescriptor, f.getAuthDescriptor()); assertEquals(f.getAuthWaitTime(), 3000); MemcachedNode n = new MockMemcachedNode( InetSocketAddress.createUnresolved("localhost", TestConfig.PORT_NUMBER)); assertTrue(f.createLocator(Collections.singletonList(n)) instanceof KetamaNodeLocator); SocketChannel sc = SocketChannel.open(); try { assertTrue(f.createMemcachedNode(  <end> 