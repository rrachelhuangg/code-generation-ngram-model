protected void onPause ( ) { tsuper . onPause ( ) ; tLog . i ( TAG , " called onPause() " ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tLog . i ( TAG , " called onCreate() " ) ; } 
protected void onDestroy ( ) { tsuper . onDestroy ( ) ; tLog . i ( TAG , " called onDestroy() " ) ; } 
protected void onResume ( ) { tsuper . onResume ( ) ; tLog . i ( TAG , " called onResume() " ) ; } 
protected void showToastNotification ( int message ) { tToast tmptoast = Toast . makeText ( this , message , Toast . LENGTH_SHORT ) ; ttmptoast . show ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tmainHandler = new Handler ( ) ; trosterEntryList = new ArrayList < ArrayList < HashMap < String , RosterItem > > > ( ) ; trosterGroupList = new ArrayList < HashMap < String , String > > ( ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tshowFirstStartUpDialogIfPrefsEmpty ( ) ; tregisterXMPPService ( ) ; tcreateUICallback ( ) ; tsetContentView ( R . layout . main ) ; tregisterForContextMenu ( getExpandableListView ( ) ) ; } 
protected void onPause ( ) { tsuper . onPause ( ) ; if ( serviceAdapter ! = null ) tserviceAdapter . unregisterUICallback ( rosterCallback ) ; tunbindXMPPService ( ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isServiceAuthenticated ( ) ) ) { 
public void onCreateContextMenu ( ContextMenu menu , View v , tContextMenu . ContextMenuInfo menuInfo ) { tExpandableListView . ExpandableListContextMenuInfo info ; ttry { tinfo = ( ExpandableListView . ExpandableListContextMenuInfo ) menuInfo ; } catch ( ClassCastException e ) { tLog . e ( TAG , " bad menuinfo: " , e ) ; treturn ; } tlong packedPosition = info . packedPosition ; tboolean isChild = isChild ( packedPosition ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . roster_contextmenu , menu ) ; tint groupPosition = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ; tString groupName = rosterGroupList . get ( groupPosition ) . get ( tAdapterConstants . GROUP_NAME [ 0 ] ) ; if ( isChild ) { tmenu . setGroupVisible ( R . id . roster_contacts_group , true ) ; 
public boolean onContextItemSelected ( MenuItem item ) { treturn applyMenuContextChoice ( item ) ; } 
private boolean isChild ( long packedPosition ) { tint type = ExpandableListView . getPackedPositionType ( packedPosition ) ; treturn ( type = = ExpandableListView . PACKED_POSITION_TYPE_CHILD ) ; } 
private void startChatActivity ( String user ) { tIntent chatIntent = new Intent ( this , tde . hdmstuttgart . yaxim . chat . ChatWindow . class ) ; tUri userNameUri = Uri . parse ( user ) ; tchatIntent . setData ( userNameUri ) ; tstartActivity ( chatIntent ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tpopulateMainMenu ( menu ) ; treturn super . onCreateOptionsMenu ( menu ) ; } 
public boolean onOptionsItemSelected ( MenuItem item ) { treturn applyMainMenuChoice ( item ) ; } 
private void populateMainMenu ( Menu menu ) { tmenu . add ( Menu . NONE , CONNECT , Menu . NONE , ( getConnectDisconnectText ( ) ) ) . setIcon ( getConnectDisconnectIcon ( ) ) ; tmenu . add ( Menu . NONE , ADD_FRIEND , Menu . NONE , ( getString ( R . string . Menu_addFriend ) ) ) . setIcon ( tandroid . R . drawable . ic_menu_add ) ; tmenu . add ( Menu . NONE , SHOW_HIDE , Menu . NONE , getShowHideMenuText ( ) ) . setIcon ( getShowHideMenuIcon ( ) ) ; tmenu . add ( Menu . NONE , STATUS , Menu . NONE , ( getString ( R . string . Menu_Status ) ) ) . setIcon ( tandroid . R . drawable . ic_menu_myplaces ) ; tmenu . add ( Menu . NONE , EXIT , Menu . NONE , ( getString ( R . string . Global_Exit ) ) ) . setIcon ( android . R . drawable . ic_menu_close_clear_cancel ) ; tmenu . add ( Menu . NONE , SETTINGS , Menu . NONE , ( getString ( R . string . Menu_Settings ) ) ) . setIcon ( tandroid . R . drawable . ic_menu_preferences ) ; tmenu . add ( Menu . NONE , ACC_SET , Menu . NONE , ( getString ( R . string . Menu_AccSettings ) ) ) . setIcon ( 
public boolean onChildClick ( ExpandableListView parent , View v , tint groupPosition , int childPosition , long id ) { tLog . i ( TAG , " Called onChildClick() " ) ; tString user = rosterEntryList . get ( groupPosition ) . get ( childPosition ) . get ( AdapterConstants . CONTACT_ID ) . jabberID ; tstartChatActivity ( user ) ; treturn true ; } 
private void toggleConnection ( MenuItem item ) { if ( serviceAdapter . isServiceAuthenticated ( ) ) { ( new Thread ( ) { public void run ( ) { tserviceAdapter . disconnect ( ) ; tstopService ( xmppServiceIntent ) ; } } ) . start ( ) ; tclearRoster ( ) ; tisConnected = false ; } else { tshowDialog ( DIALOG_CONNECTING ) ; ( new Thread ( ) { public void run ( ) { tstartService ( xmppServiceIntent ) ; } } ) . start ( ) ; tisConnected = true ; } titem . setIcon ( getConnectDisconnectIcon ( ) ) ; titem . setTitle ( getConnectDisconnectText ( ) ) ; } 
public void run ( ) { tserviceAdapter . disconnect ( ) ; tstopService ( xmppServiceIntent ) ; } 
private void clearRoster ( ) { trosterEntryList . clear ( ) ; trosterGroupList . clear ( ) ; if ( rosterListAdapter ! = null ) trosterListAdapter . notifyDataSetChanged ( ) ; 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; txmppServiceIntent = new Intent ( this , XMPPService . class ) ; txmppServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; txmppServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tserviceAdapter = new XMPPRosterServiceAdapter ( tIXMPPRosterService . Stub . asInterface ( service ) ) ; tserviceAdapter . registerUICallback ( rosterCallback ) ; tcreateRosterIfConnected ( ) ; tsetIsConnected ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { tLog . i ( TAG , " called onServiceDisconnected() " ) ; } 
private void unbindXMPPService ( ) { ttry { tunbindService ( xmppServiceConnection ) ; 
private void bindXMPPService ( ) { tbindService ( xmppServiceIntent , xmppServiceConnection , BIND_AUTO_CREATE ) ; } 
private void registerListAdapter ( ) { tcreateRosterEntryList ( ) ; tcreateRosterGroupList ( ) ; trosterListAdapter = new ExpandableRosterAdapter ( this , rosterGroupList , tR . layout . maingroup_row , AdapterConstants . GROUP_NAME , tnew int [ ] { R . id . groupname } , rosterEntryList , tR . layout . mainchild_row , AdapterConstants . CHILD_DATA_KEYS , tnew int [ ] { R . id . roster_screenname , R . id . roster_statusmsg } ) ; tsetListAdapter ( rosterListAdapter ) ; } 
private void createRosterEntryList ( ) { tList < String > rosterGroups = serviceAdapter . getRosterGroups ( ) ; tfor ( String rosterGroup : rosterGroups ) { tArrayList < HashMap < String , RosterItem > > rosterGroupItems = getRosterGroupItems ( rosterGroup ) ; 
public void createRoster ( ) { tLog . i ( TAG , " called createRoster() " ) ; if ( serviceAdapter . isServiceAuthenticated ( ) ) { tclearRoster ( ) ; 
private void createUICallback ( ) { trosterCallback = new IXMPPRosterCallback . Stub ( ) { 
public void rosterChanged ( ) throws RemoteException { tLog . i ( TAG , " called rosterChanged() " ) ; tmainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void connectionSuccessful ( ) throws RemoteException { tmainHandler . post ( new Runnable ( ) { 
public void run ( ) { tcreateRosterIfConnected ( ) ; tisConnected = true ; if ( progressDialog . isShowing ( ) ) tdismissDialog ( DIALOG_CONNECTING ) ; 
public void connectionFailed ( ) throws RemoteException { tmainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { showToastNotification ( R . string . toast_connectfail_message ) ; tisConnected = false ; if ( progressDialog . isShowing ( ) ) tdismissDialog ( DIALOG_CONNECTING ) ; 
protected Dialog onCreateDialog ( int id ) { tswitch ( id ) { tcase DIALOG_CONNECTING : 
private void showFirstStartUpDialogIfPrefsEmpty ( ) { tSharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; tString configuredJabberID = prefs . getString ( PreferenceConstants . JID , " " ) ; tLog . i ( TAG , " called showFirstStartUpDialogIfPrefsEmpty, string from pref was: " + configuredJabberID ) ; if ( configuredJabberID . length ( ) < 3 ) { tshowFirstStartUpDialog ( ) ; 
private void showFirstStartUpDialog ( ) { tnew FirstStartDialog ( this , serviceAdapter ) . show ( ) ; } 
public boolean isServiceAuthenticated ( ) { ttry { treturn xmppServiceStub . isAuthenticated ( ) ; } catch ( RemoteException e ) { te . printStackTrace ( ) ; } treturn false ; } 
public void addRosterItem ( String user , String alias , String group ) { ttry { txmppServiceStub . addRosterItem ( user , alias , group ) ; 
public void renameRosterGroup ( String group , String newGroup ) { ttry { txmppServiceStub . renameRosterGroup ( group , newGroup ) ; 
public void renameRosterItem ( String contact , String newItemName ) { ttry { txmppServiceStub . renameRosterItem ( contact , newItemName ) ; 
public void moveRosterItemToGroup ( String user , String group ) { ttry { txmppServiceStub . moveRosterItemToGroup ( user , group ) ; 
public void addRosterGroup ( String group ) { ttry { txmppServiceStub . addRosterGroup ( group ) ; 
public void removeRosterItem ( String user ) { ttry { txmppServiceStub . removeRosterItem ( user ) ; 
public void registerUICallback ( IXMPPRosterCallback uiCallback ) { ttry { txmppServiceStub . registerRosterCallback ( uiCallback ) ; 
public void unregisterUICallback ( IXMPPRosterCallback uiCallback ) { ttry { txmppServiceStub . unregisterRosterCallback ( uiCallback ) ; 
public boolean isAuthenticated ( ) { ttry { treturn xmppServiceStub . isAuthenticated ( ) ; } catch ( RemoteException e ) { te . printStackTrace ( ) ; } treturn false ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tchatItemList = new ArrayList < ChatItem > ( ) ; thandler = new Handler ( ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tregisterXMPPService ( ) ; tcreateUICallback ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetChatItems ( ) ; tsetContactFromUri ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + jabberID ) ; } 
protected void onPause ( ) { tsuper . onPause ( ) ; tserviceAdapter . unregisterUICallback ( chatCallback ) ; tunbindXMPPService ( ) ; } 
protected void onResume ( ) { tsuper . onResume ( ) ; notificationMGR . cancel ( NOTIFY_ID ) ; tbindXMPPService ( ) ; } 
private void processMessageQueue ( ) { tList < String > queue = serviceAdapter . pullMessagesForContact ( jabberID ) ; tfor ( String message : queue ) { tprocessIncomingMessageInHandler ( jabberID , message ) ; 
private void createUICallback ( ) { tchatCallback = new IXMPPChatCallback . Stub ( ) { 
public void newMessage ( String from , String message ) tthrows RemoteException { tprocessIncomingMessageInHandler ( from , message ) ; } 
private void processIncomingMessageInHandler ( String from , String message ) { tfinal ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + from , message ) ; thandler . post ( new Runnable ( ) { public void run ( ) { 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; txmppServiceIntent = new Intent ( this , XMPPService . class ) ; tUri chatURI = Uri . parse ( " chatwindow " ) ; txmppServiceIntent . setData ( chatURI ) ; txmppServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; txmppServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tserviceAdapter = new XMPPChatServiceAdapter ( tIXMPPChatService . Stub . asInterface ( service ) , jabberID ) ; tserviceAdapter . registerUICallback ( chatCallback ) ; tprocessMessageQueue ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { tLog . i ( TAG , " called onServiceDisconnected() " ) ; tserviceAdapter . unregisterUICallback ( chatCallback ) ; } 
private void sendMessage ( String message ) { tChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; tadapter . add ( newChatItem ) ; tuserInput . setText ( null ) ; tsend . setEnabled ( false ) ; tserviceAdapter . sendMessage ( jabberID , message ) ; } 
public boolean onKey ( View v , int keyCode , KeyEvent event ) { if ( event . getAction ( ) = = KeyEvent . ACTION_DOWN & & keyCode = = KeyEvent . KEYCODE_ENTER ) { tsendMessageIfNotNull ( ) ; treturn true ; } treturn false ; 
private void showToastNotification ( int message ) { tToast tmptoast = Toast . makeText ( this , message , Toast . LENGTH_SHORT ) ; ttmptoast . show ( ) ; } 
public void registerUICallback ( IXMPPChatCallback uiCallback ) { ttry { txmppServiceStub . registerChatCallback ( uiCallback , jabberID ) ; 
public void unregisterUICallback ( IXMPPChatCallback uiCallback ) { ttry { txmppServiceStub . unregisterChatCallback ( uiCallback , jabberID ) ; 
public void sendMessage ( String user , String message ) { ttry { tLog . i ( TAG , " Called sendMessage(): " + jabberID + " : " + message ) ; 
public List < String > pullMessagesForContact ( tString jabberID ) { tList < String > queue = null ; ttry { tqueue = xmppServiceStub . pullMessagesForContact ( jabberID ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } treturn queue ; } 
public RosterItem createFromParcel ( Parcel in ) { treturn new RosterItem ( in ) ; } 
public void writeToParcel ( Parcel out , int flags ) { out . writeString ( jabberID ) ; out . writeString ( screenName ) ; out . writeString ( statusMode ) ; out . writeString ( statusMessage ) ; out . writeString ( group ) ; } 
private int compareStatusModes ( StatusMode otherMode ) { tint compVal = ( otherMode . getPriority ( ) - this . getStatusMode ( ) . getPriority ( ) ) ; if ( compVal < 0 ) { treturn - 1 ; } if ( compVal > 0 ) { treturn 1 ; } treturn 0 ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . addrosteritemdialog ) ; tsetTitle ( R . string . addFriend_Title ) ; tsetUserInputField ( ) ; tsetAliasInputField ( ) ; tsetGroupSpinner ( ) ; tsetNewGroupInputField ( ) ; tcreateAndSetGroupSpinnerAdapter ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
private void createAndSetGroupSpinnerAdapter ( ) { tgroupList = serviceAdapter . getRosterGroups ( ) ; if ( ! groupList . contains ( AdapterConstants . EMPTY_GROUP ) ) { tgroupList = new ArrayList < String > ( ) ; tgroupList . add ( AdapterConstants . EMPTY_GROUP ) ; tgroupList . addAll ( serviceAdapter . getRosterGroups ( ) ) ; } tgroupList . add ( mainWindow . getString ( R . string . addrosteritemaddgroupchoice ) ) ; tArrayAdapter < String > groupSpinnerAdapter = new ArrayAdapter < String > ( tmainWindow , android . R . layout . simple_spinner_item , groupList ) ; tgroupSpinnerAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; tgroupSpinner . setAdapter ( groupSpinnerAdapter ) ; tgroupSpinner . setOnItemSelectedListener ( this ) ; } 
public void afterTextChanged ( Editable s ) { ttry { tXMPPHelper . verifyJabberID ( s ) ; 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . statusdialog ) ; tsetStatusRadioGroup ( ) ; tsetStatusTextField ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
public void onCheckedChanged ( RadioGroup radioGroup , int selectedID ) { if ( radioGroup = = statusRadioGroup ) { tswitch ( selectedID ) { 
public void afterTextChanged ( Editable arg0 ) { } public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , tint arg3 ) { } public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , tint arg3 ) { } public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . firststartdialog ) ; tsetTitle ( R . string . StartupDialog_Title ) ; tsetEditPort ( ) ; tsetEditPassword ( ) ; tsetEditJabberID ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
private void verifyAndSavePreferences ( ) { tString password = editPassword . getText ( ) . toString ( ) ; tString jabberID = editJabberID . getText ( ) . toString ( ) ; tString port = editPort . getText ( ) . toString ( ) ; if ( port = = null ) { tsavePreferences ( jabberID , password ) ; 
public void beforeTextChanged ( CharSequence s , int start , int count , tint after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private void savePreferences ( String jabberID , String password , String port ) { tSharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; tEditor editor = sharedPreferences . edit ( ) ; teditor . putString ( PreferenceConstants . JID , jabberID ) ; teditor . putString ( PreferenceConstants . PASSWORD , password ) ; teditor . putString ( PreferenceConstants . PORT , port ) ; teditor . commit ( ) ; } private void savePreferences ( String jabberID , String password ) { tsavePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } } 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private void savePreferences ( String jabberID , String password , String port ) { tSharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; tEditor editor = sharedPreferences . edit ( ) ; teditor . putString ( PreferenceConstants . JID , jabberID ) ; teditor . putString ( PreferenceConstants . PASSWORD , password ) ; teditor . putString ( PreferenceConstants . PORT , port ) ; teditor . commit ( ) ; } private void savePreferences ( String jabberID , String password ) { tsavePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } } 
private void savePreferences ( String jabberID , String password , String port ) { tSharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; tEditor editor = sharedPreferences . edit ( ) ; teditor . putString ( PreferenceConstants . JID , jabberID ) ; teditor . putString ( PreferenceConstants . PASSWORD , password ) ; teditor . putString ( PreferenceConstants . PORT , port ) ; teditor . commit ( ) ; } 
private void savePreferences ( String jabberID , String password ) { tsavePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tgetWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_BLUR_BEHIND , WindowManager . LayoutParams . FLAG_BLUR_BEHIND ) ; tsetCancelable ( true ) ; } 
private void tryToSetMainWindow ( Context context ) { ttry { tthis . mainWindow = ( MainWindow ) context ; 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . moverosterentrytogroupdialog ) ; tsetTitle ( R . string . MoveRosterEntryToGroupDialog_title ) ; tsetGroupSpinner ( ) ; tcreateAndSetGroupSpinnerAdapter ( ) ; tsetNewGroupInputField ( ) ; tsetCancelButton ( ) ; tsetOkButton ( ) ; } 
private void createAndSetGroupSpinnerAdapter ( ) { tgroupList = serviceAdapter . getRosterGroups ( ) ; if ( ! groupList . contains ( AdapterConstants . EMPTY_GROUP ) ) { tgroupList = new ArrayList < String > ( ) ; tgroupList . add ( AdapterConstants . EMPTY_GROUP ) ; tgroupList . addAll ( serviceAdapter . getRosterGroups ( ) ) ; } tArrayAdapter < String > groupSpinnerAdapter = new ArrayAdapter < String > ( tmainWindow , android . R . layout . simple_spinner_item , groupList ) ; tgroupSpinnerAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; tgroupSpinner . setAdapter ( groupSpinnerAdapter ) ; tgroupSpinnerAdapter . add ( mainWindow . getString ( R . string . addrosteritemaddgroupchoice ) ) ; tgroupSpinner . setOnItemSelectedListener ( this ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . removerosteritemdialog ) ; tsetTitle ( R . string . deleteRosterItem_title ) ; tsetTextField ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . renamegroupdialog ) ; tsetTitle ( R . string . RenameGroup_title ) ; tsetRenameGroupTextField ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . renameentrydialog ) ; tsetTitle ( R . string . RenameEntry_title ) ; tsetRenameGroupTextField ( ) ; tsetOkButton ( ) ; tsetCancelButton ( ) ; } 
public boolean onPreferenceChange ( Preference preference , tObject newValue ) { tLog . e ( " accountprefs " , " jabberid pref changed " ) ; tnewSummary = ( CharSequence ) newValue ; if ( newValue ! = null ) { tprefAccountID 
public void onTextChanged ( CharSequence s , int start , tint before , int count ) { ttry { tXMPPHelper . verifyJabberID ( s . toString ( ) ) ; 
public boolean onPreferenceChange ( Preference preference , tObject newValue ) { tnewResourceSummary = ( CharSequence ) newValue ; if ( newValue ! = null ) { tprefResource 
public boolean onPreferenceChange ( Preference preference , tObject newValue ) { ttry { tint prioIntValue = Integer . parseInt ( newValue 
public void afterTextChanged ( Editable s ) { ttry { tprioIntValue = Integer . parseInt ( s . toString ( ) ) ; 
 public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . layout . mainprefs ) ; } 
public IBinder onBind ( Intent arg0 ) { tLog . i ( TAG , " called onBind() " ) ; treturn null ; } 
public boolean onUnbind ( Intent intent ) { tLog . i ( TAG , " called onUnbind() " ) ; treturn super . onUnbind ( intent ) ; } 
public void onRebind ( Intent intent ) { tLog . i ( TAG , " called onRebind() " ) ; tsuper . onRebind ( intent ) ; } 
public void onCreate ( ) { tLog . i ( TAG , " called onCreate() " ) ; tsuper . onCreate ( ) ; tvibrator = ( Vibrator ) getSystemService ( Context . VIBRATOR_SERVICE ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; addNotificationMGR ( ) ; } 
public void onDestroy ( ) { tLog . i ( TAG , " called onDestroy() " ) ; tsuper . onDestroy ( ) ; } 
public void onStart ( Intent intent , int startId ) { tLog . i ( TAG , " called onStart() " ) ; tsuper . onStart ( intent , startId ) ; } 
private void addNotificationMGR ( ) { notificationMGR = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; notificationIntent = new Intent ( this , ChatWindow . class ) ; } 
protected void notifyClient ( String from , String message ) { notificationCounter + + ; tString title = " Message from " + from ; notification = new Notification ( R . drawable . icon , APP_NAME + " : " + title , System . currentTimeMillis ( ) ) ; tUri userNameUri = Uri . parse ( from ) ; notificationIntent . setData ( userNameUri ) ; tPendingIntent pendingIntent = PendingIntent . getActivity ( this , 0 , notificationIntent , 0 ) ; notification . setLatestEventInfo ( this , title , message , pendingIntent ) ; notification . number = notificationCounter ; notification . flags = Notification . FLAG_AUTO_CANCEL | Notification . FLAG_ONLY_ALERT_ONCE ; vibraNotififaction ( ) ; if ( isLEDNotify ) { notification . flags | = Notification . DEFAULT_LIGHTS ; notification . ledARGB = Color . MAGENTA ; notification . ledOnMS = 300 ; notification . ledOffMS = 1000 ; notification . flags | = Notification . FLAG_SHOW_LIGHTS ; } notificationMGR . notify ( NOTIFY_ID , notification ) ; } 
private void vibraNotififaction ( ) { if ( isVibraNotify ) { tvibrator . vibrate ( 500 ) ; 
protected void shortToastNotify ( String msg ) { tToast toast = Toast . makeText ( this , msg , Toast . LENGTH_SHORT ) ; ttoast . show ( ) ; } 
tboolean doConnect ( ) throws YaximXMPPException ; tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
tArrayList < String > getRosterGroups ( ) ; tArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
private int validatePriority ( int jabPriority ) { if ( jabPriority > 127 ) treturn 127 ; telse if ( jabPriority < - 127 ) treturn - 127 ; treturn jabPriority ; } 
public boolean doConnect ( ) throws YaximXMPPException { if ( ! conn . isConnected ( ) ) { ttryToConnect ( ) ; if ( isAuthenticated ( ) ) { tregisterMessageHandler ( ) ; tregisterRosterHandler ( ) ; tPresence presence = new Presence ( Presence . Type . available ) ; tpresence . setPriority ( jabPriority ) ; tconn . sendPacket ( presence ) ; tsetRosterEntries ( ) ; } } treturn ( conn . isConnected ( ) & & conn . isAuthenticated ( ) ) ; } 
public void addRosterItem ( String user , String alias , String group ) tthrows YaximXMPPException { ttryToAddRosterEntry ( user , alias , group ) ; } 
public void removeRosterItem ( String user ) throws YaximXMPPException { ttryToRemoveRosterEntry ( user ) ; tcallBack . rosterChanged ( ) ; } 
public void renameRosterItem ( String user , String newName ) tthrows YaximXMPPException { troster = conn . getRoster ( ) ; tRosterEntry rosterEntry = roster . getEntry ( user ) ; if ( ! ( newName . length ( ) > 0 ) | | ( rosterEntry = = null ) ) { tthrow new YaximXMPPException ( " JabberID to rename is invalid! " ) ; } trosterEntry . setName ( newName ) ; } 
public void addRosterGroup ( String group ) { troster = conn . getRoster ( ) ; troster . createGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) { troster = conn . getRoster ( ) ; tRosterGroup groupToRename = roster . getGroup ( group ) ; trosterItemsByGroup . remove ( group ) ; tgroupToRename . setName ( newGroup ) ; } 
public void moveRosterItemToGroup ( String user , String group ) tthrows YaximXMPPException { ttryToMoveRosterEntryToGroup ( user , group ) ; } 
public ArrayList < String > pullMessagesForContact ( String jabberID ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tincomingMessageQueue . remove ( jabberID ) ; treturn queue ; } 
private void tryToConnect ( ) throws YaximXMPPException { ttry { tSmackConfiguration . setPacketReplyTimeout ( PACKET_TIMEOUT ) ; 
private void tryToMoveRosterEntryToGroup ( String user , String group ) tthrows YaximXMPPException { if ( ! ( group . length ( ) > 0 ) ) { tthrow new YaximXMPPException ( " Can't move " + user + " to a group without a name! " ) ; } troster = conn . getRoster ( ) ; tRosterGroup rosterGroup = roster . getGroup ( group ) ; if ( ! ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) ) { if ( rosterGroup = = null ) trosterGroup = roster . createGroup ( group ) ; } tRosterEntry rosterEntry = roster . getEntry ( user ) ; tunSetRosterEntry ( rosterEntry ) ; tremoveRosterEntryFromGroups ( rosterEntry ) ; if ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) treturn ; 
private void removeRosterEntryFromGroups ( RosterEntry rosterEntry ) tthrows YaximXMPPException { tCollection < RosterGroup > oldGroups = rosterEntry . getGroups ( ) ; tfor ( RosterGroup group : oldGroups ) { ttryToRemoveUserFromGroup ( group , rosterEntry ) ; 
private void tryToRemoveUserFromGroup ( RosterGroup group , tRosterEntry rosterEntry ) throws YaximXMPPException { ttry { tgroup . removeEntry ( rosterEntry ) ; 
private void tryToRemoveRosterEntry ( String user ) throws YaximXMPPException { troster = conn . getRoster ( ) ; ttry { tRosterEntry rosterEntry = roster . getEntry ( user ) ; 
private void tryToAddRosterEntry ( String user , String alias , String group ) tthrows YaximXMPPException { troster = conn . getRoster ( ) ; ttry { troster . createEntry ( user , alias , new String [ ] { group } ) ; 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { tString groupName = getGroup ( rosterEntry . getGroups ( ) ) ; tConcurrentMap < String , RosterItem > entryMap = getEntryMapForGroup ( groupName ) ; tString jabberID = rosterEntry . getUser ( ) ; if ( entryMap . containsKey ( jabberID ) ) tentryMap . remove ( jabberID ) ; if ( entryMap . size ( ) < 1 ) trosterItemsByGroup . remove ( groupName ) ; 
private ConcurrentMap < String , RosterItem > getEntryMapForGroup ( tString groupName ) { tConcurrentHashMap < String , RosterItem > tmpItemList ; if ( rosterItemsByGroup . containsKey ( groupName ) ) treturn rosterItemsByGroup . get ( groupName ) ; telse { ttmpItemList = new ConcurrentHashMap < String , RosterItem > ( ) ; trosterItemsByGroup . put ( groupName , tmpItemList ) ; } treturn tmpItemList ; } 
public int compare ( String object1 , String object2 ) { if ( object1 . equals ( AdapterConstants . EMPTY_GROUP ) ) treturn - 1 ; treturn object1 . toLowerCase ( ) . compareTo ( object2 . toLowerCase ( ) ) ; } 
private Mode stringToMode ( String modeStr ) { treturn Mode . valueOf ( modeStr ) ; } 
public void sendMessage ( String user , String message ) { tfinal Message newMessage = new Message ( user , Message . Type . chat ) ; tnewMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { tconn . sendPacket ( newMessage ) ; 
public boolean isAuthenticated ( ) { if ( conn ! = null ) { treturn conn . isAuthenticated ( ) ; } treturn false ; } 
public void registerCallback ( XMPPServiceCallback callBack ) { tthis . callBack = callBack ; } 
public void unRegisterCallback ( ) { tconn . disconnect ( ) ; trosterItemsByGroup . clear ( ) ; tthis . callBack = null ; } 
private void createConnection ( ) { tconfig = new ConnectionConfiguration ( jabServer , jabPort ) ; tconfig . setReconnectionAllowed ( true ) ; tconn = new XMPPConnection ( config ) ; } 
private void registerRosterHandler ( ) { troster = conn . getRoster ( ) ; troster . addRosterListener ( new RosterListener ( ) { 
public void entriesAdded ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = roster . getEntry ( entry ) ; tsetRosterEntry ( rosterEntry ) ; } tcallBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = roster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; } tcallBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = roster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; tsetRosterEntry ( rosterEntry ) ; } tcallBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { tString jabberID = getJabberID ( presence . getFrom ( ) ) ; tRosterEntry rosterEntry = roster . getEntry ( jabberID ) ; tsetRosterEntry ( rosterEntry ) ; tcallBack . rosterChanged ( ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { tMessage message = ( Message ) arg0 ; tString msg = message . getBody ( ) ; tString jabberID = getJabberID ( message . getFrom ( ) ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tqueue . add ( msg ) ; } tcallBack . newMessage ( jabberID , msg ) ; } } } ; tconn . addPacketListener ( myListener , filter ) ; } 
public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { tMessage message = ( Message ) arg0 ; 
public IBinder onBind ( Intent intent ) { tsuper . onBind ( intent ) ; tString caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) treturn service2ChatConnection ; treturn service2RosterConnection ; } 
public boolean onUnbind ( Intent intent ) { treturn super . onUnbind ( intent ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; trosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; tchatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; tisBoundTo = new HashSet < String > ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; } 
public void onDestroy ( ) { tsuper . onDestroy ( ) ; trosterCallbacks . kill ( ) ; tfor ( String key : chatCallbacks . keySet ( ) ) { tchatCallbacks . get ( key ) . kill ( ) ; } tdoDisconnect ( ) ; } 
public void onStart ( Intent intent , int startId ) { tsuper . onStart ( intent , startId ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tcreateAdapter ( ) ; tregisterAdapterCallback ( ) ; tdoConnect ( ) ; } 
private void createServiceChatStub ( ) { tservice2ChatConnection = new IXMPPChatService . Stub ( ) { 
public void registerChatCallback ( IXMPPChatCallback callback , tString jabberID ) throws RemoteException { if ( callback ! = null ) { resetNotificationCounter ( ) ; if ( chatCallbacks . containsKey ( jabberID ) ) tchatCallbacks . get ( jabberID ) . register ( callback ) ; telse { tRemoteCallbackList < IXMPPChatCallback > chatCallback = new RemoteCallbackList < IXMPPChatCallback > ( ) ; tchatCallback . register ( callback ) ; tchatCallbacks . put ( jabberID , chatCallback ) ; } } tisBoundTo . add ( jabberID ) ; } 
public void unregisterChatCallback ( IXMPPChatCallback callback , tString jabberID ) throws RemoteException { if ( callback ! = null ) { tchatCallbacks . get ( jabberID ) . unregister ( callback ) ; } tisBoundTo . remove ( jabberID ) ; } 
public void sendMessage ( String user , String message ) tthrows RemoteException { txmppAdapter . sendMessage ( user , message ) ; } 
public List < String > pullMessagesForContact ( String jabberID ) tthrows RemoteException { if ( xmppAdapter ! = null ) treturn xmppAdapter . pullMessagesForContact ( jabberID ) ; treturn new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) throws RemoteException { if ( xmppAdapter ! = null ) treturn xmppAdapter . isAuthenticated ( ) ; treturn false ; } 
private void createServiceRosterStub ( ) { tservice2RosterConnection = new IXMPPRosterService . Stub ( ) { 
public void registerRosterCallback ( IXMPPRosterCallback callback ) tthrows RemoteException { if ( callback ! = null ) trosterCallbacks . register ( callback ) ; 
public void unregisterRosterCallback ( IXMPPRosterCallback callback ) tthrows RemoteException { if ( callback ! = null ) trosterCallbacks . unregister ( callback ) ; 
public void setStatus ( String status , String statusMsg ) tthrows RemoteException { if ( status . equals ( " offline " ) ) { tdoDisconnect ( ) ; treturn ; } txmppAdapter . setStatus ( StatusMode . valueOf ( status ) , statusMsg ) ; } 
public void addRosterItem ( String user , String alias , String group ) tthrows RemoteException { ttry { txmppAdapter . addRosterItem ( user , alias , group ) ; 
public void addRosterGroup ( String group ) throws RemoteException { txmppAdapter . addRosterGroup ( group ) ; } 
public void removeRosterItem ( String user ) throws RemoteException { ttry { txmppAdapter . removeRosterItem ( user ) ; 
public void moveRosterItemToGroup ( String user , String group ) tthrows RemoteException { ttry { txmppAdapter . moveRosterItemToGroup ( user , group ) ; 
public void renameRosterItem ( String user , String newName ) tthrows RemoteException { ttry { txmppAdapter . renameRosterItem ( user , newName ) ; 
public List < String > getRosterGroups ( ) throws RemoteException { treturn xmppAdapter . getRosterGroups ( ) ; } 
public List < RosterItem > getRosterEntriesByGroup ( String group ) tthrows RemoteException { treturn xmppAdapter . getRosterEntriesByGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) tthrows RemoteException { txmppAdapter . renameRosterGroup ( group , newGroup ) ; } 
public void disconnect ( ) throws RemoteException { tdoDisconnect ( ) ; } 
private void splitJabberID ( String jid ) { tPattern p = Pattern . compile ( " \\ @ " ) ; tString [ ] res = p . split ( jid ) ; tthis . jabUsername = res [ 0 ] ; tthis . jabServer = res [ 1 ] ; } 
private void connectionFailed ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
private void connectionEstablished ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { if ( xmppAdapter . isAuthenticated ( ) ) trosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; telse tconnectionFailed ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
public void doDisconnect ( ) { if ( xmppAdapter ! = null ) { txmppAdapter . unRegisterCallback ( ) ; } txmppAdapter = null ; } 
private void createAdapter ( ) { ttry { txmppAdapter = new SmackableImp ( jabServer , jabUsername , jabPassword , 
private void registerAdapterCallback ( ) { txmppAdapter . registerCallback ( new XMPPServiceCallback ( ) { 
public void newMessage ( String from , String message ) { if ( ! isBoundTo . contains ( from ) ) { tLog . i ( TAG , " notification: " + from ) ; 
public void rosterChanged ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; + + i ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
public boolean isBoundTo ( String jabberID ) { treturn isBoundTo . contains ( jabberID ) ; } 
private void handleIncomingMessage ( String from , String message ) { tRemoteCallbackList < IXMPPChatCallback > chatCallbackList = chatCallbacks . get ( from ) ; tfinal int broadCastItems = chatCallbackList . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tchatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
tvoid newMessage ( String from , String messageBody ) ; tvoid rosterChanged ( ) ; tboolean isBoundTo ( String jabberID ) ; } 
public View getChildView ( int groupPosition , int childPosition , tboolean isLastChild , View convertView , ViewGroup parent ) { tView currentRow ; if ( convertView = = null ) tcurrentRow = newChildView ( isLastChild , parent ) ; telse tcurrentRow = convertView ; tRosterItem contactListItem = getRosterItem ( groupPosition , childPosition ) ; tsetLabel ( currentRow , contactListItem ) ; tString statusMessage = contactListItem . statusMessage ; tsetStatusMessage ( currentRow , statusMessage ) ; tStatusMode presenceMode = contactListItem . getStatusMode ( ) ; tsetIcon ( currentRow , presenceMode ) ; treturn currentRow ; } 
public View getGroupView ( int groupPosition , boolean isExpanded , tView convertView , ViewGroup parent ) { treturn super . getGroupView ( groupPosition , isExpanded , convertView , tparent ) ; 
public static void verifyJabberID ( String jid ) tthrows YaximXMPPAdressMalformedException { if ( jid ! = null ) { tPattern p = Pattern 
public static void verifyJabberID ( Editable jid ) tthrows YaximXMPPAdressMalformedException { verifyJabberID ( jid . toString ( ) ) ; } 
public static int tryToParseInt ( String value , int defVal ) { tint ret ; ttry { tret = Integer . parseInt ( value ) ; } catch ( NumberFormatException ne ) { tret = defVal ; } treturn ret ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tchatItemList = new ArrayList < ChatItem > ( ) ; thandler = new Handler ( ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tregisterXMPPService ( ) ; tcreateUICallback ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetContactFromUri ( ) ; tsetChatItems ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + jabberID ) ; } 
private void sendMessage ( String message ) { tChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; tadapters . get ( jabberID ) . add ( newChatItem ) ; tuserInput . setText ( null ) ; tsend . setEnabled ( false ) ; tserviceAdapter . sendMessage ( jabberID , message ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { tMessage message = ( Message ) arg0 ; tString msg = message . getBody ( ) ; tString jabberID = getJabberID ( message . getFrom ( ) ) . toLowerCase ( ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tqueue . add ( msg ) ; } tcallBack . newMessage ( jabberID , msg ) ; } } } ; tconn . addPacketListener ( myListener , filter ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isAuthenticated ( ) ) ) { 
private void toggleConnection ( MenuItem item ) { if ( serviceAdapter . isAuthenticated ( ) ) { ( new Thread ( ) { public void run ( ) { tserviceAdapter . disconnect ( ) ; tstopService ( xmppServiceIntent ) ; } } ) . start ( ) ; tclearRoster ( ) ; tisConnected = false ; } else { tshowDialog ( DIALOG_CONNECTING ) ; ( new Thread ( ) { public void run ( ) { tstartService ( xmppServiceIntent ) ; } } ) . start ( ) ; tisConnected = true ; } titem . setIcon ( getConnectDisconnectIcon ( ) ) ; titem . setTitle ( getConnectDisconnectText ( ) ) ; } 
public void createRoster ( ) { tLog . i ( TAG , " called createRoster() " ) ; if ( serviceAdapter . isAuthenticated ( ) ) { tclearRoster ( ) ; 
public boolean isAuthenticated ( ) { treturn getConnectionState ( ) = = ConnectionState . AUTHENTICATED ; } 
public int getConnectionState ( ) throws RemoteException { if ( xmppAdapter ! = null & & xmppAdapter . isAuthenticated ( ) ) treturn ConnectionState . AUTHENTICATED ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tserviceAdapter = new XMPPRosterServiceAdapter ( tIXMPPRosterService . Stub . asInterface ( service ) ) ; tserviceAdapter . registerUICallback ( rosterCallback ) ; tcreateRosterIfConnected ( ) ; tsetIsConnected ( ) ; tLog . i ( TAG , " getConnectionState(): " + serviceAdapter . getConnectionState ( ) ) ; if ( serviceAdapter . getConnectionState ( ) = = ConnectionState . CONNECTING ) tshowDialog ( DIALOG_CONNECTING ) ; 
public void onCreate ( ) { tsuper . onCreate ( ) ; trosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; tchatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; tisBoundTo = new HashSet < String > ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tconnectionDemanded = connStartup ; if ( connStartup ) { 
public void onStart ( Intent intent , int startId ) { tsuper . onStart ( intent , startId ) ; tinitiateConnection ( ) ; } 
public void initiateConnection ( ) { if ( xmppAdapter = = null ) { tcreateAdapter ( ) ; tregisterAdapterCallback ( ) ; } tdoConnect ( ) ; } 
private void doConnect ( ) { tconnectionDemanded = true ; if ( connectingThread ! = null ) treturn ; tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; tconnectingThread . start ( ) ; } 
tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; 
public void doDisconnect ( ) { if ( xmppAdapter ! = null ) { txmppAdapter . unRegisterCallback ( ) ; } txmppAdapter = null ; tconnectionDemanded = false ; } 
private void doConnect ( ) { tconnectionDemanded = true ; if ( connectingThread ! = null ) treturn ; tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; tconnectingThread . start ( ) ; } 
tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; 
private void connectionFailed ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; if ( jabReconnect & & jabReconnectCount < = 5 ) { tjabReconnectCount + + ; 
public void onCreate ( ) { tsuper . onCreate ( ) ; trosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; tchatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; tisBoundTo = new HashSet < String > ( ) ; tmainHandler = new Handler ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tconnectionDemanded = connStartup ; if ( connStartup ) { 
public void connectionFailed ( final boolean willReconnect ) throws RemoteException { tmainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { showToastNotification ( R . string . toast_connectfail_message ) ; tisConnected = false ; if ( willReconnect ) tshowDialog ( DIALOG_CONNECTING ) ; 
private void connectionFailed ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( tjabReconnect & & jabReconnectCount < = 5 ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; if ( jabReconnect & & jabReconnectCount < = 5 ) { tjabReconnectCount + + ; 
private void doConnect ( ) { tconnectionDemanded = true ; if ( connectingThread ! = null ) treturn ; tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; tconnectingThread . start ( ) ; } 
tconnectingThread = new Thread ( ) { public void run ( ) { ttry { txmppAdapter . doConnect ( ) ; tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; 
private void connectionFailed ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( tjabReconnect & & jabReconnectCount < = 5 ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; tisConnected = false ; if ( jabReconnect & & jabReconnectCount < = 5 ) { tjabReconnectCount + + ; 
public void rosterChanged ( ) { if ( ! xmppAdapter . isAuthenticated ( ) ) { if ( isConnected ) tconnectionFailed ( ) ; treturn ; } tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; + + i ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
private void doConnect ( ) { tconnectionDemanded = true ; if ( connectingThread ! = null ) treturn ; tconnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( xmppAdapter . doConnect ( ) ) { tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; tconnectingThread . start ( ) ; } 
tconnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( xmppAdapter . doConnect ( ) ) { tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; 
private void connectionEstablished ( ) { tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
public void rosterChanged ( ) { if ( ! xmppAdapter . isAuthenticated ( ) ) { if ( isConnected ) { txmppAdapter . unRegisterCallback ( ) ; tregisterAdapterCallback ( ) ; tconnectionFailed ( ) ; } treturn ; } tfinal int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; + + i ) { ttry { trosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } trosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . renamegroupdialog ) ; tsetTitle ( R . string . RenameGroup_title ) ; tsetupListeners ( ) ; } 
private void setupListeners ( ) { tcancelButton . setOnClickListener ( this ) ; tokButton . setOnClickListener ( this ) ; trenameGroupTextField . setText ( groupTitle ) ; trenameGroupTextField . addTextChangedListener ( this ) ; } 
public void afterTextChanged ( Editable s ) { }} 
public void beforeTextChanged ( CharSequence s , int start , int count , tint after ) { }} 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { tokButton . setEnabled ( s . length ( ) > 0 ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tshowFirstStartUpDialogIfPrefsEmpty ( ) ; tregisterXMPPService ( ) ; tcreateUICallback ( ) ; tsetContentView ( R . layout . main ) ; tregisterForContextMenu ( getExpandableListView ( ) ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isAuthenticated ( ) ) ) { tcreateRoster ( ) ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tserviceAdapter = new XMPPRosterServiceAdapter ( tIXMPPRosterService . Stub . asInterface ( service ) ) ; tserviceAdapter . registerUICallback ( rosterCallback ) ; tcreateRosterIfConnected ( ) ; tsetIsConnected ( ) ; tLog . i ( TAG , " getConnectionState(): " + serviceAdapter . getConnectionState ( ) ) ; if ( serviceAdapter . getConnectionState ( ) = = ConnectionState . CONNECTING ) tshowDialog ( DIALOG_CONNECTING ) ; 
public void connectionFailed ( final boolean willReconnect ) tthrows RemoteException { tmainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . aboutdialog ) ; tsetTitle ( R . string . AboutDialog_title ) ; tButton okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; tokButton . setOnClickListener ( this ) ; } 
public void afterTextChanged ( Editable s ) { }} 
public void beforeTextChanged ( CharSequence s , int start , int count , tint after ) { }} 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { }} 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tconnectionDemanded = connStartup ; if ( connStartup ) { / * 
public void onStart ( Intent intent , int startId ) { tsuper . onStart ( intent , startId ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tinitiateConnection ( ) ; } 
public boolean isAuthenticated ( ) throws RemoteException { if ( xmppAdapter ! = null ) treturn xmppAdapter . isAuthenticated ( ) ; treturn false ; } 
private void splitAndSetJabberID ( String jid ) { tPattern p = Pattern . compile ( " \\ @ " ) ; tString [ ] res = p . split ( jid ) ; tthis . jabUsername = res [ 0 ] ; tthis . jabServer = res [ 1 ] ; } 
private void doConnect ( ) { tconnectionDemanded = true ; if ( connectingThread ! = null ) treturn ; tconnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( xmppAdapter . doConnect ( ) ) { tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } } ; tconnectingThread . start ( ) ; } 
public void run ( ) { ttry { if ( xmppAdapter . doConnect ( ) ) { tconnectionEstablished ( ) ; tjabReconnectCount = 0 ; tisConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tconnectingThread = null ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . aboutdialog ) ; tsetTitle ( R . string . AboutDialog_title ) ; tButton okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; tokButton . setOnClickListener ( this ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tgetPreferences ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tconnectionDemanded = connStartup ; if ( connStartup ) { / * 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage message = ( Message ) packet ; tString msg = message . getBody ( ) ; if ( msg = = null ) { treturn ; } tString jabberID = getJabberID ( message . getFrom ( ) ) . toLowerCase ( ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tqueue . add ( msg ) ; } tcallBack . newMessage ( jabberID , msg ) ; } } } ; tconn . addPacketListener ( myListener , filter ) ; } 
public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage message = ( Message ) packet ; 
private void splitAndSetJabberID ( String jid ) { tPattern p = Pattern . compile ( " \\ @ " ) ; tString [ ] res = p . split ( jid ) ; tthis . userName = res [ 0 ] ; tthis . server = res [ 1 ] ; } 
private void vibraNotififaction ( ) { if ( mConfig . isVibraNotify ) { tvibrator . vibrate ( 500 ) ; 
public boolean doConnect ( ) throws YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { ttryToConnect ( ) ; if ( isAuthenticated ( ) ) { tregisterMessageHandler ( ) ; tregisterRosterHandler ( ) ; tPresence presence = new Presence ( Presence . Type . available ) ; tpresence . setPriority ( mConfig . priority ) ; tmXMPPConnection . sendPacket ( presence ) ; tsetRosterEntries ( ) ; } } treturn ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; } 
public void removeRosterItem ( String user ) throws YaximXMPPException { ttryToRemoveRosterEntry ( user ) ; tmServiceCallBack . rosterChanged ( ) ; } 
public void renameRosterItem ( String user , String newName ) tthrows YaximXMPPException { tmRoster = mXMPPConnection . getRoster ( ) ; tRosterEntry rosterEntry = mRoster . getEntry ( user ) ; if ( ! ( newName . length ( ) > 0 ) | | ( rosterEntry = = null ) ) { tthrow new YaximXMPPException ( " JabberID to rename is invalid! " ) ; } trosterEntry . setName ( newName ) ; } 
public void addRosterGroup ( String group ) { tmRoster = mXMPPConnection . getRoster ( ) ; tmRoster . createGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) { tmRoster = mXMPPConnection . getRoster ( ) ; tRosterGroup groupToRename = mRoster . getGroup ( group ) ; trosterItemsByGroup . remove ( group ) ; tgroupToRename . setName ( newGroup ) ; } 
private void tryToMoveRosterEntryToGroup ( String user , String group ) tthrows YaximXMPPException { if ( ! ( group . length ( ) > 0 ) ) { tthrow new YaximXMPPException ( " Can't move " + user + " to a group without a name! " ) ; } tmRoster = mXMPPConnection . getRoster ( ) ; tRosterGroup rosterGroup = mRoster . getGroup ( group ) ; if ( ! ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) ) { if ( rosterGroup = = null ) trosterGroup = mRoster . createGroup ( group ) ; } tRosterEntry rosterEntry = mRoster . getEntry ( user ) ; tunSetRosterEntry ( rosterEntry ) ; tremoveRosterEntryFromGroups ( rosterEntry ) ; if ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) treturn ; 
private void tryToRemoveRosterEntry ( String user ) throws YaximXMPPException { tmRoster = mXMPPConnection . getRoster ( ) ; ttry { tRosterEntry rosterEntry = mRoster . getEntry ( user ) ; 
private void tryToAddRosterEntry ( String user , String alias , String group ) tthrows YaximXMPPException { tmRoster = mXMPPConnection . getRoster ( ) ; ttry { tmRoster . createEntry ( user , alias , new String [ ] { group } ) ; 
public void sendMessage ( String user , String message ) { tfinal Message newMessage = new Message ( user , Message . Type . chat ) ; tnewMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { tmXMPPConnection . sendPacket ( newMessage ) ; 
public boolean isAuthenticated ( ) { if ( mXMPPConnection ! = null ) { treturn mXMPPConnection . isAuthenticated ( ) ; } treturn false ; } 
public void registerCallback ( XMPPServiceCallback callBack ) { tthis . mServiceCallBack = callBack ; } 
public void unRegisterCallback ( ) { tmXMPPConnection . disconnect ( ) ; trosterItemsByGroup . clear ( ) ; tthis . mServiceCallBack = null ; } 
private void registerRosterHandler ( ) { tmRoster = mXMPPConnection . getRoster ( ) ; tmRoster . addRosterListener ( new RosterListener ( ) { 
public void entriesAdded ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tsetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; tsetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { tString jabberID = getJabberID ( presence . getFrom ( ) ) ; tRosterEntry rosterEntry = mRoster . getEntry ( jabberID ) ; tsetRosterEntry ( rosterEntry ) ; tmServiceCallBack . rosterChanged ( ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage message = ( Message ) packet ; tString msg = message . getBody ( ) ; if ( msg = = null ) { treturn ; } tString jabberID = getJabberID ( message . getFrom ( ) ) . toLowerCase ( ) ; if ( ! mServiceCallBack . isBoundTo ( jabberID ) ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tqueue . add ( msg ) ; } tmServiceCallBack . newMessage ( jabberID , msg ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
public IBinder onBind ( Intent intent ) { tsuper . onBind ( intent ) ; tString caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) treturn mService2ChatConnection ; treturn mService2RosterConnection ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tmConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tmConnectionDemanded = mConfig . connStartup ; if ( mConfig . connStartup ) { / * 
public void onDestroy ( ) { tsuper . onDestroy ( ) ; tmRosterCallbacks . kill ( ) ; tfor ( String key : mChatCallbacks . keySet ( ) ) { tmChatCallbacks . get ( key ) . kill ( ) ; } tdoDisconnect ( ) ; } 
public void initiateConnection ( ) { if ( mSmackable = = null ) { tcreateAdapter ( ) ; tregisterAdapterCallback ( ) ; } tdoConnect ( ) ; } 
private void createServiceChatStub ( ) { tmService2ChatConnection = new IXMPPChatService . Stub ( ) { 
public void registerChatCallback ( IXMPPChatCallback callback , tString jabberID ) throws RemoteException { if ( callback ! = null ) { resetNotificationCounter ( ) ; if ( mChatCallbacks . containsKey ( jabberID ) ) tmChatCallbacks . get ( jabberID ) . register ( callback ) ; telse { tRemoteCallbackList < IXMPPChatCallback > chatCallback = new RemoteCallbackList < IXMPPChatCallback > ( ) ; tchatCallback . register ( callback ) ; tmChatCallbacks . put ( jabberID , chatCallback ) ; } } tmIsBoundTo . add ( jabberID ) ; } 
public void unregisterChatCallback ( IXMPPChatCallback callback , tString jabberID ) throws RemoteException { if ( callback ! = null ) { tmChatCallbacks . get ( jabberID ) . unregister ( callback ) ; } tmIsBoundTo . remove ( jabberID ) ; } 
public void sendMessage ( String user , String message ) tthrows RemoteException { tmSmackable . sendMessage ( user , message ) ; } 
public List < String > pullMessagesForContact ( String jabberID ) tthrows RemoteException { if ( mSmackable ! = null ) treturn mSmackable . pullMessagesForContact ( jabberID ) ; treturn new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) throws RemoteException { if ( mSmackable ! = null ) treturn mSmackable . isAuthenticated ( ) ; treturn false ; } 
private void createServiceRosterStub ( ) { tmService2RosterConnection = new IXMPPRosterService . Stub ( ) { 
public void registerRosterCallback ( IXMPPRosterCallback callback ) tthrows RemoteException { if ( callback ! = null ) tmRosterCallbacks . register ( callback ) ; 
public void unregisterRosterCallback ( IXMPPRosterCallback callback ) tthrows RemoteException { if ( callback ! = null ) tmRosterCallbacks . unregister ( callback ) ; 
public int getConnectionState ( ) throws RemoteException { if ( mSmackable ! = null & & mSmackable . isAuthenticated ( ) ) treturn ConnectionState . AUTHENTICATED ; 
public void setStatus ( String status , String statusMsg ) tthrows RemoteException { if ( status . equals ( " offline " ) ) { tdoDisconnect ( ) ; treturn ; } tmSmackable . setStatus ( StatusMode . valueOf ( status ) , statusMsg ) ; } 
public void addRosterItem ( String user , String alias , String group ) tthrows RemoteException { ttry { tmSmackable . addRosterItem ( user , alias , group ) ; 
public void addRosterGroup ( String group ) throws RemoteException { tmSmackable . addRosterGroup ( group ) ; } 
public void removeRosterItem ( String user ) throws RemoteException { ttry { tmSmackable . removeRosterItem ( user ) ; 
public void moveRosterItemToGroup ( String user , String group ) tthrows RemoteException { ttry { tmSmackable . moveRosterItemToGroup ( user , group ) ; 
public void renameRosterItem ( String user , String newName ) tthrows RemoteException { ttry { tmSmackable . renameRosterItem ( user , newName ) ; 
public List < String > getRosterGroups ( ) throws RemoteException { treturn mSmackable . getRosterGroups ( ) ; } 
public List < RosterItem > getRosterEntriesByGroup ( String group ) tthrows RemoteException { treturn mSmackable . getRosterEntriesByGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) tthrows RemoteException { tmSmackable . renameRosterGroup ( group , newGroup ) ; } 
private void doConnect ( ) { tmConnectionDemanded = true ; if ( mConnectingThread ! = null ) treturn ; tmConnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( mSmackable . doConnect ( ) ) { tconnectionEstablished ( ) ; tmReconnectCount = 0 ; tmIsConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } } ; tmConnectingThread . start ( ) ; } 
public void run ( ) { ttry { if ( mSmackable . doConnect ( ) ) { tconnectionEstablished ( ) ; tmReconnectCount = 0 ; tmIsConnected = true ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } 
private void connectionFailed ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( tmConfig . reconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; tmIsConnected = false ; if ( mConfig . reconnect & & mReconnectCount < = 5 ) { tmReconnectCount + + ; 
private void connectionEstablished ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; } 
public void doDisconnect ( ) { if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tmConnectionDemanded = false ; } 
private void createAdapter ( ) { ttry { tmSmackable = new SmackableImp ( mConfig ) ; 
private void registerAdapterCallback ( ) { tmSmackable . registerCallback ( new XMPPServiceCallback ( ) { 
public void newMessage ( String from , String message ) { if ( ! mIsBoundTo . contains ( from ) ) { tLog . i ( TAG , " notification: " + from ) ; 
public void rosterChanged ( ) { if ( ! mSmackable . isAuthenticated ( ) ) { if ( mIsConnected ) { tmSmackable . unRegisterCallback ( ) ; tregisterAdapterCallback ( ) ; tconnectionFailed ( ) ; } treturn ; } tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; + + i ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; } 
public boolean isBoundTo ( String jabberID ) { treturn mIsBoundTo . contains ( jabberID ) ; } 
private void handleIncomingMessage ( String from , String message ) { tRemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; tfinal int broadCastItems = chatCallbackList . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tchatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( ) { tLog . i ( TAG , " called onCreate() " ) ; tsuper . onCreate ( ) ; tvibrator = ( Vibrator ) getSystemService ( Context . VIBRATOR_SERVICE ) ; addNotificationMGR ( ) ; } 
public void onStart ( Intent intent , int startId ) { tsuper . onStart ( intent , startId ) ; tmConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tinitiateConnection ( ) ; } 
public boolean doConnect ( ) throws YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { ttryToConnect ( ) ; if ( isAuthenticated ( ) ) { tregisterMessageHandler ( ) ; tregisterRosterHandler ( ) ; tPresence presence = new Presence ( Presence . Type . available ) ; tpresence . setPriority ( mConfig . priority ) ; tmXMPPConnection . sendPacket ( presence ) ; tsetRosterEntries ( ) ; } } treturn ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; 
public boolean doConnect ( ) throws YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { ttryToConnect ( ) ; if ( isAuthenticated ( ) ) { tregisterMessageHandler ( ) ; tregisterRosterHandler ( ) ; tPresence presence = new Presence ( Presence . Type . available ) ; tpresence . setPriority ( mConfig . priority ) ; tmXMPPConnection . sendPacket ( presence ) ; tsetRosterEntries ( ) ; } } treturn isAuthenticated ( ) ; } 
public boolean isAuthenticated ( ) { if ( mXMPPConnection ! = null ) { treturn ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; } treturn false ; } 
public void renameRosterGroup ( String group , String newGroup ) { tmRoster = mXMPPConnection . getRoster ( ) ; tRosterGroup groupToRename = mRoster . getGroup ( group ) ; tmRosterItemsByGroup . remove ( group ) ; tgroupToRename . setName ( newGroup ) ; } 
public ArrayList < String > pullMessagesForContact ( String jabberID ) { tArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; tmIncomingMessageQueue . remove ( jabberID ) ; treturn queue ; } 
private void tryToMoveRosterEntryToGroup ( String userName , String groupName ) tthrows YaximXMPPException { if ( ! ( groupName . length ( ) > 0 ) ) { tthrow new YaximXMPPException ( " Can't move " + userName + " to a group without a name! " ) ; } tmRoster = mXMPPConnection . getRoster ( ) ; tRosterGroup rosterGroup = getRosterGroup ( groupName ) ; tRosterEntry rosterEntry = mRoster . getEntry ( userName ) ; return; 
private void removeRosterEntryFromGroups ( RosterEntry rosterEntry ) tthrows YaximXMPPException { tCollection < RosterGroup > oldGroups = rosterEntry . getGroups ( ) ; tfor ( RosterGroup group : oldGroups ) { ttryToRemoveUserFromGroup ( group , rosterEntry ) ; 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { tString jabberID = rosterEntry . getUser ( ) ; tSet < Entry < String , ConcurrentHashMap < String , RosterItem > > > groupMaps = mRosterItemsByGroup . entrySet ( ) ; tfor ( Entry < String , ConcurrentHashMap < String , RosterItem > > entry : groupMaps ) { tConcurrentHashMap < String , RosterItem > entryMap = entry . getValue ( ) ; 
private ConcurrentMap < String , RosterItem > getEntryMapForGroup ( tString groupName ) { tConcurrentHashMap < String , RosterItem > tmpItemList ; if ( mRosterItemsByGroup . containsKey ( groupName ) ) treturn mRosterItemsByGroup . get ( groupName ) ; telse { ttmpItemList = new ConcurrentHashMap < String , RosterItem > ( ) ; tmRosterItemsByGroup . put ( groupName , tmpItemList ) ; } treturn tmpItemList ; } 
public void unRegisterCallback ( ) { tmXMPPConnection . disconnect ( ) ; tmRosterItemsByGroup . clear ( ) ; tthis . mServiceCallBack = null ; } 
private void registerListAdapter ( ) { } 
public void doDisconnect ( ) { tmIsConnected = false ; if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tmConnectionDemanded = false ; } 
private void splitAndSetJabberID ( String jid ) { tString [ ] res = jid . split ( " @ " ) ; tthis . userName = res [ 0 ] ; tthis . server = res [ 1 ] ; } 
public void finalize ( ) { tprefs . unregisterOnSharedPreferenceChangeListener ( this ) ; } 
public void loadPrefs ( SharedPreferences prefs ) { tthis . isLEDNotify = prefs . getBoolean ( PreferenceConstants . LEDNOTIFY , tfalse ) ; tthis . isVibraNotify = prefs . getBoolean ( tPreferenceConstants . VIBRATIONNOTIFY , false ) ; tthis . password = prefs . getString ( PreferenceConstants . PASSWORD , " " ) ; tthis . ressource = prefs . getString ( PreferenceConstants . RESSOURCE , " yaxim " ) ; tthis . port = XMPPHelper . tryToParseInt ( prefs . getString ( tPreferenceConstants . PORT , PreferenceConstants . DEFAULT_PORT ) , tPreferenceConstants . DEFAULT_PORT_INT ) ; tthis . priority = validatePriority ( XMPPHelper . tryToParseInt ( prefs . getString ( " account_prio " , " 0 " ) , 0 ) ) ; tthis . connStartup = prefs . getBoolean ( PreferenceConstants . CONN_STARTUP , tfalse ) ; tthis . reconnect = prefs . getBoolean ( tPreferenceConstants . AUTO_RECONNECT , false ) ; tString jid = prefs . getString ( PreferenceConstants . JID , " " ) ; ttry { tXMPPHelper . verifyJabberID ( jid ) ; 
public void onSharedPreferenceChanged ( SharedPreferences prefs , String key ) { tLog . i ( TAG , " onSharedPreferenceChanged(): " + key ) ; tloadPrefs ( prefs ) ; } 
public void onReceive ( Context context , Intent intent ) { Log.d(TAG, "start service"); 
public boolean onPreferenceChange ( Preference preference , tObject newValue ) { tnewResourceSummary = ( CharSequence ) newValue ; if ( newValue ! = null & & newResourceSummary . length ( ) > 0 ) { tprefResource 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tmConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tmConnectionDemanded . set ( mConfig . connStartup ) ; if ( mConfig . connStartup ) { / * 
private void doConnect ( ) { tmConnectionDemanded . set ( true ) ; if ( mConnectingThread ! = null ) treturn ; tmConnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( mSmackable . doConnect ( ) ) { tconnectionEstablished ( ) ; tmReconnectCount = 0 ; tmIsConnected . set ( true ) ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } } ; tmConnectingThread . start ( ) ; } 
public void run ( ) { ttry { if ( mSmackable . doConnect ( ) ) { tconnectionEstablished ( ) ; tmReconnectCount = 0 ; tmIsConnected . set ( true ) ; } else tconnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tconnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } 
private void connectionFailed ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( tmConfig . reconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; tmIsConnected . set ( false ) ; if ( mConfig . reconnect & & mReconnectCount < = 5 ) { tmReconnectCount + + ; 
public void doDisconnect ( ) { tmIsConnected . set ( false ) ; if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tmConnectionDemanded . set ( false ) ; } 
public void rosterChanged ( ) { if ( ! mSmackable . isAuthenticated ( ) ) { if ( mIsConnected . get ( ) ) { tmSmackable . unRegisterCallback ( ) ; tregisterAdapterCallback ( ) ; tconnectionFailed ( ) ; } treturn ; } tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; + + i ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tregisterXMPPService ( ) ; tcreateUICallback ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetContactFromUri ( ) ; tsetChatItems ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + mJabberID ) ; } 
protected void onPause ( ) { tsuper . onPause ( ) ; tmServiceAdapter . unregisterUICallback ( mChatCallback ) ; tunbindXMPPService ( ) ; } 
protected void onResume ( ) { tsuper . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; tbindXMPPService ( ) ; } 
private void processMessageQueue ( ) { tList < String > queue = mServiceAdapter . pullMessagesForContact ( mJabberID ) ; tfor ( String message : queue ) { tprocessIncomingMessageInHandler ( mJabberID , message ) ; 
private void createUICallback ( ) { tmChatCallback = new IXMPPChatCallback . Stub ( ) { 
private void processIncomingMessageInHandler ( String from , String message ) { tfinal ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + from , message ) ; tmHandler . post ( new Runnable ( ) { public void run ( ) { 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; tmServiceIntent = new Intent ( this , XMPPService . class ) ; tUri chatURI = Uri . parse ( " chatwindow " ) ; tmServiceIntent . setData ( chatURI ) ; tmServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; tmServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tmServiceAdapter = new XMPPChatServiceAdapter ( tIXMPPChatService . Stub . asInterface ( service ) , mJabberID ) ; tmServiceAdapter . registerUICallback ( mChatCallback ) ; tprocessMessageQueue ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { tLog . i ( TAG , " called onServiceDisconnected() " ) ; tmServiceAdapter . unregisterUICallback ( mChatCallback ) ; } 
private void unbindXMPPService ( ) { ttry { tunbindService ( mServiceConnection ) ; 
private void bindXMPPService ( ) { tbindService ( mServiceIntent , mServiceConnection , BIND_AUTO_CREATE ) ; } 
private void sendMessage ( String message ) { tChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; tmAdapterMap . get ( mJabberID ) . add ( newChatItem ) ; tmChatInput . setText ( null ) ; tmSendButton . setEnabled ( false ) ; tmServiceAdapter . sendMessage ( mJabberID , message ) ; } 
private void showToastNotification ( int message ) { tToast oastNotification = Toast . makeText ( this , message , Toast . LENGTH_SHORT ) ; toastNotification . show ( ) ; } 
public IBinder onBind ( Intent intent ) { tsuper . onBind ( intent ) ; tString caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) treturn mServiceChatConnection ; treturn mService2RosterConnection ; } 
private void createServiceChatStub ( ) { tmServiceChatConnection = new IXMPPChatService . Stub ( ) { 
public List < String > pullMessagesForContact ( String jabberID ) tthrows RemoteException { if ( mSmackable ! = null ) { treturn mSmackable . pullMessagesForContact ( jabberID ) ; } treturn new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) throws RemoteException { if ( mSmackable ! = null ) { treturn mSmackable . isAuthenticated ( ) ; } treturn false ; } 
private void handleIncomingMessage ( String from , String message ) { tRemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; tint broadCastItems = chatCallbackList . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tchatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tchatCallbackList . finishBroadcast ( ) ; } 
private void startChatActivity ( String user ) { tIntent chatIntent = new Intent ( this , torg . yaxim . androidclient . chat . ChatWindow . class ) ; tUri userNameUri = Uri . parse ( user ) ; tchatIntent . setData ( userNameUri ) ; tstartActivity ( chatIntent ) ; } 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; txmppServiceIntent = new Intent ( this , XMPPService . class ) ; txmppServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; txmppServiceConnection = new ServiceConnection ( ) { 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; tmServiceIntent = new Intent ( this , XMPPService . class ) ; tUri chatURI = Uri . parse ( " chatwindow " ) ; tmServiceIntent . setData ( chatURI ) ; tmServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; tmServiceConnection = new ServiceConnection ( ) { 
private void sendMessage ( String message ) { tChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; tmAdapterMap . get ( mJabberID ) . add ( newChatItem ) ; tmChatInput . setText ( null ) ; tmSendButton . setEnabled ( false ) ; tmServiceAdapter . sendMessage ( mJabberID , message ) ; } 
public void initiateConnection ( ) { tsetForeground ( true ) ; if ( mSmackable = = null ) { tcreateAdapter ( ) ; tregisterAdapterCallback ( ) ; } tdoConnect ( ) ; } 
public void doDisconnect ( ) { tmIsConnected . set ( false ) ; if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tmConnectionDemanded . set ( false ) ; tsetForeground ( false ) ; } 
public void onCreate ( SQLiteDatabase db ) { tLog . d ( TAG , " created new database " ) ; tdb . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " jabber_id TEXT, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " autoconnect BOOLEAN " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " FOREIGN KEY (account_id) REFERENCES " + ACCOUNTS + " (id) " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { tLog . w ( TAG , " Upgrading database from version " + oldVersion + " to " + newVersion + " . All data will be deleted! " ) ; tdb . execSQL ( " DROP TABLE IF EXISTS " + ACCOUNTS ) ; tdb . execSQL ( " DROP TABLE IF EXISTS " + ROSTER ) ; tdb . execSQL ( " DROP TABLE IF EXISTS " + CHATS ) ; tonCreate ( db ) ; } 
public void onCreate ( SQLiteDatabase db ) { tLog . d ( TAG , " created new database " ) ; tdb . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " user_name TEXT, " + " server TEXT, " + " port INTEGER, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " auto_reconnect BOOLEAN " + " auto_connect BOOLEAN " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " FOREIGN KEY (account_id) REFERENCES " + ACCOUNTS + " (id) " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void save ( SQLiteDatabase db ) { tContentValues values = new ContentValues ( ) ; tvalues . put ( " user_name " , userName ) ; tvalues . put ( " password " , password ) ; tvalues . put ( " server " , server ) ; tvalues . put ( " port " , port ) ; tvalues . put ( " ressource " , ressource ) ; tvalues . put ( " default_priority " , priority ) ; tvalues . put ( " auto_reconnect " , reconnect ) ; tvalues . put ( " auto_connect " , connStartup ) ; tdb . insert ( DataBaseHelper . ACCOUNTS , " user_name " , values ) ; } 
public void save ( SQLiteDatabase db ) { tContentValues values = new ContentValues ( ) ; tvalues . put ( " user_name " , userName ) ; tvalues . put ( " password " , password ) ; tvalues . put ( " server " , server ) ; tvalues . put ( " port " , port ) ; tvalues . put ( " ressource " , ressource ) ; tvalues . put ( " default_priority " , priority ) ; tvalues . put ( " auto_reconnect " , autoReconnect ) ; tvalues . put ( " auto_connect " , autoConnect ) ; tdb . insert ( DataBaseHelper . ACCOUNTS , " user_name " , values ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tmConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; tmConnectionDemanded . set ( mConfig . autoConnect ) ; if ( mConfig . autoConnect ) { / * 
private void connectionFailed ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( tmConfig . autoReconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; tmIsConnected . set ( false ) ; if ( mConfig . autoReconnect & & mReconnectCount < = 5 ) { tmReconnectCount + + ; 
protected void onResume ( ) { tsuper . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; tbindXMPPService ( ) ; tmChatInput . requestFocus ( ) ; 
public void onCreate ( SQLiteDatabase db ) { tLog . d ( TAG , " created new database " ) ; tdb . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " user_name TEXT, " + " server TEXT, " + " port INTEGER, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " auto_reconnect BOOLEAN " + " auto_connect BOOLEAN " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " ); " ) ; tdb . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " time TIMESTAMP, " 
public int delete ( Uri url , String where , String [ ] whereArgs ) { tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tint count ; tlong rowId = 0 ; tswitch ( URI_MATCHER . match ( url ) ) { tcase MESSAGES : tcount = db . delete ( TABLE_NAME , where , whereArgs ) ; tbreak ; tcase MESSAGES_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { twhere = " _id= " + segment ; } else { twhere = " _id= " + segment + " AND ( " + where + " ) " ; } tcount = db . delete ( TABLE_NAME , where , whereArgs ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; } 
public Uri insert ( Uri url , ContentValues initialValues ) { if ( URI_MATCHER . match ( url ) ! = MESSAGES ) { tthrow new IllegalArgumentException ( " Cannot insert into URL: " + url ) ; } tContentValues values = ( initialValues ! = null ) ? new ContentValues ( tinitialValues ) : new ContentValues ( ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tlong rowId = db . insert ( TABLE_NAME , " time " , values ) ; if ( rowId < 0 ) { tthrow new SQLException ( " Failed to insert row into " + url ) ; } treturn null ; } 
public boolean onCreate ( ) { tmOpenHelper = new DatabaseHelper ( getContext ( ) ) ; treturn true ; } 
public Cursor query ( Uri url , String [ ] projectionIn , String selection , tString [ ] selectionArgs , String sort ) { tSQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder ( ) ; tint match = URI_MATCHER . match ( url ) ; tswitch ( match ) { tcase MESSAGES : tqBuilder . setTables ( TABLE_NAME ) ; tbreak ; tcase MESSAGES_ID : tqBuilder . setTables ( TABLE_NAME ) ; tqBuilder . appendWhere ( " _id= " ) ; tqBuilder . appendWhere ( url . getPathSegments ( ) . get ( 1 ) ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Unknown URL " + url ) ; } tSQLiteDatabase db = mOpenHelper . getReadableDatabase ( ) ; tCursor ret = qBuilder . query ( db , projectionIn , selection , selectionArgs , tnull , null , sort ) ; if ( ret = = null ) { if ( LogConstants . LOG_INFO ) tLog . i ( TAG , " ChatProvider.query: failed " ) ; } else { tret . setNotificationUri ( getContext ( ) . getContentResolver ( ) , url ) ; } treturn ret ; } 
public int update ( Uri url , ContentValues values , String where , tString [ ] whereArgs ) { tint count ; tlong rowId = 0 ; tint match = URI_MATCHER . match ( url ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tswitch ( match ) { tcase MESSAGES_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; tcount = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; tbreak ; tdefault : tthrow new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; 
public void onCreate ( SQLiteDatabase db ) { tdb . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + " _id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { tdb . execSQL ( " DROP TABLE IF EXISTS " + TABLE_NAME ) ; tonCreate ( db ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tint count ; tlong rowId = 0 ; tswitch ( URI_MATCHER . match ( url ) ) { tcase MESSAGES : tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tcase MESSAGES_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { twhere = " _id= " + segment ; } else { twhere = " _id= " + segment + " AND ( " + where + " ) " ; } tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; } 
public Uri insert ( Uri url , ContentValues initialValues ) { if ( URI_MATCHER . match ( url ) ! = MESSAGES ) { tthrow new IllegalArgumentException ( " Cannot insert into URL: " + url ) ; } tContentValues values = ( initialValues ! = null ) ? new ContentValues ( tinitialValues ) : new ContentValues ( ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tlong rowId = db . insert ( YaximChats . TABLE_NAME , Chats . TIME , values ) ; if ( rowId < 0 ) { tthrow new SQLException ( " Failed to insert row into " + url ) ; } treturn null ; } 
public int update ( Uri url , ContentValues values , String where , tString [ ] whereArgs ) { tint count ; tlong rowId = 0 ; tint match = URI_MATCHER . match ( url ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tswitch ( match ) { tcase MESSAGES_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; tcount = db . update ( YaximChats . TABLE_NAME , values , " _id= " + rowId , tnull ) ; tbreak ; tdefault : tthrow new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; 
public void onCreate ( SQLiteDatabase db ) { tdb . execSQL ( " CREATE TABLE " + YaximChats . TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { tdb . execSQL ( " DROP TABLE IF EXISTS " + YaximChats . TABLE_NAME ) ; tonCreate ( db ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tint count ; tlong rowId = 0 ; tswitch ( URI_MATCHER . match ( url ) ) { tcase MESSAGES : tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { twhere = " _id= " + segment ; } else { twhere = " _id= " + segment + " AND ( " + where + " ) " ; } tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; } 
public int update ( Uri url , ContentValues values , String where , tString [ ] whereArgs ) { tint count ; tlong rowId = 0 ; tint match = URI_MATCHER . match ( url ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tswitch ( match ) { tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; tcount = db . update ( YaximChats . TABLE_NAME , values , " _id= " + rowId , tnull ) ; tbreak ; tdefault : tthrow new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " creating new chat table " ) ; } tdb . execSQL ( " CREATE TABLE " + YaximChats . TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { tString jabberID = rosterEntry . getUser ( ) ; tSet < Entry < String , ConcurrentHashMap < String , RosterItem > > > groupMaps = mRosterItemsByGroup . entrySet ( ) ; tfor ( Entry < String , ConcurrentHashMap < String , RosterItem > > entry : groupMaps ) { tConcurrentHashMap < String , RosterItem > entryMap = entry . getValue ( ) ; 
public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; 
private void createAdapter ( ) { ttry { tmSmackable = new SmackableImp ( mConfig , getContentResolver ( ) ) ; 
private void handleIncomingMessage ( String from , String message ) { tRemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; tint broadCastItems = chatCallbackList . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tchatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tchatCallbackList . finishBroadcast ( ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tint count ; tswitch ( URI_MATCHER . match ( url ) ) { tcase MESSAGES : tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; if ( TextUtils . isEmpty ( where ) ) { twhere = " _id= " + segment ; } else { twhere = " _id= " + segment + " AND ( " + where + " ) " ; } tcount = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tint count ; tswitch ( URI_MATCHER . match ( url ) ) { tcase MESSAGES : tcount = db . delete ( TABLE_NAME , where , whereArgs ) ; tbreak ; tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; if ( TextUtils . isEmpty ( where ) ) { twhere = " _id= " + segment ; } else { twhere = " _id= " + segment + " AND ( " + where + " ) " ; } tcount = db . delete ( TABLE_NAME , where , whereArgs ) ; tbreak ; tdefault : tthrow new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; } 
public int update ( Uri url , ContentValues values , String where , tString [ ] whereArgs ) { tint count ; tlong rowId = 0 ; tint match = URI_MATCHER . match ( url ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tswitch ( match ) { tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; tcount = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; tbreak ; tdefault : tthrow new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " creating new chat table " ) ; } tdb . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + Chats . DATE 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tregisterXMPPService ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetContactFromUri ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + mJabberID ) ; tsetChatWindowAdapter ( ) ; } 
protected void onResume ( ) { tsuper . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; tbindXMPPService ( ) ; tmChatInput . requestFocus ( ) ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tmServiceAdapter = new XMPPChatServiceAdapter ( tIXMPPChatService . Stub . asInterface ( service ) , mJabberID ) ; 
private void sendMessage ( String message ) { tmChatInput . setText ( null ) ; tmSendButton . setEnabled ( false ) ; tmServiceAdapter . sendMessage ( mJabberID , message ) ; } 
tvoid populateFrom ( int date , String from , String message ) { tgetDateView ( ) . setText ( date ) ; tgetFromView ( ) . setText ( from ) ; tgetMessageView ( ) . setText ( message ) ; } 
private void showToastNotification ( int message ) { tToast oastNotification = Toast . makeText ( this , message , tToast . LENGTH_SHORT ) ; toastNotification . show ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tregisterXMPPService ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetContactFromUri ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + mWithJabberID ) ; tsetChatWindowAdapter ( ) ; } 
public void onServiceConnected ( ComponentName name , IBinder service ) { tLog . i ( TAG , " called onServiceConnected() " ) ; tmServiceAdapter = new XMPPChatServiceAdapter ( tIXMPPChatService . Stub . asInterface ( service ) , 
private void sendMessage ( String message ) { tmChatInput . setText ( null ) ; tmSendButton . setEnabled ( false ) ; tmServiceAdapter . sendMessage ( mWithJabberID , message ) ; } 
tvoid populateFrom ( String date , String from , String message ) { tgetDateView ( ) . setText ( date ) ; tgetFromView ( ) . setText ( from ) ; tgetMessageView ( ) . setText ( message ) ; } 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " creating new chat table " ) ; } tdb . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + Constants . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + Constants . DATE 
public void sendMessage ( String toJID , String message ) { tfinal Message newMessage = new Message ( toJID , Message . Type . chat ) ; tnewMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { tmXMPPConnection . sendPacket ( newMessage ) ; 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( fromJID , toJID , chatMessage , false ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
private void writeToDB ( String fromJID , String toJID , String message , tboolean read ) { tContentValues values = new ContentValues ( ) ; tvalues . put ( Constants . FROM_JID , fromJID ) ; tvalues . put ( Constants . TO_JID , toJID ) ; tvalues . put ( Constants . MESSAGE , message ) ; tvalues . put ( Constants . HAS_BEEN_READ , false ) ; tvalues . put ( Constants . DATE , System . currentTimeMillis ( ) ) ; tmContentResolver . insert ( ChatProvider . CONTENT_URI , values ) ; } 
public int compare ( String group1 , String group2 ) { if ( group1 . equals ( AdapterConstants . EMPTY_GROUP ) ) treturn - 1 ; treturn group1 . toLowerCase ( ) . compareTo ( group2 . toLowerCase ( ) ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( fromJID , toJID , chatMessage , false ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
tboolean doConnect ( ) throws YaximXMPPException ; tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
public void onDestroy ( ) { tsuper . onDestroy ( ) ; tmRosterCallbacks . kill ( ) ; tdoDisconnect ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tLog . i ( TAG , " called onCreate() " ) ; tExceptionHandler . register ( this , " http:duenndns.de/yaxim-crash/ " ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( fromJID , toJID , chatMessage , false ) ; tmServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
tvoid populateFrom ( String date , boolean from_me , String from , String message ) { tLog . i ( TAG , " populateFrom( " + from_me + " , " + from + " , " + message + " ) " ) ; tgetDateView ( ) . setText ( date ) ; if ( ! from_me ) { tgetDateView ( ) . setTextColor ( 0xffff8888 ) ; tgetFromView ( ) . setText ( from ) ; tgetFromView ( ) . setTextColor ( 0xffff8888 ) ; } tgetMessageView ( ) . setText ( message ) ; } 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( false , fromJID , chatMessage , false ) ; tmServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
private void writeToDB ( boolean from_me , String JID , String message , tboolean read ) { tContentValues values = new ContentValues ( ) ; tvalues . put ( Constants . FROM_ME , from_me ) ; tvalues . put ( Constants . JID , JID ) ; tvalues . put ( Constants . MESSAGE , message ) ; tvalues . put ( Constants . HAS_BEEN_READ , false ) ; tvalues . put ( Constants . DATE , System . currentTimeMillis ( ) ) ; tmContentResolver . insert ( ChatProvider . CONTENT_URI , values ) ; } 
private void doConnect ( ) { tmConnectionDemanded . set ( true ) ; if ( mConnectingThread ! = null ) treturn ; tmConnectingThread = new Thread ( ) { public void postFail ( ) { tmMainHandler . post ( new Runnable ( ) { public void run ( ) { tconnectionFailed ( ) ; } } ) ; } public void run ( ) { ttry { if ( ! mSmackable . doConnect ( ) ) tpostFail ( ) ; } catch ( YaximXMPPException e ) { tpostFail ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } } ; tmConnectingThread . start ( ) ; } 
public void postFail ( ) { tmMainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { ttry { if ( ! mSmackable . doConnect ( ) ) tpostFail ( ) ; } catch ( YaximXMPPException e ) { tpostFail ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } 
public void doDisconnect ( ) { tmConnectionDemanded . set ( false ) ; tmIsConnected . set ( false ) ; if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tsetForeground ( false ) ; } 
public void rosterChanged ( ) { } 
public IBinder onBind ( Intent intent ) { tsuper . onBind ( intent ) ; tString caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) { resetNotificationCounter ( ) ; treturn mServiceChatConnection ; } treturn mService2RosterConnection ; } 
tvoid populateFrom ( String date , boolean from_me , String from , String message ) { tLog . i ( TAG , " populateFrom( " + from_me + " , " + from + " , " + message + " ) " ) ; tgetDateView ( ) . setText ( date ) ; if ( from_me ) { tgetDateView ( ) . setTextColor ( 0xff8888ff ) ; tgetFromView ( ) . setText ( getString ( R . string . chat_from_me ) ) ; tgetFromView ( ) . setTextColor ( 0xff8888ff ) ; } else { tgetDateView ( ) . setTextColor ( 0xffff8888 ) ; tgetFromView ( ) . setText ( from + " : " ) ; tgetFromView ( ) . setTextColor ( 0xffff8888 ) ; } tgetMessageView ( ) . setText ( message ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . aboutdialog ) ; tsetTitle ( versionTitle ) ; tButton okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; tokButton . setOnClickListener ( this ) ; } 
public void onCreate ( Bundle icicle ) { tsuper . onCreate ( icicle ) ; tsetContentView ( R . layout . firststartdialog ) ; tsetTitle ( R . string . StartupDialog_Title ) ; tsetCancelable ( false ) ; tsetEditJabberID ( ) ; } 
private void verifyAndSavePreferences ( ) { tString password = mEditPassword . getText ( ) . toString ( ) ; tString jabberID = mEditJabberID . getText ( ) . toString ( ) ; tString port = mEditPort . getText ( ) . toString ( ) ; if ( port = = null ) { tsavePreferences ( jabberID , password ) ; 
public void run ( ) { showToastNotification ( R . string . toast_connectfail_message ) ; tisConnected = false ; if ( progressDialog . isShowing ( ) ) { tdismissDialog ( DIALOG_CONNECTING ) ; 
private void tryToMoveRosterEntryToGroup ( String userName , String groupName ) tthrows YaximXMPPException { if ( ! ( groupName . length ( ) > 0 ) ) { tthrow new YaximXMPPException ( " Can't move " + userName + " to a group without a name! " ) ; } tmRoster = mXMPPConnection . getRoster ( ) ; tRosterGroup rosterGroup = getRosterGroup ( groupName ) ; tRosterEntry rosterEntry = mRoster . getEntry ( userName ) ; tremoveRosterEntryFromGroups ( rosterEntry ) ; if ( groupName . equals ( AdapterConstants . EMPTY_GROUP ) ) treturn ; 
private void registerMessageHandler ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( false , fromJID , chatMessage , false ) ; tmServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; tmXMPPConnection . addPacketListener ( myListener , filter ) ; } 
public void onCreate ( ) { tsuper . onCreate ( ) ; tcreateServiceRosterStub ( ) ; tcreateServiceChatStub ( ) ; tmConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( this ) ) ; if ( mConfig . autoConnect ) { / * 
private void doConnect ( ) { if ( mConnectingThread ! = null ) { treturn ; } tmConnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( ! mSmackable . doConnect ( ) ) tpostConnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tpostConnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } } ; tmConnectingThread . start ( ) ; } 
public void run ( ) { ttry { if ( ! mSmackable . doConnect ( ) ) tpostConnectionFailed ( ) ; } catch ( YaximXMPPException e ) { tpostConnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } tmConnectingThread = null ; } 
public void postConnectionFailed ( ) { tmMainHandler . post ( new Runnable ( ) { public void run ( ) { 
private void connectionFailed ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; tmIsConnected . set ( false ) ; } 
public void doDisconnect ( ) { tmIsConnected . set ( false ) ; if ( mSmackable ! = null ) { tmSmackable . unRegisterCallback ( ) ; } tmSmackable = null ; tsetForeground ( false ) ; } 
public void rosterChanged ( ) { } 
public boolean doConnect ( ) throws YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { ttryToConnect ( ) ; if ( isAuthenticated ( ) ) { tregisterMessageListener ( ) ; tregisterRosterListener ( ) ; tPresence presence = new Presence ( Presence . Type . available ) ; tpresence . setPriority ( mConfig . priority ) ; tmXMPPConnection . sendPacket ( presence ) ; tsetRosterEntries ( ) ; } } treturn isAuthenticated ( ) ; } 
private void registerRosterListener ( ) { tmRoster = mXMPPConnection . getRoster ( ) ; tmRoster . addRosterListener ( new RosterListener ( ) { 
private void registerMessageListener ( ) { tPacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; tPacketListener listener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { tMessage msg = ( Message ) packet ; tString chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { treturn ; } tString fromJID = getJabberID ( msg . getFrom ( ) ) ; tString toJID = getJabberID ( msg . getTo ( ) ) ; twriteToDB ( false , fromJID , chatMessage , false ) ; tmServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; tmXMPPConnection . addPacketListener ( listener , filter ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , tContextMenu . ContextMenuInfo menuInfo ) { tExpandableListView . ExpandableListContextMenuInfo info ; ttry { tinfo = ( ExpandableListView . ExpandableListContextMenuInfo ) menuInfo ; } catch ( ClassCastException e ) { tLog . e ( TAG , " bad menuinfo: " , e ) ; treturn ; } tlong packedPosition = info . packedPosition ; tboolean isChild = isChild ( packedPosition ) ; tMenuInflater inflater = getMenuInflater ( ) ; tinflater . inflate ( R . menu . roster_contextmenu , menu ) ; tint groupPosition = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ; tString groupName = rosterGroupList . get ( groupPosition ) . get ( tAdapterConstants . GROUP_NAME [ 0 ] ) ; tString menuTitle = getString ( R . string . roster_contextmenu_title ) ; if ( isChild ) { tmenu . setGroupVisible ( R . id . roster_contextmenu_contact_menu , true ) ; 
public void requestAuthorizationForRosterItem ( String user ) { ttry { txmppServiceStub . requestAuthorizationForRosterItem ( user ) ; 
tboolean doConnect ( ) throws YaximXMPPException ; tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tboolean isAuthenticated ( ) ; tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid addRosterItem ( String user , String alias , String group ) throws YaximXMPPException ; tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid removeRosterItem ( String user ) throws YaximXMPPException ; tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid renameRosterItem ( String user , String newName ) throws YaximXMPPException ; tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException ; tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid renameRosterGroup ( String group , String newGroup ) ; tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
tvoid requestAuthorizationForRosterItem ( String user ) ; tvoid addRosterGroup ( String group ) ; tvoid setStatus ( StatusMode status , String statusMsg ) ; tvoid sendMessage ( String user , String message ) ; tvoid registerCallback ( XMPPServiceCallback callBack ) ; tvoid unRegisterCallback ( ) ; tArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; tArrayList < String > getRosterGroups ( ) ; } 
public void requestAuthorizationForRosterItem ( String user ) { tPresence response = new Presence ( Presence . Type . subscribe ) ; tresponse . setTo ( user ) ; tmXMPPConnection . sendPacket ( response ) ; } 
public void requestAuthorizationForRosterItem ( String user ) tthrows RemoteException { tmSmackable . requestAuthorizationForRosterItem ( user ) ; } 
private void doConnect ( ) { if ( mConnectingThread ! = null ) { treturn ; } tmConnectingThread = new Thread ( ) { public void run ( ) { ttry { if ( ! mSmackable . doConnect ( ) ) { tpostConnectionFailed ( ) ; } else { tpostConnectionEstablished ( ) ; } } catch ( YaximXMPPException e ) { tpostConnectionFailed ( ) ; tLog . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } finally { tmConnectingThread = null ; } } } ; tmConnectingThread . start ( ) ; } 
public void postConnectionEstablished ( ) { tmMainHandler . post ( new Runnable ( ) { public void run ( ) { 
private void connectionEstablished ( ) { tfinal int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; tfor ( int i = 0 ; i < broadCastItems ; i + + ) { ttry { tmRosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { tLog . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } tmRosterCallbacks . finishBroadcast ( ) ; tmIsConnected . set ( true ) ; } 
public void rosterChanged ( ) { if ( mIsConnected . get ( ) ) { tfinal int broadCastItems = mRosterCallbacks 
public void onRebind ( Intent intent ) { tsuper . onRebind ( intent ) ; tString caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) { resetNotificationCounter ( ) ; 
public void onCreate ( Bundle savedInstanceState ) { tsuper . onCreate ( savedInstanceState ) ; tsetContentView ( R . layout . mainchat ) ; tregisterForContextMenu ( getListView ( ) ) ; tsetContactFromUri ( ) ; tregisterXMPPService ( ) ; setNotificationManager ( ) ; tsetUserInput ( ) ; tsetSendButton ( ) ; tsetTitle ( getText ( R . string . chat_titlePrefix ) + " " + mWithJabberID ) ; tsetChatWindowAdapter ( ) ; } 
private void registerXMPPService ( ) { tLog . i ( TAG , " called startXMPPService() " ) ; tmServiceIntent = new Intent ( this , XMPPService . class ) ; tUri chatURI = Uri . parse ( mWithJabberID ) ; tmServiceIntent . setData ( chatURI ) ; tmServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; tmServiceConnection = new ServiceConnection ( ) { 
public IBinder onBind ( Intent intent ) { tsuper . onBind ( intent ) ; tString chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { resetNotificationCounter ( ) ; tmIsBoundTo . add ( chatPartner ) ; treturn mServiceChatConnection ; } treturn mService2RosterConnection ; } 
public void onRebind ( Intent intent ) { tsuper . onRebind ( intent ) ; tString chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { tmIsBoundTo . add ( chatPartner ) ; 
public boolean onUnbind ( Intent intent ) { tString chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { tmIsBoundTo . remove ( chatPartner ) ; } treturn true ; } 
public void removeRosterItem ( String user ) throws YaximXMPPException { tLog . d ( TAG , " removeRosterItem( " + user + " ) " ) ; ttryToRemoveRosterEntry ( user ) ; tmServiceCallBack . rosterChanged ( ) ; } 
public void unRegisterCallback ( ) { tLog . d ( TAG , " unRegisterCallback() " ) ; tmXMPPConnection . disconnect ( ) ; tmRosterItemsByGroup . clear ( ) ; tthis . mServiceCallBack = null ; } 
public void entriesAdded ( Collection < String > entries ) { tLog . d ( TAG , " entriesAdded( " + entries + " ) " ) ; tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tsetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { tLog . d ( TAG , " entriesDeleted( " + entries + " ) " ) ; tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { tLog . d ( TAG , " entriesUpdated( " + entries + " ) " ) ; tfor ( String entry : entries ) { tRosterEntry rosterEntry = mRoster . getEntry ( entry ) ; tunSetRosterEntry ( rosterEntry ) ; tsetRosterEntry ( rosterEntry ) ; } tmServiceCallBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { tLog . d ( TAG , " presenceChanged( " + presence . getFrom ( ) + " ) " ) ; tString jabberID = getJabberID ( presence . getFrom ( ) ) ; tRosterEntry rosterEntry = mRoster . getEntry ( jabberID ) ; tsetRosterEntry ( rosterEntry ) ; tmServiceCallBack . rosterChanged ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { tgetMenuInflater ( ) . inflate ( R . menu . roster_options , menu ) ; treturn true ; } 
public boolean onPrepareOptionsMenu ( Menu menu ) { tsetMenuItem ( menu , R . id . menu_connect , tgetConnectDisconnectIcon ( ) , tgetConnectDisconnectText ( ) ) ; tsetMenuItem ( menu , R . id . menu_show_hide , tgetShowHideMenuIcon ( ) , tgetShowHideMenuText ( ) ) ; treturn true ; } 
private void toggleConnection ( MenuItem item ) { if ( serviceAdapter . isAuthenticated ( ) ) { ( new Thread ( ) { 
public int update ( Uri url , ContentValues values , String where , tString [ ] whereArgs ) { tint count ; tlong rowId = 0 ; tint match = URI_MATCHER . match ( url ) ; tSQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; tswitch ( match ) { tcase MESSAGES : tcount = db . update ( TABLE_NAME , values , where , null ) ; tbreak ; tcase MESSAGE_ID : tString segment = url . getPathSegments ( ) . get ( 1 ) ; trowId = Long . parseLong ( segment ) ; tcount = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; tbreak ; tdefault : tthrow new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { tLog . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } tgetContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; treturn count ; 
