protected void onPause ( ) { super . onPause ( ) ; Log . i ( TAG , " called onPause() " ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Log . i ( TAG , " called onCreate() " ) ; } 
protected void onDestroy ( ) { super . onDestroy ( ) ; Log . i ( TAG , " called onDestroy() " ) ; } 
protected void onResume ( ) { super . onResume ( ) ; Log . i ( TAG , " called onResume() " ) ; } 
protected void showToastNotification ( int message ) { Toast mptoast = Toast . makeText ( his , message , Toast . LENGTH_SHORT ) ; tmptoast . show ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mainHandler = new Handler ( ) ; rosterEntryList = new ArrayList < ArrayList < HashMap < String , RosterItem > > > ( ) ; rosterGroupList = new ArrayList < HashMap < String , String > > ( ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; showFirstStartUpDialogIfPrefsEmpty ( ) ; registerXMPPService ( ) ; createUICallback ( ) ; setContentView ( R . layout . main ) ; registerForContextMenu ( getExpandableListView ( ) ) ; } 
protected void onPause ( ) { super . onPause ( ) ; if ( serviceAdapter ! = null ) serviceAdapter . unregisterUICallback ( rosterCallback ) ; unbindXMPPService ( ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isServiceAuthenticated ( ) ) ) { 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { ExpandableListView . ExpandableListContextMenuInfo info ; try { info = ( ExpandableListView . ExpandableListContextMenuInfo ) menuInfo ; } catch ( ClassCastException e ) { Log . e ( TAG , " bad menuinfo: " , e ) ; return ; } long packedPosition = info . packedPosition ; boolean isChild = isChild ( packedPosition ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . roster_contextmenu , menu ) ; int groupPosition = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ; String groupName = rosterGroupList . get ( groupPosition ) . get ( AdapterConstants . GROUP_NAME [ 0 ] ) ; if ( isChild ) { menu . setGroupVisible ( R . id . roster_contacts_group , rue ) ; 
public boolean onContextItemSelected ( MenuItem item ) { return applyMenuContextChoice ( item ) ; } 
private boolean isChild ( long packedPosition ) { int ype = ExpandableListView . getPackedPositionType ( packedPosition ) ; return ( ype = = ExpandableListView . PACKED_POSITION_TYPE_CHILD ) ; } 
private void startChatActivity ( String user ) { Intent chatIntent = new Intent ( his , de . hdmstuttgart . yaxim . chat . ChatWindow . class ) ; Uri userNameUri = Uri . parse ( user ) ; chatIntent . setData ( userNameUri ) ; startActivity ( chatIntent ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { populateMainMenu ( menu ) ; return super . onCreateOptionsMenu ( menu ) ; } 
public boolean onOptionsItemSelected ( MenuItem item ) { return applyMainMenuChoice ( item ) ; } 
private void populateMainMenu ( Menu menu ) { menu . add ( Menu . NONE , CONNECT , Menu . NONE , ( getConnectDisconnectText ( ) ) ) . setIcon ( getConnectDisconnectIcon ( ) ) ; menu . add ( Menu . NONE , ADD_FRIEND , Menu . NONE , ( getString ( R . string . Menu_addFriend ) ) ) . setIcon ( android . R . drawable . ic_menu_add ) ; menu . add ( Menu . NONE , SHOW_HIDE , Menu . NONE , getShowHideMenuText ( ) ) . setIcon ( getShowHideMenuIcon ( ) ) ; menu . add ( Menu . NONE , STATUS , Menu . NONE , ( getString ( R . string . Menu_Status ) ) ) . setIcon ( android . R . drawable . ic_menu_myplaces ) ; menu . add ( Menu . NONE , EXIT , Menu . NONE , ( getString ( R . string . Global_Exit ) ) ) . setIcon ( android . R . drawable . ic_menu_close_clear_cancel ) ; menu . add ( Menu . NONE , SETTINGS , Menu . NONE , ( getString ( R . string . Menu_Settings ) ) ) . setIcon ( android . R . drawable . ic_menu_preferences ) ; menu . add ( Menu . NONE , ACC_SET , Menu . NONE , ( getString ( R . string . Menu_AccSettings ) ) ) . setIcon ( 
public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) { Log . i ( TAG , " Called onChildClick() " ) ; String user = rosterEntryList . get ( groupPosition ) . get ( childPosition ) . get ( AdapterConstants . CONTACT_ID ) . jabberID ; startChatActivity ( user ) ; return rue ; } 
private void oggleConnection ( MenuItem item ) { if ( serviceAdapter . isServiceAuthenticated ( ) ) { ( new Thread ( ) { public void run ( ) { serviceAdapter . disconnect ( ) ; stopService ( xmppServiceIntent ) ; } } ) . start ( ) ; clearRoster ( ) ; isConnected = false ; } else { showDialog ( DIALOG_CONNECTING ) ; ( new Thread ( ) { public void run ( ) { startService ( xmppServiceIntent ) ; } } ) . start ( ) ; isConnected = rue ; } item . setIcon ( getConnectDisconnectIcon ( ) ) ; item . setTitle ( getConnectDisconnectText ( ) ) ; } 
public void run ( ) { serviceAdapter . disconnect ( ) ; stopService ( xmppServiceIntent ) ; } 
private void clearRoster ( ) { rosterEntryList . clear ( ) ; rosterGroupList . clear ( ) ; if ( rosterListAdapter ! = null ) rosterListAdapter . notifyDataSetChanged ( ) ; 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; xmppServiceIntent = new Intent ( his , XMPPService . class ) ; xmppServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; xmppServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; serviceAdapter = new XMPPRosterServiceAdapter ( IXMPPRosterService . Stub . asInterface ( service ) ) ; serviceAdapter . registerUICallback ( rosterCallback ) ; createRosterIfConnected ( ) ; setIsConnected ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { Log . i ( TAG , " called onServiceDisconnected() " ) ; } 
private void unbindXMPPService ( ) { try { unbindService ( xmppServiceConnection ) ; 
private void bindXMPPService ( ) { bindService ( xmppServiceIntent , xmppServiceConnection , BIND_AUTO_CREATE ) ; } 
private void registerListAdapter ( ) { createRosterEntryList ( ) ; createRosterGroupList ( ) ; rosterListAdapter = new ExpandableRosterAdapter ( his , rosterGroupList , R . layout . maingroup_row , AdapterConstants . GROUP_NAME , new int [ ] { R . id . groupname } , rosterEntryList , R . layout . mainchild_row , AdapterConstants . CHILD_DATA_KEYS , new int [ ] { R . id . roster_screenname , R . id . roster_statusmsg } ) ; setListAdapter ( rosterListAdapter ) ; } 
private void createRosterEntryList ( ) { List < String > rosterGroups = serviceAdapter . getRosterGroups ( ) ; for ( String rosterGroup : rosterGroups ) { ArrayList < HashMap < String , RosterItem > > rosterGroupItems = getRosterGroupItems ( rosterGroup ) ; 
public void createRoster ( ) { Log . i ( TAG , " called createRoster() " ) ; if ( serviceAdapter . isServiceAuthenticated ( ) ) { clearRoster ( ) ; 
private void createUICallback ( ) { rosterCallback = new IXMPPRosterCallback . Stub ( ) { 
public void rosterChanged ( ) hrows RemoteException { Log . i ( TAG , " called rosterChanged() " ) ; mainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void connectionSuccessful ( ) hrows RemoteException { mainHandler . post ( new Runnable ( ) { 
public void run ( ) { createRosterIfConnected ( ) ; isConnected = rue ; if ( progressDialog . isShowing ( ) ) dismissDialog ( DIALOG_CONNECTING ) ; 
public void connectionFailed ( ) hrows RemoteException { mainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { showToastNotification ( R . string . oast_connectfail_message ) ; isConnected = false ; if ( progressDialog . isShowing ( ) ) dismissDialog ( DIALOG_CONNECTING ) ; 
protected Dialog onCreateDialog ( int id ) { switch ( id ) { case DIALOG_CONNECTING : 
private void showFirstStartUpDialogIfPrefsEmpty ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( his ) ; String configuredJabberID = prefs . getString ( PreferenceConstants . JID , " " ) ; Log . i ( TAG , " called showFirstStartUpDialogIfPrefsEmpty, string from pref was: " + configuredJabberID ) ; if ( configuredJabberID . length ( ) < 3 ) { showFirstStartUpDialog ( ) ; 
private void showFirstStartUpDialog ( ) { new FirstStartDialog ( his , serviceAdapter ) . show ( ) ; } 
public boolean isServiceAuthenticated ( ) { try { return xmppServiceStub . isAuthenticated ( ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } return false ; } 
public void addRosterItem ( String user , String alias , String group ) { try { xmppServiceStub . addRosterItem ( user , alias , group ) ; 
public void renameRosterGroup ( String group , String newGroup ) { try { xmppServiceStub . renameRosterGroup ( group , newGroup ) ; 
public void renameRosterItem ( String contact , String newItemName ) { try { xmppServiceStub . renameRosterItem ( contact , newItemName ) ; 
public void moveRosterItemToGroup ( String user , String group ) { try { xmppServiceStub . moveRosterItemToGroup ( user , group ) ; 
public void addRosterGroup ( String group ) { try { xmppServiceStub . addRosterGroup ( group ) ; 
public void removeRosterItem ( String user ) { try { xmppServiceStub . removeRosterItem ( user ) ; 
public void registerUICallback ( IXMPPRosterCallback uiCallback ) { try { xmppServiceStub . registerRosterCallback ( uiCallback ) ; 
public void unregisterUICallback ( IXMPPRosterCallback uiCallback ) { try { xmppServiceStub . unregisterRosterCallback ( uiCallback ) ; 
public boolean isAuthenticated ( ) { try { return xmppServiceStub . isAuthenticated ( ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } return false ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; chatItemList = new ArrayList < ChatItem > ( ) ; handler = new Handler ( ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; registerXMPPService ( ) ; createUICallback ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setChatItems ( ) ; setContactFromUri ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + jabberID ) ; } 
protected void onPause ( ) { super . onPause ( ) ; serviceAdapter . unregisterUICallback ( chatCallback ) ; unbindXMPPService ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; notificationMGR . cancel ( NOTIFY_ID ) ; bindXMPPService ( ) ; } 
private void processMessageQueue ( ) { List < String > queue = serviceAdapter . pullMessagesForContact ( jabberID ) ; for ( String message : queue ) { processIncomingMessageInHandler ( jabberID , message ) ; 
private void createUICallback ( ) { chatCallback = new IXMPPChatCallback . Stub ( ) { 
public void newMessage ( String from , String message ) throws RemoteException { processIncomingMessageInHandler ( from , message ) ; } 
private void processIncomingMessageInHandler ( String from , String message ) { final ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + from , message ) ; handler . post ( new Runnable ( ) { public void run ( ) { 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; xmppServiceIntent = new Intent ( his , XMPPService . class ) ; Uri chatURI = Uri . parse ( " chatwindow " ) ; xmppServiceIntent . setData ( chatURI ) ; xmppServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; xmppServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; serviceAdapter = new XMPPChatServiceAdapter ( IXMPPChatService . Stub . asInterface ( service ) , jabberID ) ; serviceAdapter . registerUICallback ( chatCallback ) ; processMessageQueue ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { Log . i ( TAG , " called onServiceDisconnected() " ) ; serviceAdapter . unregisterUICallback ( chatCallback ) ; } 
private void sendMessage ( String message ) { ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; adapter . add ( newChatItem ) ; userInput . setText ( null ) ; send . setEnabled ( false ) ; serviceAdapter . sendMessage ( jabberID , message ) ; } 
public boolean onKey ( View v , int keyCode , KeyEvent event ) { if ( event . getAction ( ) = = KeyEvent . ACTION_DOWN & & keyCode = = KeyEvent . KEYCODE_ENTER ) { sendMessageIfNotNull ( ) ; return rue ; } return false ; 
private void showToastNotification ( int message ) { Toast mptoast = Toast . makeText ( his , message , Toast . LENGTH_SHORT ) ; tmptoast . show ( ) ; } 
public void registerUICallback ( IXMPPChatCallback uiCallback ) { try { xmppServiceStub . registerChatCallback ( uiCallback , jabberID ) ; 
public void unregisterUICallback ( IXMPPChatCallback uiCallback ) { try { xmppServiceStub . unregisterChatCallback ( uiCallback , jabberID ) ; 
public void sendMessage ( String user , String message ) { try { Log . i ( TAG , " Called sendMessage(): " + jabberID + " : " + message ) ; 
public List < String > pullMessagesForContact ( String jabberID ) { List < String > queue = null ; try { queue = xmppServiceStub . pullMessagesForContact ( jabberID ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } return queue ; } 
public RosterItem createFromParcel ( Parcel in ) { return new RosterItem ( in ) ; } 
public void writeToParcel ( Parcel out , int flags ) { out . writeString ( jabberID ) ; out . writeString ( screenName ) ; out . writeString ( statusMode ) ; out . writeString ( statusMessage ) ; out . writeString ( group ) ; } 
private int compareStatusModes ( StatusMode otherMode ) { int compVal = ( otherMode . getPriority ( ) - his . getStatusMode ( ) . getPriority ( ) ) ; if ( compVal < 0 ) { return - 1 ; } if ( compVal > 0 ) { return 1 ; } return 0 ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . addrosteritemdialog ) ; setTitle ( R . string . addFriend_Title ) ; setUserInputField ( ) ; setAliasInputField ( ) ; setGroupSpinner ( ) ; setNewGroupInputField ( ) ; createAndSetGroupSpinnerAdapter ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
private void createAndSetGroupSpinnerAdapter ( ) { groupList = serviceAdapter . getRosterGroups ( ) ; if ( ! groupList . contains ( AdapterConstants . EMPTY_GROUP ) ) { groupList = new ArrayList < String > ( ) ; groupList . add ( AdapterConstants . EMPTY_GROUP ) ; groupList . addAll ( serviceAdapter . getRosterGroups ( ) ) ; } groupList . add ( mainWindow . getString ( R . string . addrosteritemaddgroupchoice ) ) ; ArrayAdapter < String > groupSpinnerAdapter = new ArrayAdapter < String > ( mainWindow , android . R . layout . simple_spinner_item , groupList ) ; groupSpinnerAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; groupSpinner . setAdapter ( groupSpinnerAdapter ) ; groupSpinner . setOnItemSelectedListener ( his ) ; } 
public void afterTextChanged ( Editable s ) { try { XMPPHelper . verifyJabberID ( s ) ; 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . statusdialog ) ; setStatusRadioGroup ( ) ; setStatusTextField ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
public void onCheckedChanged ( RadioGroup radioGroup , int selectedID ) { if ( radioGroup = = statusRadioGroup ) { switch ( selectedID ) { 
public void afterTextChanged ( Editable arg0 ) { } public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void beforeTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void onTextChanged ( CharSequence arg0 , int arg1 , int arg2 , int arg3 ) { } } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . firststartdialog ) ; setTitle ( R . string . StartupDialog_Title ) ; setEditPort ( ) ; setEditPassword ( ) ; setEditJabberID ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
private void verifyAndSavePreferences ( ) { String password = editPassword . getText ( ) . oString ( ) ; String jabberID = editJabberID . getText ( ) . oString ( ) ; String port = editPort . getText ( ) . oString ( ) ; if ( port = = null ) { savePreferences ( jabberID , password ) ; 
public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private void savePreferences ( String jabberID , String password , String port ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; Editor editor = sharedPreferences . edit ( ) ; editor . putString ( PreferenceConstants . JID , jabberID ) ; editor . putString ( PreferenceConstants . PASSWORD , password ) ; editor . putString ( PreferenceConstants . PORT , port ) ; editor . commit ( ) ; } private void savePreferences ( String jabberID , String password ) { savePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } } 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { } private void savePreferences ( String jabberID , String password , String port ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; Editor editor = sharedPreferences . edit ( ) ; editor . putString ( PreferenceConstants . JID , jabberID ) ; editor . putString ( PreferenceConstants . PASSWORD , password ) ; editor . putString ( PreferenceConstants . PORT , port ) ; editor . commit ( ) ; } private void savePreferences ( String jabberID , String password ) { savePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } } 
private void savePreferences ( String jabberID , String password , String port ) { SharedPreferences sharedPreferences = PreferenceManager . getDefaultSharedPreferences ( mainWindow ) ; Editor editor = sharedPreferences . edit ( ) ; editor . putString ( PreferenceConstants . JID , jabberID ) ; editor . putString ( PreferenceConstants . PASSWORD , password ) ; editor . putString ( PreferenceConstants . PORT , port ) ; editor . commit ( ) ; } 
private void savePreferences ( String jabberID , String password ) { savePreferences ( jabberID , password , PreferenceConstants . DEFAULT_PORT ) ; } 
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . setFlags ( WindowManager . LayoutParams . FLAG_BLUR_BEHIND , WindowManager . LayoutParams . FLAG_BLUR_BEHIND ) ; setCancelable ( rue ) ; } 
private void ryToSetMainWindow ( Context context ) { try { this . mainWindow = ( MainWindow ) context ; 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . moverosterentrytogroupdialog ) ; setTitle ( R . string . MoveRosterEntryToGroupDialog_title ) ; setGroupSpinner ( ) ; createAndSetGroupSpinnerAdapter ( ) ; setNewGroupInputField ( ) ; setCancelButton ( ) ; setOkButton ( ) ; } 
private void createAndSetGroupSpinnerAdapter ( ) { groupList = serviceAdapter . getRosterGroups ( ) ; if ( ! groupList . contains ( AdapterConstants . EMPTY_GROUP ) ) { groupList = new ArrayList < String > ( ) ; groupList . add ( AdapterConstants . EMPTY_GROUP ) ; groupList . addAll ( serviceAdapter . getRosterGroups ( ) ) ; } ArrayAdapter < String > groupSpinnerAdapter = new ArrayAdapter < String > ( mainWindow , android . R . layout . simple_spinner_item , groupList ) ; groupSpinnerAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; groupSpinner . setAdapter ( groupSpinnerAdapter ) ; groupSpinnerAdapter . add ( mainWindow . getString ( R . string . addrosteritemaddgroupchoice ) ) ; groupSpinner . setOnItemSelectedListener ( his ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . removerosteritemdialog ) ; setTitle ( R . string . deleteRosterItem_title ) ; setTextField ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . renamegroupdialog ) ; setTitle ( R . string . RenameGroup_title ) ; setRenameGroupTextField ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . renameentrydialog ) ; setTitle ( R . string . RenameEntry_title ) ; setRenameGroupTextField ( ) ; setOkButton ( ) ; setCancelButton ( ) ; } 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { Log . e ( " accountprefs " , " jabberid pref changed " ) ; newSummary = ( CharSequence ) newValue ; if ( newValue ! = null ) { prefAccountID 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { try { XMPPHelper . verifyJabberID ( s . oString ( ) ) ; 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { newResourceSummary = ( CharSequence ) newValue ; if ( newValue ! = null ) { prefResource 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { try { int prioIntValue = Integer . parseInt ( newValue 
public void afterTextChanged ( Editable s ) { try { prioIntValue = Integer . parseInt ( s . oString ( ) ) ; 
 public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . layout . mainprefs ) ; } 
public IBinder onBind ( Intent arg0 ) { Log . i ( TAG , " called onBind() " ) ; return null ; } 
public boolean onUnbind ( Intent intent ) { Log . i ( TAG , " called onUnbind() " ) ; return super . onUnbind ( intent ) ; } 
public void onRebind ( Intent intent ) { Log . i ( TAG , " called onRebind() " ) ; super . onRebind ( intent ) ; } 
public void onCreate ( ) { Log . i ( TAG , " called onCreate() " ) ; super . onCreate ( ) ; vibrator = ( Vibrator ) getSystemService ( Context . VIBRATOR_SERVICE ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; addNotificationMGR ( ) ; } 
public void onDestroy ( ) { Log . i ( TAG , " called onDestroy() " ) ; super . onDestroy ( ) ; } 
public void onStart ( Intent intent , int startId ) { Log . i ( TAG , " called onStart() " ) ; super . onStart ( intent , startId ) ; } 
private void addNotificationMGR ( ) { notificationMGR = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; notificationIntent = new Intent ( his , ChatWindow . class ) ; } 
protected void notifyClient ( String from , String message ) { notificationCounter + + ; String itle = " Message from " + from ; notification = new Notification ( R . drawable . icon , APP_NAME + " : " + itle , System . currentTimeMillis ( ) ) ; Uri userNameUri = Uri . parse ( from ) ; notificationIntent . setData ( userNameUri ) ; PendingIntent pendingIntent = PendingIntent . getActivity ( his , 0 , notificationIntent , 0 ) ; notification . setLatestEventInfo ( his , itle , message , pendingIntent ) ; notification . number = notificationCounter ; notification . flags = Notification . FLAG_AUTO_CANCEL | Notification . FLAG_ONLY_ALERT_ONCE ; vibraNotififaction ( ) ; if ( isLEDNotify ) { notification . flags | = Notification . DEFAULT_LIGHTS ; notification . ledARGB = Color . MAGENTA ; notification . ledOnMS = 300 ; notification . ledOffMS = 1000 ; notification . flags | = Notification . FLAG_SHOW_LIGHTS ; } notificationMGR . notify ( NOTIFY_ID , notification ) ; } 
private void vibraNotififaction ( ) { if ( isVibraNotify ) { vibrator . vibrate ( 500 ) ; 
protected void shortToastNotify ( String msg ) { Toast oast = Toast . makeText ( his , msg , Toast . LENGTH_SHORT ) ; toast . show ( ) ; } 
boolean doConnect ( ) hrows YaximXMPPException ; boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
ArrayList < String > getRosterGroups ( ) ; ArrayList < String > pullMessagesForContact ( String jabberID ) ; } 
private int validatePriority ( int jabPriority ) { if ( jabPriority > 127 ) return 127 ; else if ( jabPriority < - 127 ) return - 127 ; return jabPriority ; } 
public boolean doConnect ( ) hrows YaximXMPPException { if ( ! conn . isConnected ( ) ) { tryToConnect ( ) ; if ( isAuthenticated ( ) ) { registerMessageHandler ( ) ; registerRosterHandler ( ) ; Presence presence = new Presence ( Presence . Type . available ) ; presence . setPriority ( jabPriority ) ; conn . sendPacket ( presence ) ; setRosterEntries ( ) ; } } return ( conn . isConnected ( ) & & conn . isAuthenticated ( ) ) ; } 
public void addRosterItem ( String user , String alias , String group ) throws YaximXMPPException { tryToAddRosterEntry ( user , alias , group ) ; } 
public void removeRosterItem ( String user ) hrows YaximXMPPException { tryToRemoveRosterEntry ( user ) ; callBack . rosterChanged ( ) ; } 
public void renameRosterItem ( String user , String newName ) throws YaximXMPPException { roster = conn . getRoster ( ) ; RosterEntry rosterEntry = roster . getEntry ( user ) ; if ( ! ( newName . length ( ) > 0 ) | | ( rosterEntry = = null ) ) { throw new YaximXMPPException ( " JabberID to rename is invalid! " ) ; } rosterEntry . setName ( newName ) ; } 
public void addRosterGroup ( String group ) { roster = conn . getRoster ( ) ; roster . createGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) { roster = conn . getRoster ( ) ; RosterGroup groupToRename = roster . getGroup ( group ) ; rosterItemsByGroup . remove ( group ) ; groupToRename . setName ( newGroup ) ; } 
public void moveRosterItemToGroup ( String user , String group ) throws YaximXMPPException { tryToMoveRosterEntryToGroup ( user , group ) ; } 
public ArrayList < String > pullMessagesForContact ( String jabberID ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; incomingMessageQueue . remove ( jabberID ) ; return queue ; } 
private void ryToConnect ( ) hrows YaximXMPPException { try { SmackConfiguration . setPacketReplyTimeout ( PACKET_TIMEOUT ) ; 
private void ryToMoveRosterEntryToGroup ( String user , String group ) throws YaximXMPPException { if ( ! ( group . length ( ) > 0 ) ) { throw new YaximXMPPException ( " Can't move " + user + " to a group without a name! " ) ; } roster = conn . getRoster ( ) ; RosterGroup rosterGroup = roster . getGroup ( group ) ; if ( ! ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) ) { if ( rosterGroup = = null ) rosterGroup = roster . createGroup ( group ) ; } RosterEntry rosterEntry = roster . getEntry ( user ) ; unSetRosterEntry ( rosterEntry ) ; removeRosterEntryFromGroups ( rosterEntry ) ; if ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) return ; 
private void removeRosterEntryFromGroups ( RosterEntry rosterEntry ) throws YaximXMPPException { Collection < RosterGroup > oldGroups = rosterEntry . getGroups ( ) ; for ( RosterGroup group : oldGroups ) { tryToRemoveUserFromGroup ( group , rosterEntry ) ; 
private void ryToRemoveUserFromGroup ( RosterGroup group , RosterEntry rosterEntry ) hrows YaximXMPPException { try { group . removeEntry ( rosterEntry ) ; 
private void ryToRemoveRosterEntry ( String user ) hrows YaximXMPPException { roster = conn . getRoster ( ) ; try { RosterEntry rosterEntry = roster . getEntry ( user ) ; 
private void ryToAddRosterEntry ( String user , String alias , String group ) throws YaximXMPPException { roster = conn . getRoster ( ) ; try { roster . createEntry ( user , alias , new String [ ] { group } ) ; 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { String groupName = getGroup ( rosterEntry . getGroups ( ) ) ; ConcurrentMap < String , RosterItem > entryMap = getEntryMapForGroup ( groupName ) ; String jabberID = rosterEntry . getUser ( ) ; if ( entryMap . containsKey ( jabberID ) ) entryMap . remove ( jabberID ) ; if ( entryMap . size ( ) < 1 ) rosterItemsByGroup . remove ( groupName ) ; 
private ConcurrentMap < String , RosterItem > getEntryMapForGroup ( String groupName ) { ConcurrentHashMap < String , RosterItem > mpItemList ; if ( rosterItemsByGroup . containsKey ( groupName ) ) return rosterItemsByGroup . get ( groupName ) ; else { tmpItemList = new ConcurrentHashMap < String , RosterItem > ( ) ; rosterItemsByGroup . put ( groupName , mpItemList ) ; } return mpItemList ; } 
public int compare ( String object1 , String object2 ) { if ( object1 . equals ( AdapterConstants . EMPTY_GROUP ) ) return - 1 ; return object1 . oLowerCase ( ) . compareTo ( object2 . oLowerCase ( ) ) ; } 
private Mode stringToMode ( String modeStr ) { return Mode . valueOf ( modeStr ) ; } 
public void sendMessage ( String user , String message ) { final Message newMessage = new Message ( user , Message . Type . chat ) ; newMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { conn . sendPacket ( newMessage ) ; 
public boolean isAuthenticated ( ) { if ( conn ! = null ) { return conn . isAuthenticated ( ) ; } return false ; } 
public void registerCallback ( XMPPServiceCallback callBack ) { this . callBack = callBack ; } 
public void unRegisterCallback ( ) { conn . disconnect ( ) ; rosterItemsByGroup . clear ( ) ; this . callBack = null ; } 
private void createConnection ( ) { config = new ConnectionConfiguration ( jabServer , jabPort ) ; config . setReconnectionAllowed ( rue ) ; conn = new XMPPConnection ( config ) ; } 
private void registerRosterHandler ( ) { roster = conn . getRoster ( ) ; roster . addRosterListener ( new RosterListener ( ) { 
public void entriesAdded ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = roster . getEntry ( entry ) ; setRosterEntry ( rosterEntry ) ; } callBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = roster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; } callBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = roster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; setRosterEntry ( rosterEntry ) ; } callBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { String jabberID = getJabberID ( presence . getFrom ( ) ) ; RosterEntry rosterEntry = roster . getEntry ( jabberID ) ; setRosterEntry ( rosterEntry ) ; callBack . rosterChanged ( ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { Message message = ( Message ) arg0 ; String msg = message . getBody ( ) ; String jabberID = getJabberID ( message . getFrom ( ) ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; queue . add ( msg ) ; } callBack . newMessage ( jabberID , msg ) ; } } } ; conn . addPacketListener ( myListener , filter ) ; } 
public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { Message message = ( Message ) arg0 ; 
public IBinder onBind ( Intent intent ) { super . onBind ( intent ) ; String caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) return service2ChatConnection ; return service2RosterConnection ; } 
public boolean onUnbind ( Intent intent ) { return super . onUnbind ( intent ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; rosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; chatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; isBoundTo = new HashSet < String > ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; } 
public void onDestroy ( ) { super . onDestroy ( ) ; rosterCallbacks . kill ( ) ; for ( String key : chatCallbacks . keySet ( ) ) { chatCallbacks . get ( key ) . kill ( ) ; } doDisconnect ( ) ; } 
public void onStart ( Intent intent , int startId ) { super . onStart ( intent , startId ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; createAdapter ( ) ; registerAdapterCallback ( ) ; doConnect ( ) ; } 
private void createServiceChatStub ( ) { service2ChatConnection = new IXMPPChatService . Stub ( ) { 
public void registerChatCallback ( IXMPPChatCallback callback , String jabberID ) hrows RemoteException { if ( callback ! = null ) { resetNotificationCounter ( ) ; if ( chatCallbacks . containsKey ( jabberID ) ) chatCallbacks . get ( jabberID ) . register ( callback ) ; else { RemoteCallbackList < IXMPPChatCallback > chatCallback = new RemoteCallbackList < IXMPPChatCallback > ( ) ; chatCallback . register ( callback ) ; chatCallbacks . put ( jabberID , chatCallback ) ; } } isBoundTo . add ( jabberID ) ; } 
public void unregisterChatCallback ( IXMPPChatCallback callback , String jabberID ) hrows RemoteException { if ( callback ! = null ) { chatCallbacks . get ( jabberID ) . unregister ( callback ) ; } isBoundTo . remove ( jabberID ) ; } 
public void sendMessage ( String user , String message ) throws RemoteException { xmppAdapter . sendMessage ( user , message ) ; } 
public List < String > pullMessagesForContact ( String jabberID ) throws RemoteException { if ( xmppAdapter ! = null ) return xmppAdapter . pullMessagesForContact ( jabberID ) ; return new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) hrows RemoteException { if ( xmppAdapter ! = null ) return xmppAdapter . isAuthenticated ( ) ; return false ; } 
private void createServiceRosterStub ( ) { service2RosterConnection = new IXMPPRosterService . Stub ( ) { 
public void registerRosterCallback ( IXMPPRosterCallback callback ) throws RemoteException { if ( callback ! = null ) rosterCallbacks . register ( callback ) ; 
public void unregisterRosterCallback ( IXMPPRosterCallback callback ) throws RemoteException { if ( callback ! = null ) rosterCallbacks . unregister ( callback ) ; 
public void setStatus ( String status , String statusMsg ) throws RemoteException { if ( status . equals ( " offline " ) ) { doDisconnect ( ) ; return ; } xmppAdapter . setStatus ( StatusMode . valueOf ( status ) , statusMsg ) ; } 
public void addRosterItem ( String user , String alias , String group ) throws RemoteException { try { xmppAdapter . addRosterItem ( user , alias , group ) ; 
public void addRosterGroup ( String group ) hrows RemoteException { xmppAdapter . addRosterGroup ( group ) ; } 
public void removeRosterItem ( String user ) hrows RemoteException { try { xmppAdapter . removeRosterItem ( user ) ; 
public void moveRosterItemToGroup ( String user , String group ) throws RemoteException { try { xmppAdapter . moveRosterItemToGroup ( user , group ) ; 
public void renameRosterItem ( String user , String newName ) throws RemoteException { try { xmppAdapter . renameRosterItem ( user , newName ) ; 
public List < String > getRosterGroups ( ) hrows RemoteException { return xmppAdapter . getRosterGroups ( ) ; } 
public List < RosterItem > getRosterEntriesByGroup ( String group ) throws RemoteException { return xmppAdapter . getRosterEntriesByGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) throws RemoteException { xmppAdapter . renameRosterGroup ( group , newGroup ) ; } 
public void disconnect ( ) hrows RemoteException { doDisconnect ( ) ; } 
private void splitJabberID ( String jid ) { Pattern p = Pattern . compile ( " \\ @ " ) ; String [ ] res = p . split ( jid ) ; this . jabUsername = res [ 0 ] ; this . jabServer = res [ 1 ] ; } 
private void connectionFailed ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { rosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
private void connectionEstablished ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { if ( xmppAdapter . isAuthenticated ( ) ) rosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; else connectionFailed ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
public void doDisconnect ( ) { if ( xmppAdapter ! = null ) { xmppAdapter . unRegisterCallback ( ) ; } xmppAdapter = null ; } 
private void createAdapter ( ) { try { xmppAdapter = new SmackableImp ( jabServer , jabUsername , jabPassword , 
private void registerAdapterCallback ( ) { xmppAdapter . registerCallback ( new XMPPServiceCallback ( ) { 
public void newMessage ( String from , String message ) { if ( ! isBoundTo . contains ( from ) ) { Log . i ( TAG , " notification: " + from ) ; 
public void rosterChanged ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; + + i ) { try { rosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
public boolean isBoundTo ( String jabberID ) { return isBoundTo . contains ( jabberID ) ; } 
private void handleIncomingMessage ( String from , String message ) { RemoteCallbackList < IXMPPChatCallback > chatCallbackList = chatCallbacks . get ( from ) ; final int broadCastItems = chatCallbackList . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { chatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
void newMessage ( String from , String messageBody ) ; void rosterChanged ( ) ; boolean isBoundTo ( String jabberID ) ; } 
public View getChildView ( int groupPosition , int childPosition , boolean isLastChild , View convertView , ViewGroup parent ) { View currentRow ; if ( convertView = = null ) currentRow = newChildView ( isLastChild , parent ) ; else currentRow = convertView ; RosterItem contactListItem = getRosterItem ( groupPosition , childPosition ) ; setLabel ( currentRow , contactListItem ) ; String statusMessage = contactListItem . statusMessage ; setStatusMessage ( currentRow , statusMessage ) ; StatusMode presenceMode = contactListItem . getStatusMode ( ) ; setIcon ( currentRow , presenceMode ) ; return currentRow ; } 
public View getGroupView ( int groupPosition , boolean isExpanded , View convertView , ViewGroup parent ) { return super . getGroupView ( groupPosition , isExpanded , convertView , parent ) ; 
public static void verifyJabberID ( String jid ) throws YaximXMPPAdressMalformedException { if ( jid ! = null ) { Pattern p = Pattern 
public static void verifyJabberID ( Editable jid ) throws YaximXMPPAdressMalformedException { verifyJabberID ( jid . oString ( ) ) ; } 
public static int ryToParseInt ( String value , int defVal ) { int ret ; try { ret = Integer . parseInt ( value ) ; } catch ( NumberFormatException ne ) { ret = defVal ; } return ret ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; chatItemList = new ArrayList < ChatItem > ( ) ; handler = new Handler ( ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; registerXMPPService ( ) ; createUICallback ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setContactFromUri ( ) ; setChatItems ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + jabberID ) ; } 
private void sendMessage ( String message ) { ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; adapters . get ( jabberID ) . add ( newChatItem ) ; userInput . setText ( null ) ; send . setEnabled ( false ) ; serviceAdapter . sendMessage ( jabberID , message ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet arg0 ) { if ( arg0 instanceof Message ) { Message message = ( Message ) arg0 ; String msg = message . getBody ( ) ; String jabberID = getJabberID ( message . getFrom ( ) ) . oLowerCase ( ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; queue . add ( msg ) ; } callBack . newMessage ( jabberID , msg ) ; } } } ; conn . addPacketListener ( myListener , filter ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isAuthenticated ( ) ) ) { 
private void oggleConnection ( MenuItem item ) { if ( serviceAdapter . isAuthenticated ( ) ) { ( new Thread ( ) { public void run ( ) { serviceAdapter . disconnect ( ) ; stopService ( xmppServiceIntent ) ; } } ) . start ( ) ; clearRoster ( ) ; isConnected = false ; } else { showDialog ( DIALOG_CONNECTING ) ; ( new Thread ( ) { public void run ( ) { startService ( xmppServiceIntent ) ; } } ) . start ( ) ; isConnected = rue ; } item . setIcon ( getConnectDisconnectIcon ( ) ) ; item . setTitle ( getConnectDisconnectText ( ) ) ; } 
public void createRoster ( ) { Log . i ( TAG , " called createRoster() " ) ; if ( serviceAdapter . isAuthenticated ( ) ) { clearRoster ( ) ; 
public boolean isAuthenticated ( ) { return getConnectionState ( ) = = ConnectionState . AUTHENTICATED ; } 
public int getConnectionState ( ) hrows RemoteException { if ( xmppAdapter ! = null & & xmppAdapter . isAuthenticated ( ) ) return ConnectionState . AUTHENTICATED ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; serviceAdapter = new XMPPRosterServiceAdapter ( IXMPPRosterService . Stub . asInterface ( service ) ) ; serviceAdapter . registerUICallback ( rosterCallback ) ; createRosterIfConnected ( ) ; setIsConnected ( ) ; Log . i ( TAG , " getConnectionState(): " + serviceAdapter . getConnectionState ( ) ) ; if ( serviceAdapter . getConnectionState ( ) = = ConnectionState . CONNECTING ) showDialog ( DIALOG_CONNECTING ) ; 
public void onCreate ( ) { super . onCreate ( ) ; rosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; chatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; isBoundTo = new HashSet < String > ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; connectionDemanded = connStartup ; if ( connStartup ) { 
public void onStart ( Intent intent , int startId ) { super . onStart ( intent , startId ) ; initiateConnection ( ) ; } 
public void initiateConnection ( ) { if ( xmppAdapter = = null ) { createAdapter ( ) ; registerAdapterCallback ( ) ; } doConnect ( ) ; } 
private void doConnect ( ) { connectionDemanded = rue ; if ( connectingThread ! = null ) return ; connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; connectingThread . start ( ) ; } 
connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; 
public void doDisconnect ( ) { if ( xmppAdapter ! = null ) { xmppAdapter . unRegisterCallback ( ) ; } xmppAdapter = null ; connectionDemanded = false ; } 
private void doConnect ( ) { connectionDemanded = rue ; if ( connectingThread ! = null ) return ; connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; jabReconnectCount = 0 ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; connectingThread . start ( ) ; } 
connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; jabReconnectCount = 0 ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; 
private void connectionFailed ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { rosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; if ( jabReconnect & & jabReconnectCount < = 5 ) { jabReconnectCount + + ; 
public void onCreate ( ) { super . onCreate ( ) ; rosterCallbacks = new RemoteCallbackList < IXMPPRosterCallback > ( ) ; chatCallbacks = new HashMap < String , RemoteCallbackList < IXMPPChatCallback > > ( ) ; isBoundTo = new HashSet < String > ( ) ; mainHandler = new Handler ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; connectionDemanded = connStartup ; if ( connStartup ) { 
public void connectionFailed ( final boolean willReconnect ) hrows RemoteException { mainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { showToastNotification ( R . string . oast_connectfail_message ) ; isConnected = false ; if ( willReconnect ) showDialog ( DIALOG_CONNECTING ) ; 
private void connectionFailed ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { rosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( jabReconnect & & jabReconnectCount < = 5 ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; if ( jabReconnect & & jabReconnectCount < = 5 ) { jabReconnectCount + + ; 
private void doConnect ( ) { connectionDemanded = rue ; if ( connectingThread ! = null ) return ; connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; connectingThread . start ( ) ; } 
connectingThread = new Thread ( ) { public void run ( ) { try { xmppAdapter . doConnect ( ) ; connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; 
private void connectionFailed ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { rosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( jabReconnect & & jabReconnectCount < = 5 ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; isConnected = false ; if ( jabReconnect & & jabReconnectCount < = 5 ) { jabReconnectCount + + ; 
public void rosterChanged ( ) { if ( ! xmppAdapter . isAuthenticated ( ) ) { if ( isConnected ) connectionFailed ( ) ; return ; } final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; + + i ) { try { rosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
private void doConnect ( ) { connectionDemanded = rue ; if ( connectingThread ! = null ) return ; connectingThread = new Thread ( ) { public void run ( ) { try { if ( xmppAdapter . doConnect ( ) ) { connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; connectingThread . start ( ) ; } 
connectingThread = new Thread ( ) { public void run ( ) { try { if ( xmppAdapter . doConnect ( ) ) { connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; 
private void connectionEstablished ( ) { final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { rosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
public void rosterChanged ( ) { if ( ! xmppAdapter . isAuthenticated ( ) ) { if ( isConnected ) { xmppAdapter . unRegisterCallback ( ) ; registerAdapterCallback ( ) ; connectionFailed ( ) ; } return ; } final int broadCastItems = rosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; + + i ) { try { rosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } rosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . renamegroupdialog ) ; setTitle ( R . string . RenameGroup_title ) ; setupListeners ( ) ; } 
private void setupListeners ( ) { cancelButton . setOnClickListener ( his ) ; okButton . setOnClickListener ( his ) ; renameGroupTextField . setText ( groupTitle ) ; renameGroupTextField . addTextChangedListener ( his ) ; } 
public void afterTextChanged ( Editable s ) { }} 
public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { }} 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { okButton . setEnabled ( s . length ( ) > 0 ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; showFirstStartUpDialogIfPrefsEmpty ( ) ; registerXMPPService ( ) ; createUICallback ( ) ; setContentView ( R . layout . main ) ; registerForContextMenu ( getExpandableListView ( ) ) ; } 
private void createRosterIfConnected ( ) { if ( ( serviceAdapter ! = null ) & & ( serviceAdapter . isAuthenticated ( ) ) ) { createRoster ( ) ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; serviceAdapter = new XMPPRosterServiceAdapter ( IXMPPRosterService . Stub . asInterface ( service ) ) ; serviceAdapter . registerUICallback ( rosterCallback ) ; createRosterIfConnected ( ) ; setIsConnected ( ) ; Log . i ( TAG , " getConnectionState(): " + serviceAdapter . getConnectionState ( ) ) ; if ( serviceAdapter . getConnectionState ( ) = = ConnectionState . CONNECTING ) showDialog ( DIALOG_CONNECTING ) ; 
public void connectionFailed ( final boolean willReconnect ) throws RemoteException { mainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . aboutdialog ) ; setTitle ( R . string . AboutDialog_title ) ; Button okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; okButton . setOnClickListener ( his ) ; } 
public void afterTextChanged ( Editable s ) { }} 
public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { }} 
public void onTextChanged ( CharSequence s , int start , int before , int count ) { }} 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; connectionDemanded = connStartup ; if ( connStartup ) { / * 
public void onStart ( Intent intent , int startId ) { super . onStart ( intent , startId ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; initiateConnection ( ) ; } 
public boolean isAuthenticated ( ) hrows RemoteException { if ( xmppAdapter ! = null ) return xmppAdapter . isAuthenticated ( ) ; return false ; } 
private void splitAndSetJabberID ( String jid ) { Pattern p = Pattern . compile ( " \\ @ " ) ; String [ ] res = p . split ( jid ) ; this . jabUsername = res [ 0 ] ; this . jabServer = res [ 1 ] ; } 
private void doConnect ( ) { connectionDemanded = rue ; if ( connectingThread ! = null ) return ; connectingThread = new Thread ( ) { public void run ( ) { try { if ( xmppAdapter . doConnect ( ) ) { connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } } ; connectingThread . start ( ) ; } 
public void run ( ) { try { if ( xmppAdapter . doConnect ( ) ) { connectionEstablished ( ) ; jabReconnectCount = 0 ; isConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } connectingThread = null ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . aboutdialog ) ; setTitle ( R . string . AboutDialog_title ) ; Button okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; okButton . setOnClickListener ( his ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; getPreferences ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; connectionDemanded = connStartup ; if ( connStartup ) { / * 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; String msg = message . getBody ( ) ; if ( msg = = null ) { return ; } String jabberID = getJabberID ( message . getFrom ( ) ) . oLowerCase ( ) ; if ( ! callBack . isBoundTo ( jabberID ) ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; queue . add ( msg ) ; } callBack . newMessage ( jabberID , msg ) ; } } } ; conn . addPacketListener ( myListener , filter ) ; } 
public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; 
private void splitAndSetJabberID ( String jid ) { Pattern p = Pattern . compile ( " \\ @ " ) ; String [ ] res = p . split ( jid ) ; this . userName = res [ 0 ] ; this . server = res [ 1 ] ; } 
private void vibraNotififaction ( ) { if ( mConfig . isVibraNotify ) { vibrator . vibrate ( 500 ) ; 
public boolean doConnect ( ) hrows YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { tryToConnect ( ) ; if ( isAuthenticated ( ) ) { registerMessageHandler ( ) ; registerRosterHandler ( ) ; Presence presence = new Presence ( Presence . Type . available ) ; presence . setPriority ( mConfig . priority ) ; mXMPPConnection . sendPacket ( presence ) ; setRosterEntries ( ) ; } } return ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; } 
public void removeRosterItem ( String user ) hrows YaximXMPPException { tryToRemoveRosterEntry ( user ) ; mServiceCallBack . rosterChanged ( ) ; } 
public void renameRosterItem ( String user , String newName ) throws YaximXMPPException { mRoster = mXMPPConnection . getRoster ( ) ; RosterEntry rosterEntry = mRoster . getEntry ( user ) ; if ( ! ( newName . length ( ) > 0 ) | | ( rosterEntry = = null ) ) { throw new YaximXMPPException ( " JabberID to rename is invalid! " ) ; } rosterEntry . setName ( newName ) ; } 
public void addRosterGroup ( String group ) { mRoster = mXMPPConnection . getRoster ( ) ; mRoster . createGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) { mRoster = mXMPPConnection . getRoster ( ) ; RosterGroup groupToRename = mRoster . getGroup ( group ) ; rosterItemsByGroup . remove ( group ) ; groupToRename . setName ( newGroup ) ; } 
private void ryToMoveRosterEntryToGroup ( String user , String group ) throws YaximXMPPException { if ( ! ( group . length ( ) > 0 ) ) { throw new YaximXMPPException ( " Can't move " + user + " to a group without a name! " ) ; } mRoster = mXMPPConnection . getRoster ( ) ; RosterGroup rosterGroup = mRoster . getGroup ( group ) ; if ( ! ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) ) { if ( rosterGroup = = null ) rosterGroup = mRoster . createGroup ( group ) ; } RosterEntry rosterEntry = mRoster . getEntry ( user ) ; unSetRosterEntry ( rosterEntry ) ; removeRosterEntryFromGroups ( rosterEntry ) ; if ( group . equals ( AdapterConstants . EMPTY_GROUP ) ) return ; 
private void ryToRemoveRosterEntry ( String user ) hrows YaximXMPPException { mRoster = mXMPPConnection . getRoster ( ) ; try { RosterEntry rosterEntry = mRoster . getEntry ( user ) ; 
private void ryToAddRosterEntry ( String user , String alias , String group ) throws YaximXMPPException { mRoster = mXMPPConnection . getRoster ( ) ; try { mRoster . createEntry ( user , alias , new String [ ] { group } ) ; 
public void sendMessage ( String user , String message ) { final Message newMessage = new Message ( user , Message . Type . chat ) ; newMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { mXMPPConnection . sendPacket ( newMessage ) ; 
public boolean isAuthenticated ( ) { if ( mXMPPConnection ! = null ) { return mXMPPConnection . isAuthenticated ( ) ; } return false ; } 
public void registerCallback ( XMPPServiceCallback callBack ) { this . mServiceCallBack = callBack ; } 
public void unRegisterCallback ( ) { mXMPPConnection . disconnect ( ) ; rosterItemsByGroup . clear ( ) ; this . mServiceCallBack = null ; } 
private void registerRosterHandler ( ) { mRoster = mXMPPConnection . getRoster ( ) ; mRoster . addRosterListener ( new RosterListener ( ) { 
public void entriesAdded ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; setRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; setRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { String jabberID = getJabberID ( presence . getFrom ( ) ) ; RosterEntry rosterEntry = mRoster . getEntry ( jabberID ) ; setRosterEntry ( rosterEntry ) ; mServiceCallBack . rosterChanged ( ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message message = ( Message ) packet ; String msg = message . getBody ( ) ; if ( msg = = null ) { return ; } String jabberID = getJabberID ( message . getFrom ( ) ) . oLowerCase ( ) ; if ( ! mServiceCallBack . isBoundTo ( jabberID ) ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; queue . add ( msg ) ; } mServiceCallBack . newMessage ( jabberID , msg ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
public IBinder onBind ( Intent intent ) { super . onBind ( intent ) ; String caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) return mService2ChatConnection ; return mService2RosterConnection ; } 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; mConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; mConnectionDemanded = mConfig . connStartup ; if ( mConfig . connStartup ) { / * 
public void onDestroy ( ) { super . onDestroy ( ) ; mRosterCallbacks . kill ( ) ; for ( String key : mChatCallbacks . keySet ( ) ) { mChatCallbacks . get ( key ) . kill ( ) ; } doDisconnect ( ) ; } 
public void initiateConnection ( ) { if ( mSmackable = = null ) { createAdapter ( ) ; registerAdapterCallback ( ) ; } doConnect ( ) ; } 
private void createServiceChatStub ( ) { mService2ChatConnection = new IXMPPChatService . Stub ( ) { 
public void registerChatCallback ( IXMPPChatCallback callback , String jabberID ) hrows RemoteException { if ( callback ! = null ) { resetNotificationCounter ( ) ; if ( mChatCallbacks . containsKey ( jabberID ) ) mChatCallbacks . get ( jabberID ) . register ( callback ) ; else { RemoteCallbackList < IXMPPChatCallback > chatCallback = new RemoteCallbackList < IXMPPChatCallback > ( ) ; chatCallback . register ( callback ) ; mChatCallbacks . put ( jabberID , chatCallback ) ; } } mIsBoundTo . add ( jabberID ) ; } 
public void unregisterChatCallback ( IXMPPChatCallback callback , String jabberID ) hrows RemoteException { if ( callback ! = null ) { mChatCallbacks . get ( jabberID ) . unregister ( callback ) ; } mIsBoundTo . remove ( jabberID ) ; } 
public void sendMessage ( String user , String message ) throws RemoteException { mSmackable . sendMessage ( user , message ) ; } 
public List < String > pullMessagesForContact ( String jabberID ) throws RemoteException { if ( mSmackable ! = null ) return mSmackable . pullMessagesForContact ( jabberID ) ; return new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) hrows RemoteException { if ( mSmackable ! = null ) return mSmackable . isAuthenticated ( ) ; return false ; } 
private void createServiceRosterStub ( ) { mService2RosterConnection = new IXMPPRosterService . Stub ( ) { 
public void registerRosterCallback ( IXMPPRosterCallback callback ) throws RemoteException { if ( callback ! = null ) mRosterCallbacks . register ( callback ) ; 
public void unregisterRosterCallback ( IXMPPRosterCallback callback ) throws RemoteException { if ( callback ! = null ) mRosterCallbacks . unregister ( callback ) ; 
public int getConnectionState ( ) hrows RemoteException { if ( mSmackable ! = null & & mSmackable . isAuthenticated ( ) ) return ConnectionState . AUTHENTICATED ; 
public void setStatus ( String status , String statusMsg ) throws RemoteException { if ( status . equals ( " offline " ) ) { doDisconnect ( ) ; return ; } mSmackable . setStatus ( StatusMode . valueOf ( status ) , statusMsg ) ; } 
public void addRosterItem ( String user , String alias , String group ) throws RemoteException { try { mSmackable . addRosterItem ( user , alias , group ) ; 
public void addRosterGroup ( String group ) hrows RemoteException { mSmackable . addRosterGroup ( group ) ; } 
public void removeRosterItem ( String user ) hrows RemoteException { try { mSmackable . removeRosterItem ( user ) ; 
public void moveRosterItemToGroup ( String user , String group ) throws RemoteException { try { mSmackable . moveRosterItemToGroup ( user , group ) ; 
public void renameRosterItem ( String user , String newName ) throws RemoteException { try { mSmackable . renameRosterItem ( user , newName ) ; 
public List < String > getRosterGroups ( ) hrows RemoteException { return mSmackable . getRosterGroups ( ) ; } 
public List < RosterItem > getRosterEntriesByGroup ( String group ) throws RemoteException { return mSmackable . getRosterEntriesByGroup ( group ) ; } 
public void renameRosterGroup ( String group , String newGroup ) throws RemoteException { mSmackable . renameRosterGroup ( group , newGroup ) ; } 
private void doConnect ( ) { mConnectionDemanded = rue ; if ( mConnectingThread ! = null ) return ; mConnectingThread = new Thread ( ) { public void run ( ) { try { if ( mSmackable . doConnect ( ) ) { connectionEstablished ( ) ; mReconnectCount = 0 ; mIsConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } } ; mConnectingThread . start ( ) ; } 
public void run ( ) { try { if ( mSmackable . doConnect ( ) ) { connectionEstablished ( ) ; mReconnectCount = 0 ; mIsConnected = rue ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } 
private void connectionFailed ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( mConfig . reconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; mIsConnected = false ; if ( mConfig . reconnect & & mReconnectCount < = 5 ) { mReconnectCount + + ; 
private void connectionEstablished ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; } 
public void doDisconnect ( ) { if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; mConnectionDemanded = false ; } 
private void createAdapter ( ) { try { mSmackable = new SmackableImp ( mConfig ) ; 
private void registerAdapterCallback ( ) { mSmackable . registerCallback ( new XMPPServiceCallback ( ) { 
public void newMessage ( String from , String message ) { if ( ! mIsBoundTo . contains ( from ) ) { Log . i ( TAG , " notification: " + from ) ; 
public void rosterChanged ( ) { if ( ! mSmackable . isAuthenticated ( ) ) { if ( mIsConnected ) { mSmackable . unRegisterCallback ( ) ; registerAdapterCallback ( ) ; connectionFailed ( ) ; } return ; } final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; + + i ) { try { mRosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; } 
public boolean isBoundTo ( String jabberID ) { return mIsBoundTo . contains ( jabberID ) ; } 
private void handleIncomingMessage ( String from , String message ) { RemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; final int broadCastItems = chatCallbackList . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { chatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( ) { Log . i ( TAG , " called onCreate() " ) ; super . onCreate ( ) ; vibrator = ( Vibrator ) getSystemService ( Context . VIBRATOR_SERVICE ) ; addNotificationMGR ( ) ; } 
public void onStart ( Intent intent , int startId ) { super . onStart ( intent , startId ) ; mConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; initiateConnection ( ) ; } 
public boolean doConnect ( ) hrows YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { tryToConnect ( ) ; if ( isAuthenticated ( ) ) { registerMessageHandler ( ) ; registerRosterHandler ( ) ; Presence presence = new Presence ( Presence . Type . available ) ; presence . setPriority ( mConfig . priority ) ; mXMPPConnection . sendPacket ( presence ) ; setRosterEntries ( ) ; } } return ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; 
public boolean doConnect ( ) hrows YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { tryToConnect ( ) ; if ( isAuthenticated ( ) ) { registerMessageHandler ( ) ; registerRosterHandler ( ) ; Presence presence = new Presence ( Presence . Type . available ) ; presence . setPriority ( mConfig . priority ) ; mXMPPConnection . sendPacket ( presence ) ; setRosterEntries ( ) ; } } return isAuthenticated ( ) ; } 
public boolean isAuthenticated ( ) { if ( mXMPPConnection ! = null ) { return ( mXMPPConnection . isConnected ( ) & & mXMPPConnection . isAuthenticated ( ) ) ; } return false ; } 
public void renameRosterGroup ( String group , String newGroup ) { mRoster = mXMPPConnection . getRoster ( ) ; RosterGroup groupToRename = mRoster . getGroup ( group ) ; mRosterItemsByGroup . remove ( group ) ; groupToRename . setName ( newGroup ) ; } 
public ArrayList < String > pullMessagesForContact ( String jabberID ) { ArrayList < String > queue = getMessageQueueForContact ( jabberID ) ; mIncomingMessageQueue . remove ( jabberID ) ; return queue ; } 
private void ryToMoveRosterEntryToGroup ( String userName , String groupName ) throws YaximXMPPException { if ( ! ( groupName . length ( ) > 0 ) ) { throw new YaximXMPPException ( " Can't move " + userName + " to a group without a name! " ) ; } mRoster = mXMPPConnection . getRoster ( ) ; RosterGroup rosterGroup = getRosterGroup ( groupName ) ; RosterEntry rosterEntry = mRoster . getEntry ( userName ) ; return; 
private void removeRosterEntryFromGroups ( RosterEntry rosterEntry ) throws YaximXMPPException { Collection < RosterGroup > oldGroups = rosterEntry . getGroups ( ) ; for ( RosterGroup group : oldGroups ) { tryToRemoveUserFromGroup ( group , rosterEntry ) ; 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { String jabberID = rosterEntry . getUser ( ) ; Set < Entry < String , ConcurrentHashMap < String , RosterItem > > > groupMaps = mRosterItemsByGroup . entrySet ( ) ; for ( Entry < String , ConcurrentHashMap < String , RosterItem > > entry : groupMaps ) { ConcurrentHashMap < String , RosterItem > entryMap = entry . getValue ( ) ; 
private ConcurrentMap < String , RosterItem > getEntryMapForGroup ( String groupName ) { ConcurrentHashMap < String , RosterItem > mpItemList ; if ( mRosterItemsByGroup . containsKey ( groupName ) ) return mRosterItemsByGroup . get ( groupName ) ; else { tmpItemList = new ConcurrentHashMap < String , RosterItem > ( ) ; mRosterItemsByGroup . put ( groupName , mpItemList ) ; } return mpItemList ; } 
public void unRegisterCallback ( ) { mXMPPConnection . disconnect ( ) ; mRosterItemsByGroup . clear ( ) ; this . mServiceCallBack = null ; } 
private void registerListAdapter ( ) { } 
public void doDisconnect ( ) { mIsConnected = false ; if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; mConnectionDemanded = false ; } 
private void splitAndSetJabberID ( String jid ) { String [ ] res = jid . split ( " @ " ) ; this . userName = res [ 0 ] ; this . server = res [ 1 ] ; } 
public void finalize ( ) { prefs . unregisterOnSharedPreferenceChangeListener ( his ) ; } 
public void loadPrefs ( SharedPreferences prefs ) { this . isLEDNotify = prefs . getBoolean ( PreferenceConstants . LEDNOTIFY , false ) ; this . isVibraNotify = prefs . getBoolean ( PreferenceConstants . VIBRATIONNOTIFY , false ) ; this . password = prefs . getString ( PreferenceConstants . PASSWORD , " " ) ; this . ressource = prefs . getString ( PreferenceConstants . RESSOURCE , " yaxim " ) ; this . port = XMPPHelper . ryToParseInt ( prefs . getString ( PreferenceConstants . PORT , PreferenceConstants . DEFAULT_PORT ) , PreferenceConstants . DEFAULT_PORT_INT ) ; this . priority = validatePriority ( XMPPHelper . ryToParseInt ( prefs . getString ( " account_prio " , " 0 " ) , 0 ) ) ; this . connStartup = prefs . getBoolean ( PreferenceConstants . CONN_STARTUP , false ) ; this . reconnect = prefs . getBoolean ( PreferenceConstants . AUTO_RECONNECT , false ) ; String jid = prefs . getString ( PreferenceConstants . JID , " " ) ; try { XMPPHelper . verifyJabberID ( jid ) ; 
public void onSharedPreferenceChanged ( SharedPreferences prefs , String key ) { Log . i ( TAG , " onSharedPreferenceChanged(): " + key ) ; loadPrefs ( prefs ) ; } 
public void onReceive ( Context context , Intent intent ) { Log.d(TAG, "start service"); 
public boolean onPreferenceChange ( Preference preference , Object newValue ) { newResourceSummary = ( CharSequence ) newValue ; if ( newValue ! = null & & newResourceSummary . length ( ) > 0 ) { prefResource 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; mConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; mConnectionDemanded . set ( mConfig . connStartup ) ; if ( mConfig . connStartup ) { / * 
private void doConnect ( ) { mConnectionDemanded . set ( rue ) ; if ( mConnectingThread ! = null ) return ; mConnectingThread = new Thread ( ) { public void run ( ) { try { if ( mSmackable . doConnect ( ) ) { connectionEstablished ( ) ; mReconnectCount = 0 ; mIsConnected . set ( rue ) ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } } ; mConnectingThread . start ( ) ; } 
public void run ( ) { try { if ( mSmackable . doConnect ( ) ) { connectionEstablished ( ) ; mReconnectCount = 0 ; mIsConnected . set ( rue ) ; } else connectionFailed ( ) ; } catch ( YaximXMPPException e ) { connectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } 
private void connectionFailed ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( mConfig . reconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; mIsConnected . set ( false ) ; if ( mConfig . reconnect & & mReconnectCount < = 5 ) { mReconnectCount + + ; 
public void doDisconnect ( ) { mIsConnected . set ( false ) ; if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; mConnectionDemanded . set ( false ) ; } 
public void rosterChanged ( ) { if ( ! mSmackable . isAuthenticated ( ) ) { if ( mIsConnected . get ( ) ) { mSmackable . unRegisterCallback ( ) ; registerAdapterCallback ( ) ; connectionFailed ( ) ; } return ; } final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; + + i ) { try { mRosterCallbacks . getBroadcastItem ( i ) . rosterChanged ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; registerXMPPService ( ) ; createUICallback ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setContactFromUri ( ) ; setChatItems ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + mJabberID ) ; } 
protected void onPause ( ) { super . onPause ( ) ; mServiceAdapter . unregisterUICallback ( mChatCallback ) ; unbindXMPPService ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; bindXMPPService ( ) ; } 
private void processMessageQueue ( ) { List < String > queue = mServiceAdapter . pullMessagesForContact ( mJabberID ) ; for ( String message : queue ) { processIncomingMessageInHandler ( mJabberID , message ) ; 
private void createUICallback ( ) { mChatCallback = new IXMPPChatCallback . Stub ( ) { 
private void processIncomingMessageInHandler ( String from , String message ) { final ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + from , message ) ; mHandler . post ( new Runnable ( ) { public void run ( ) { 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; mServiceIntent = new Intent ( his , XMPPService . class ) ; Uri chatURI = Uri . parse ( " chatwindow " ) ; mServiceIntent . setData ( chatURI ) ; mServiceIntent . setAction ( " de.hdmstuttgart.yaxim.XMPPSERVICE " ) ; mServiceConnection = new ServiceConnection ( ) { 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; mServiceAdapter = new XMPPChatServiceAdapter ( IXMPPChatService . Stub . asInterface ( service ) , mJabberID ) ; mServiceAdapter . registerUICallback ( mChatCallback ) ; processMessageQueue ( ) ; } 
public void onServiceDisconnected ( ComponentName name ) { Log . i ( TAG , " called onServiceDisconnected() " ) ; mServiceAdapter . unregisterUICallback ( mChatCallback ) ; } 
private void unbindXMPPService ( ) { try { unbindService ( mServiceConnection ) ; 
private void bindXMPPService ( ) { bindService ( mServiceIntent , mServiceConnection , BIND_AUTO_CREATE ) ; } 
private void sendMessage ( String message ) { ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; mAdapterMap . get ( mJabberID ) . add ( newChatItem ) ; mChatInput . setText ( null ) ; mSendButton . setEnabled ( false ) ; mServiceAdapter . sendMessage ( mJabberID , message ) ; } 
private void showToastNotification ( int message ) { Toast oastNotification = Toast . makeText ( his , message , Toast . LENGTH_SHORT ) ; toastNotification . show ( ) ; } 
public IBinder onBind ( Intent intent ) { super . onBind ( intent ) ; String caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) return mServiceChatConnection ; return mService2RosterConnection ; } 
private void createServiceChatStub ( ) { mServiceChatConnection = new IXMPPChatService . Stub ( ) { 
public List < String > pullMessagesForContact ( String jabberID ) throws RemoteException { if ( mSmackable ! = null ) { return mSmackable . pullMessagesForContact ( jabberID ) ; } return new ArrayList < String > ( ) ; } 
public boolean isAuthenticated ( ) hrows RemoteException { if ( mSmackable ! = null ) { return mSmackable . isAuthenticated ( ) ; } return false ; } 
private void handleIncomingMessage ( String from , String message ) { RemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; int broadCastItems = chatCallbackList . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { chatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } chatCallbackList . finishBroadcast ( ) ; } 
private void startChatActivity ( String user ) { Intent chatIntent = new Intent ( his , org . yaxim . androidclient . chat . ChatWindow . class ) ; Uri userNameUri = Uri . parse ( user ) ; chatIntent . setData ( userNameUri ) ; startActivity ( chatIntent ) ; } 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; xmppServiceIntent = new Intent ( his , XMPPService . class ) ; xmppServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; xmppServiceConnection = new ServiceConnection ( ) { 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; mServiceIntent = new Intent ( his , XMPPService . class ) ; Uri chatURI = Uri . parse ( " chatwindow " ) ; mServiceIntent . setData ( chatURI ) ; mServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; mServiceConnection = new ServiceConnection ( ) { 
private void sendMessage ( String message ) { ChatItem newChatItem = new ChatItem ( GetDateTimeHelper . setDate ( ) + " : " + getString ( R . string . Global_Me ) , message ) ; mAdapterMap . get ( mJabberID ) . add ( newChatItem ) ; mChatInput . setText ( null ) ; mSendButton . setEnabled ( false ) ; mServiceAdapter . sendMessage ( mJabberID , message ) ; } 
public void initiateConnection ( ) { setForeground ( rue ) ; if ( mSmackable = = null ) { createAdapter ( ) ; registerAdapterCallback ( ) ; } doConnect ( ) ; } 
public void doDisconnect ( ) { mIsConnected . set ( false ) ; if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; mConnectionDemanded . set ( false ) ; setForeground ( false ) ; } 
public void onCreate ( SQLiteDatabase db ) { Log . d ( TAG , " created new database " ) ; db . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " jabber_id TEXT, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " autoconnect BOOLEAN " + " ); " ) ; db . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " FOREIGN KEY (account_id) REFERENCES " + ACCOUNTS + " (id) " + " ); " ) ; db . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { Log . w ( TAG , " Upgrading database from version " + oldVersion + " to " + newVersion + " . All data will be deleted! " ) ; db . execSQL ( " DROP TABLE IF EXISTS " + ACCOUNTS ) ; db . execSQL ( " DROP TABLE IF EXISTS " + ROSTER ) ; db . execSQL ( " DROP TABLE IF EXISTS " + CHATS ) ; onCreate ( db ) ; } 
public void onCreate ( SQLiteDatabase db ) { Log . d ( TAG , " created new database " ) ; db . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " user_name TEXT, " + " server TEXT, " + " port INTEGER, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " auto_reconnect BOOLEAN " + " auto_connect BOOLEAN " + " ); " ) ; db . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " FOREIGN KEY (account_id) REFERENCES " + ACCOUNTS + " (id) " + " ); " ) ; db . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void save ( SQLiteDatabase db ) { ContentValues values = new ContentValues ( ) ; values . put ( " user_name " , userName ) ; values . put ( " password " , password ) ; values . put ( " server " , server ) ; values . put ( " port " , port ) ; values . put ( " ressource " , ressource ) ; values . put ( " default_priority " , priority ) ; values . put ( " auto_reconnect " , reconnect ) ; values . put ( " auto_connect " , connStartup ) ; db . insert ( DataBaseHelper . ACCOUNTS , " user_name " , values ) ; } 
public void save ( SQLiteDatabase db ) { ContentValues values = new ContentValues ( ) ; values . put ( " user_name " , userName ) ; values . put ( " password " , password ) ; values . put ( " server " , server ) ; values . put ( " port " , port ) ; values . put ( " ressource " , ressource ) ; values . put ( " default_priority " , priority ) ; values . put ( " auto_reconnect " , autoReconnect ) ; values . put ( " auto_connect " , autoConnect ) ; db . insert ( DataBaseHelper . ACCOUNTS , " user_name " , values ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; mConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; mConnectionDemanded . set ( mConfig . autoConnect ) ; if ( mConfig . autoConnect ) { / * 
private void connectionFailed ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( mConfig . autoReconnect & & mReconnectCount < = 5 ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; mIsConnected . set ( false ) ; if ( mConfig . autoReconnect & & mReconnectCount < = 5 ) { mReconnectCount + + ; 
protected void onResume ( ) { super . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; bindXMPPService ( ) ; mChatInput . requestFocus ( ) ; 
public void onCreate ( SQLiteDatabase db ) { Log . d ( TAG , " created new database " ) ; db . execSQL ( " CREATE TABLE " + ACCOUNTS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " user_name TEXT, " + " server TEXT, " + " port INTEGER, " + " password TEXT, " + " ressource TEXT, " + " default_priority INTEGER, " + " away_priority INTEGER, " + " status_message TEXT, " + " auto_reconnect BOOLEAN " + " auto_connect BOOLEAN " + " ); " ) ; db . execSQL ( " CREATE TABLE " + ROSTER + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " account_id INTEGER, " + " jabberid TEXT, " + " screen_name TEXT, " + " status_mode INTEGER " + " status_message TEXT, " + " group TEXT " + " ); " ) ; db . execSQL ( " CREATE TABLE " + CHATS + " ( " + " id INTEGER PRIMARY KEY AUTOINCREMENT, " + " ime TIMESTAMP, " 
public int delete ( Uri url , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; long rowId = 0 ; switch ( URI_MATCHER . match ( url ) ) { case MESSAGES : count = db . delete ( TABLE_NAME , where , whereArgs ) ; break ; case MESSAGES_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { where = " _id= " + segment ; } else { where = " _id= " + segment + " AND ( " + where + " ) " ; } count = db . delete ( TABLE_NAME , where , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; } 
public Uri insert ( Uri url , ContentValues initialValues ) { if ( URI_MATCHER . match ( url ) ! = MESSAGES ) { throw new IllegalArgumentException ( " Cannot insert into URL: " + url ) ; } ContentValues values = ( initialValues ! = null ) ? new ContentValues ( initialValues ) : new ContentValues ( ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; long rowId = db . insert ( TABLE_NAME , " ime " , values ) ; if ( rowId < 0 ) { throw new SQLException ( " Failed to insert row into " + url ) ; } return null ; } 
public boolean onCreate ( ) { mOpenHelper = new DatabaseHelper ( getContext ( ) ) ; return rue ; } 
public Cursor query ( Uri url , String [ ] projectionIn , String selection , String [ ] selectionArgs , String sort ) { SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder ( ) ; int match = URI_MATCHER . match ( url ) ; switch ( match ) { case MESSAGES : qBuilder . setTables ( TABLE_NAME ) ; break ; case MESSAGES_ID : qBuilder . setTables ( TABLE_NAME ) ; qBuilder . appendWhere ( " _id= " ) ; qBuilder . appendWhere ( url . getPathSegments ( ) . get ( 1 ) ) ; break ; default : throw new IllegalArgumentException ( " Unknown URL " + url ) ; } SQLiteDatabase db = mOpenHelper . getReadableDatabase ( ) ; Cursor ret = qBuilder . query ( db , projectionIn , selection , selectionArgs , null , null , sort ) ; if ( ret = = null ) { if ( LogConstants . LOG_INFO ) Log . i ( TAG , " ChatProvider.query: failed " ) ; } else { ret . setNotificationUri ( getContext ( ) . getContentResolver ( ) , url ) ; } return ret ; } 
public int update ( Uri url , ContentValues values , String where , String [ ] whereArgs ) { int count ; long rowId = 0 ; int match = URI_MATCHER . match ( url ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; switch ( match ) { case MESSAGES_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; count = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; break ; default : throw new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; 
public void onCreate ( SQLiteDatabase db ) { db . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + " _id INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( " DROP TABLE IF EXISTS " + TABLE_NAME ) ; onCreate ( db ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; long rowId = 0 ; switch ( URI_MATCHER . match ( url ) ) { case MESSAGES : count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; case MESSAGES_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { where = " _id= " + segment ; } else { where = " _id= " + segment + " AND ( " + where + " ) " ; } count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; } 
public Uri insert ( Uri url , ContentValues initialValues ) { if ( URI_MATCHER . match ( url ) ! = MESSAGES ) { throw new IllegalArgumentException ( " Cannot insert into URL: " + url ) ; } ContentValues values = ( initialValues ! = null ) ? new ContentValues ( initialValues ) : new ContentValues ( ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; long rowId = db . insert ( YaximChats . TABLE_NAME , Chats . TIME , values ) ; if ( rowId < 0 ) { throw new SQLException ( " Failed to insert row into " + url ) ; } return null ; } 
public int update ( Uri url , ContentValues values , String where , String [ ] whereArgs ) { int count ; long rowId = 0 ; int match = URI_MATCHER . match ( url ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; switch ( match ) { case MESSAGES_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; count = db . update ( YaximChats . TABLE_NAME , values , " _id= " + rowId , null ) ; break ; default : throw new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; 
public void onCreate ( SQLiteDatabase db ) { db . execSQL ( " CREATE TABLE " + YaximChats . TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " 
public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( " DROP TABLE IF EXISTS " + YaximChats . TABLE_NAME ) ; onCreate ( db ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; long rowId = 0 ; switch ( URI_MATCHER . match ( url ) ) { case MESSAGES : count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; if ( TextUtils . isEmpty ( where ) ) { where = " _id= " + segment ; } else { where = " _id= " + segment + " AND ( " + where + " ) " ; } count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; } 
public int update ( Uri url , ContentValues values , String where , String [ ] whereArgs ) { int count ; long rowId = 0 ; int match = URI_MATCHER . match ( url ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; switch ( match ) { case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; count = db . update ( YaximChats . TABLE_NAME , values , " _id= " + rowId , null ) ; break ; default : throw new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " creating new chat table " ) ; } db . execSQL ( " CREATE TABLE " + YaximChats . TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " 
private void unSetRosterEntry ( RosterEntry rosterEntry ) { String jabberID = rosterEntry . getUser ( ) ; Set < Entry < String , ConcurrentHashMap < String , RosterItem > > > groupMaps = mRosterItemsByGroup . entrySet ( ) ; for ( Entry < String , ConcurrentHashMap < String , RosterItem > > entry : groupMaps ) { ConcurrentHashMap < String , RosterItem > entryMap = entry . getValue ( ) ; 
public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; 
private void createAdapter ( ) { try { mSmackable = new SmackableImp ( mConfig , getContentResolver ( ) ) ; 
private void handleIncomingMessage ( String from , String message ) { RemoteCallbackList < IXMPPChatCallback > chatCallbackList = mChatCallbacks . get ( from ) ; int broadCastItems = chatCallbackList . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { chatCallbackList . getBroadcastItem ( i ) . newMessage ( from , message ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } chatCallbackList . finishBroadcast ( ) ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; switch ( URI_MATCHER . match ( url ) ) { case MESSAGES : count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; if ( TextUtils . isEmpty ( where ) ) { where = " _id= " + segment ; } else { where = " _id= " + segment + " AND ( " + where + " ) " ; } count = db . delete ( YaximChats . TABLE_NAME , where , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; } 
public int delete ( Uri url , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; switch ( URI_MATCHER . match ( url ) ) { case MESSAGES : count = db . delete ( TABLE_NAME , where , whereArgs ) ; break ; case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; if ( TextUtils . isEmpty ( where ) ) { where = " _id= " + segment ; } else { where = " _id= " + segment + " AND ( " + where + " ) " ; } count = db . delete ( TABLE_NAME , where , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Cannot delete from URL: " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; } 
public int update ( Uri url , ContentValues values , String where , String [ ] whereArgs ) { int count ; long rowId = 0 ; int match = URI_MATCHER . match ( url ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; switch ( match ) { case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; count = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; break ; default : throw new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " creating new chat table " ) ; } db . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + Chats . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + Chats . DATE 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; registerXMPPService ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setContactFromUri ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + mJabberID ) ; setChatWindowAdapter ( ) ; } 
protected void onResume ( ) { super . onResume ( ) ; mNotificationMGR . cancel ( NOTIFY_ID ) ; bindXMPPService ( ) ; mChatInput . requestFocus ( ) ; 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; mServiceAdapter = new XMPPChatServiceAdapter ( IXMPPChatService . Stub . asInterface ( service ) , mJabberID ) ; 
private void sendMessage ( String message ) { mChatInput . setText ( null ) ; mSendButton . setEnabled ( false ) ; mServiceAdapter . sendMessage ( mJabberID , message ) ; } 
void populateFrom ( int date , String from , String message ) { getDateView ( ) . setText ( date ) ; getFromView ( ) . setText ( from ) ; getMessageView ( ) . setText ( message ) ; } 
private void showToastNotification ( int message ) { Toast oastNotification = Toast . makeText ( his , message , Toast . LENGTH_SHORT ) ; toastNotification . show ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; registerXMPPService ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setContactFromUri ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + mWithJabberID ) ; setChatWindowAdapter ( ) ; } 
public void onServiceConnected ( ComponentName name , IBinder service ) { Log . i ( TAG , " called onServiceConnected() " ) ; mServiceAdapter = new XMPPChatServiceAdapter ( IXMPPChatService . Stub . asInterface ( service ) , 
private void sendMessage ( String message ) { mChatInput . setText ( null ) ; mSendButton . setEnabled ( false ) ; mServiceAdapter . sendMessage ( mWithJabberID , message ) ; } 
void populateFrom ( String date , String from , String message ) { getDateView ( ) . setText ( date ) ; getFromView ( ) . setText ( from ) ; getMessageView ( ) . setText ( message ) ; } 
public void onCreate ( SQLiteDatabase db ) { if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " creating new chat table " ) ; } db . execSQL ( " CREATE TABLE " + TABLE_NAME + " ( " + Constants . _ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + Constants . DATE 
public void sendMessage ( String oJID , String message ) { final Message newMessage = new Message ( oJID , Message . Type . chat ) ; newMessage . setBody ( message ) ; if ( isAuthenticated ( ) ) { mXMPPConnection . sendPacket ( newMessage ) ; 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( fromJID , oJID , chatMessage , false ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
private void writeToDB ( String fromJID , String oJID , String message , boolean read ) { ContentValues values = new ContentValues ( ) ; values . put ( Constants . FROM_JID , fromJID ) ; values . put ( Constants . TO_JID , oJID ) ; values . put ( Constants . MESSAGE , message ) ; values . put ( Constants . HAS_BEEN_READ , false ) ; values . put ( Constants . DATE , System . currentTimeMillis ( ) ) ; mContentResolver . insert ( ChatProvider . CONTENT_URI , values ) ; } 
public int compare ( String group1 , String group2 ) { if ( group1 . equals ( AdapterConstants . EMPTY_GROUP ) ) return - 1 ; return group1 . oLowerCase ( ) . compareTo ( group2 . oLowerCase ( ) ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( fromJID , oJID , chatMessage , false ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
boolean doConnect ( ) hrows YaximXMPPException ; boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void renameRosterGroup ( String group , String newGroup ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
public void onDestroy ( ) { super . onDestroy ( ) ; mRosterCallbacks . kill ( ) ; doDisconnect ( ) ; } 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Log . i ( TAG , " called onCreate() " ) ; ExceptionHandler . register ( his , " http:duenndns.de/yaxim-crash/ " ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( fromJID , oJID , chatMessage , false ) ; mServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
void populateFrom ( String date , boolean from_me , String from , String message ) { Log . i ( TAG , " populateFrom( " + from_me + " , " + from + " , " + message + " ) " ) ; getDateView ( ) . setText ( date ) ; if ( ! from_me ) { getDateView ( ) . setTextColor ( 0xffff8888 ) ; getFromView ( ) . setText ( from ) ; getFromView ( ) . setTextColor ( 0xffff8888 ) ; } getMessageView ( ) . setText ( message ) ; } 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( false , fromJID , chatMessage , false ) ; mServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
private void writeToDB ( boolean from_me , String JID , String message , boolean read ) { ContentValues values = new ContentValues ( ) ; values . put ( Constants . FROM_ME , from_me ) ; values . put ( Constants . JID , JID ) ; values . put ( Constants . MESSAGE , message ) ; values . put ( Constants . HAS_BEEN_READ , false ) ; values . put ( Constants . DATE , System . currentTimeMillis ( ) ) ; mContentResolver . insert ( ChatProvider . CONTENT_URI , values ) ; } 
private void doConnect ( ) { mConnectionDemanded . set ( rue ) ; if ( mConnectingThread ! = null ) return ; mConnectingThread = new Thread ( ) { public void postFail ( ) { mMainHandler . post ( new Runnable ( ) { public void run ( ) { connectionFailed ( ) ; } } ) ; } public void run ( ) { try { if ( ! mSmackable . doConnect ( ) ) postFail ( ) ; } catch ( YaximXMPPException e ) { postFail ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } } ; mConnectingThread . start ( ) ; } 
public void postFail ( ) { mMainHandler . post ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { try { if ( ! mSmackable . doConnect ( ) ) postFail ( ) ; } catch ( YaximXMPPException e ) { postFail ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } 
public void doDisconnect ( ) { mConnectionDemanded . set ( false ) ; mIsConnected . set ( false ) ; if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; setForeground ( false ) ; } 
public void rosterChanged ( ) { } 
public IBinder onBind ( Intent intent ) { super . onBind ( intent ) ; String caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) { resetNotificationCounter ( ) ; return mServiceChatConnection ; } return mService2RosterConnection ; } 
void populateFrom ( String date , boolean from_me , String from , String message ) { Log . i ( TAG , " populateFrom( " + from_me + " , " + from + " , " + message + " ) " ) ; getDateView ( ) . setText ( date ) ; if ( from_me ) { getDateView ( ) . setTextColor ( 0xff8888ff ) ; getFromView ( ) . setText ( getString ( R . string . chat_from_me ) ) ; getFromView ( ) . setTextColor ( 0xff8888ff ) ; } else { getDateView ( ) . setTextColor ( 0xffff8888 ) ; getFromView ( ) . setText ( from + " : " ) ; getFromView ( ) . setTextColor ( 0xffff8888 ) ; } getMessageView ( ) . setText ( message ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . aboutdialog ) ; setTitle ( versionTitle ) ; Button okButton = ( Button ) findViewById ( R . id . AboutDialog_OkButton ) ; okButton . setOnClickListener ( his ) ; } 
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . firststartdialog ) ; setTitle ( R . string . StartupDialog_Title ) ; setCancelable ( false ) ; setEditJabberID ( ) ; } 
private void verifyAndSavePreferences ( ) { String password = mEditPassword . getText ( ) . oString ( ) ; String jabberID = mEditJabberID . getText ( ) . oString ( ) ; String port = mEditPort . getText ( ) . oString ( ) ; if ( port = = null ) { savePreferences ( jabberID , password ) ; 
public void run ( ) { showToastNotification ( R . string . oast_connectfail_message ) ; isConnected = false ; if ( progressDialog . isShowing ( ) ) { dismissDialog ( DIALOG_CONNECTING ) ; 
private void ryToMoveRosterEntryToGroup ( String userName , String groupName ) throws YaximXMPPException { if ( ! ( groupName . length ( ) > 0 ) ) { throw new YaximXMPPException ( " Can't move " + userName + " to a group without a name! " ) ; } mRoster = mXMPPConnection . getRoster ( ) ; RosterGroup rosterGroup = getRosterGroup ( groupName ) ; RosterEntry rosterEntry = mRoster . getEntry ( userName ) ; removeRosterEntryFromGroups ( rosterEntry ) ; if ( groupName . equals ( AdapterConstants . EMPTY_GROUP ) ) return ; 
private void registerMessageHandler ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener myListener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( false , fromJID , chatMessage , false ) ; mServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; mXMPPConnection . addPacketListener ( myListener , filter ) ; } 
public void onCreate ( ) { super . onCreate ( ) ; createServiceRosterStub ( ) ; createServiceChatStub ( ) ; mConfig = new YaximConfiguration ( PreferenceManager . getDefaultSharedPreferences ( his ) ) ; if ( mConfig . autoConnect ) { / * 
private void doConnect ( ) { if ( mConnectingThread ! = null ) { return ; } mConnectingThread = new Thread ( ) { public void run ( ) { try { if ( ! mSmackable . doConnect ( ) ) postConnectionFailed ( ) ; } catch ( YaximXMPPException e ) { postConnectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } } ; mConnectingThread . start ( ) ; } 
public void run ( ) { try { if ( ! mSmackable . doConnect ( ) ) postConnectionFailed ( ) ; } catch ( YaximXMPPException e ) { postConnectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } mConnectingThread = null ; } 
public void postConnectionFailed ( ) { mMainHandler . post ( new Runnable ( ) { public void run ( ) { 
private void connectionFailed ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionFailed ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; mIsConnected . set ( false ) ; } 
public void doDisconnect ( ) { mIsConnected . set ( false ) ; if ( mSmackable ! = null ) { mSmackable . unRegisterCallback ( ) ; } mSmackable = null ; setForeground ( false ) ; } 
public void rosterChanged ( ) { } 
public boolean doConnect ( ) hrows YaximXMPPException { if ( ! mXMPPConnection . isConnected ( ) ) { tryToConnect ( ) ; if ( isAuthenticated ( ) ) { registerMessageListener ( ) ; registerRosterListener ( ) ; Presence presence = new Presence ( Presence . Type . available ) ; presence . setPriority ( mConfig . priority ) ; mXMPPConnection . sendPacket ( presence ) ; setRosterEntries ( ) ; } } return isAuthenticated ( ) ; } 
private void registerRosterListener ( ) { mRoster = mXMPPConnection . getRoster ( ) ; mRoster . addRosterListener ( new RosterListener ( ) { 
private void registerMessageListener ( ) { PacketTypeFilter filter = new PacketTypeFilter ( Message . class ) ; PacketListener listener = new PacketListener ( ) { public void processPacket ( Packet packet ) { if ( packet instanceof Message ) { Message msg = ( Message ) packet ; String chatMessage = msg . getBody ( ) ; if ( chatMessage = = null ) { return ; } String fromJID = getJabberID ( msg . getFrom ( ) ) ; String oJID = getJabberID ( msg . getTo ( ) ) ; writeToDB ( false , fromJID , chatMessage , false ) ; mServiceCallBack . newMessage ( fromJID , chatMessage ) ; } } } ; mXMPPConnection . addPacketListener ( listener , filter ) ; } 
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { ExpandableListView . ExpandableListContextMenuInfo info ; try { info = ( ExpandableListView . ExpandableListContextMenuInfo ) menuInfo ; } catch ( ClassCastException e ) { Log . e ( TAG , " bad menuinfo: " , e ) ; return ; } long packedPosition = info . packedPosition ; boolean isChild = isChild ( packedPosition ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . roster_contextmenu , menu ) ; int groupPosition = ExpandableListView . getPackedPositionGroup ( info . packedPosition ) ; String groupName = rosterGroupList . get ( groupPosition ) . get ( AdapterConstants . GROUP_NAME [ 0 ] ) ; String menuTitle = getString ( R . string . roster_contextmenu_title ) ; if ( isChild ) { menu . setGroupVisible ( R . id . roster_contextmenu_contact_menu , rue ) ; 
public void requestAuthorizationForRosterItem ( String user ) { try { xmppServiceStub . requestAuthorizationForRosterItem ( user ) ; 
boolean doConnect ( ) hrows YaximXMPPException ; boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
boolean isAuthenticated ( ) ; void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void addRosterItem ( String user , String alias , String group ) hrows YaximXMPPException ; void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void removeRosterItem ( String user ) hrows YaximXMPPException ; void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void renameRosterItem ( String user , String newName ) hrows YaximXMPPException ; void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void moveRosterItemToGroup ( String user , String group ) hrows YaximXMPPException ; void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void renameRosterGroup ( String group , String newGroup ) ; void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
void requestAuthorizationForRosterItem ( String user ) ; void addRosterGroup ( String group ) ; void setStatus ( StatusMode status , String statusMsg ) ; void sendMessage ( String user , String message ) ; void registerCallback ( XMPPServiceCallback callBack ) ; void unRegisterCallback ( ) ; ArrayList < RosterItem > getRosterEntriesByGroup ( String group ) ; ArrayList < String > getRosterGroups ( ) ; } 
public void requestAuthorizationForRosterItem ( String user ) { Presence response = new Presence ( Presence . Type . subscribe ) ; response . setTo ( user ) ; mXMPPConnection . sendPacket ( response ) ; } 
public void requestAuthorizationForRosterItem ( String user ) throws RemoteException { mSmackable . requestAuthorizationForRosterItem ( user ) ; } 
private void doConnect ( ) { if ( mConnectingThread ! = null ) { return ; } mConnectingThread = new Thread ( ) { public void run ( ) { try { if ( ! mSmackable . doConnect ( ) ) { postConnectionFailed ( ) ; } else { postConnectionEstablished ( ) ; } } catch ( YaximXMPPException e ) { postConnectionFailed ( ) ; Log . e ( TAG , " YaximXMPPException in doConnect(): " + e ) ; } finally { mConnectingThread = null ; } } } ; mConnectingThread . start ( ) ; } 
public void postConnectionEstablished ( ) { mMainHandler . post ( new Runnable ( ) { public void run ( ) { 
private void connectionEstablished ( ) { final int broadCastItems = mRosterCallbacks . beginBroadcast ( ) ; for ( int i = 0 ; i < broadCastItems ; i + + ) { try { mRosterCallbacks . getBroadcastItem ( i ) . connectionSuccessful ( ) ; } catch ( RemoteException e ) { Log . e ( TAG , " caught RemoteException: " + e . getMessage ( ) ) ; } } mRosterCallbacks . finishBroadcast ( ) ; mIsConnected . set ( rue ) ; } 
public void rosterChanged ( ) { if ( mIsConnected . get ( ) ) { final int broadCastItems = mRosterCallbacks 
public void onRebind ( Intent intent ) { super . onRebind ( intent ) ; String caller = intent . getDataString ( ) ; if ( ( caller ! = null ) & & caller . equals ( " chatwindow " ) ) { resetNotificationCounter ( ) ; 
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mainchat ) ; registerForContextMenu ( getListView ( ) ) ; setContactFromUri ( ) ; registerXMPPService ( ) ; setNotificationManager ( ) ; setUserInput ( ) ; setSendButton ( ) ; setTitle ( getText ( R . string . chat_titlePrefix ) + " " + mWithJabberID ) ; setChatWindowAdapter ( ) ; } 
private void registerXMPPService ( ) { Log . i ( TAG , " called startXMPPService() " ) ; mServiceIntent = new Intent ( his , XMPPService . class ) ; Uri chatURI = Uri . parse ( mWithJabberID ) ; mServiceIntent . setData ( chatURI ) ; mServiceIntent . setAction ( " org.yaxim.androidclient.XMPPSERVICE " ) ; mServiceConnection = new ServiceConnection ( ) { 
public IBinder onBind ( Intent intent ) { super . onBind ( intent ) ; String chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { resetNotificationCounter ( ) ; mIsBoundTo . add ( chatPartner ) ; return mServiceChatConnection ; } return mService2RosterConnection ; } 
public void onRebind ( Intent intent ) { super . onRebind ( intent ) ; String chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { mIsBoundTo . add ( chatPartner ) ; 
public boolean onUnbind ( Intent intent ) { String chatPartner = intent . getDataString ( ) ; if ( ( chatPartner ! = null ) ) { mIsBoundTo . remove ( chatPartner ) ; } return rue ; } 
public void removeRosterItem ( String user ) hrows YaximXMPPException { Log . d ( TAG , " removeRosterItem( " + user + " ) " ) ; tryToRemoveRosterEntry ( user ) ; mServiceCallBack . rosterChanged ( ) ; } 
public void unRegisterCallback ( ) { Log . d ( TAG , " unRegisterCallback() " ) ; mXMPPConnection . disconnect ( ) ; mRosterItemsByGroup . clear ( ) ; this . mServiceCallBack = null ; } 
public void entriesAdded ( Collection < String > entries ) { Log . d ( TAG , " entriesAdded( " + entries + " ) " ) ; for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; setRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void entriesDeleted ( Collection < String > entries ) { Log . d ( TAG , " entriesDeleted( " + entries + " ) " ) ; for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void entriesUpdated ( Collection < String > entries ) { Log . d ( TAG , " entriesUpdated( " + entries + " ) " ) ; for ( String entry : entries ) { RosterEntry rosterEntry = mRoster . getEntry ( entry ) ; unSetRosterEntry ( rosterEntry ) ; setRosterEntry ( rosterEntry ) ; } mServiceCallBack . rosterChanged ( ) ; } 
public void presenceChanged ( Presence presence ) { Log . d ( TAG , " presenceChanged( " + presence . getFrom ( ) + " ) " ) ; String jabberID = getJabberID ( presence . getFrom ( ) ) ; RosterEntry rosterEntry = mRoster . getEntry ( jabberID ) ; setRosterEntry ( rosterEntry ) ; mServiceCallBack . rosterChanged ( ) ; } 
public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . roster_options , menu ) ; return rue ; } 
public boolean onPrepareOptionsMenu ( Menu menu ) { setMenuItem ( menu , R . id . menu_connect , getConnectDisconnectIcon ( ) , getConnectDisconnectText ( ) ) ; setMenuItem ( menu , R . id . menu_show_hide , getShowHideMenuIcon ( ) , getShowHideMenuText ( ) ) ; return rue ; } 
private void oggleConnection ( MenuItem item ) { if ( serviceAdapter . isAuthenticated ( ) ) { ( new Thread ( ) { 
public int update ( Uri url , ContentValues values , String where , String [ ] whereArgs ) { int count ; long rowId = 0 ; int match = URI_MATCHER . match ( url ) ; SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; switch ( match ) { case MESSAGES : count = db . update ( TABLE_NAME , values , where , null ) ; break ; case MESSAGE_ID : String segment = url . getPathSegments ( ) . get ( 1 ) ; rowId = Long . parseLong ( segment ) ; count = db . update ( TABLE_NAME , values , " _id= " + rowId , null ) ; break ; default : throw new UnsupportedOperationException ( " Cannot update URL: " + url ) ; } if ( LogConstants . LOG_INFO ) { Log . i ( TAG , " *** notifyChange() rowId: " + rowId + " url " + url ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( url , null ) ; return count ; 
